=== notes ud_gitlab ci beguinner : ===

== notes install minikube : ===

minikube start --kubernetes-version=v1.20.0 --cpus 4  --disk-size 20g --memory 8192M
minikube addons enable ingress
http://127.0.0.1:46653/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/

utilisation d'une conf light pour tourner sur minikube :

curl --output values.yaml "https://gitlab.com/gitlab-org/charts/gitlab/raw/master/examples/values-minikube-minimum.yaml"

modification de l'ip du fichier par l'ip de notre minikube :
minikube node list           
minikube	192.168.39.69  <<<< ip qu'on renseigne dans le fichier de value

minikube ip
192.168.39.69

fichier d'install minimal pour minikube :
cat values-minikube.yaml                                                                                                                       [☸ |minikube:default]
# values-minikube.yaml
# This example intended as baseline to use Minikube for the deployment of GitLab
# - Services that are not compatible with how Minikube runs are disabled
# - Configured to use 192.168.99.100, and nip.io for the domain

# Minimal settings
global:
  ingress:
    configureCertmanager: false
    class: "nginx"
  hosts:
    domain: 192.168.39.69.nip.io
    externalIP: 192.168.39.69
  shell:
    # Configure the clone link in the UI to include the high-numbered NodePort
    # value from below (`gitlab.gitlab-shell.service.nodePort`)
    port: 32022
# Don't use certmanager, we'll self-sign
certmanager:
  install: false
# Use the `ingress` addon, not our Ingress (can't map 22/80/443)
nginx-ingress:
  enabled: false
# Map gitlab-shell to a high-numbered NodePort cloning over SSH since
# Minikube takes port 22.
gitlab:
  gitlab-shell:
    service:
      type: NodePort
      nodePort: 32022
# Provide gitlab-runner with secret object containing self-signed certificate chain
gitlab-runner:
  certsSecretName: gitlab-wildcard-tls-chain




on ajoute le repo gitlab 
helm repo add gitlab https://charts.gitlab.io
on lance le setup en passant en argument le fichier minimal dl et modifié auparavant :
helm install gitlab -f values-minikube.yaml gitlab/gitlab                                                                                     [☸ |minikube:default]

W0206 12:35:13.131654  130195 warnings.go:70] extensions/v1beta1 Ingress is deprecated in v1.14+, unavailable in v1.22+; use networking.k8s.io/v1 Ingress
W0206 12:35:13.133515  130195 warnings.go:70] extensions/v1beta1 Ingress is deprecated in v1.14+, unavailable in v1.22+; use networking.k8s.io/v1 Ingress
W0206 12:35:13.135040  130195 warnings.go:70] extensions/v1beta1 Ingress is deprecated in v1.14+, unavailable in v1.22+; use networking.k8s.io/v1 Ingress
W0206 12:35:40.643249  130195 warnings.go:70] extensions/v1beta1 Ingress is deprecated in v1.14+, unavailable in v1.22+; use networking.k8s.io/v1 Ingress
W0206 12:35:40.653756  130195 warnings.go:70] extensions/v1beta1 Ingress is deprecated in v1.14+, unavailable in v1.22+; use networking.k8s.io/v1 Ingress
W0206 12:35:40.653795  130195 warnings.go:70] extensions/v1beta1 Ingress is deprecated in v1.14+, unavailable in v1.22+; use networking.k8s.io/v1 Ingress
NAME: gitlab
LAST DEPLOYED: Sat Feb  6 12:35:10 2021
NAMESPACE: default
STATUS: deployed
REVISION: 1
NOTES:
NOTICE: The resource requests have increased for the Webservice and Sidekiq charts.
    For more information on Webservice resources, see https://docs.gitlab.com/charts/charts/gitlab/webservice/index.html#resources
    For more information on Sidekiq resources, see https://docs.gitlab.com/charts/charts/gitlab/sidekiq/index.html#resource
    Related merge request: https://gitlab.com/gitlab-org/charts/gitlab/-/merge_requests/1634

    To restore the original resource specifications:
    --set gitlab.sidekiq.resources.requests.cpu=50m
    --set gitlab.sidekiq.resources.requests.memory=650M
    --set gitlab.webservice.resources.requests.memory=1.5G

WARNING: Automatic TLS certificate generation with cert-manager is disabled and no TLS certificates were provided. Self-signed certificates were generated.

You may retrieve the CA root for these certificates from the `gitlab-wildcard-tls-ca` secret, via the following command. It can then be imported to a web browser or system store.

    kubectl get secret gitlab-wildcard-tls-ca -ojsonpath='{.data.cfssl_ca}' | base64 --decode > gitlab.192.168.39.69.nip.io.ca.pem

If you do not wish to use self-signed certificates, please set the following properties:
  - global.ingress.tls.secretName
  OR
  - global.ingress.tls.enabled (set to `true`)
  - gitlab.webservice.ingress.tls.secretName
  - registry.ingress.tls.secretName
  - minio.ingress.tls.secretName


Help us improve the install experience, let us know how we did with a 1 minute survey:
https://gitlab.fra1.qualtrics.com/jfe/form/SV_6kVqZANThUQ1bZb?installation=helm&release=13-8

on renseigne dans notre fichier host le record 

192.168.39.69 gitlab.192.168.39.69.nip.io


on peut recup le certif auto signé et l'ajouter dans notre magasin de certifs du navigateur :

 kubectl get secret gitlab-wildcard-tls-ca -ojsonpath='{.data.cfssl_ca}' | base64 --decode > gitlab.192.168.39.69.nip.io.ca.pem

 on va ensuite recupérer les créentials générésà l'install pour se logger sur notre browser : 

kubectl get secret <name>-gitlab-initial-root-password -ojsonpath='{.data.password}' | base64 --decode ; echo
eDZIM3RZN0dpRjFPN212WUFUOFVjVElYQjcyYW55RkhOZFl1T1RSVzBIWklpYWtCazhWV0g4ZXlEa3ZPVTFVZQ==" |base64 -d                  [☸ |minikube:default]

x6H3tY7GiF1O7mvYAT8UcTIXB72anyFHNdYuOTRW0HZIiakBk8VWH8eyDkvOU1Ue%

on se logge ensuite avec le user root et le mdp recupéré sur l'url http://gitlab.192.168.39.69.nip.io

kubectl get secret <name>-gitlab-initial-root-password -ojsonpath='{.data.password}' | base64 --decode ; echo

root 



== fin de set up ==


== ud gitab ci beguinner ==


= architecture : 

gitlab server :

interface .Fourni tous les composants pour gérer notre project.
tout est stocké en db

des qu'on crée un pipeline : tout est géré par le gitlab server qui va déléguer le job a un gitlab runner qui va executer les taches et créer un artifact si besoin.
le gitlab serveur ne gére pas la charge de traitement mais manage le runner et s'assure qu'il a bien fait le job.
La solution est scalable ca on peut donc ajouter le nombre de gitlab runner qu'on veut pour assurer le job.

par exemple un runner lance un job :
> une image docker de ruby 2.5 est utilisée (img de base pour les runners) 
> le repo est cloné
> les steps sont fait
> un artifact est build
> le container est détruit à la fin du job
> on peut recup l'artifact et consulter les logs pour examiner le déroulement du job.

- runners :

on peur voir la maniere dont ils sont configurés :

projet > settings > ci /cd > on chercher runners > expand 
shared runners : 
ils sont dispos pour tous les users de gitlab
on peut dédié des runners pour nos tasks : tels projets, tel jobs seront dédiés.

= basic :

ci /cd 

> ci 
integration icontinue de code avec d'autres dev
chaque fois qu'on met du code à jour ce code va être intégré et testé ( build , test ok ? )

code >| build > code quality > tests > package |
        les phases entre | sont un pipeline
             ci pipeline

les erreurs sont détectées rapidement
le temps d'intégration est réduit
le dev se fait plus vite.

> cd 
apres avoir créer un package ( fin de ci) on va tester , installer le code sur un serveur de test puis déployer (manuellement ou pas sur la production)

package > | test review > staging > production |
                cd pipeline

chaque changement est releasable grace aux tests
reduction des risques de déployement 
deployement plus rapide : mise en place plus rapide de feature

                
- creation d'un project 

clone de https://gitlab.com/gitlab-course-public/my-static-website-no-pipeline.git

nodejs :
javascript runtime sans l'obligation d'ouvrir un navigateur.
npm : node package manager

static website 

https://www.gatsbyjs.com/docs/quick-start/#install-the-gatsby-cli

npm init gatsby


on installe 2 plugins :
gatsby-plugin-offline, gatsby-plugin-mdx


on se deplace dans notre folder :

cd static-website                                                                            
 boogie@boogieland  ~/Documents/lab/gitlab/projet/my-static-website-no-pipeline/static-website   master  ls 
gatsby-config.js  node_modules  package.json  package-lock.json  README.md  src

Start the local development server with

  npm run develop

See all commands at

  https://www.gatsbyjs.com/docs/gatsby-cli/

on peut acceder sur notre browser à un server http :

http://localhost:8000/


on va créer dans gitlab un nouveau projet :

static-website : on va cloner le repo sur notre poste

on crée un fichier .gitignore qui va contenir les fichiers que l'on ne veut pas synchro sur notre repo : node_modules package-lock.json

-  gatsby : étapes de build 

> construction de html et js 
> css et js sont compressés pour réduire la taille  'minified'
> gatsby build : on compile 



on peut prefixer les commandes avec npx :
https://github.com/gatsbyjs/gatsby/issues/15276

npx gatsby build
...
....

info Generated public/sw.js, which will precache 6 files, totaling 283328 bytes.
The following pages will be precached:
/offline-plugin-app-shell-fallback/index.html
success onPostBuild - 0.078s
info Done building in 11.535389074 sec







