=== git udemy fr ===

= intro : 
on va versionnier : historiser notre code.
historiquement on copiait nos fichiers pour backuper. il n'y avait pas de metadata (auteur, date ....).On a ensuite ajouter des bdd. Viennent ensuitee les veritables vcs : on centralise les projets sur un repo central. Si on a le serveur hs : pls personne ne peut travailler.
On va ensuite avoir les systeme distribuer : on recupere tous les projets en local sur notre poste : on en dépend plus d'un seul server.
git : libre et distribué.
gihub heberge la plupart des projets de code.

= set up : 

linux :
sudo apt install git-all ( on install git et les applis graphiques rattachées à git.)

config : 
on va renseigner le nm et mailbox de notre conf git 

git config --global 

> on configure l'ensemble des infos pour nos projets 

git config --global user.name="boogie"
git config --global user.mail="boogie@lapin.net"

check :

on peut examiner la conf global de notre setting git avec : 
git config --global --list 

user.name=boogie
user.email=boogie@lapin.net
core.editor=vim
diff.tool=meld
alias.co=checkout
alias.br=branch
alias.st=status
alias.unstage=reset --soft HEAD^
alias.com=commit
alias.com-am=commit -am

on voit dans notre example que la conf globale comporte des éléments supplementaires comm des alias , l'editeur de texte par default utilisé avec git , l'outil de diff utilisé dans git ...

git sans params nous donne l'équivalent de git --help

= utilisation de base de git : 


- notions git :

- repo /depo : on va transformer un rep sur notre poste pour le transformer en repo git. 
le repo git contiendra differentes informations 

un dossier caché .git est crée à la creation du depot avec la commande git init.
ce dossier caché va contenir les informations permettant de traiter le dossier comme un repo git.
- l'historique 
- la zone d'index 
- ensemble d'info pour le fonctionnement de git.

3 grandes phases d'enregistrement des modifs d'un projet dans git :

-> dossier de travail : on modifie notre code dans un repertoire


-> zone d'index : va contenir toutes le modifs que veut garder et selectionner et les ajouter. Celles ci seront mises "en packet" et injectées dans l'historique git.
on peut désindexer des modifs ( elles retourneront dans notre zone / dossier de travail. 

-> une fois qu'on a selectionner nos modifs on va pouvoir les historiser en les commitant dans le dépot local.

- creation de repo :

pour utiliser git on créer un repo :
mkdir mon_site_web && cd mon_site_web

git init    
Initialized empty Git repository in /home/boogie/Documents/lab/worksop_git/mon_site_web/.git/

- mise en place du projet :

on ajoute un fichier  hello.html et un style.css

avec git status on voit que deux fichiers sont présents dans le repo mais pas suivi par git :

 boogie@boogieland  ~/Documents/lab/workshop_git/mon_site_web   master  git status
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	hello.html
	sty.css

nothing added to commit but untracked files present (use "git add" to track)


on va donc ajouter les fichiers pour qu'il soient intégrés dans la zone d'index  de git.

git add <fichier> va indexer les fichiers dans notre repo

git add hello.html style.css

on verifie avec git status :

git st
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

	new file:   hello.html
	new file:   style.css


pour désindexer un fichier ( le sortir de la zone d'index pour supprimer des modifs par exemple.) 

git reset <fichier>

git reset hello.html
on verifie avec git status la nouvelle modif :

git status 
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

	new file:   style.css

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	hello.html


on remet le fichier hello.html dans la zone d'index 
git add . ( on met toutes les modifs de la zone de travail dans la zone d'index.)

- Commit :

maintenant que nos fichiers sont dans la zone d'index on va réaliser un commit.

git commit -m "message" 

on va ajouter un message précisant le detail en général de notre commit.
 git commit -m "mon premier commit"
[master (root-commit) 9778b53] mon premier commit
 2 files changed, 102 insertions(+)
 create mode 100644 hello.html
 create mode 100644 style.css

on check on voit que notre rep de travail est clean 

git status
On branch master
nothing to commit, working tree clean

on modifie notre fichier hello.html pour ajouter en lign 16 l'instruction chargeant le style graphique : top-banner :

      <div id=top-banner>
on recharge la page html et on voit un un style plus graphique.

un git status nous montre que le fichier a été modifié 

on va pouvoir examiner les differences entre les modif du workspace et celle enregistrées dans le depot avec la commande git diff

git diff <nomdefichier1....>  : on examine les diffs entre notre fichier modifié dans le workspace et le fichier enregistré dans le repo

ou 
git diff pour voir toutes les modifs entre le workspace et le repo


git diff hello.html


diff --git a/hello.html b/hello.html
index ada4889..e55a02e 100644
--- a/hello.html
+++ b/hello.html
@@ -13,9 +13,9 @@
        <body>

                <!-- TITRE -->
-               <div>
+               <div id=top-banner>^M
                        Bienvenue dans cette formation GIT !
                </div>

        </body>
-</html>
\ No newline at end of file
+</html>^M

on ajoute nos modifs 
git add hello.html
on check 
git diff : ne nous renvoie plus de diff entre notre zone d'index et notre repo

on peut voir les modifs en cours dans la zone d'indexage avec :

git diff --cached 

diff --git a/hello.html b/hello.html
index ada4889..e55a02e 100644
--- a/hello.html
+++ b/hello.html
@@ -13,9 +13,9 @@
        <body>

                <!-- TITRE -->
-               <div>
+               <div id=top-banner>^M
                        Bienvenue dans cette formation GIT !
                </div>

        </body>
-</html>
\ No newline at end of file
+</html>^M
(END)


..on retouvre bien les modifs effectuées.

on commit nos modifs avec un bon message : 
git commit -m 'ajout du top banner'
[master 2b4c399] ajout du top banner
 1 file changed, 2 insertions(+), 2 deletions(-)


= historique git :

l'historique d'un repo git correspond a un ensemble de vcommit reliés ensemble par un pointer.
un ensemble de commit reliés entre eux constitue une branche. 
Tout projet à une branche principale nommée "master"

un commit comporte 
un id de 40 caracteres appellés sha1
un ensemble de modif
commentaire decrivant le commit
infos sur l'auteur
date de creation
liste des cha1 de son ou ses parents.

- tag :

notion tres importante dans git :
un tag est un intitulé suivi d'un pointeur vers un commit
(intitule / sha1)

Toutes les branches de git possede un tag a son nom : branche master possede un tag master
La particularité de ces tag de branche est qu'il pointent toujours sur le dernier commit de la branche ( si notre branche est au commit "d" et qu'on ajoute des données : le tag de la branche suivra et sera donc au commit "e"

on peut créer des tags sur un commit et ces tags personnels eux ne suivent pas l'evolution de la branche.


Git gere aussi un autre pointeur "head"
le commit sur lequel nous travaillons en ce moment.

- afficher nos commits :

git log 

on peut voir les différentes info (head : on voit sur quel commit on est en ce moment, on voit la date , les modifs , l'auteur ..et biensur le num de commit.)


commit 73bb937fba2790ad40c577c3ebbcd1ce59c00731 (HEAD -> master)
Author: fredsobon <frederic.sobon@gmail.com>
Date:   Mon Apr 13 17:47:55 2020 +0200

    add comment in block

commit 99d3be156546500cc59705c96acf3df3e4ed9a74
Author: fredsobon <frederic.sobon@gmail.com>
Date:   Mon Apr 13 17:46:09 2020 +0200

    add comment in block

commit 2b4c3993793ae41d394d047013aaed517005ce96
Author: fredsobon <frederic.sobon@gmail.com>
Date:   Mon Apr 13 17:42:24 2020 +0200

    ajout du top banner

commit 9778b533e448535ec30bbb8c0b26e224e1969d6c
Author: fredsobon <frederic.sobon@gmail.com>
Date:   Mon Apr 13 17:28:30 2020 +0200

    mon premier commit

on peut afficher un nombre voulu de commit :
git log -n nombre voulu 


git log -n 2 

commit 73bb937fba2790ad40c577c3ebbcd1ce59c00731 (HEAD -> master)
Author: fredsobon <frederic.sobon@gmail.com>
Date:   Mon Apr 13 17:47:55 2020 +0200

    add comment in block

commit 99d3be156546500cc59705c96acf3df3e4ed9a74
Author: fredsobon <frederic.sobon@gmail.com>
Date:   Mon Apr 13 17:46:09 2020 +0200

    add comment in block

- afficher le contenu d'un commit :

on recupere le num de commit qui nous interresse puis :

git show numcommit


git show 99d3be156546500cc59705c96acf3df3e4ed9a74

commit 99d3be156546500cc59705c96acf3df3e4ed9a74
Author: fredsobon <frederic.sobon@gmail.com>
Date:   Mon Apr 13 17:46:09 2020 +0200

    add comment in block

diff --git a/hello.html b/hello.html
index e55a02e..127fe4d 100644
--- a/hello.html
+++ b/hello.html
@@ -16,6 +16,9 @@
                <div id=top-banner>
                        Bienvenue dans cette formation GIT !
                </div>
+                <div>^M
+                        <p> "hello boogieman !!</p>     ^M
+                </div>^M

        </body>
   <html>      

   
on peut aussi afficher les modif en utilisant les tags a la place des num de commit 

ex :
git show master 

commit 73bb937fba2790ad40c577c3ebbcd1ce59c00731 (HEAD -> master)
Author: fredsobon <frederic.sobon@gmail.com>
Date:   Mon Apr 13 17:47:55 2020 +0200

    add comment in block

diff --git a/hello.html b/hello.html
index 127fe4d..c417846 100644
--- a/hello.html
+++ b/hello.html
@@ -17,7 +17,7 @@
                        Bienvenue dans cette formation GIT !
                </div>
                 <div>
-                        <p> "hello boogieman !!</p>
+                        <p> "hello boogieman !!"</p>     ^M
                 </div>


- Navigation dans l'historique :

on va pouvoir se deplacer dans l'historique de git 

git checkout <numdecommit>

ex: si on se deplace dans le deuxieme commit ( apres avoir trouver le num de commit avec git log ) 
git checkout 2b4c3993793ae41d394d047013aaed517005ce96
Note: checking out '2b4c3993793ae41d394d047013aaed517005ce96'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b <new-branch-name>

HEAD is now at 2b4c399 ajout du top banner

On voit maintenant que head pointe sur le num de commit voulu ( on a voyagé dans le temps.)

Si on fait un git log nous n'aurons que les deux premiers commits en historique : ce qui est normal vu que c'a n'existe pas encore. )
git log affiche les commits avant le tag HEAD

pour revenir dans la versin la plus recente on va pouvoir donc faire 

git checkout master

- Creation et utilisation de tag :

pour naviguer plus facilement dans l'historique on va pouvoir utiliser des tags.

on va pouvoir utiliser les tags pour identifier précisement un commit : ex site v.0.01, V1 , V2.4 ..

pour tagger un commit : on le repere (git log) , on se met dedans git checkout numcommit

git checkout 2b4c3993793ae41d394d047013aaed517005ce96

git tag nomdutag

git tag bob

en faisant un git log on a l'info du tag crée qui apparait bien :


commit 2b4c3993793ae41d394d047013aaed517005ce96 (HEAD, tag: bob)
Author: fredsobon <frederic.sobon@gmail.com>
Date:   Mon Apr 13 17:42:24 2020 +0200

    ajout du top banner

commit 9778b533e448535ec30bbb8c0b26e224e1969d6c
Author: fredsobon <frederic.sobon@gmail.com>
Date:   Mon Apr 13 17:28:30 2020 +0200

    mon premier commit


pour changer le nom du tafg on peut supprimer le tag qui nous gène :

git tag --delete nomdetag

git tag --delete bob
Deleted tag 'bob' (was 2b4c399)

on remet un nom de tag plus précis : ( on peut donner un message pour information avec "-m" )

git tag monsite-v1 -m "la premiere version du site"

commit 2b4c3993793ae41d394d047013aaed517005ce96 (HEAD, tag: monsite-v1)
Author: fredsobon <frederic.sobon@gmail.com>
Date:   Mon Apr 13 17:42:24 2020 +0200

    ajout du top banner

commit 9778b533e448535ec30bbb8c0b26e224e1969d6c
Author: fredsobon <frederic.sobon@gmail.com>
Date:   Mon Apr 13 17:28:30 2020 +0200

    mon premier commit

on retourne dans le commit master 

pour voir la liste des tags :


git tag 


monsite-v1

on peut maintenant retourner dans le commit voulu avec le tag :
git checkout monsite-v1
Note: checking out 'monsite-v1'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b <new-branch-name>

HEAD is now at 2b4c399 ajout du top banner


= github :

plateforme en ligne pour herberger les depots git.

pull request : proposition d'amelioration de code pour un repo qui n'est pas à la base le notre. 

gist : partage de bout de code.

- gist :

outil permettant de partager du code 
ex: sur un forum on peut donner un gist pour se faire aider 

ex creer un gist :

-> donner un nom pour le bout de code "Hello World !"
-> on ajoute le nom du fichier en précisant l'extension ( c'est important cela active la coloration syntaxique.) : ex : hello_world.py 
-> mettre dans le champ dédié le bout de code
print("hello jazzyworld !!")
-> puis créer secret ou public gist.

on peut updater le code , on voit les modifs dans le champ revision, on peut partager le code via un lien etc...
on peut selectionner le lien du gist une fois avoir choisi embded 

et coller ce lien dans un doc html de notre repo par exemple :
                <!-- gist -->
                <h1> my gist </h1>
                <div>
                <p><script src="https://gist.github.com/boogie777/2c9f483ae5313705cde9085cc39ba1f3.js"></script></p>
                </div>


en affichant la page dans le navigateur on aura la possibilité de voir le code et des indications de github sur notre page web créée

- creation de repo :
on creer un repo


on peut ajouter un readme, le fichier .gitignore dans lequel on va ignorer des fichiers inutiles dans le repo
une fois créee on peut utiliser les onglets : dont settings ( utilisation ou nom de wiki , hooks - script executé : ex quand on commit un script est lancé ..., etc ...)

- exploration de repo github :

ex : si on browse le contenu d'un repo 
ex vim :
on a l'onglet code qui permet d'examiner le code, les tags , l'historique 

on peut examiner en cliquant sur l'onglet commits les différents commits : on peut voir le commentaire du commit, le sha1 du commit et en cliquant sur celui ci : le detail du commit , le sha1 du parent etc ...


on peut voir la liste des branches 

on peut voir l'onglet release : une release correspond a un tag posé sur le projet . on peut voir le num de commit correspondant au tag.

on peut voir les différents contributeurs au projet.

- utilisation des issues :

va servir a remonter les différents pb rencontrés sur le projet, ou proposition d'evolution du projet
on peut filter les taches 

on peut crer un issue , associer un label afin de trier plus facilement notre issue
on peut indiquer le num d'issue correspondant a un fix dans notre commit

- pull request :
on va pouvoir proposer des évolutions d'un projet sur lequel on a pas les droits d'ecriture.

cela ce passe en plusieurs etapes :

-> fork : on duplique le projet : on peut donc ecrire faire des commits dans ce projet.
-> pull request : une fois qu'on a fait notre modif : on l'envoi au proprietaire du projet pour qu'il valide la modif dans le repo original.

examen de pull request : on clic sur l'onglet pull request d'un projet

un pull request est un peu comme un issue : il est composé d'un titre , d'un id.
on peut voir des conversations etc ..

pour créer une pull request on doit d'abord faire un fork : en clicant sur fork github crée une copie du projet et la met dans notre compte github : on a donc un nouveau repo dans notre arbo de projets.

= Utilisation d'un repo distant :

on va donc utiliser github 
on va pouvoir avoir une sauvegarde du repo et pouvoir travailler en equipe.

on va avoir un type de modele distribué : tout le code sera sur chaque poste des users du projet
on va donc pouvoir cloner le repo ( on a donc tous les commits présents ) 

- cloner un repo :

on va recup notre repo distant :

git clone remote_folder 

 depot distant ( origin )              depot local
   
   master >   C         git clone       master              C
              B                         origin/master       B
              A                                             A
  
on a lors du clone l'ajout automatique du remote qui sera donc origin  
on a donc dans le repo local 2 tags 
-> master : qui nous montre ou est le dernier commit de notre repo local
-> origin/master : qui nous montre ou est le dernier commit sur notre repo distant

git clone https://github.com/boogie777/draft_website.git

on va modifier notre user et mailadress pour gérer notre conf avec le repo distant

git config user.name "boogie777"
git config user.email jazz77777@gmail.com

un check du .git/config nous montre la conf : 

[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[remote "origin"]
        url = https://github.com/boogie777/draft_website.git
        fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
        remote = origin
        merge = refs/heads/master
[user]
        name = boogie777
        email = jazz77777@gmail.com

on peut voir la liste des remotes dans notre rep cloné :
 git remote -v                                                                                      
origin	https://github.com/boogie777/draft_website.git (fetch)
origin	https://github.com/boogie777/draft_website.git (push)

on voit qu'on va recup les modif sur le remote (fetch) et pousser nos modifs sur le distants push 

on peut voir les infos du repo remote : 
git remote show origin                                                                             
* remote origin
  Fetch URL: https://github.com/boogie777/draft_website.git
  Push  URL: https://github.com/boogie777/draft_website.git
  HEAD branch: master
  Remote branch:
    master tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (up to date)


on a cloner le repo distant mais celui ci est vide 
un depot remote est un pointeur vers un autre repos qui va nous servir de référence.

notre premier repo de travail : contenant notre code ne porte pas le meme nom que le repo distant : on renomme notre repo local comme le disant : mv mon_site_web draft_website

pour ajouter un repo remote on peut utiliser les commandes suivantes  :

git remote add origin https://github.com/boogie777/draft_website.git
 boogie@boogieland  ~/Documents/lab/workshop_git/mon_site_web   master  git remote -v
origin	https://github.com/boogie777/draft_website.git (fetch)
origin	https://github.com/boogie777/draft_website.git (push)


- envoi des commits de notre repo initial sur le repo distant :

git push -u origin master  
Username for 'https://github.com': boogie777
Password for 'https://boogie777@github.com': 
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 8 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 1.26 KiB | 1.26 MiB/s, done.
Total 4 (delta 0), reused 0 (delta 0)
To https://github.com/boogie777/draft_website.git
   258e058..0d3ee27  master -> master

/!\ des problemes sont apparus ( du fait d'une premiere copie des fichiers de code dans le rep clone puis poussés sur origin : quand on a voulu pousser les fichiers de notre repo original renommé le push n'a pas pu se faire : on a été obligés de forcer le push 
git push -u origin master -f
Username for 'https://github.com': boogie777
Password for 'https://boogie777@github.com':
Enumerating objects: 22, done.
Counting objects: 100% (22/22), done.
Delta compression using up to 8 threads
Compressing objects: 100% (22/22), done.
Writing objects: 100% (22/22), 2.80 KiB | 1.40 MiB/s, done.
Total 22 (delta 6), reused 0 (delta 0)
remote: Resolving deltas: 100% (6/6), done.
To https://github.com/boogie777/draft_website.git
 + 0d3ee27...fd801fb master -> master (forced update)
Branch 'master' set up to track remote branch 'master' from 'origin'.

si on examine le repo sur github : nos modifs sont bien poussées ..

Attention les tags initiaux ont disparus car ils ne sont pas poussés sur le remote 

pour pousser un tag de notre repo local vers origin :
on le selectionnet et on passe la commande :

git push origin montag 

ex: 
git tag 
mon_site_v2
monsite-v1

git push origin monsite-v1
Username for 'https://github.com': boogie777
Password for 'https://boogie777@github.com':
Enumerating objects: 1, done.
Counting objects: 100% (1/1), done.
Writing objects: 100% (1/1), 174 bytes | 174.00 KiB/s, done.
Total 1 (delta 0), reused 0 (delta 0)
To https://github.com/boogie777/draft_website.git

on a maintenant sur notre remote github notre tag de présent .

on selectionne l'onglet branche et la on voit branche / tag : on selectionne tag : et on voit notre tag monsite-v1 de présent.


on peut pousser tous les tags avec la commandes :
git push origin ( qui peut etre facultatif puisque git va utiliser origin de base ) --tags 
-> tous nos tags sont visibles sur github désormais.


on a pour la suite deux repos :

draft_website : le repo mon_site_web renommé
draft_website.old : le clone de notre remote que l'on a aussi renommé 


- recuperation des modifs distantes en local :

on va pouvoir avoir des commits sur le repo distant non présentes sur le local 
ex: 
  remote                                         local

  master >  D                                   
            C                                     master  > C
            B                                 origin/master B
            A                                               A

on va utiliser la commande fetch qui permettra d'avoir le repo local à jour avec le distant 
dans ce cas on aura 
  git fetch 

  remote                                         local

  master >  D                                origin/master> D
            C                                     master  > C
            B                                               B
            A                                               A

on voit que notre branche master locale elle n'est pas à jour 
on va utiliser donc la commande git pull et on aura : 

  remote                                         local

                                             master
  master >  D                                origin/master> D
            C                                               C
            B                                               B
            A                                               A


on peut faire un git pull directement ( cette commande comporte  un git fetch intégré)  


si on va dans notre repo draft_website.old et qu'on fait un fecth : on récupere bien les modifs présentes sur le remote ( dont les tags poussés depuis le repo draft_website ) 
git fetch
remote: Enumerating objects: 23, done.
remote: Counting objects: 100% (23/23), done.
remote: Compressing objects: 100% (17/17), done.
remote: Total 23 (delta 6), reused 23 (delta 6), pack-reused 0
Unpacking objects: 100% (23/23), done.
From https://github.com/boogie777/draft_website
 + 0d3ee27...fd801fb master     -> origin/master  (forced update)
 * [new tag]         mon_site_v2 -> mon_site_v2
 * [new tag]         monsite-v1  -> monsite-v1



on peut avoir un souci avec l'impossibilité de pull ( pb de méconnaissance de repos entre eux : dans notre cas draft_website.old et draft_website qui ont le meme remote ) :
solution : 
git pull origin master --allow-unrelated-histories
git pull origin master --allow-unrelated-histories
From https://github.com/boogie777/draft_website
 * branch            master     -> FETCH_HEAD
Auto-merging hello.html
CONFLICT (add/add): Merge conflict in hello.html
Automatic merge failed; fix conflicts and then commit the result.


on a un conflit dans le fichier hello.html suite à une modif faite et poussée depuis le repo draft_website .on modifie le fichier dans la branche draft_website.old pour fixer le conflit puis add et commit 
git commit -am 'fix conflict in hello.html'

[master cc460fd] up
 boogie@boogieland  ~/Documents/lab/workshop_git/draft_website.old   master  git pull origin master --allow-unrelated-histories
From https://github.com/boogie777/draft_website
 * branch            master     -> FETCH_HEAD
Already up to date.


un git log permet de voir que l'historique des modifs est bien présents dans notre repo local.

- commit avec issue link :

on peut créer un issue sur le remote.
sur notre repos local on va corriger notre code puis dans notre commit indiquer le num d'issue présent sur le remote correspondant au fix :

ex: 
git commit -am '#1: add dummy readme'

on pousse et on voit sur github le commit et un lien vers l'issue directement clicable.
on peut donc ensuite fermer l'issue dans l'interface github quand notre bug est fixé

quand on va dans le repo draft_website on peut récup les modifs avec un git pull 
 git pull
remote: Enumerating objects: 16, done.
remote: Counting objects: 100% (16/16), done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 14 (delta 1), reused 14 (delta 1), pack-reused 0
Unpacking objects: 100% (14/14), done.
From https://github.com/boogie777/draft_website
   fd801fb..9641fa8  master     -> origin/master
Updating fd801fb..9641fa8
Fast-forward
 README.md | 3 +++
 1 file changed, 3 insertions(+)
 create mode 100644 README.md

on est donc à jour.


=  Travail en équipes : 


