==== notes git ====

==== workflow git ====

working dir  staging repository (.git)    remote repo
file         add      commit              push / pull


== config git ==

on peut voir notre config git avec : 

git config --global --list
user.email=l.apin@lapin.org
user.name=lapin
diff.tool=meld
core.editor=vim

pour faire nos settings : 

git config --global --user.name=lapin
git config --global --user.email=l.apin@lapin.org


nos conf sont sauvées dans le fichier .gitconfig dans le $home de notre user : 
cat ~/.gitconfig 
[user]
    email=l.apin@lapin.org
    name=lapin
[diff]
    tool=meld
[core]
     editor=vim
[alias]
#    fa=fetch -a --prune
#    co=checkout
#    br=branch
#    ci=commit
#    st=status
#    save=!git add -A && git commit -m 'SAVEPOINT'
#    undo=reset HEAD~1 --mixed
#[pull]
#    rebase=true

on peut definir nos alias dans le fichier de conf :

[alias]
    hist = log --oneline --graph
    st   = status
    ci   = commit 

    

== status ==

git status nous montre l'etat de notre repo 

== add ==

git add ajout un fichier 

-u : update : met à jour l'index mais n'ajoute pas de fichiers
(quand on a par exemple deplacer un fichier , puis finalement remis dans la même arborscence.)

-A : --all  ajoute l'intégralité des fichiers.

== rename ==

git mv oldname newname


== log ==

git log : permet de voir les commits 

git log --oneline : est un condensé de "--pretty=oneline --abbrev-commit"
on va dans ce ca avoir une sortie sur une ligne avec le numero de commit réduit et le commentaire du commit : 
git log --oneline
69d93cd up
24f3b6b up
40155bf Merge branch 'master' of https://github.com/fredsobon/stuff

git log --graph : on va pouvoir avoir une représentation graphique de l'historique de commit :
ex :
| Date:   Mon Aug 27 19:20:17 2018 +0200
| 
|     up
|   
*   commit 40155bfd2eb6cb5c4d72d6f7a3ba96b0da97d7fb
|\  Merge: 71b2399 b38974d
| | Author: fredsobon <f.sobon@meetic-corp.com>
| | Date:   Mon Aug 27 19:03:11 2018 +0200
| | 
| |     Merge branch 'master' of https://github.com/fredsobon/stuff
| | 
| * commit b38974daa31617ca65b690f39beb263e7c0da987
| | Author: Fred Sobon <frederic.sobon@gmail.com>
| | Date:   Tue Aug 21 19:46:00 2018 +0200

on peut combiner les options : 

git log --oneline --graph

* 69d93cd up
* 24f3b6b up
*   40155bf Merge branch 'master' of https://github.com/fredsobon/stuff
|\  
| * b38974d up
* | 71b2399 .
|/ 


== diff ==

on va pouvoir afficher les differences entre nos differents "stages" : working directory ; staging aera ; repository avec la commande git diff :

- comparaison working aera / staging 

git diff
diff --git a/versionning/git/gitconfig b/versionning/git/gitconfig
index 42bc468..efe5a04 100644
--- a/versionning/git/gitconfig
+++ b/versionning/git/gitconfig
@@ -13,6 +13,7 @@
   br = branch
   ci = commit
   st = status
+  hist = log --oneline --graph
   save = !git add -A && git commit -m 'SAVEPOINT'
   undo = reset HEAD~1 --mixed



ici on voit qu'une ligne non commitée est presente dans le working directory 
(+  hist = log --oneline --graph ) mais pas dans le staging.

on peut lancer git difftool si on a configurer un outil de diff dans notre config git 
ex : 
[diff]
    tool  = meld

- comparaison working directory et repo :
on peut voir les differences entre le contenu de notre repo et notre working directory :

git diff HEAD 
git difftool HEAD 

- comparaison staging et repo :

git diff --staged HEAD 
git difftool --staged HEAD


- comparaison sur un fichier particulier 
pour l'instant toutes les modifs examiness concernent le "repo" global.On peut biensur comparer uniquement un fichier 

git diff -- fichier

git diff -- git_cheat.txt
diff --git a/versionning/git/git_cheat.txt b/versionning/git/git_cheat.txt
index 1df976b..e14dfda 100644
--- a/versionning/git/git_cheat.txt
+++ b/versionning/git/git_cheat.txt
@@ -134,6 +134,27 @@ index 42bc468..efe5a04 100644
 ici on voit qu'une ligne non commitée est presente dans le working directory 
 (+  hist = log --oneline --graph ) mais pas dans le staging.
 
+on peut lancer git difftool si on a configurer un outil de diff dans notre config git 
 

- comparaison de commits :

on va pouvoir comparer des commits.
on va devoir chercher les commits qui nous interesse avec git log puis les passer en arguments : 

git log --oneline |head
09109bc up
dfa6430 up
da0c987 up
7ba9fb7 up
679148b up
e1409f6 up

ici on va comparer les deux derniers commits entre eux : 

git diff 09109bc dfa6430
diff --git a/TODO b/TODO
index f8eafb5..7308740 100644
--- a/TODO
+++ b/TODO
@@ -4,7 +4,6 @@
 net : lan subnet creation / config / lacp / jumbo frame
 redondancy : failover / HA
 loadbalancing 
-routage
 firewalling / codes attacks /audit /
 
on peut utiliser le nom HEAD qui represente le dernier commit de notre branch : 

c'est donc completement equivalent a l'exemple précédent :
 ~/Documents/stuff/versionning/git  ⑂ master +  $  git diff HEAD dfa6430
diff --git a/TODO b/TODO
index f8eafb5..7308740 100644
--- a/TODO
+++ b/TODO
@@ -4,7 +4,6 @@
 net : lan subnet creation / config / lacp / jumbo frame
 redondancy : failover / HA
 loadbalancing 
-routage
 firewalling / codes attacks /audit /

on peut aussi pour comparer les deux derniers commit utiliser HEAD ( le dernier commit ) et HEAD^ ( l'avant dernier commit ) 

 ~/Documents/stuff/versionning/git  ⑂ master +  $  git diff HEAD HEAD^
diff --git a/TODO b/TODO
index f8eafb5..7308740 100644
--- a/TODO
+++ b/TODO
@@ -4,7 +4,6 @@
 net : lan subnet creation / config / lacp / jumbo frame
 redondancy : failover / HA
 loadbalancing 
-routage
 firewalling / codes attacks /audit /
 
ce qui revient encore à la même chose que nos deux exemples precedents 

- comparaison de la branche master local et la branche master distante (remote) :


== branch + merge request ==

creation de branch : 
git branch subscrib_gen
on passe dans la branche créee : 
git checkout subscrib_gen

- on verifie la branch dans la quelle on est : 
git branch

- Resynchro notre branche avec le repo principal :
quand on est dans une branche on veut s'assurer qu"on récupere bien les modif faites sur la master par exemple .
Quand on execute la commande un message sur le prompt s'affiche pour nous prévenir que notre branche va suivre le repo distant spécifié : 

git branch -u origin/master

La branche lapin est paramétrée pour suivre la branche distante master depuis origin.

- recupération d'une branche distante et basculement à l'interrieur : 

git checkout -b  scala origin/scala


- on fait une modif : 
vi subscriptions.pp

git status

- on commit 

git commit -am '[sensu] expose a var to generate subscriptions provided in hiera'

- on pousse notre branch sur l'origine : 

git push origin subscrib_gen


Décompte des objets: 10, fait.
Delta compression using up to 4 threads.
Compression des objets: 100% (9/9), fait.
Écriture des objets: 100% (10/10), 1.02 KiB | 0 bytes/s, fait.
Total 10 (delta 5), reused 0 (delta 0)
remote: 
remote: Create merge request for subscrib_gen:
remote:   https://gitlab.meetic.ilius.net/infra-prod/puppet/merge_requests/new?merge_request%5Bsource_branch%5D=subscrib_gen
remote: 
To gitlab.meetic.ilius.net:infra-prod/puppet.git
 * [new branch]        subscrib_gen -> subscrib_gen


visible dans le repo 


== git stash ==

Il est possible de mettre de côté une modification de fichier qu'on fait pour continuer à travailler sur autre chose 
et on pourra reprendre plus tard notre fichier modifié sans qu'il ait été commité 

ex : on taff sur le fichier toto 
git status 
Sur la branche back
Modifications qui ne seront pas validées :
  (utilisez "git add <fichier>..." pour mettre à jour ce qui sera validé)
  (utilisez "git checkout -- <fichier>..." pour annuler les modifications dans la copie de travail)

	modified:   toto

on va le mettre de coté et reprendre plus tard :

$ git stash 
Saved working directory and index state Work on back: c77d5d4 [back] blabla
HEAD est maintenant à c77d5d4 [back] add blabla file

On peut voir la liste de nos fichiers mis de coté : 
$ git stash list
stash@{0}: Work on back: c77d5d4 [back] add blabla file


Quand on veut appliquer les modifs mise de coté :

$ git stash apply 


On peut faire plusieurs stashs à droite et gauche. Comment s’y retrouver ?

Git stash list vous donnera la liste des stashs de ce repository:

$test(master) sam$ git stash list
stash@{0}: WIP on master: bd30f7b a
stash@{1}: WIP on master: bd30f7b a
Pour appliquer un stash en particulier, par exemple “stash@{0}”

git stash apply stash@{0}
Pour savoir ce qu’il y a dans un stash:

git stash show stash@{0}
Si un stash commence à être précieux, et que vous sentez que vous aller devoir bosser dessus pas mal de temps, vous pouvez toujours décider de finalement faire une branche avec:

git stash branch stash@{0}
Pour supprimer un stash:

git stash drop stash@{0}
Pour toutes ces commandes, si on ne précise pas le stash ciblé, le dernière créé sera utilisé par défaut.

La plupart du temps on créé un stash de manière temporaire, donc plutot que de faire un stash apply puis un stash drop, on peut faire:

git stash pop
Cela fait un stash apply avec le stash le plus récent, mais en plus cela supprime le stash de la liste.

Comme les stashs sont comme des commits ordinaires, mais simplement en dehors de tout historique et de toute branche, on peut faire toutes les operations qu’on fait sur les commit sur les stashs: merge, checkout, patch, etc. Cela dit c’est un usage avancé que je ne recommande pas au débutant car il faut être capable de visualiser l’état de son travail du point de vue de Git pour s’en sortir.

Si vous découvrez Git, vous n’avez vraiment que deux commandes dont ils faut se souvenir:

git stash
git stash apply




- Rebase :

par securité et être en phase avec un repo officiel : ex production , avant de pousser notre branche on pourra être ammené à faire récupérer :

1/ on se met dans la branch que l'on veut pousser :
git checkout elastic_update 

Basculement sur la branche 'elastic_update'
Votre branche est à jour avec 'origin/elastic_update'.
boogie-/home/boogie/Documents/work/repos_work/puppet>> 
boogie-/home/boogie/Documents/work/repos_work/puppet>> 
boogie-/home/boogie/Documents/work/repos_work/puppet>> 

2/ On recupére les modif passées sur notre branche officielle production que l'on réintegre dans notre branche de test :

boogie-/home/boogie/Documents/work/repos_work/puppet>> git rebase production 
Premièrement, rembobinons head pour rejouer votre travail par-dessus...
Application de  [elk] test upgrade for centos 7

3/ puis on pousse les modifs de notre branche de test sur l'origine (si besoin avec les options pour passer en douceurs les eventuels soucis) : 

boogie-/home/boogie/Documents/work/repos_work/puppet>> git push --set-upstream origin elastic_update --force-with-lease
Décompte des objets: 5, fait.
Delta compression using up to 4 threads.
Compression des objets: 100% (5/5), fait.
Écriture des objets: 100% (5/5), 805 bytes | 0 bytes/s, fait.
Total 5 (delta 2), reused 0 (delta 0)
remote: 
remote: Create merge request for elastic_update:
remote:   https://gitlab.meetic.ilius.net/infra-prod/puppet/merge_requests/new?merge_request%5Bsource_branch%5D=elastic_update
remote: 
To gitlab.meetic.ilius.net:infra-prod/puppet.git
 + c91e4358...79a64987 elastic_update -> elastic_update (forced update)
La branche elastic_update est paramétrée pour suivre la branche distante elastic_update depuis origin.


- Supression de branche : 

git branch -D nom de branch 

on ne doit pas être placé dans la branche qu'on veut delete 
boogie-/home/boogie/Documents/work/repos_work/puppet>> git branch 
* production
  subscrib_gen
boogie-/home/boogie/Documents/work/repos_work/puppet>> git branch -D subscrib_gen 
Branche subscrib_gen supprimée (précédemment 54fdef3d).
boogie-/home/boogie/Documents/work/repos_work/puppet>> git branch 
* production


- Listing des branches distantes : 

git branch -r

- Récupération d'une branche d'un repos distant :

git checkout -b nom_de_notre_branche  origin/nom_de_notre_branche


- Recupération des fichiers de branche d'un repo distant :

git pull origin nom_de_branche

git pull origin elastic_update
Depuis gitlab:prod/puppet
 * branch              nom_de_branch -> FETCH_HEAD
 Mise à jour 8500f951..13c2eeff
 Fast-forward
  lapin/manifests/init.pp        | 11 ++++++-----
  lapin_nain/manifests/init.pp |  5 +++--
  2 files changed, 9 insertions(+), 7 deletions(-)


== Conflits / erreurs : ==

= Reset d'une modif de fichier apres un git add :

si on a fait une erreur et qu'on veut restaurer le fichier a la version d'avant notre add : 

git reset HEAD <nomdefichier>  : on repasse de notre stage a notre working directory 

si on s'apercoit que malgré tout le fichier que l'on retrouve dans notre working directory n'est pas le bon on peut récupérer le dernier fichier commité :

git checkout --<nomdefichier>


= Reset de conf après un commit (avant avoir pousser ) 

Si on s'apercoit que notre dernier commit n'est pas bon on peut restaurer l'ancienne version avant de pousser sur le repo : 

git reset HEAD~


= Checkout / restauration fichier original : =

Comment restaurer un fichier 
1/ rechercher le numero de commit : 

git log --oneline
e4a48903 [evtbus] appdyn by pass for kafka dev
5fca95d7 set only one record for xmidevtbusdv00uv
20dff863 [kafka] dev adjusts for dev env
b603fb8d [BASE] - updating hosts file for new VM xmidevtbusdv00uv


git log -p 


2/ recupération du fichier concerné dans la bonne version : on examine la conf du fichier avant le commit qui l'a modifier : 

git checkout df9192dc main-config.xml.erb



