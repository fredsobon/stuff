==== notes git ====


== branch + merge request ==

creation de branch : 
git branch subscrib_gen
on passe dans la branche créee : 
git checkout subscrib_gen

- on verifie la branch dans la quelle on est : 
git branch

- on fait une modif : 
vi subscriptions.pp

git status

- on commit 

git commit -am '[sensu] expose a var to generate subscriptions provided in hiera'

- on pousse notre branch sur l'origine : 

git push origin subscrib_gen


Décompte des objets: 10, fait.
Delta compression using up to 4 threads.
Compression des objets: 100% (9/9), fait.
Écriture des objets: 100% (10/10), 1.02 KiB | 0 bytes/s, fait.
Total 10 (delta 5), reused 0 (delta 0)
remote: 
remote: Create merge request for subscrib_gen:
remote:   https://gitlab.meetic.ilius.net/infra-prod/puppet/merge_requests/new?merge_request%5Bsource_branch%5D=subscrib_gen
remote: 
To gitlab.meetic.ilius.net:infra-prod/puppet.git
 * [new branch]        subscrib_gen -> subscrib_gen


visible dans le repo 


- Rebase :

par securité et être en phase avec un repo officiel : ex production , avant de pousser notre branche on pourra être ammené à faire récupérer :

1/ on se met dans la branch que l'on veut pousser :
git checkout elastic_update 

Basculement sur la branche 'elastic_update'
Votre branche est à jour avec 'origin/elastic_update'.
boogie-/home/boogie/Documents/work/repos_work/puppet>> 
boogie-/home/boogie/Documents/work/repos_work/puppet>> 
boogie-/home/boogie/Documents/work/repos_work/puppet>> 

2/ On recupére les modif passées sur notre branche officielle production que l'on réintegre dans notre branche de test :

boogie-/home/boogie/Documents/work/repos_work/puppet>> git rebase production 
Premièrement, rembobinons head pour rejouer votre travail par-dessus...
Application de  [elk] test upgrade for centos 7

3/ puis on pousse les modifs de notre branche de test sur l'origine (si besoin avec les options pour passer en douceurs les eventuels soucis) : 

boogie-/home/boogie/Documents/work/repos_work/puppet>> git push --set-upstream origin elastic_update --force-with-lease
Décompte des objets: 5, fait.
Delta compression using up to 4 threads.
Compression des objets: 100% (5/5), fait.
Écriture des objets: 100% (5/5), 805 bytes | 0 bytes/s, fait.
Total 5 (delta 2), reused 0 (delta 0)
remote: 
remote: Create merge request for elastic_update:
remote:   https://gitlab.meetic.ilius.net/infra-prod/puppet/merge_requests/new?merge_request%5Bsource_branch%5D=elastic_update
remote: 
To gitlab.meetic.ilius.net:infra-prod/puppet.git
 + c91e4358...79a64987 elastic_update -> elastic_update (forced update)
La branche elastic_update est paramétrée pour suivre la branche distante elastic_update depuis origin.






- Supression de branche : 

git branch -D nom de branch 

on ne doit pas être placé dans la branche qu'on veut delete 
boogie-/home/boogie/Documents/work/repos_work/puppet>> git branch 
* production
  subscrib_gen
boogie-/home/boogie/Documents/work/repos_work/puppet>> git branch -D subscrib_gen 
Branche subscrib_gen supprimée (précédemment 54fdef3d).
boogie-/home/boogie/Documents/work/repos_work/puppet>> git branch 
* production


- Listing des branches distantes : 

git branch -r

- Récupération d'une branche d'un repos distant :

git checkout -b nom_de_notre_branche  origin/nom_de_notre_branche

 

- Recupération des fichiers de branche d'un repo distant :

git pull origin nom_de_branche

git pull origin elastic_update
Depuis gitlab:prod/puppet
 * branch              nom_de_branch -> FETCH_HEAD
 Mise à jour 8500f951..13c2eeff
 Fast-forward
  lapin/manifests/init.pp        | 11 ++++++-----
  lapin_nain/manifests/init.pp |  5 +++--
  2 files changed, 9 insertions(+), 7 deletions(-)







= Checkout / restauration fichier original : =

Comment restaurer un fichier 
1/ rechercher le numero de commit : 

git log --oneline
e4a48903 [evtbus] appdyn by pass for kafka dev
5fca95d7 set only one record for xmidevtbusdv00uv
20dff863 [kafka] dev adjusts for dev env
b603fb8d [BASE] - updating hosts file for new VM xmidevtbusdv00uv


git log -p 



2/ recupération du fichier concerné dans la bonne version : on examine la conf du fichier avant le commit qui l'a modifier : 

git checkout df9192dc main-config.xml.erb



=== Reset de conf après un commit (avant avoir pousser ) 

Si on s'apercoit que notre dernier commit n'est pas bon on peut restaurer l'ancienne version avant de pousser sur le repo : 

git reset HEAD~
