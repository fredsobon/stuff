==== notes sur videos oreilly ansible v2 ====

=== Yaml syntax :  ===
Yet Another Markup Language : c'est le language utilisé pour ecrire des playbooks : blocs de code ansible.

un doc yaml commence par ---

---

# les commentaires sont possibles et commencent par un #
on a plusieurs type de données dans un yaml. ex :

-dictionaires de type clé/valeur.
name: gorgonzola youki
occupation:  cheese tester
state: paris

- list :
elles s'ecrivent sous la forme :
- gorgonzola
- brie
- gouda

dans ansible les lists sont de ce type :

cheeses:
 - gorgonzola
 - brie
 - gouda
 
on peut egalement pour gagner en place ou en clarté ecrire les listes entre [ ] 
cheeses: ['gorgonzola', 'brie', 'gouda']

on va pouvoir également quotter nos chaines de caracteres quand il y a des caractères spéciaux et même des variables.
Dans yaml et ansible tout ce qui est situé après un ":" est considéré comme appartenant a un dictionnaire.
ex :

cheese: "{{my_cheese}}" < ici on encadre une variable ansible {{}} par des " " 


== creation de notre env de test : ==

on va passer par vagrant et virtualbox en provider 
2 box vont nous servir :

vagrant box add  bento/centos-7.2
vagrant box add  ubuntu/xenial64

== installation de ansible : ==

1/ sur notre ubuntu 

on se loggue en ssh : vagrant ssh :

on va pouvoir passer par les repos de type ppa: 

apt-add-repository ppa:ansible/ansible

ubuntu@ubuntu-xenial:~$ sudo apt-add-repository ppa:ansible/ansible
 Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications— automate in a language that approaches plain English, using SSH, with no agents to install on remote systems.

http://ansible.com/
 More info: https://launchpad.net/~ansible/+archive/ubuntu/ansible
Press [ENTER] to continue or ctrl-c to cancel adding it

gpg: keyring `/tmp/tmpbrtp7rr4/secring.gpg' created
gpg: keyring `/tmp/tmpbrtp7rr4/pubring.gpg' created
gpg: requesting key 7BB9C367 from hkp server keyserver.ubuntu.com
gpg: /tmp/tmpbrtp7rr4/trustdb.gpg: trustdb created
gpg: key 7BB9C367: public key "Launchpad PPA for Ansible, Inc." imported
gpg: Total number processed: 1
gpg:               imported: 1  (RSA: 1)
OK


on update les repos et on install ansible. On verifie ensuite la version de notre appli :

sudo apt-get update && sudo apt install ansible
ubuntu@ubuntu-xenial:~$ ansible --version
ansible 2.3.2.0
  config file = /etc/ansible/ansible.cfg
  configured module search path = Default w/o overrides
  python version = 2.7.12 (default, Nov 19 2016, 06:48:10) [GCC 5.4.0 20160609]

on a donc la derniere version dispo en cours sur notre server

Sur centos / redhat il va falloir gérer un peu différement :

- yum repolist : 

[root@localhost ~]# yum repolist
Modules complémentaires chargés : fastestmirror
base                                              | 3.6 kB     00:00     
extras                                            | 3.4 kB     00:00     
updates                                           | 3.4 kB     00:00     
(1/4): base/7/x86_64/group_gz                       | 155 kB   00:01     
(2/4): extras/7/x86_64/primary_db                   | 191 kB   00:02     
(3/4): base/7/x86_64/primary_db                     | 5.6 MB   00:13     
(4/4): updates/7/x86_64/primary_db                  | 7.8 MB   00:18     
Determining fastest mirrors
 * base: mirror.guru
 * extras: mirror.guru
 * updates: centos.mirrors.ovh.net
id du dépôt                     nom du dépôt                       statut
base/7/x86_64                   CentOS-7 - Base                    9 363
extras/7/x86_64                 CentOS-7 - Extras                    450
updates/7/x86_64                CentOS-7 - Updates                 2 146
repolist: 11 959

Nous n'avons pas de paquet ansible, on va devoir ajouter un repo fedora :

[root@localhost ~]# wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm

puis l'installer 
[root@localhost ~]# rpm -ivh epel-release-latest-7.noarch.rpm
on update :
[root@localhost ~]# yum repolist
puis on install ansible :
[root@localhost ~]# yum install ansible

[root@localhost ~]# ansible --version
ansible 2.2.9.0
  config file = /etc/ansible/ansible.cfg
  configured module search path = Default w/o overrides
  python version = 2.7.5 (default, Nov 20 2015, 02:00:19) [GCC 4.8.5 20150623 (Red Hat 4.8.5-4)]



Si la version n'est pas assez elevée on peut intégrer les versions testing :
on install le package qui va contenir le binaire nous permettant de gérer les repo "testing" 
[root@localhost ~]# yum install yum-utils.noarch
on active le repo testing :
[root@localhost ~]# yum-config-manager --enable epel-testing

[root@localhost ~]# yum-config-manager --enable epel-testing
Modules complémentaires chargés : fastestmirror
========================== repo: epel-testing ===========================
[epel-testing]
async = True
bandwidth = 0
base_persistdir = /var/lib/yum/repos/x86_64/7
baseurl = 
cache = 0
cachedir = /var/cache/yum/x86_64/7/epel-testing
check_config_file_age = True
compare_providers_priority = 80
cost = 1000
deltarpm_metadata_percentage = 100
deltarpm_percentage = 
enabled = 1
enablegroups = True
exclude = 
failovermethod = priority
ftp_disable_epsv = False
gpgcadir = /var/lib/yum/repos/x86_64/7/epel-testing/gpgcadir
gpgcakey = 
gpgcheck = True
gpgdir = /var/lib/yum/repos/x86_64/7/epel-testing/gpgdir
gpgkey = file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7
hdrdir = /var/cache/yum/x86_64/7/epel-testing/headers
http_caching = all
includepkgs = 
ip_resolve = 
keepalive = True
keepcache = False
mddownloadpolicy = sqlite
mdpolicy = group:small
mediaid = 
metadata_expire = 21600
metadata_expire_filter = read-only:present
metalink = https://mirrors.fedoraproject.org/metalink?repo=testing-epel7&arch=x86_64
minrate = 0
mirrorlist = 
mirrorlist_expire = 86400
name = Extra Packages for Enterprise Linux 7 - Testing - x86_64
old_base_cache_dir = 
password = 
persistdir = /var/lib/yum/repos/x86_64/7/epel-testing
pkgdir = /var/cache/yum/x86_64/7/epel-testing/packages
proxy = False
proxy_dict = 
proxy_password = 
proxy_username = 
repo_gpgcheck = False
retries = 10
skip_if_unavailable = False
ssl_check_cert_permissions = True
sslcacert = 
sslclientcert = 
sslclientkey = 
sslverify = True
throttle = 0
timeout = 30.0
ui_id = epel-testing/x86_64
ui_repoid_vars = releasever,
   basearch
username = 

on upgrade 
[root@localhost ~]# yum upgrade ansible
[root@localhost ~]# ansible --version
ansible 2.3.1.0
  config file = /etc/ansible/ansible.cfg
  configured module search path = Default w/o overrides
  python version = 2.7.5 (default, Nov 20 2015, 02:00:19) [GCC 4.8.5 20150623 (Red Hat 4.8.5-4)]
[root@localhost ~]# ansible --version
ansible 2.3.1.0
  config file = /etc/ansible/ansible.cfg
  configured module search path = Default w/o overrides
  python version = 2.7.5 (default, Nov 20 2015, 02:00:19) [GCC 4.8.5 20150623 (Red Hat 4.8.5-4)]


== ansible configuration =

Pour nos exemples  on va utiliser une conf speciale de ansible couplée a vagrant . Ansible va être notre provisionner par lequel nos vm pourront être contactée
On va specifier a vagrant qu'on va utiliser ansible sur notre box et utiliser une arbo présente sur notre server local :
http://docs.ansible.com/ansible/latest/guide_vagrant.html

on dit a vagrant d'utiliser ansible pour executer le fichier playbook.yml présent dans notre arbo locale provisioning/playbook.yml : qui contiendra notre conf ansible. On ajoute agalement un fichier hosts dans lequel on stockera notre parc server.
On rajoute egalement l'option verbose qui est particulièrement utile pour le debug ansible pour vagrant.
  config.vm.provision "ansible" do |ansible|
  ansible.verbose = "v"
  ansible.playbook = "provisioning/playbook.yml"
  end

on va donc creer notre arbo qui nous servira de base de travail sur notre server ansible : 
 tree working_dir/
working_dir/
├── provisioning
│   └── playbooks
│       └── hosts
├── ubuntu-xenial-16.04-cloudimg-console.log
└── Vagrantfile

cette arbo sera donc visible depuis notre box vagrant via le point de montage : 
ubuntu@ubuntu-xenial:~$ ls -l /vagrant/
total 48
drwxr-xr-x 1 ubuntu ubuntu  4096 Aug 20 09:01 provisioning
-rw------- 1 ubuntu ubuntu 40390 Aug 20 09:22 ubuntu-xenial-16.04-cloudimg-console.log
-rw-r--r-- 1 ubuntu ubuntu  3121 Aug 20 08:52 Vagrantfile


On va copier la clé pub de notre user dans l'authorized key du user root de notre box
On renseigne le host de la manière suivante pour effectuer les premiers tests :

/Documents/lab/ansible/ansible_oreilly_video/vm/provisioning/playbooks$ cat hosts 
Debianubuntu-ansible ansible_ssh_host=127.0.0.1 ansible_ssh_port=2222 ansible_ssh_user=root ansible_ssh_private_key_file=/home/boogie/.ssh/id_rsa

/!\ on peut overrider la config ansible dont la base se situe dans le fichier /etc/ansible/ansible.cfg
on peut par exemple setter en direct la clé priv avec laquelle les authent seront faites dans le fichier /etc/ansible/ansible.cfg
private_key_file = /home/boogie/.ssh/id_rsa
et donc alleger notre fichier hosts :

ubuntu-ansible ansible_ssh_host=127.0.0.1 ansible_ssh_port=2222 ansible_ssh_user=root

on va donc faire notre premier test :
on invoque ansible en lui passant comme argument le server renseigné dans le host <ubuntu-ansible> -i fichier d'inventaire <hosts> ici et -m module utilisé <ping> ici 
:


ansible ubuntu-ansible -i hosts -m ping
ubuntu-ansible | SUCCESS => {
    "changed": false, 
    "ping": "pong"
}

= host settings : =

on peut definir dans notre fichier d'inventaire plusieurs type d'info 
un host, une ip , un host écoutant sur un port particulier , un groupe de server , definir des variables qui seront héritées pour tout un groupe de server .....(même si ce n'est pas une pratique recommandée il peut être utile de le savoir.)

#Making a comment in my hosts file

rainbows.unicorns.com

[testServer]
52.36.167.137 ansible_user=ec2-user ansible_ssh_user=ec2-user  <<< setting de connection particulier pour notre server
test1.example.com:5555  <<< port ssh différent du standart 

[testServer:vars]
ansible_user=ec2-user <<< setting de variables héritées pour le groupe testServer

[webServers]
apache[01:50].example.com <<< range de server avec range en chiffre
nginx[50:100].example.com <<< range de server avec range en chiffre.

[appServers]
app[a:f].example.com    <<< range de server avec range en lettre.

== fichier de conf ansible : =

ordre de priorité de lecture :

$ANSIBLE_CONFIG path de la variable $ANSIBLE_CONFIG si elle est définie
$PWD repertoire courant
$HOME_DIR /home/user
Install par defaut (/etc/ansible)

Ce concept est essentiel dans ansible  : on peut donc overrider notre conf a plusieurs endroits.

les differents blocs de config sont nombreux on peut voir les param généraux, ssh ....

[defaults]  correspondont au param généraux.

ask_pass < permet de demander ou pas un passwd a la connex
fork < permet de définir le nombre de process lancé pendant la connexion a un host . Plus on a de host a gérer dans notre playbook plus ce param est a augmenter pour améliorer le temps de traitement du run.
library < permet de définir l'endroit dans lequel sont stockés les modules.on peut biensur en ajouter et modifier ce path 
remote_user = root < permet de definir le user qui executera le code ansible
private_key_file = /home/boogie/.ssh/id_rsa < definir la clé priv du user qui gérera la connexion 
timeout < permet de definir le temps max pour etablir une connexion avec un host 
transport = smart < permet de definir la maniere dont les run seront traités : openssh en premier sinon on devra définir specifiquement.

inventory      = /etc/ansible/hosts
library        = /usr/share/my_modules/
forks          = 5
ask_pass       = True
transport      = smart
remote_port    = 22
remote_user    = root 
private_key_file = /home/boogie/.ssh/id_rsa

== commandes integrée : ==

on va pouvoir executer des commandes directement :
l'enchainement sera toujours a peu pret identique :

ansible <machine/groupe de machine> -i <inventaire pour le run> -m module < option de modules> -b < permet de devenir become root


- commandes systeme :
le module command nous permet de passer des commandes systeme à nos hosts :

ooks$ ansible ubuntu -i hosts -m command -a "w"
ubuntu | SUCCESS | rc=0 >>
 17:27:20 up  8:05,  2 users,  load average: 0.00, 0.00, 0.00
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
ubuntu   pts/0    10.0.2.2         09:24   16.00s  0.18s  0.18s -bash
root     pts/1    10.0.2.2         17:27    0.00s  0.07s  0.00s w

boogie@apollo:~/Documents/lab/ansible/ansible_oreilly_video/working_dir/provisioning/playbooks$ ansible ubuntu -i hosts -m command -a "service nginx status"
ubuntu | SUCCESS | rc=0 >>
● nginx.service - A high performance web server and a reverse proxy server
   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)
   Active: active (running) since Sun 2017-08-20 17:23:13 UTC; 4min 35s ago
  Process: 4085 ExecStop=/sbin/start-stop-daemon --quiet --stop --retry QUIT/5 --pidfile /run/nginx.pid (code=exited, status=0/SUCCESS)
  Process: 4182 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0/SUCCESS)
  Process: 4179 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, status=0/SUCCESS)
 Main PID: 4184 (nginx)
    Tasks: 3
   Memory: 2.2M
      CPU: 58ms
   CGroup: /system.slice/nginx.service
           ├─4184 nginx: master process /usr/sbin/nginx -g daemon on; master_process on
           ├─4185 nginx: worker process                           
           └─4186 nginx: worker process                           

Aug 20 17:23:13 ubuntu-xenial systemd[1]: Starting A high performance web server and a reverse proxy server...
Aug 20 17:23:13 ubuntu-xenial systemd[1]: Started A high performance web server and a reverse proxy server.

- setup : va nous permettre de récuperer les infos du/des  server(s) 
ansible ubuntu -i hosts -m setup |head
ubuntu | SUCCESS => {
    "ansible_facts": {
        "ansible_all_ipv4_addresses": [
            "10.0.2.15"
        ], 
        "ansible_all_ipv6_addresses": [
            "fe80::2b:21ff:fe2a:210d"
        ], 
        "ansible_architecture": "x86_64", 
        "ansible_bios_date": "12/01/2006", 

- apt / yum : va nous permettre de gerer via les providers de packages des install a des versions precises de packages :

ansible ubuntu -i hosts -m apt -a "name=tree state=latest" -b 
ubuntu | SUCCESS => {
    "cache_update_time": 1503248938, 
    "cache_updated": false, 
    "changed": true, 
    "stderr": "", 
    "stdout": "Reading package lists...\nBuilding dependency tree...\nReading state information...\nThe following NEW packages will be installed:\n  tree\n0 upgraded, 1 newly installed, 0 to remove and 5 not upgraded.\nNeed to get 40.6 kB of archives.\nAfter this operation, 138 kB of additional disk space will be used.\nGet:1 http://archive.ubuntu.com/ubuntu xenial/universe amd64 tree amd64 1.7.0-3 [40.6 kB]\nFetched 40.6 kB in 0s (268 kB/s)\nSelecting previously unselected package tree.\r\n(Reading database ... \r(Reading database ... 5%\r(Reading database ... 10%\r(Reading database ... 15%\r(Reading database ... 20%\r(Reading database ... 25%\r(Reading database ... 30%\r(Reading database ... 35%\r(Reading database ... 40%\r(Reading database ... 45%\r(Reading database ... 50%\r(Reading database ... 55%\r(Reading database ... 60%\r(Reading database ... 65%\r(Reading database ... 70%\r(Reading database ... 75%\r(Reading database ... 80%\r(Reading database ... 85%\r(Reading database ... 90%\r(Reading database ... 95%\r(Reading database ... 100%\r(Reading database ... 56949 files and directories currently installed.)\r\nPreparing to unpack .../tree_1.7.0-3_amd64.deb ...\r\nUnpacking tree (1.7.0-3) ...\r\nProcessing triggers for man-db (2.7.5-1) ...\r\nSetting up tree (1.7.0-3) ...\r\n", 
    "stdout_lines": [
        "Reading package lists...", 
        "Building dependency tree...", 
        "Reading state information...", 
        "The following NEW packages will be installed:", 
        "  tree", 
        "0 upgraded, 1 newly installed, 0 to remove and 5 not upgraded.", 
        "Need to get 40.6 kB of archives.", 
        "After this operation, 138 kB of additional disk space will be used.", 
        "Get:1 http://archive.ubuntu.com/ubuntu xenial/universe amd64 tree amd64 1.7.0-3 [40.6 kB]", 
        "Fetched 40.6 kB in 0s (268 kB/s)", 
        "Selecting previously unselected package tree.", 
        "(Reading database ... ", 
        "(Reading database ... 5%", 
        "(Reading database ... 10%", 
        "(Reading database ... 15%", 
        "(Reading database ... 20%", 
        "(Reading database ... 25%", 
        "(Reading database ... 30%", 
        "(Reading database ... 35%", 
        "(Reading database ... 40%", 
        "(Reading database ... 45%", 
        "(Reading database ... 50%", 
        "(Reading database ... 55%", 
        "(Reading database ... 60%", 
        "(Reading database ... 65%", 
        "(Reading database ... 70%", 
        "(Reading database ... 75%", 
        "(Reading database ... 80%", 
        "(Reading database ... 85%", 
        "(Reading database ... 90%", 
        "(Reading database ... 95%", 
        "(Reading database ... 100%", 
        "(Reading database ... 56949 files and directories currently installed.)", 
        "Preparing to unpack .../tree_1.7.0-3_amd64.deb ...", 
        "Unpacking tree (1.7.0-3) ...", 
        "Processing triggers for man-db (2.7.5-1) ...", 
        "Setting up tree (1.7.0-3) ..."
    ]
}

si on relance notre commande il ne se passera rien car le paquet est dejà installé :

ansible ubuntu -i hosts -m apt -a "name=tree state=latest" 
ubuntu | SUCCESS => {
    "cache_update_time": 1503248938, 
    "cache_updated": false, 
    "changed": false
}

ansible est indempotent
on va installer nginx et verifier si le service est démarré : 
ansible ubuntu -i hosts -m apt -a "name=nginx state=latest" 

on arrete nginx sur notre host :
ubuntu@ubuntu-xenial:/vagrant$ sudo service nginx stop

ubuntu@ubuntu-xenial:/vagrant$ pgrep nginx
ubuntu@ubuntu-xenial:/vagrant$ 

 ansible ubuntu -i hosts -m service -a "name=nginx state=started" -b
ubuntu | SUCCESS => {
    "changed": true, 
    "name": "nginx", 
    "state": "started", 
    "status": {
on voit bien notre service up maintenant :

ubuntu@ubuntu-xenial:/vagrant$ pgrep nginx
4184
4185
4186


== help == 


- help sur la doc : 
ansible-doc --help

- recherche de doc sur keyword générique : 
ansible-doc -l |grep bigip
bigip_device_dns                   Manage BIG-IP device DNS settings                  
bigip_device_ntp                   Manage NTP servers on a BIG-IP                     
...
- doc sur un module : 
ansible-doc bigip_device_dns


== playbook intro ==

les playbooks sont les blocks de construction de code ansible.On peut faire de la config, de l'orchestration et du deploiement via des playbooks.
Ils sont rédigés en yaml et on des structures définis : les plays 
exemple :
play.yml

---
- name: ici on decrit ce que notre playbook/play va faire pour avoir du code lisible.
  hosts: ici on defini notre / nos targer : host, group etc ...
  remote_user: user_dedie si on ne l'a pas deja renseigné dans notre conf globale ou hosts
  become: yes : ici on peut definir si notre user dedié pourra executer les cmds en root

  vars:
    vardefinie: on declare ici des variable qui pourront être alimentée
  tasks: ici on defini les taches qui seront faite sequentiellement et qui pourront être rejouees tant qu'il y a des erreurs.
    - name : on decrit les tasks
      template: src=mylocal_file dst=path_of_file/on_remote_server :on peut utiliser un template : un fichier source qui sera pri de notre env local et poussé dans l'arbo désiree sur notre server.
      notify: on pourra eventuellement faire une action si notre conf est modifier : restarter un service par exemple : pour cela on devra creer une section handler qui actionnera le redemarrage
  handlers: 
  - name : on donne une description
    service: name=nomduservice state=action voulue 


exemple : 
---
- name: install and configure mariadb
  hosts: centos
  become: yes

  vars:
    mysql_port: 3307

  tasks:
    - name: install mariadb server
      yum: name=mariadb-server state=latest
      
    - name: add the config file
      template: src=my.cnf.j2 dest=/etc/my.cnf
      notify: restart mariadb

    - name: create mariadb log file
      file: path=/var/log/mysqld.log state=touch owner=mysql group=mysql mode=0775
    
    - name: start mariadb service
      service: name=mariadb state=started enabled=yes

  handlers:  
  - name: restart mariadb
    service: name=mariadb state=restarted


On va créer notre template my.cnf 

 ~/Documents/lab/ansible/provisionning  $  cat my.cnf.j2 
[mysqld)
datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock
user=mysql

# disabled symlinks 
symbolic-links=0
port={{mysql_port}}

[mysql_safe]
log-error=/var/log/mysqld.log
pid-file=/var/run/mariadb/mysql.pid

Pour executer notre playbook on lance donc :
ansible-playbook -i fichier_inventaire nom_du_playbook.yml

exemple : 

ansible-playbook -i hosts mariadb.yml 

PLAY [install and configure mariadb] *******************************************

TASK [setup] *******************************************************************
ok: [centos]

TASK [install mariadb server] **************************************************
changed: [centos]

TASK [prepare main conf file] **************************************************
changed: [centos]

TASK [create mariadb log file] *************************************************
changed: [centos]
..


== variables : ==

on va pouvoir utiliser des variables dans ansible pour appliquer des conf differentes en fonction de nos serveurs.
Il y a toute une serie de parcours d'arbo hierarchiques pour appliquer une variable si elle est trouvée :
on part de la liste suivante
on override dans l'ordre suivant : 

-> roles par defaut
-> variables d'inventaire
-> groupe de variables d'inventaire
-> variable de host d'inventaire
-> groupe de variable de playbooks
-> variable de host d'un playbook
-> hosts facts
-> facts enregistrés
-> facts definis
-> variable de play
-> variable de prompt de play
-> variable de fichier de play
-> variable de Role et include 
-> variables de bloc
-> variables de tasks
-> extra variables  



On peut definir des variables au sein de notre playbook .

ex : 

on alimente notre playbook de variables au sein d'une section: 
...
vars:
  log_path: "/var/log"

qu'on appelle ensuite plus loin dans notre conf :

...
    - name: create mariadb log file
      file: path={{ log_path }}/mysqld.log state=touch owner=mysql group=mysql mode=0775

On peut pour plus de clarter definir un fichier de variables externe à notre playbook et l'appeller au sein de notre conf :


cat maria_vars.yml 
---
mysql_port: 3307
log_path: "/var/log"


dans notre playbook on remplacera la section vars par vars_file qui contiendra notre fichier de déclaration de variables; 

  vars_files:
    - maria_vars.yml

On peut aussi definir les variable dans la section hosts :
ex : 
---
- name: install and configure mariadb
  hosts: "{{ my_host }}"

qui pourra ensuite être overrider / configurer en cli :
on va donc pouvoir passer notre run sur une selection precise de machine qu'on passe en argument et qui seront ensuite recupérer pour l'execution de notre playbook : 
ansible-playbook -i hosts mariadb.yml --extra-vars "host=centos"  


- Variables "register" : souvent utilisées avec les commandes du module  shell

ex :

---
- name: testing misc variables
  hosts: centos

  tasks:
  - name: get the date of our server
    shell: date
    register: output
     
  -debug: msg="the date is {{ output.stdout }}" 

on va donc enregister dans la variable output notre date puis l'afficher via une task debug : 

 ansible-playbook -i hosts vars_cases.yml 

PLAY [testing misc variables] **************************************************

TASK [setup] *******************************************************************
ok: [centos]

TASK [get the date of our server] **********************************************
changed: [centos]

TASK [debug] *******************************************************************
ok: [centos] => {
    "msg": "the date is lun. août 28 11:01:31 UTC 2017"
}

PLAY RECAP *********************************************************************
centos                     : ok=3    changed=1    unreachable=0    failed=0   
 

- Variables facts : 
on va pouvoir travailler avec les variables récupérées des facts présents sur nos serveurs : 

ex on peut regrouper nos servers via des facts qui serviront pour le tri : 

  - debug: var=ansible_distribution_version
  
  - name: group some machines temporaly
    group_by: key=rhel_{{ansible_distribution_version}}
    register: group_result
 
  - debug: var=group_result  

ex : 
 $  ansible-playbook -i hosts vars_cases.yml 
..

TASK [debug] *******************************************************************
ok: [centos] => {
    "ansible_distribution_version": "7.3.1611"
}

TASK [group some machines temporaly] *******************************************
ok: [centos]

TASK [debug] *******************************************************************
ok: [centos] => {
    "group_result": {
        "add_group": "rhel_7.3.1611", 
        "changed": false
    }
}

PLAY RECAP *********************************************************************
centos                     : ok=6    changed=1    unreachable=0    failed=0   


==  conditionals : ==

On peut controler l'execution de nos playbooks avec des tests qui permettront ou pas de realiser l'action 
ex : 

 ~/Documents/lab/ansible/provisionning  $  cat conditionals.yml 
---
- name: testing some conditionals 
  hosts: centos
  become: yes

  vars:
    lapin: true   << on set une variable a vrai 

  tasks:
  - name: do not check on debian server
    yum: name=tree state=latest
    #when: ansible_os_family=="Redhat"   <<< on test si notre os est une red hat 
    when: (ansible_os_family=="Redhat" and ansible_distribution_major_version=="6")   <<< on peut cumuler avec des opérateurs booleens AND OR ....

  - name: lapin is ral or fake ?
    shell: echo "lapin is fake!!" 
    when: not lapin      <<<< on va tester et afficher lapin is fake si on a pas defini lapin en variable 


 ansible-playbook -i hosts conditionals.yml 

PLAY [testing some conditionals] ***********************************************

TASK [setup] *******************************************************************
ok: [centos]

TASK [do not check on debian server] *******************************************
skipping: [centos]

TASK [lapin is ral or fake ?] **************************************************
skipping: [centos]

PLAY RECAP *********************************************************************
centos                     : ok=1    changed=0    unreachable=0    failed=0   


on va pouvoir afficher notre message si on enregistre le dans une variable notre commande shell et qu'on l'affiche ensuite ;

  - name: lapin is ral or fake ?
    shell: echo "lapin is fake!!" 
    register: output
    when: lapin

  - debug: msg="for sure "{{ output.stdout }}""


 ~/Documents/lab/ansible/provisionning  $  ansible-playbook -i hosts conditionals.yml 

PLAY [testing some conditionals] ***********************************************

TASK [setup] *******************************************************************
ok: [centos]

TASK [do not check on debian server] *******************************************
skipping: [centos]

TASK [lapin is ral or fake ?] **************************************************
changed: [centos]

TASK [debug] *******************************************************************
ok: [centos] => {
    "msg": "for sure \"lapin is fake!!\""
}

PLAY RECAP *********************************************************************
centos                     : ok=3    changed=1    unreachable=0    failed=0   


== loops : ==
on va  pouvoir se servir des bloucles pour permettre la gestion multiples d'actions.Plusieurs types de boucles existent.

- with_items : est une forme de boucle très utilisée dans ansible.
On va pouvoir itérer un nombre le nombre de fois nécéssaire sur une liste.

exemple pour l'installation de plusieurs paquets on va definir une variable qui va récupérer chaque entrée d'une liste et procéder à l'install :

  tasks: 
  - name: install tools 
    yum: name={{ item }} state=installed
    with_items: 
    - lsof
    - tree
    - nmap
- with_dict : va nous permettre d'iterer sur un dictionnaire 


- name: testing loops
host: centos

  tasks:
  - name: looping other env facts
    debug: msg={{item.key}}=>>{{item.value}}
    with_dict: "{{ ansible_env }}"

- with_files , with_fileglob etc ..: on va opérer sur les elements de fichier : 

  - name: looping over files
    copy: src={{item}} dest=/tmp/loops   <<< on defini nos rep de source et destination
    with_fileglob: "/tmp/*.conf"    <<<< ici on defini le pattern de nos fichiers source qui seront copiés sur la dest.


- until : une autre forme de loop :

  - name: do until something 
    shell: echo "hello!!"
    register: output
    retries: 5
    delay: 5
    until: output.stdout.find('hello!!') != -1

    
== blocks : ==

Ils vont nous permettre de regrouper des tasks logiquement entre elles.C'est utile avec les tests condtionnels et les escalades de privileges nécéssaire pour l'execution des taches multiples.

ex : on va pouvoir ici installer toute une conf mariadb si notre os est de type RedHat 



- name: install and configure mariadb
  hosts: centos
  strategy: debug

  vars_files:
    - maria_vars.yml

  tasks:
    - blocks:
       - name: install mariadb server
         yum: name=mariadb-server state=latest
 
       - name: prepare main conf file
         template: src='my.cnf.j2' dest='/etc/my.cnf'
         notify: restart mariadb
 
       - name: create mariadb log file
         file: path='/var/log/mysqld.log' state=touch owner=mysql group=mysql mode=0775
 
       - name: start mariadb service
         service: name=mariadb state=started enabled=yes
     when: ansible_os_family=="Redhat"
     become: yes

Les blocs permettent egalement une tres bonne gestion des erreurs.



---
- name: testing blocks for debug
  hosts: centos
  

  tasks:
  - block: 
    - name: copy files to dst
    - copy: src=/tmp/lapin dest=/tmp/loops
    rescue:   <<<<<<<<<<<<<<<<<<<<<<< ici on pose un rescue 
    - debug: msg="Always stop for debug"   <<<< le message s'affichera en cas d'erreur
    always:   <<<<<<<<<<<<<<<<<<<<<< ici on pose un always 
    - debug: msg="always show the message !" <<<<< le message sera toujours affiché


  - block:   <<<<< on peut imbriquer des blocs
    - block:
      - block:
        - debug: msg="nesting some blocs!"


