=== quick notes for docker ===

= docker cmds = :

- pull :

on recupere une image depuis un repo. Sans precision l'image sera la derniere dispo : latest et le repo sera le docker hub 

docker pull  nginx
Using default tag: latest
latest: Pulling from library/nginx
Digest: sha256:dd2d0ac3fff2f007d99e033b64854be0941e19a2ad51f174d9240dda20d9f534
Status: Image is up to date for nginx:latest

- run  

on va pouvoir demarrer une image et donc lancer un container.
Si on ne dispose pas de l'image en local alors la commande run va aller chercher l'image sur un repo et lancer l'execution du container de cette image: 

docker run nginx
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
6ae821421a7d: Pull complete 
da4474e5966c: Pull complete 
eb2aec2b9c9f: Pull complete 
Digest: sha256:dd2d0ac3fff2f007d99e033b64854be0941e19a2ad51f174d9240dda20d9f534
Status: Downloaded newer image for nginx:latest

options :

-it : va lancer un tty interractif 
-d : va lancer le container en mode background
-p : va rediriger un port choisi de notre host vers notre container 
-P : va laisser docker choisir un port de redirection pour nous
-exec : va permettre de lancer l'execution d'une commande dans notre container 
--rm : va detruire le container quand la console sera quittée ( ctrl + C ou exit si on est dans le container ) 
--name : on va pouvoir donner un nom à notre container.

ex : 
lance un container avec tty qui se deletera apres l'utilisation dont le port host local 80 redirige vers le port 80 du container 
docker run -it --rm -p 80:80 test_nginx 

- ps  ou container ls ( qui est la nouvelle forme )

on va pouvoir examiner le status de nos containers avec ps :

seul docker ps nous montre les containers actifs 

boogie@satellite:/tmp/docker$ docker ps 
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
c87893dd3020        test_nginx          "nginx -g 'daemon of…"   3 seconds ago       Up 2 seconds        80/tcp              fervent_austin

- ps -a : l'option -a de ps nous permet de voir les containers coupés mais toujours présents sur le systeme : 

boogie@satellite:/tmp/docker$ docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES
c87893dd3020        test_nginx          "nginx -g 'daemon of…"   25 seconds ago      Up 24 seconds               80/tcp              fervent_austin
61da09a86823        nginx               "nginx -g 'daemon of…"   14 minutes ago      Exited (0) 13 minutes ago                       thirsty_agnesi
76e4c434a635        fce289e99eb9        "/hello"                 4 hours ago         Exited (0) 4 hours ago                          determined_curran
01b8007cd18e        fce289e99eb9        "/hello"                 4 hours ago         Exited (0) 4 hours ago                          peaceful_wilson

- stop
on va arrêter un container 
on peut stopper le container par son nom ou par son id : 
docker stop silly_mirzakhani
docker stop 99cda3458bab

- container 
on va pouvoir examiner les containers avec la commande container 
ex 
docker container ls 

boogie@satellite:/tmp/docker$ docker container ls
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
c87893dd3020        test_nginx          "nginx -g 'daemon of…"   4 minutes ago       Up 4 minutes        80/tcp              fervent_austin

- images :

on va pouvoir examiner les images présentes sur le systeme avec :

docker images 
boogie@satellite:/tmp/docker$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
test_nginx          latest              ee0931fc9765        6 minutes ago       157MB
nginx               latest              f09fe80eb0e7        11 days ago         109MB

- rmi :

suppression d'images avec la commandes rmi /!\ Attention aucun container issu de cette image ne doit être démarré : sinon ca ne fonctionne pas ( on peut cepandant by passer avec l'option force -f )

toutes les layers de l'images seront supprimées : 

boogie@satellite:/tmp/docker$ docker rmi test_nginx
Untagged: test_nginx:latest
Deleted: sha256:ee0931fc97651e73c3416af00c46cd62a5f783588fccb29257abf86ced9d8459
Deleted: sha256:92d2be83c1df91049dfba524bd9bc2ac0c897eee0a550ffa57dadb48dbbe2eb5
Deleted: sha256:880becabb408765d24e181a6507bc258ca0fb92c6a1d52c084b6ebcfaf6cda18
Deleted: sha256:ace5bb277eb13b902696f77a3d5414894fe22bcbc4188318f66b69df7721a509
Deleted: sha256:fc314536b936845563d8a66db4cd0c619282d09fd5c2091a143ecd655211c02c
Deleted: sha256:0a16cfeeba33e4facb63f6ef20959c68eb6b29cc41eb5e9a4fb7f4085198db53


- stats : 

on va pouvoir examiner les différentes ressources prises par notre container :
exemple on lance un container :
docker run  -it --rm --name testo   testo bash
root@ea74df66b3ec:/#
et on examine son status : 
docker stats testo

iCONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT    MEM %               NET I/O             BLOCK I/O           PIDS
ea74df66b3ec        testo               0.00%               1.27MiB / 15.35GiB   0.01%               3.29kB / 0B         0B / 0B             1

- top : 

on va pouvoir examiner les process de notre container avec un top : 

docker top testo
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                3277                3262                0                   19:21               pts/0               00:00:00            bash



- inspect : va nous permettre d'avoir tout une liste d'information relative à notre container :

 docker inspect testo
[
    {
        "Id": "ea74df66b3ec74d57b04adc70fc6d032789bc547d1f13b83d047e41c08110d0d",
        "Created": "2019-02-25T18:21:33.142412379Z",
        "Path": "bash",
        "Args": [],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 3277,
        ...
        },
        "Image": "sha256:b38b9a4041a4158587d5fb26add06a7044aeed4f0f8064a376e59a8b6ae7117f",
        "ResolvConfPath": "/var/lib/docker/containers/ea74df66b3ec74d57b04adc70fc6d032789bc547d1f13b83d047e41c08110d0d/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/ea74df66b3ec74d57b04adc70fc6d032789bc547d1f13b83d047e41c08110d0d/hostname",
        "HostsPath": "/var/lib/docker/containers/ea74df66b3ec74d57b04adc70fc6d032789bc547d1f13b83d047e41c08110d0d/hosts",
        "LogPath": "/var/lib/docker/containers/ea74df66b3ec74d57b04adc70fc6d032789bc547d1f13b83d047e41c08110d0d/ea74df66b3ec74d57b04adc70fc6d032789bc547d1f13b83d047e41c08110d0d-json.log",
        "Name": "/testo",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
                ...
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
                ...
                "MergedDir": "/var/lib/docker/overlay2/20f318b167119c60e60fb4a29ed215bb70cfeceb8a85b27fa6d572f2bcc6f31c/merged",
                "UpperDir": "/var/lib/docker/overlay2/20f318b167119c60e60fb4a29ed215bb70cfeceb8a85b27fa6d572f2bcc6f31c/diff",
                "WorkDir": "/var/lib/docker/overlay2/20f318b167119c60e60fb4a29ed215bb70cfeceb8a85b27fa6d572f2bcc6f31c/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [
            {
                "Type": "volume",
                "Name": "fa0daedb6892ea52e6fe2304ed39295c7d7d90c70dd09332d7c0f08118251a3a",
                "Source": "/var/lib/docker/volumes/fa0daedb6892ea52e6fe2304ed39295c7d7d90c70dd09332d7c0f08118251a3a/_data",
                "Destination": "/etc/nginx/conf.d",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            },
            {
                "Type": "volume",
                "Name": "c95cd0ce42d4089a13ff14ca7f94da24866d7fdb9226dc8a6a57f2629096b607",
                "Source": "/var/lib/docker/volumes/c95cd0ce42d4089a13ff14ca7f94da24866d7fdb9226dc8a6a57f2629096b607/_data",
                "Destination": "/var/www",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ],
        ...
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "dd19b06426615da763591ef411472a636c95f7b01ebc7d79c74fa41f73e7f34a",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {
                "80/tcp": null,
                "9000/tcp": null
            },
            "EndpointID": "3b840d204ef9ce527e335273a2a16d57dd9e38536cae4537c976d57b977e4e38",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "97ba5230251f3f6fe11fe751e0dfb58adf6760e8b84b4092c5f3dd4290ceb039",
                    "EndpointID": "3b840d204ef9ce527e335273a2a16d57dd9e38536cae4537c976d57b977e4e38",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
....
.......


 Il est possible d'obtenir assez finement les informations de notre image .
 ex : ici on va rechercher toutes les infos relatives au label ( metadata ) de notre image :

 docker image inspect -f {{.Config.Labels}} testo
map[maintainer:NGINX Docker Maintainers <docker-maint@nginx.com> version:777]


- history :

on va pouvoir examiner les différentes couches / layers de notre image afin de voir la décomposition des strates :

docker history testo
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
b38b9a4041a4        3 days ago          /bin/sh -c #(nop)  CMD ["/bin/echo" "BoogieW…   0B
405cb62bb2c1        3 days ago          /bin/sh -c #(nop)  EXPOSE 9000                  0B
31c6c7055f62        3 days ago          /bin/sh -c #(nop)  VOLUME [/etc/nginx/conf.d…   0B
fe16e70aa223        3 days ago          /bin/sh -c #(nop)  VOLUME [/var/www/]           0B
7719d5c07884        3 days ago          /bin/sh -c rm /etc/nginx/conf.d/default.conf    0B
e3c69195032a        3 days ago          /bin/sh -c apt update -y && apt install -y v…   47.4MB
64aa32a5a151        3 days ago          /bin/sh -c #(nop)  LABEL version=777            0B
f09fe80eb0e7        2 weeks ago         /bin/sh -c #(nop)  CMD ["nginx" "-g" "daemon…   0B

- build :

on va pouvoir construire une image et ensuite l'executer en tant que container :

on va pouvoir donner un nom tagger notre image .
On va pour la builder s'assurer d'être dans un repertoire dédié ne comportant que le necessaire pour notre image.
Nous allons alimenter un Dockerfile qui sera le fichier d'instruction pour le build , puis lancer le build avec : 

/!\ attention a bien ordonnancer nos ressources dans le dockerfile : l'installation de packets et tache gourmandes sont a faire en debut de fichier : car a chaque rebuild ( debug de notre appli ) le traitement ne sera pas a refaire : un cache local est utilisé.

Il va être important d'essayer de cumuler les etapes consommatrices de volume : ex combiner les opérations d'intallation , suppression de packets : à chaque appel de commande dans le dockerfile une strate est créee 

docker build -t test_nginx .

- Dockerfile :

plusieurs section vont être nécéssaire pour remplir le dockerfile 

FROM image source 
RUN  commande a executer sur notre container
COPY source_locale dest_container
LABEL
VOLUME
EXPOSE
ENV
CMD
ENTRYPOINT
...

exemple : ici on va builder une image dont la source sera une image docker officielle nginx . On va ensuite installer vim sur l'image .On va ensuite copier depuis notre arbo locale vers le file system deux fichiers : une ressource html et une conf ) 

boogie@satellite:/tmp/docker$ cat Dockerfile 
FROM nginx
RUN apt-get update && apt-get install -y vim
COPY testo/testo.html /var/www/
COPY testo/testo.conf /etc/nginx/conf.d/default.conf
boogie@satellite:/tmp/docker$ tree
.
├── Dockerfile
└── testo
    ├── testo.conf
    └── testo.html

Il est possible d'ajouter d'autre conf dans nos dockerfile :


-FROM : va nous permettre de définir l'image de base qui va servir à construire notre propre image 


-RUN : va nous permettre d'agit sur le contenu de notre image : ajouter des packets, lancer des scripts , delete des rep .....
ex: 

RUN apk add --update nginx && \
  rm -rf /var/cache/apk/* && \
  mkdir -p /tmp/nginx/


-LABEL : va nous permettre d'ajouter des metadata qui seront utiles : info du mainteneur, version de l'image ...La forme attendue des entrées est key=value :
ex :
LABEL version="1.1"
LABEL description="image pour faire des gaufres ..."

-VOLUME : il va être possible de préparer des points de montage dans notre conf d'image dans ce cas le montage sera "exposé" et lors du demarrage du container on precisera la source locale de notre directory qui sera montée dans notre container. On peut déclarer plusieurs VOLUME qu'il faudra instancier explicitement lors du démarrage de notre docker : 

-EXPOSE : il va être possible de definir un ou plusieurs ports ouverts dans notre container. Comme pour les points de montage, il faudra les définir explicitement lors du démarrage de notre container :
EXPOSE 9000
On peut definir le port corrrespondant au container de notre host avec l'option -p <port_host>:<port_container> 

docker run --rm -p 80:9000 testo
ce qui nous donnera avec un docker ps :

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                          NAMES
f9292f069e6a        testo               "/bin/sleep 100"    7 seconds ago       Up 6 seconds        80/tcp, 0.0.0.0:80->9000/tcp   elastic_meninsky

on peut sinon laisser docker choisir lui même le port avec un -p <port_container> 

docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                             NAMES
27706d4ec7e2        testo               "/bin/sleep 100"    4 seconds ago       Up 3 seconds        80/tcp, 0.0.0.0:32769->9000/tcp   trusting_vaughan


- CMD : on peut permettre a notre container d'executer une commande apres son démarrage : un seul bloc CMD par dockerfile 
CMD ["/bin/echo", "BoogieWonderlanD!" ]

docker run --rm -p 9000 testo
BoogieWonderlanD


ex : 

VOLUME /var/www/
VOLUME /etc/nginx/conf.d/

docker run --rm -v /home/boogie/Documents/work/repos_work/docker-workshop/workshop2/app/:/var/www/ -v /home/boogie/Documents/work/repos_work/docker-workshop/workshop2/config:/etc/nginx/conf.d/ testo


FROM  nginx
LABEL version="777"
RUN   apt update -y && apt install -y vim
#COPY  config/workshop.conf config/9000.conf /etc/nginx/conf.d/
#COPY  app/index.html  app/idx.html /var/www/
RUN   rm /etc/nginx/conf.d/default.conf
VOLUME /var/www/
VOLUME /etc/nginx/conf.d/
EXPOSE 9000
CMD ["/bin/sleep", "100" ]


- docker version
de base quand on utilise docker notre client interroge le serveur (installé en local) celui ci repond via l'api docker .

boogie@satellite:/tmp$ docker version
Client:
 Version:           18.06.1-ce
 API version:       1.38
 Go version:        go1.10.4
 Git commit:        e68fc7a
 Built:             Fri Jan 25 14:34:22 2019
 OS/Arch:           linux/amd64
 Experimental:      false

Server:
 Engine:
  Version:          18.06.1-ce
  API version:      1.38 (minimum version 1.12)
  Go version:       go1.10.4
  Git commit:       e68fc7a
  Built:            Thu Jan 24 10:47:43 2019
  OS/Arch:          linux/amd64
  Experimental:     false


- docker info 

va nous permettre d'avoir beaucoup d'informations utiles sur notre environment local : 

docker info
Containers: 5
 Running: 0
 Paused: 0
 Stopped: 5
Images: 19
Server Version: 18.09.1
Storage Driver: overlay2
 Backing Filesystem: extfs
 Supports d_type: true
 Native Overlay Diff: true
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: bridge host macvlan null overlay
 Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
Swarm: inactive
Runtimes: runc
Default Runtime: runc
Init Binary: docker-init
containerd version: 9754871865f7fe2f4e74d43e2fc7ccd237edcbce
runc version: 96ec2177ae841256168fcf76954f7177af9446eb
init version: fec3683
Security Options:
 apparmor
 seccomp
  Profile: default
Kernel Version: 4.19.0-1-amd64
Operating System: Debian GNU/Linux buster/sid
OSType: linux
Architecture: x86_64
CPUs: 4
Total Memory: 15.35GiB
Name: lapin
ID: 55PR:2LQX:N4JS:5MKG:GRTI:SZRU:5DQC:75TM:7Y3T:MFKY:UEHD:FLYX
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://index.docker.io/v1/
Labels:
Experimental: false
Insecure Registries:
 127.0.0.0/8
Live Restore Enabled: false
Product License: Community Engine

WARNING: No swap limit support

