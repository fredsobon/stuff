==== Notes from puppet_essntials_2nd edition ====


== Chapitre 1 Writing  first manifests ==

= Demarrage :
 l'installation se fait via les repos des distrib ou alors directement depuis le site puppetlabs
 On peut aussi décider d'intaller puppet en ruby gem mais ce n'est pas recommandé.
Apres l'install on peut commencer à ecrire un manifest ce qui est le language / script de puppet . il est ecris endsl (domain specfic language)


on utilise pour l'instant una machine vagrant avec un client puppet installé.
On se place dans une arbo , on crée notre manifest et on le lance :

[root@client manifests]# cat helloworld.pp 
notify {'hello, world !':
}

[root@client manifests]# puppet apply helloworld.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.06 seconds
Notice: hello, world !
Notice: /Stage[main]/Main/Notify[hello, world !]/message: defined 'message' as 'hello, world !'
Notice: Applied catalog in 0.02 seconds

Pour eviter de mettre la bazar sur le system on va essayer de ne pas faire démarrer auto un service : exemple puppet :) 

puppet_service.pp
service { 'puppet':
ensure => 'stopped',
enable => false,
}

[root@client manifests]# puppet apply puppet_service.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.25 seconds
Notice: /Stage[main]/Main/Service[puppet]/ensure: ensure changed 'running' to 'stopped'
Notice: Applied catalog in 0.11 seconds

A noter que l'on execute les commandes puppet avec un sudo ou en root

Si on relance notre run : rien ne se passe car le service a dejà ete arreté

[root@client manifests]# puppet apply puppet_service.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.24 seconds
Notice: Applied catalog in 0.03 seconds


On met ici en evidence qe puppet est un systeme indepomdent : il examine une resssoure, l'etat attendu de cette ressource et ne procede aux changements que si quelque chose n'est pas configuré comme attendu.



= Ressources et propriétés :=

Les resources sont les blocs élémentaires des manifests :chacune à un type ( exemple notify, service) et un nom , un titre ( exemple : hello world , puppet )
Chaque resource est unique dans un manifest et peut être référencées par la combinaison de son nom et son type 
Une ressource est aussi definie par un ensemble de 0 à plusieurs attributs : un attribut est un enemble clé valeur de type : "enable" => false

Attention le nom des attributs depend des ressources on ne peut pas mettre n'inporte quoi . Certains param sont dispo pour tout type de ressource (metaparametres) d'autre sont commun : ex "ensure" 

Ex le type service supporte la proprieté ensure ( status de la ressource) alors que la propriéte enable a comme scope le demarrage du system par l'os.
Les termes attributs, parametres et proprité sont utilisés de diffrentes manière.

On doit juste savoir que les param et proprietes sont deux differents type d'attributs que puppet utilise 

on voit ici deux proprités et un parametre dans le manifest suivant 

service { 'puppet':
ensure   => 'stopped',
enable   => false,
provider => 'upstart',
}

le parametre provider indique à puppe qu'il doit travailler avec upstart contrairement par exemple  systemd ou init
Sans cette definition explicite : puppet gerera le param de son choix grace a des fonctions internes

EN gros les paramètres indique à puppet commennt gérer une ressource et pas quel est l'etat désiré.

Une propriété est considére synchro avec le systeme pour une ressource donnée 

Pour mémo : les propriétes  peuvent être hors synchro  alors que les param eux ne le peuvent pas.

Puppet peut lire une config sur le systeme avec la commande puppet ressource : 


root@puppetmaster:~# puppet resource user root
user { 'root':
ensure      => 'present',
comment     => 'root',
gid         => '0',
home        => '/root',
password    => '$6$17/7FtU/$TvYEDtFgGr0SaS7xOVloWXVTqQxxDUgH. eBKJ7bgHJ.hdoc03Xrvm2ru0HFKpu1QSpVW/7o.rLdk/9MZANEGt/',
password_max_age => '99999',
password_min_age => '0',
shell => '/bin/bash',
uid => '0',
}

Interpretatin de la sortie de la commande apply 


On a lors de la sortie de commande en gros deux phases :
une premiere pour la compilation du catalogue et la seconde correspondant à l'application du catalogue


[root@client manifests]# puppet apply puppet_service.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.26 seconds
Notice: Applied catalog in 0.03 seconds

0n peut avoir beaucoup plus d'info en invoquand par exemple :

[root@client manifests]# puppet apply -e'service { "puppet": enable => true, }'
Notice: Compiled catalog for client.example.com in environment production in 0.24 seconds
Notice: /Stage[main]/Main/Service[puppet]/enable: enable changed 'false' to 'true'
Notice: Applied catalog in 0.11 seconds

On voit ici qu'on forcer en commande ligne la modif de param de notre resource


- Dry run :

on va pouvoir lancer les comandes en dry run : pas d'effet on voit juste le comportement de notre run : 

[root@client manifests]# puppet apply puppet_service.pp --noop
Notice: Compiled catalog for client.example.com in environment production in 0.24 seconds
Notice: /Stage[main]/Main/Service[puppet]/enable: current_value true, should be false (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 1 events
Notice: Stage[main]: Would have triggered 'refresh' from 1 events
Notice: Applied catalog in 0.03 seconds


- Structures de controle dans les manifests :

on peut comme dans les language utilisés des formes de controle .
ex : 

bloc if /else :


if 'mail_lda' in $needed_services {
service { 'dovecot': enable => true }
} else {
service { 'dovecot': enable => false }
}

Case :


case $role {
'imap_server': {
    package { 'dovecot': ensure => 'installed' }
    service { 'dovecot': ensure => 'running' }
  }
/_webserver$/: {
    service { [ 'apache', 'ssh' ]: ensure => 'running' }
  }
default: {
    service { 'ssh': ensure => running }
  }
}

on a une definiton de cas par défaut .

On peut trouver egalement une autre forme de tests de controle : les selectors : 

package { 'dovecot':
    ensure => $role ? {
    'imap_server' => 'installed',
    /desktop$/    => 'purged',
default    => 'removed',
  },
}


- Utilisation de variables : 

Toutes les variables commencent avec un $ 

$download_server = 'img2.example.net'
$url = "https://${download_server}/pkg/example_source.tar.gz"

Comme dans les autres languages on a un comportement différent si on place des ",' ...pour l'interprétation de nos variables.

Dans puppet une fois qu'une variable a été créee elle ne peut pas être modifier ( il y a une copie d'objet)

- Types de variables :

  $a_bool = true
  $a_string = 'This is a string value'
  $an_array = [ 'This', 'forms', 'an', 'array' ]
  $a_hash = {
  'subject' => 'Hashes',
  'predicate' => 'are written',
  'object'    => 'like this',
  'note'      => 'not actual grammar!',
  'also note' => [ 'nesting is',
  { 'allowed' => ' of course' } ],
}

Pour l'assignement de valeurs : c'est simple 

$x = $a_string
$y = $an_array[1]
$z = $a_hash['object']

Les strings peuvent être des attibuts de variable
il faut faire attention que le titre d'une ressource soit aussi une référence  de variable 

package { $apache_package:
ensure => 'installed'
}

on peut egalement utiliser un tableau pour déclarer tout un lot de resource dans une seule section.
ex : ici on s'assure que tous les packets mentionnés dansle tableau soient bien installés.

$packages = [ 'apache2',
    'libapache2-mod-php5',
     'libapache2-mod-passenger', ]
package { $packages:
ensure => 'installed'
}

Il n'est pas nécéssaire de stocker les valeurs du tableau dans une variable mais c'est une bonne pratique.


- Controle de l'ordre d'évaluation : 

Un manifest n'est pas un script : c'est juste un outil pour définir l'etat d'un systeme a travers differentes ressources (packages , services, fichiers, cron ...;)
Le language de puppet est déclaratif : le manifest déclare un set de resources qui doivent avoir des états  particulier .Ces ressources sont mises dans un catalogue et puppet essaie de construire le build . Le compilateur parse les manifests dans l'ordre mais le configurateur le fait dans un tout autre ordre.
Le manifest décrit ce que l'on veut obtenir : les actions spécifiques pour atteindre ce résultat sont prises par puppet.


package { 'haproxy':
    ensure => 'installed',
}
file {'/etc/haproxy/haproxy.cfg':
    ensure => file,
    owner => 'root',
    group => 'root',
    mode => '0644',
    source => 'puppet:///modules/haproxy/etc/haproxy/haproxy.cfg',
}
service { 'haproxy':
ensure => 'running',
}

Dans ce manifest puppet s'assure que le packet haproxy est installé , le fichier haproxy.cfg a un contenu particulier présent dans un repertoire module et haproxy est démarré.
Dans les versions  récentes de puppet ont peu définir l'ordre d'évaluation dans le puppet.conf
ordering = manifest
c'est la setting par defaut dans puppet4

-Déclaration de dépendances : 

Un  des moyens les plus simple pour assurer un ordre est d'utiliser un chaining de ressource : on utilise un symbole "->"


package { 'haproxy':
  ensure => 'installed',
  }
->
file { '/etc/haproxy/haproxy.cfg':
ensure => file,
owner => 'root',
group => 'root',
mode
=> '0644',
source => 'puppet:///modules/haproxy/etc/haproxy/haproxy.cfg',
}
->
service {'haproxy':
ensure => 'running',
}

Ceci  est possible si toutes les ressources peuvent être définies  dans un seul et même fichier.
Il existe des méthodes beaucoup plus fléxibles en utilisant des metaparamètres : paramètres qui sont utilisables pour differents type de resources
Pour la gestion de l'ordre des resources puppet utilisent par exemple :
before et require .
Attention on ne peut déclarer des metaparametres que sur des ressources existant dans le catalogue.

On voit ici la manifest haproxy avec l'utilisation de require :

package { 'haproxy':
   ensure => 'installed',
  }
file {'/etc/haproxy/haproxy.cfg':
ensure => file,
owner => 'root',
group => 'root',
mode  => '0644',
source => 'puppet:///modules/haproxy/etc/haproxy/haproxy.cfg',
require => Package['haproxy'],
}
service {'haproxy':
ensure => 'running',
require => File['/etc/haproxy/haproxy.cfg'],
}


Ici le même manifest est utilisant maintenant before :

package { 'haproxy':
  ensure => 'installed',
  before => File['/etc/haproxy/haproxy.cfg'],
}
file { '/etc/haproxy/haproxy.cfg':
  ensure => file,
  owner => 'root',
  group => 'root',
  mode  => '0644',
  source => 'puppet:///modules/haproxy/etc/haproxy/haproxy.cfg',
before => Service['haproxy'],
  }
service { 'haproxy':
ensure => 'running',
}

Il est courant d'utiliser require mais dans certains cas ( gestion de packages ) before peut être très pratique.

- Erreurs de propagation : la definition de require permet de definir un autre sujet important : les references sur les resources déclarées seront considérées comme valides si la dépendance initiale s'est finie correctement : c'est un "point d'arret de puppet" lorsqu'une dependance n'est pas satisfaite.
ex : on a une erreur de run si notre fichier de conf suivant n'est pas trouvé :

file { '/etc/haproxy/haproxy.cfg':
ensure => file,
source => 'puppet:///modules/haproxy/etc/haproxy.cfg',
}

root@puppetmaster:~# puppet apply typo.pp
Notice: Compiled catalog for puppetmaster.example.net in environment
production in 0.62 seconds
Error: /Stage[main]/Main/File[/etc/haproxy/haproxy.cfg]: Could not
evaluate: Could not retrieve information from environment production
source(s) puppet:///modules/haproxy/etc/haproxy.cfg
Notice: /Stage[main]/Main/Service[haproxy]: Dependency File[/etc/haproxy/
haproxy.cfg] has failures: true
Warning: /Stage[main]/Main/Service[haproxy]: Skipping because of failed
dependencies
Notice: Applied catalog in 0.06 seconds

On a donc une erreur de run : on voit ici que le service n'est pas modifié (redémarré par ex) car le fichier de conf n'est pas trouvé. : c'est donc une méthode sécure.


- Interdire les dépendances circulaires :

Il est capitale de ne pas définir de dépendances circulaires 
ex :

file { '/etc/haproxy':
ensure => 'directory',
owner => 'root',
group => 'root',
mode  => '0644',
}

file { '/etc/haproxy/haproxy.cfg':
ensure => file',
owner => 'root',
group => 'root',
mode  => '0644',
source => 'puppet:///modules/haproxy/etc/haproxy/haproxy.cfg',
}

service { 'haproxy':
ensure => 'running',
require => File['/etc/haproxy/haproxy.cfg'],
before => File['/etc/haproxy'],
}


on a ici des dépendances  a tous les niveaux : le fichier /etc/haproxy/haproxy.cfg dépend implictement de  la création du rep /etc/haproxy . Le repertoire /etc/haproxy dépend du service  haproxy et le service haproxy dépend du fichier de conf /etc/haproxy/haproxy.cfg ...

A noter :
si un fichier et un rep dépendent de la creation d'un rep superrieur : puppet le créer en auto
si un user et le groupe primaire du user sont définis : puppet crée en premier le groupe 
si un fichier et son user sont déclarés : puppet crée en premier le user 

on aura donc comme message lors de notre run une alerte de dépendance circulaire : 

root@puppetmaster:~# puppet apply circle.pp
Notice: Compiled catalog for puppetmaster.example.net in environment
production in 0.62 seconds
Error: Failed to apply catalog: Found 1 dependency cycle:
(File[/etc/haproxy/haproxy.cfg] => Service[haproxy] => File[/etc/haproxy]
=> File[/etc/haproxy/haproxy.cfg])
Try the '--graph' option and opening the resulting '.dot' file in
OmniGraffle or GraphViz

on a un message qui nous montre les dépendances . Pour les cas complexes on peut utiliser une option qui va nous aider à mieux comprendre les dépendances :

--graph option.

si on utilise  cette option puppet incluera le chemin complet de notre fichier .dot (fichier de graph) dans sa sortie

digraph Resource_Cycles {
label = "Resource Cycles"
"File[/etc/haproxy/haproxy.cfg]" ->"Service[haproxy]" ->"File[/etc/
haproxy]" ->"File[/etc/haproxy/haproxy.cfg]"
}



- Implementation des interractions de ressources :

En parallele des dépendances les ressources peuvent aussi avoir des relations 
ex: 

root@puppetmaster:~# puppet apply puppet_service.pp
--noop
Notice: Compiled catalog for puppetmaster.example.net in environment
production in 0.62 seconds
Notice: /Stage[main]/Main/Service[puppet]/ensure: current_value running,
should be stopped (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 1 events
Notice: Stage[main]: Would have triggered 'refresh' from 1 events
Notice: Applied catalog in 0.05 seconds

on voit ici que le refresh devra être lancé car la ressource service aura un status changé : un event aura changé le comportement.
Le mechanisme rentrant en ligne de commpte est comparable au pub/sub queue : les resources sont configurées pour réagir a un event : on place dans  les manifests un notify : qui va donc déclencher une réaction.
Typiquement on a des reload de services quand un fichier de conf a été modifié pour un service.

ex: avec subscribe :


file { '/etc/haproxy/haproxy.cfg':
ensure => file,
owner  => 'root',
group  => 'root',
mode   => '0644',
source => 'puppet:///modules/haproxy/etc/haproxy/haproxy.cfg',
require => Package['haproxy'],
}
service { 'haproxy':
  ensure    => 'running',
  subscribe => File['/etc/haproxy/haproxy.cfg'],
}


Equivalence avec un notify :

file { '/etc/haproxy/haproxy.cfg':
  ensure => file,
  owner  => 'root',
  group  => 'root',
  mode   => '0644',
  source => 'puppet:///modules/haproxy/etc/haproxy/haproxy.cfg',
  require => Package['haproxy'],
  notify => Service['haproxy'],
}
service { 'haproxy':
  ensure => 'running',
}

On peut eventuellement utiliser la notion de dashing :

file { '/etc/haproxy/haproxy.cfg': ... }
   ~>  service { 'haproxy': ... }

La resource service est une de celle à utiliser régulierement les notify / subscribe.

- Examen des principales resources : 


-> files :

ex :

file { '/etc/modules':
  ensure => file,
  content => "# Managed by Puppet!\n\ndrbd\n",
}
The double quotes allow expansion of escape sequences such as \n.

Another useful capability is managing symbolic links:
file { '/etc/apache2/sites-enabled/001-puppet-lore.org':
ensure => 'link',
target => '../sites-available/puppet-lore.org',
}

-> package :

on va ici pouvoir avoir la notion de provider ( apt / yum ..) 
package { 'haproxy':
ensure   => present,
provider => 'dpkg',
source   => '/opt/packages/haproxy-1.5.1_amd64.dpkg',
}

-> service :
on peut gérer les services avec le provider base  qui peut gérer les process en background 

service { 'count-logins':
provider  => 'base',
ensure    => 'running',
binary    => '/usr/local/bin/cnt-logins',
start     => '/usr/local/bin/cnt-logins --daemonize',
subscribe => File['/usr/local/bin/cnt-logins'],
}

ici le service sera reloasd si la conf est changé ou le service non démarré ...(? a voir pas clair ) 


-> user / group : 

Si on a pas de gestion centralisée avec un ldap par ex , il va être crucial de gérer nos users sur nos systèmes 
On va pouvoir gérer les infos classiques ( /home , bash ,uid ...) 


group { 'proxy-admins':
ensure => present,
gid    => 4002,
}
user { 'john':
ensure        => present,
uid           => 2014,
home          => '/home/john'
managehome    => true, # <- adds -m to useradd
gid           => 1000,
shell         => '/bin/zsh',
groups        => [ 'proxy-admins' ],
}

Il est toujours nécéssaire de définir un group avant le user ..comme in faut un repertoire pour ecrire un fichier à l'interrieur.

NB  : si un attribut n'est pas gérer pour la resource user : le run ne sera pas cassé mais un warning apparaitra.

-> exec : 

il peut être  utile dans certains cas d'utiliser la commande exec mais c'est en général à proscrire : ce n'est pas le rôle de puppet :


exec { 'tar cjf /opt/packages/homebrewn-3.2.tar.bz2':
cwd     => '/opt',
path    => '/bin:/usr/bin',
creates => '/opt/homebrewn-3.2',
}

ici creates est important car nous indique l'endroit ou la commande doit être executée : une fois crééer puppet considere la conf updatée 

Il est possible de spécifier des param spéciaux pour puppet et gérer des cas . On peut utiliser unlessou onlyif.
ex :

exec { 'perl -MCPAN -e "install YAML"':
path   => '/bin:/usr/bin',
unless => 'cpan -l | grep -qP ^YAML\\b',
}

ici la command exec sera en echec si le retour de unless est vrai : pas d'install de module perl si le package est trouvé .
On va aussi pour la resource  exec utiliser les param notify et subscribe :

exec { 'apt-get update':
path        => '/bin:/usr/bin',
subscribe   => File['/etc/apt/sources.list.d/jenkins.list'],
refreshonly => true,
}


On va pouvoir avoir des infos :

"puppet describe <type> [-s]
In case you are unsure whether a type exists, you can tell Puppet
describe to return a full list of all available resource types:
puppet describe --list"


-> cron :

on va pouvoir gérer nos cronjobs :

cron { 'clean-files':
ensure      => present,
user        => 'root',
command     => '/usr/local/bin/clean-files',
minute      => '1',
hour        => '3',
weekday     => [ '2', '6' ],
environment => 'MAILTO=felix@example.net',
}


On peut ajouter des variables dédiées à notre cron en utilisant le param "environment" 

-> mount :

on va pouvoir gérer nos points de montage  avec les infos essentielles (device, mountpoint ..)

La traduction d'une ligne de fstab pourra être faite comme ceci :

mount { '/media/gluster-data':
ensure  => 'mounted',
device  => 'gluster01:/data',
fstype  => 'glusterfs',
options => 'defaults,_netdev',
dump    => 0,
pass    => 0,
}

pour cette resource puppet va s'assurer que la resource est bien montée et dispo après le run 


== Chapter 2 : puppet server / agent ==

l'utilisation de puppet apply est parfaite pour tester des confs en local .mais c'est souvent la notion master / agent qiu est utilisée. le master compile le catalogue que l'agent vient récupérer régulièrement via une connection ssl.

- master :

-> il comporte toutes les infos de tous les systemes gérés.
-> stocke les manifests et les compilation de catalogue 
-> sert d'authorité de certif
-> génère les rapports  des agents.
-> recupere les infos des agents

A l'initialisation le master génere un ca certificate pour les agents .Le certif est autosigné et la clé priv de puppet doit être protégé .
Les nouveaux clients demandent un certif qui est signé avec la ca du master

c'est une bonne pratique de copietr la ca dans notre provisionning : pour gérer facilement la signature du certif après la validation de l'identité  du master 

Anciennement avant puppet 4 on parlait de master : la gestion ssl etait faite par apache et un module passenger 
maintenant puppet embarque du jruby qui embarque du ssl natif servi par une jvm jetty 

puppetserver est donc plus rapide et stable 



= set up de server : =







