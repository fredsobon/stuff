=== notes according learning puppet 4 (oreilly book) ===

== Introduction :

puppet s'occupe de la configuration des ressources d'un systeme : user, package, service, data, process.Puppet s'occupe de la conformité du système en fonction de l'état désiré.Il combine une hierarchie flexible de config de données avec des données particulières pour un node précis.On peut donc s'en servir pour :
-> déployer des nouvelles applis /composants
-> effectuer des mise à jour applicatives / secu 
-> adapter des nouvelles technos à des vieux systèmes.
-> reduire l'effort de changement sur un grand nombre de machine.
->etc ...
On doit juste utiliser le language déclaratif de puppet qui nous sert à décrire l'état dans le quel on souhaite avoir notre systeme. On veut que le résultat de notre action de config soit systematiquement identique à notre définition.
La specification doit décrire l'état désiré et laisser la résolution de ces tâches à un interpréteur.

Fonctionnement de puppet :

Tous les nodes qu'ont controle ont un puppet agent : cet agent évalue et et applique les manifests puppet : les fichiers de configuration de puppet qui contienne la description de l'etat désiré du node.
L'agent evalue l'etat de chaque composant dans le manifest et determine si un changement est à faire ou pas.
Si un chagement est à faire l'agent le fait et enregistre le changement dans un journal.
Si puppet est configuré avec un serveur central de managment de config : le serveur envoit les données de conf au serveur qui à son tour va renvoyer un catalogue des changements à effectuer si besoin afin de toujours être dans l'etat désiré.  

On peut biensur agir finement et ne passer des changements qu'a un certain nombre de machinnes grace à des systemes de clasification. (ex : hostname, os , puppet version etc ...)
Les agents puppet peuvent être invoqués avec des tag speciaux. Les nodes recoivent leur catalogue individuellement et ne sont pas soumi a des filles d'attente.Un rapport est généré à chaque run .Il est possible d'utiliser un orchestrateur pour piloter un grand nombre de node.



== Part 1 : controlling with puppet apply :

= chapitre 1 : "Pensez déclaratif" 
En developpant des scripts shell, ruby , python etc ..on utilise un language imperatif : qui va permettre le changement d'état par etapes successives : on dit aussi procedural : succession d'etapes pour le changement.
Même si cette façon de penser ou faire peut aider : pour utiliser et comprendre le language de puppet, il vaut mieux tout oublier car pour ecrire de bon manifests puppet il faut utiliser un language declaratif.

On peut voir par exemple que si on lance une commande de creation de user : la premiere execution sera ok mais en relancant la même commande on aura une erreur puisque le user existe dejà : une simple tache comme celle ci devient donc comliquée car il faut gérer des tests et conditions ...c'est evidemment difficile à maintenir des que le systeme augment en complexité : c'est pour cela qu'un language déclaratif est adapté à notre gestion de systeme : une commande lancée de multiples fois genere toujours le même resultat.
On utilise des instructions indempotent ( latin:"idem + potent":"même pouvoir" ) : résultat identique à chaque execution.  

Il est donc important pour la configuration de notre systeme d'utiliser un language pour décrire l'état désiré de notre système et non pas comment arriver à cet état.

user { 'joe':
  ensure => present,
  uid => '1001',
  gid => '1000',
  comment => 'Joe User',
  managehome => true,
}

Comme on le voit le code est très simple à lire et est independant du système d'exploitation.
Le code sera réexecutable a volonté et sera jouer tant que l'état désiré  ne sera pas atteind : c'est ce que fera le puppet agent quand il evaluera le manifest a appliqué et l'etat actuel du système.

== chapitre 2 : creation de notre environment d'apprentissage :

1/
Le set up va se faire en utilisant vagrant /virtualbox
Une fois vagrant installé sur le systeme on va downloader notre "vm" : une centos 7 issue du puppetlabs fait l'affaire.
puppet est déjà installé dessus.

ex :
 $ vagrant box add --provider virtualbox puppetlabs/centos-7.2-64-nocm
 ==> box: Loading metadata for box 'puppetlabs/centos-7.2-64-nocm'
 box: URL: https://atlas.hashicorp.com/puppetlabs/centos-7.2-64-nocm
 ==> box: Adding box 'puppetlabs/centos-7.2-64-nocm' (v1.0.2)
 for provider: virtualbox
 box: Downloading: https://atlas.hashicorp.com/puppetlabs/boxes/
 centos-7.2-64-nocm/versions/1.0.2/providers/virtualbox.box
 ==> box: Successfully added box 'puppetlabs/centos-7.2-64-nocm' (v1.0.2)

2 / clone du repo d'apprentissage :

Il va contenir les outils et l'environmment de dev :

 $ git clone https://github.com/jorhett/learning-puppet4
 Cloning into 'learning-puppet4'...
 remote: Counting objects: 64, done.
 remote: Total 64 (delta 0), reused 0 (delta 0)
 Unpacking objects: 100% (64/64), done.
 Checking connectivity... done.
 $ cd learning-puppet4

NB : on doit pouvoir acceder au contenu du repo git learning-puppet4 depuis notre vm vagrant dans le repertoire vagrant :
A noter que le repo git contient plusieurs conf pour plusieurs vm puppet .
on lancera tjs notre vm avec le nom qu'il convient :
ex vagrant up client 

[vagrant@client ~]$ ls /vagrant/
bin  etc-puppet  LICENSE  manifests  README.md  systemd-puppet  Vagrantfile

On installe ensuite le plugin  vagrant-vbguest qui va être utile pour avoir des mises a jour auto de vagrant ( notamment pour les evolutions de noyaux, access au repertoires partagés : vagrant share : qui peut être mal détecté en cas de maj ...)

$ vagrant plugin install vagrant-vbguest
Installing the 'vagrant-vbguest' plugin. This can take a few minutes...
Installed the plugin 'vagrant-vbguest (0.11.0)'!

On va initialiser notre set up avec vagrant up (qui va lire un vagrant file présent dans notre "learning repo"

En cas de souci on peut essayer de debugguer : vagrant s'intall dans notre /home et crée un repertoire par vm. Dans chacun il ya un un fichier VBox.log qui va nous aider à débuguer.


Attention il est nécessaire d'avoir la Vt d'activer dans le bios : cf manuel vagrant si besoin.

On peut utiliser le  baba de vagrant avec quelques commandes :

$ vagrant suspend client
==> client: Saving VM state and suspending execution...

$ vagrant resume client
==> client: Resuming suspended VM...
==> client: Booting VM...
==> client: Waiting for machine to boot. This may take a few minutes...
client: SSH address: 127.0.0.1:2222
client: SSH username: vagrant
client: SSH auth method: private key
client: Warning: Connection refused. Retrying...
==> client: Machine booted and ready!

$ vagrant destroy client
client: Are you sure you want to destroy the 'client' VM? [y/N] n
==> client: The VM 'client' will not be destroyed, since the confirmation
==> client: was declined.

On reboot notre vm avec un vagrant up 

Pour se connecter à notre client on va faire un :
$ vagrant ssh client
[vagrant@client ~]$

Sur notre vm on va installer des utilitaires :

[vagrant@client ~]$ sudo yum install rsync git vim 

On peut installer le plugin de syntaxe puppet pour vim :

qui se place vu que le client puppet est en 1.4 dans /opt/puppetlabs/puppet/share/vim/puppet-vimfiles/.


== chapitre 3 : installation de puppet :

On a délibérement choisi une distrib sans puppet de pré-installé.On va donc le faire.
On va installer et activer un repo puppet lab puppet collection. On peut examiner les dernières versions compatibles avec notre os sur le puppet lab. Il est possible sinon de downloader directement le pkg et l'installer :
[vagrant@client ~]$ sudo yum install -y  http://yum.puppetlabs.com/puppetlabs-release-pc1-el-7.noarch.rpm

Ceci va installer puppet4 et des outils.Ex :

vagrant@client ~]$ sudo yum repolist
Loaded plugins: fastestmirror
...snip repository checks...
puppetlabs-pc1/x86_64  Puppet Labs PC1 Repository el 7 - x86_64  41 

On voit par exemple ici qu'on a 41 packets d'installés.
On a l'ecosysteme puppet de telecharger : puppet , facter , interpreteur ruby, mcollective.
puppet agent , puppet server et puppet db sont des applis autonomes mais interdépendantes.

Il est important de faire attention a des potentiels pb : maj de secu, pb de cohabitation de differents interpreteur ruby ...
On a donc lors des install / maj : puppet core : qui embarque une version dediée de ruby ( sans conflit avec celle du systeme) : toutes les puppet collections sont faites pour eviter d'avoir des pb de compatibilités de version ( client / server ...)

Install client : 

vagrant@client ~]$ sudo yum install -y puppet-agent
Loaded plugins: fastestmirror
Loading mirror speeds from cached hos
...
...
Verifying : puppet-agent-1.4.0-1.el7.x86_64
1/1
1/1
Installed:
puppet-agent.x86_64 0:1.4.0-1.el7
Complete!

Les versions recentes de puppet4 ont une arbo nouvelle : AIO : "all in one" package . Toutes les dependances sont embarquées et visisble dans :
[vagrant@client ~]$ ls -la /opt/puppetlabs/bin/

A l'install un shell /etc/profile.d/puppet-agent.sh va sourcer le binaire puppet agent (qui n'est plus dans /usr/bin)  vers /opt/puppetlabs/bin. 

NB : si on ecrase notre $PATH il faudra bien de nouveau sourcer le binaire puppet.

-facter : va evaluer les facts d'un système (hostname, ip ....)
-hiera : va charger les données utilisées par les manifests puppet et les modules.Hiera permet de configurer des valeurs par defaut ou de les surcharger ou etendre via une hierarchie adaptable.
-mcollective : est un framework d'orchestration.

Une installation  privée de ruby et des gem est faite dans  /opt/puppetlabs/puppet
Le $confdir est maintenant dans  /etc/puppetlabs/puppet : tout ce qui est dans /etc/puppet sera ignoré.
Le $ssldir est maintenant dans le $confdir
La conf de mcollective est exclusivement dans : /etc/puppetlabs/mcollective
Le $rundir est exclusivement dans : /var/run/puppetlabs
Les manifests, modules et hiera sont dans : /etc/puppetlabs/code et sont donc maintenant dans le $codedir
Ce repertoire contient donc :
$environmentpath : les différents environments.
$basemodulepath : l'arbo des modules.
$hiera_config correspond au hiera.yaml

Pour la facilité d'apprentissage on va change rles droits pour permettre à vagrant d'être utilisé :

[vagrant@client ~]$ sudo chown -R vagrant /etc/puppetlabs


/!\ path des commandes puppet : on va utiliser les binaires puppet pour nos tests avec le user vagrant en sudo 
attention : sudo reset de base la recherche des commandes utilisées par un user et va utiliser des repertoires et path secureles binaires de puppet n'en font pas partie 
exemple :
env de notre user : 
[vagrant@client ~]$ env |grep -i path
PATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/opt/puppetlabs/bin:/home/vagrant/.local/bin:/home/vagrant/bin

env de notre user via sudo : 
[vagrant@client ~]$ sudo env |grep -i path
PATH=/sbin:/bin:/usr/sbin:/usr/bin

On va devoir rajouter notre env puppet dans le secure path de sudo :

[vagrant@client ~]$ sudo grep secure_path /etc/sudoers |sed -e 's#$#:/opt/puppetlabs/bin#' |sudo tee /etc/sudoers.d/puppet-securepath
Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/opt/puppetlabs/bin


[vagrant@client ~]$ sudo cat /etc/sudoers.d/puppet-securepath
Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/opt/puppetlabs/bin

C'est desormais ok :
[vagrant@client ~]$ sudo env |grep -i path
PATH=/sbin:/bin:/usr/sbin:/usr/bin:/opt/puppetlabs/bin


== chapitres 4 :  Writing manifests : 

Un manifest est un fichier contenant du code puppet decrivant la configuration desirée de nos ressources.C'est la base de toute la stratégie de config de nos nodes jusqu'a des blocs de config de modules très complexes.

Les ressources sont les plus petits blocs de code puppet qui nous servent à definir, modifier supprimer un element sur un systeme.Puppet embarque des resources de base telles que : users, services, packages, files , groups ...On peut egalement creer nos propres ressources.

- ressources :

On commence par notify qui va afficher un message :

notify (ressource){ 'greeting':
        message (attribut) => 'Hello, world!' (valeur)
}

on declare une ressource notify ayant pour titre greeting , ayant un attribut message auquel on donne une valeur.
les attributs sont séparées de leur valeurs par un "=>" (comme en perl , ruby)

#Exemple dans le repos cloné pour la lesson "Learning puppet4" un repertoire manifest contient des exemples de code :
#boogie@x61-boogie:~/lab/puppetlab/learning-puppet4/manifests$ cat helloworld.pp 
#notify { 'greeting':
#  message => 'Hello, world!'
#}

On creer donc pour tester un repertoire manifest dans le home de notre user vagrant et on y cree le manifest :

/home/vagrant/manifests/helloworld.pp
On test facilement notre manifest avec la commande puppet apply manifest.pp :

[vagrant@client manifests]$ sudo puppet apply helloworld.pp 
Notice: Compiled catalog for client in environment production in 0.22 seconds
Notice: Hello, world!
Notice: /Stage[main]/Main/Notify[greeting]/message: defined 'message' as 'Hello, world!'
Notice: Applied catalog in 0.03 seconds
[vagrant@client manifests]$ pwd
/home/vagrant/manifests

On voit donc la creation du build du catalogue et differente etapes jusqu'a l'affichage de notre message et du rapport de run.

on peut utiliser les manifests de notre env partages du repo git présent dans le dir /vagrant/manifests depuis la vm :

[vagrant@client ~]$ sudo puppet apply /vagrant/manifests/helloworld.pp 
Notice: Compiled catalog for client.example.com in environment production in 1.20 seconds
Notice: Hello, world!
Notice: /Stage[main]/Main/Notify[greeting]/message: defined 'message' as 'Hello, world!'
Notice: Applied catalog in 0.02 seconds

-Declaration de ressources : regles :
quelques regles sont impératives pour la déclaration de ressources puppet :

Les ressources DOIVENT être unique : il ne peut y avoir qu'une seule ressource de même nom / titre par type (file, user etc..)

resource_type { 'resource_title':
    ensure  => present, # habituellement present ou absent 
    attribute1 => 1234, # nombre
    attribute2 => 'value', # string
    attribute3 => ['red','blue'], # tableau
    noop       => false, # booleen
}


Plusieurs appels à une ressource du même nom ET du même type génère donc une erreur de déclaration :

exemple : 
[vagrant@client manifests]$ cat myfile.pp
file { 'my_file':
    ensure => present,
    path => '/tmp/my_file.txt',
}
file { 'my_file':
    ensure => present,
    path => '/tmp/my_file.yaml',
}
file { 'my_file':
    ensure => present,
    path => '/tmp/my_file.csv',
}

nous donne au run :
[vagrant@client manifests]$ sudo puppet apply myfile.pp 
Error: Evaluation Error: Error while evaluating a Resource Statement, Duplicate declaration: File[my_file] is already declared in file /home/vagrant/manifests/myfile.pp:1; cannot redeclare at /home/vagrant/manifests/myfile.pp:5 at /home/vagrant/manifests/myfile.pp:5:1 on node client.example.com

NB: on peut avoir des ressources de type differents porant le même nom : pas de souci :
[vagrant@client manifests]$ cat myfile.pp 
file { 'my_file':
    ensure => present,
    path => '/tmp/my_file.txt',
}
notify { 'my_file':
    message=> 'this is my file !!',
}
[vagrant@client manifests]$ sudo puppet apply myfile.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.06 seconds
Notice: this is my file !!
Notice: /Stage[main]/Main/Notify[my_file]/message: defined 'message' as 'this is my file !!'
Notice: Applied catalog in 0.02 seconds

-Examen de ressources :

puppet peut nous permettre d'analyser le découpage d'une ressource externe a la config puppet : cela va nous permettre de construire plus facilement notre code 
grace a la commande puppet ressource 
Ce mecanisme est le même qu'utilise puppet pour analyser et modifier les config systemes 


[vagrant@client manifests]$ sudo puppet resource mailalias postmaster
mailalias { 'postmaster':
  ensure    => 'present',
  recipient => ['root'],
  target    => '/etc/aliases',
}


exemple on voit que puppet interprete notre ressource user vagrant de cette façon :
[vagrant@client manifests]$ sudo puppet resource user vagrant
user { 'vagrant':
  ensure           => 'present',
  gid              => '1000',
  groups           => ['vagrant'],
  home             => '/home/vagrant',
  password         => '!!',
  password_max_age => '99999',
  password_min_age => '0',
  shell            => '/bin/bash',
  uid              => '1000',
}
on peut donc s'inspirer de ces retours pour creeer du code et le tester avec un puppet apply 

Attention certain attribut ne peuvent pas etre sette tel quel et génere une erreur en cas d'utilisation c'est le cas de readonly qui ne peut être sette dans une ressources : voir doc sur les ressources.



