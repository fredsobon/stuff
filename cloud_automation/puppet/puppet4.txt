=== notes according learning puppet 4 (oreilly book) ===

== Introduction :

puppet s'occupe de la configuration des ressources d'un systeme : user, package, service, data, process.Puppet s'occupe de la conformité du système en fonction de l'état désiré.Il combine une hierarchie flexible de config de données avec des données particulières pour un node précis.On peut donc s'en servir pour :
-> déployer des nouvelles applis /composants
-> effectuer des mise à jour applicatives / secu 
-> adapter des nouvelles technos à des vieux systèmes.
-> reduire l'effort de changement sur un grand nombre de machine.
->etc ...
On doit juste utiliser le language déclaratif de puppet qui nous sert à décrire l'état dans le quel on souhaite avoir notre systeme. On veut que le résultat de notre action de config soit systematiquement identique à notre définition.
La specification doit décrire l'état désiré et laisser la résolution de ces tâches à un interpréteur.

Fonctionnement de puppet :

Tous les nodes qu'ont controle ont un puppet agent : cet agent évalue et et applique les manifests puppet : les fichiers de configuration de puppet qui contienne la description de l'etat désiré du node.
L'agent evalue l'etat de chaque composant dans le manifest et determine si un changement est à faire ou pas.
Si un chagement est à faire l'agent le fait et enregistre le changement dans un journal.
Si puppet est configuré avec un serveur central de managment de config : le serveur envoit les données de conf au serveur qui à son tour va renvoyer un catalogue des changements à effectuer si besoin afin de toujours être dans l'etat désiré.  

On peut biensur agir finement et ne passer des changements qu'a un certain nombre de machinnes grace à des systemes de clasification. (ex : hostname, os , puppet version etc ...)
Les agents puppet peuvent être invoqués avec des tag speciaux. Les nodes recoivent leur catalogue individuellement et ne sont pas soumi a des filles d'attente.Un rapport est généré à chaque run .Il est possible d'utiliser un orchestrateur pour piloter un grand nombre de node.



== Part 1 : controlling with puppet apply :

= chapitre 1 : "Pensez déclaratif" 
En developpant des scripts shell, ruby , python etc ..on utilise un language imperatif : qui va permettre le changement d'état par etapes successives : on dit aussi procedural : succession d'etapes pour le changement.
Même si cette façon de penser ou faire peut aider : pour utiliser et comprendre le language de puppet, il vaut mieux tout oublier car pour ecrire de bon manifests puppet il faut utiliser un language declaratif.

On peut voir par exemple que si on lance une commande de creation de user : la premiere execution sera ok mais en relancant la même commande on aura une erreur puisque le user existe dejà : une simple tache comme celle ci devient donc comliquée car il faut gérer des tests et conditions ...c'est evidemment difficile à maintenir des que le systeme augment en complexité : c'est pour cela qu'un language déclaratif est adapté à notre gestion de systeme : une commande lancée de multiples fois genere toujours le même resultat.
On utilise des instructions indempotent ( latin:"idem + potent":"même pouvoir" ) : résultat identique à chaque execution.  

Il est donc important pour la configuration de notre systeme d'utiliser un language pour décrire l'état désiré de notre système et non pas comment arriver à cet état.

user { 'joe':
  ensure => present,
  uid => '1001',
  gid => '1000',
  comment => 'Joe User',
  managehome => true,
}

Comme on le voit le code est très simple à lire et est independant du système d'exploitation.
Le code sera réexecutable a volonté et sera jouer tant que l'état désiré  ne sera pas atteind : c'est ce que fera le puppet agent quand il evaluera le manifest a appliqué et l'etat actuel du système.

== chapitre 2 : creation de notre environment d'apprentissage :

1/
Le set up va se faire en utilisant vagrant /virtualbox
Une fois vagrant installé sur le systeme on va downloader notre "vm" : une centos 7 issue du puppetlabs fait l'affaire.
puppet est déjà installé dessus.

ex :
 $ vagrant box add --provider virtualbox puppetlabs/centos-7.2-64-nocm
 ==> box: Loading metadata for box 'puppetlabs/centos-7.2-64-nocm'
 box: URL: https://atlas.hashicorp.com/puppetlabs/centos-7.2-64-nocm
 ==> box: Adding box 'puppetlabs/centos-7.2-64-nocm' (v1.0.2)
 for provider: virtualbox
 box: Downloading: https://atlas.hashicorp.com/puppetlabs/boxes/
 centos-7.2-64-nocm/versions/1.0.2/providers/virtualbox.box
 ==> box: Successfully added box 'puppetlabs/centos-7.2-64-nocm' (v1.0.2)

2 / clone du repo d'apprentissage :

Il va contenir les outils et l'environmment de dev :

 $ git clone https://github.com/jorhett/learning-puppet4
 Cloning into 'learning-puppet4'...
 remote: Counting objects: 64, done.
 remote: Total 64 (delta 0), reused 0 (delta 0)
 Unpacking objects: 100% (64/64), done.
 Checking connectivity... done.
 $ cd learning-puppet4

NB : on doit pouvoir acceder au contenu du repo git learning-puppet4 depuis notre vm vagrant dans le repertoire vagrant :
A noter que le repo git contient plusieurs conf pour plusieurs vm puppet .
on lancera tjs notre vm avec le nom qu'il convient :
ex vagrant up client 

[vagrant@client ~]$ ls /vagrant/
bin  etc-puppet  LICENSE  manifests  README.md  systemd-puppet  Vagrantfile

On installe ensuite le plugin  vagrant-vbguest qui va être utile pour avoir des mises a jour auto de vagrant ( notamment pour les evolutions de noyaux, access au repertoires partagés : vagrant share : qui peut être mal détecté en cas de maj ...)

$ vagrant plugin install vagrant-vbguest
Installing the 'vagrant-vbguest' plugin. This can take a few minutes...
Installed the plugin 'vagrant-vbguest (0.11.0)'!

On va initialiser notre set up avec vagrant up (qui va lire un vagrant file présent dans notre "learning repo"

En cas de souci on peut essayer de debugguer : vagrant s'intall dans notre /home et crée un repertoire par vm. Dans chacun il ya un un fichier VBox.log qui va nous aider à débuguer.


Attention il est nécessaire d'avoir la Vt d'activer dans le bios : cf manuel vagrant si besoin.

On peut utiliser le  baba de vagrant avec quelques commandes :

$ vagrant suspend client
==> client: Saving VM state and suspending execution...

$ vagrant resume client
==> client: Resuming suspended VM...
==> client: Booting VM...
==> client: Waiting for machine to boot. This may take a few minutes...
client: SSH address: 127.0.0.1:2222
client: SSH username: vagrant
client: SSH auth method: private key
client: Warning: Connection refused. Retrying...
==> client: Machine booted and ready!

$ vagrant destroy client
client: Are you sure you want to destroy the 'client' VM? [y/N] n
==> client: The VM 'client' will not be destroyed, since the confirmation
==> client: was declined.

On reboot notre vm avec un vagrant up 

Pour se connecter à notre client on va faire un :
$ vagrant ssh client
[vagrant@client ~]$

Sur notre vm on va installer des utilitaires :

[vagrant@client ~]$ sudo yum install rsync git vim 

On peut installer le plugin de syntaxe puppet pour vim :

qui se place vu que le client puppet est en 1.4 dans /opt/puppetlabs/puppet/share/vim/puppet-vimfiles/.


== chapitre 3 : installation de puppet :

On a délibérement choisi une distrib sans puppet de pré-installé.On va donc le faire.
On va installer et activer un repo puppet lab puppet collection. On peut examiner les dernières versions compatibles avec notre os sur le puppet lab. Il est possible sinon de downloader directement le pkg et l'installer :
[vagrant@client ~]$ sudo yum install -y  http://yum.puppetlabs.com/puppetlabs-release-pc1-el-7.noarch.rpm

Ceci va installer puppet4 et des outils.Ex :

vagrant@client ~]$ sudo yum repolist
Loaded plugins: fastestmirror
...snip repository checks...
puppetlabs-pc1/x86_64  Puppet Labs PC1 Repository el 7 - x86_64  41 

On voit par exemple ici qu'on a 41 packets d'installés.
On a l'ecosysteme puppet de telecharger : puppet , facter , interpreteur ruby, mcollective.
puppet agent , puppet server et puppet db sont des applis autonomes mais interdépendantes.

Il est important de faire attention a des potentiels pb : maj de secu, pb de cohabitation de differents interpreteur ruby ...
On a donc lors des install / maj : puppet core : qui embarque une version dediée de ruby ( sans conflit avec celle du systeme) : toutes les puppet collections sont faites pour eviter d'avoir des pb de compatibilités de version ( client / server ...)

Install client : 

vagrant@client ~]$ sudo yum install -y puppet-agent
Loaded plugins: fastestmirror
Loading mirror speeds from cached hos
...
...
Verifying : puppet-agent-1.4.0-1.el7.x86_64
1/1
1/1
Installed:
puppet-agent.x86_64 0:1.4.0-1.el7
Complete!

Les versions recentes de puppet4 ont une arbo nouvelle : AIO : "all in one" package . Toutes les dependances sont embarquées et visisble dans :
[vagrant@client ~]$ ls -la /opt/puppetlabs/bin/

A l'install un shell /etc/profile.d/puppet-agent.sh va sourcer le binaire puppet agent (qui n'est plus dans /usr/bin)  vers /opt/puppetlabs/bin. 

NB : si on ecrase notre $PATH il faudra bien de nouveau sourcer le binaire puppet.

-facter : va evaluer les facts d'un système (hostname, ip ....)
-hiera : va charger les données utilisées par les manifests puppet et les modules.Hiera permet de configurer des valeurs par defaut ou de les surcharger ou etendre via une hierarchie adaptable.
-mcollective : est un framework d'orchestration.

Une installation  privée de ruby et des gem est faite dans  /opt/puppetlabs/puppet
Le $confdir est maintenant dans  /etc/puppetlabs/puppet : tout ce qui est dans /etc/puppet sera ignoré.
Le $ssldir est maintenant dans le $confdir
La conf de mcollective est exclusivement dans : /etc/puppetlabs/mcollective
Le $rundir est exclusivement dans : /var/run/puppetlabs
Les manifests, modules et hiera sont dans : /etc/puppetlabs/code et sont donc maintenant dans le $codedir
Ce repertoire contient donc :
$environmentpath : les différents environments.
$basemodulepath : l'arbo des modules.
$hiera_config correspond au hiera.yaml

Pour la facilité d'apprentissage on va change rles droits pour permettre à vagrant d'être utilisé :

[vagrant@client ~]$ sudo chown -R vagrant /etc/puppetlabs


/!\ path des commandes puppet : on va utiliser les binaires puppet pour nos tests avec le user vagrant en sudo 
attention : sudo reset de base la recherche des commandes utilisées par un user et va utiliser des repertoires et path secureles binaires de puppet n'en font pas partie 
exemple :
env de notre user : 
[vagrant@client ~]$ env |grep -i path
PATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/opt/puppetlabs/bin:/home/vagrant/.local/bin:/home/vagrant/bin

env de notre user via sudo : 
[vagrant@client ~]$ sudo env |grep -i path
PATH=/sbin:/bin:/usr/sbin:/usr/bin

On va devoir rajouter notre env puppet dans le secure path de sudo :

[vagrant@client ~]$ sudo grep secure_path /etc/sudoers |sed -e 's#$#:/opt/puppetlabs/bin#' |sudo tee /etc/sudoers.d/puppet-securepath
Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/opt/puppetlabs/bin


[vagrant@client ~]$ sudo cat /etc/sudoers.d/puppet-securepath
Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/opt/puppetlabs/bin

C'est desormais ok :
[vagrant@client ~]$ sudo env |grep -i path
PATH=/sbin:/bin:/usr/sbin:/usr/bin:/opt/puppetlabs/bin


== chapitres 4 : manifests : 

Un manifest est un fichier contenant du code puppet decrivant la configuration desirée de nos ressources.C'est la base de toute la stratégie de config de nos nodes jusqu'a des blocs de config de modules très complexes.

Les ressources sont les plus petits blocs de code puppet qui nous servent à definir, modifier supprimer un element sur un systeme.Puppet embarque des resources de base telles que : users, services, packages, files , groups ...On peut egalement creer nos propres ressources.

= ressources :

On commence par notify qui va afficher un message :

notify (ressource){ 'greeting':
        message (attribut) => 'Hello, world!' (valeur)
}

on declare une ressource notify ayant pour titre greeting , ayant un attribut message auquel on donne une valeur.
les attributs sont séparées de leur valeurs par un "=>" (comme en perl , ruby)

#Exemple dans le repos cloné pour la lesson "Learning puppet4" un repertoire manifest contient des exemples de code :
#boogie@x61-boogie:~/lab/puppetlab/learning-puppet4/manifests$ cat helloworld.pp 
#notify { 'greeting':
#  message => 'Hello, world!'
#}

On creer donc pour tester un repertoire manifest dans le home de notre user vagrant et on y cree le manifest :

/home/vagrant/manifests/helloworld.pp
On test facilement notre manifest avec la commande puppet apply manifest.pp :

[vagrant@client manifests]$ sudo puppet apply helloworld.pp 
Notice: Compiled catalog for client in environment production in 0.22 seconds
Notice: Hello, world!
Notice: /Stage[main]/Main/Notify[greeting]/message: defined 'message' as 'Hello, world!'
Notice: Applied catalog in 0.03 seconds
[vagrant@client manifests]$ pwd
/home/vagrant/manifests

On voit donc la creation du build du catalogue et differente etapes jusqu'a l'affichage de notre message et du rapport de run.

on peut utiliser les manifests de notre env partages du repo git présent dans le dir /vagrant/manifests depuis la vm :

[vagrant@client ~]$ sudo puppet apply /vagrant/manifests/helloworld.pp 
Notice: Compiled catalog for client.example.com in environment production in 1.20 seconds
Notice: Hello, world!
Notice: /Stage[main]/Main/Notify[greeting]/message: defined 'message' as 'Hello, world!'
Notice: Applied catalog in 0.02 seconds

-Declaration de ressources : regles :
quelques regles sont impératives pour la déclaration de ressources puppet :

Les ressources DOIVENT être unique : il ne peut y avoir qu'une seule ressource de même nom / titre par type (file, user etc..)

resource_type { 'resource_title':
    ensure  => present, # habituellement present ou absent 
    attribute1 => 1234, # nombre
    attribute2 => 'value', # string
    attribute3 => ['red','blue'], # tableau
    noop       => false, # booleen
}


Plusieurs appels à une ressource du même nom ET du même type génère donc une erreur de déclaration :

exemple : 
[vagrant@client manifests]$ cat myfile.pp
file { 'my_file':
    ensure => present,
    path => '/tmp/my_file.txt',
}
file { 'my_file':
    ensure => present,
    path => '/tmp/my_file.yaml',
}
file { 'my_file':
    ensure => present,
    path => '/tmp/my_file.csv',
}

nous donne au run :
[vagrant@client manifests]$ sudo puppet apply myfile.pp 
Error: Evaluation Error: Error while evaluating a Resource Statement, Duplicate declaration: File[my_file] is already declared in file /home/vagrant/manifests/myfile.pp:1; cannot redeclare at /home/vagrant/manifests/myfile.pp:5 at /home/vagrant/manifests/myfile.pp:5:1 on node client.example.com

NB: on peut avoir des ressources de type differents porant le même nom : pas de souci :
[vagrant@client manifests]$ cat myfile.pp 
file { 'my_file':
    ensure => present,
    path => '/tmp/my_file.txt',
}
notify { 'my_file':
    message=> 'this is my file !!',
}
[vagrant@client manifests]$ sudo puppet apply myfile.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.06 seconds
Notice: this is my file !!
Notice: /Stage[main]/Main/Notify[my_file]/message: defined 'message' as 'this is my file !!'
Notice: Applied catalog in 0.02 seconds

-Examen de ressources :

puppet peut nous permettre d'analyser le découpage d'une ressource externe a la config puppet : cela va nous permettre de construire plus facilement notre code 
grace a la commande puppet ressource 
Ce mecanisme est le même qu'utilise puppet pour analyser et modifier les config systemes 


[vagrant@client manifests]$ sudo puppet resource mailalias postmaster
mailalias { 'postmaster':
  ensure    => 'present',
  recipient => ['root'],
  target    => '/etc/aliases',
}


exemple on voit que puppet interprete notre ressource user vagrant de cette façon :
[vagrant@client manifests]$ sudo puppet resource user vagrant
user { 'vagrant':
  ensure           => 'present',
  gid              => '1000',
  groups           => ['vagrant'],
  home             => '/home/vagrant',
  password         => '!!',
  password_max_age => '99999',
  password_min_age => '0',
  shell            => '/bin/bash',
  uid              => '1000',
}
on peut donc s'inspirer de ces retours pour creeer du code et le tester avec un puppet apply 

Attention certain attribut ne peuvent pas etre sette tel quel et génere une erreur en cas d'utilisation c'est le cas de readonly qui ne peut être sette dans une ressources : voir doc sur les ressources.


- execution de commande :

la ressource exec permet de lancer une commande au sein de notre manifest.
ex : 
exec { 'echo-holy-cow':
    path  => ['/bin'],
    cwd   => '/tmp',
    command   => 'echo "holy cow!" > testfile.txt',
    creates   => '/tmp/testfile.txt',
    returns   => [0],
    logoutput => on_failure,
}

A noter qu'en puppet on utlise toujours les simples quotes quand aucune variable n'est présente : on ne veut pas d'interpolation. Ce qui n'est pas le cas des doubles quotes quisont utilisées lors de passage de variable en param.

on a ici l'utiisation de l'attribut creates qui va donc definir le resulat de l'execution de la commande .
Si le fichier existe la commande NE sera pas executer : il faut donc être tres prudent avec cerre utilisation d'attribut de ressource et se référer à la doc puppet.

Il est clair que cette resource est importante MAIS est à utiliser le moins possible : car on est plus dans le déclaratif mais dans du procedural et qu'une modification du contenu du fichier ne sera pas corrigée car si ce fichier existe ..la commande exec ne le recrera pas.

On evite la ressource exec et souvent la présence de cette ressource peut être evitée par l'ecriture de manifest plus propre.

- gestion de fichiers :

la ressource file nous permet de gerer correctement le contenu du fichier ( le contenu est flaggué en dur et chaque changement sera efface avec replace sette a true)et sa présence

file { '/tmp/testfile.txt':
    ensure => present,
    mode   => '0644',
    replace => true,
    content => 'holy cow!',
}
[vagrant@client manifests]$ sudo cat /tmp/testfile.txt 
holy cow![vagrant@client manifests]$

A noter que si on veut rajouter un retour chariot dans du texte il faut le faire en rajoutant un \n et entourer notre texte entre " " car le \n est interprété.

file { '/tmp/testfile.txt':
    ensure => present,
    mode   => '0644',
    replace => true,
    content => "holy cow!\n",
}
nous donne :
[vagrant@client manifests]$ sudo cat /tmp/testfile.txt 
holy cow!

- backup de fichiers :

tous les fichiers passés sous puppet sont backupés et index sous forme de hash dans la directive  clientbucketdir

On peut donc backuper un fichier 
sudo puppet filebucket --local backup /tmp/testfile.txt

voir la liste des fichiers backupés :

[vagrant@client manifests]$ sudo puppet filebucket --local list
0eb429526e5e170cd9ed4f84c24e442b 2017-01-09 20:43:14 /tmp/testfile.txt
3d508c856685853ed8a168a290dd709c 2017-01-09 20:43:49 /tmp/testfile.txt
2421d24b7d984ed88425f56feb2b5201 2017-01-09 20:49:23 /tmp/testfile.txt


- restorer les fichiers :
on peut examiner le contenu d'un fichier backupé en saisissant son hash 

[vagrant@client manifests]$ sudo puppet filebucket --local get 2421d24b7d984ed88425f56feb2b5201
holy cowbow![vagrant@client manifests]$ 

On peut voir le diff entre deux fichier : le courant et un ancien backupé avec son hash 

holy cowbow![vagrant@client manifests]$ sudo puppet filebucket --local diff  2421d24b7d984ed88425f56feb2b5201  /tmp/testfile.txt 
--- /tmp/diff20170109-5248-820397   2017-01-09 21:00:35.960114772 +0000
+++ /tmp/testfile.txt   2017-01-09 20:50:56.364225000 +0000
@@ -1 +1 @@
-holy cowbow!
\ No newline at end of file
+holy cow!
\ No newline at end of file

pour restaurer :
ex notre fichier d'origine 
[vagrant@client manifests]$ sudo cat /tmp/testfile.txt 
holy cow![vagrant@client manifests]$ 

qu'on va changer et restaurer :
[vagrant@client manifests]$ sudo puppet filebucket --local restore /tmp/testfile.txt 2421d24b7d984ed88425f56feb2b5201
[vagrant@client manifests]$ sudo cat /tmp/testfile.txt 
holy cowbow![vagrant@client manifests]$ 

- Proscrire l'imperatif dans les manifests :
comme avec la commande exec 
Si le code demande a l'interpréteur quoi faire , quand le faire et comment le faire : alors on fait de l'imperatif
Si notre code decrit a l'interpreteur comment le resulat doit être alors on fait du déclaratif

La raison pour ne pas utiliser exec est simple : la commande est executée et peut faire des dégats sur le systeme sans que puppet ne puisse être au courant puisque le seul code retour de l'execution d'exec est un status normal :quelle que soit les changements sur le systeme.
Il est donc toujours possible de suivre les changements , de restaurer comaprer avec les md5 des hash de fichiers quand on utilise la ressource file.

On ne doit utiliser exec quand vraiment nous n'avons pas d'autres choix.

== chapitre 5 : language de configuration puppet :

La bonne ecriture de manifests est la chose la plus importante dans puppet : il faut donc toujours s'y attacher et s'y améliorer.

= les variables :
toutes les variables dans puppet commencent avec un $ et sont en minuscule ; composées de lettres, underscore ou chiffres. Elles ne commencent pas par des majuscules, des chiffres et ne comportent pas de tiret.
Attention : les variables qui commencent par un _ sont uniquement dédiées au scope local : $_myvar : sera uniquement interprete dans notre manifest local.

Les types sont classiques :
$my_name  = 'joe'  < string 
$my_token = 115    < number
$not_true = false  < booleen

une variable non initialisee sera considérée comme undef on peut creer une variable avec une valeur indefinie :

$my_var = undef

Le module stlib de puppetlabs peut nous permettre de voir de quel type est notre variable :
include stdlib
$myname = 'joe'
$mytype = typeof($myname)


- Numbers :
les nombres non entourés par des " ou des '  sont de type numeric
Les nombres commencant par un 0 sont des octals et sceux commencant par 0x des hexa

- Tableaux et hash :

$mylist = [1,3,5,7]
$mytab = ['yes',5,'lapin',5.3]
$mymy =['yop',['lala',5]]

on peut definir des variables a des valeurs dans des tableaux si le nombre de variables et de valeur sont identiques :

[$myvar, $yourvar , $var] = ['lapin', 3, true]   <<<< GOOD
[$myvar, $yourvar , $var] = ['lapin', 3]         <<<<< ERROR

Certaines fonctions demandent une liste de valeur en arguments a la place d'element de tableau.On peut utiliser '*' pour convertir les elements d'un tableau en éléments séparés par une virgule avec la syntaxe de type :
$myfonction(* $array_of_args) { ..}

- table de hash key/ valeur :
on peut utiliser une table de hash avec la représentation clé / valeur 

# monoligne :
$homes = { 'joe' => '/home/joe', 'jack' => '/home/jack', }

# muliligne :

$user = {
    'username' => 'joe',
    'uid'      => 1000,
    'home'     => '/home/joe',
}
Attention les  hash doivent être soient entiers soient strings . Les valeurs peuvent prendre toutes les types  possibles.

- Variables et strings :
on encadre toujours les strings avec des simple quote sauf quand il y a interpolation : on utilise dans ce cas des "
$myvar = 'hey mec !'
$my = "hey ${username} happy to see you"

-HEREDOC : pour les grands blocs de texte on utilise les commentaires heredoc :
on place une balise @(END) a la fin de notre déclaration de variable et on cloture le texte par END :

$message_text = @(END)
This is a very long message,
which will be composed over
many lines of text.
END

Idem en cas d'interpolation de variable on va entourer notre heredoc de " :

$message_text = @("END")
Dear ${user},
Your password is ${password}.
Please login at ${site_url} to continue.
END

Il est toujours conseille d'utiliser les {} pour entourer une variable de chaine de caractere :

$the_greeting = "Hello ${myname}, you have received ${num_tokens} tokens!"

- Protection : on va pouvoir proteger d'interpolation certains de nos carateres speciaux en les faisant précéder de \ ou alors en entourant le texte en entier par des ' ''


- Namespace / scope : AUCUNE variable puppet ne peut être REdeclarée au sein d'un même NAMESPACE / SCOPE 

C'est clairement pour continuer a penser en déclaratif : puppet nous jette donc une erreur si on declare plusieurs fois une variable avec des valeurs differentes.

- Mots réservés : on a comme dans beaucoup de language des mots clés réservés qu'on ne peut utiliser pour déclarer nos variables ou qu'on l'on doit encadrer de ' ou " si on veut utiliser leur valeur en tant que mot :

and elsif node
attr false private
case function or
class if
true
default in
type
define import
undef
else inherits unless


= Facter : va nous fournir des variables systemes : 

vagrant@client manifests]$ facter |grep mb
    vendor => "innotek GmbH",
  manufacturer => "innotek GmbH",
[vagrant@client manifests]$ facter |grep free
[vagrant@client manifests]$ facter |grep version
aio_agent_version => 1.8.2
  version => "1.4.0"
    version => "VirtualBox"
facterversion => 3.5.0
kernelmajversion => 3.10
kernelversion => 3.10.0
  version => "2.1.9"


certaines varibles facter vont être directement utilisée par puppet et ses modules :

facter --puppet 

io_agent_version => 1.8.2
augeas => {
  version => "1.4.0"
}
disks => {
  sda => {
    model => "VBOX HARDDISK",
    size => "20.00 GiB",
    size_bytes => 21474836480,
    vendor => "ATA"
  }
...
...
system_uptime => {
  days => 0,
  hours => 1,
  seconds => 7004,
  uptime => "1:56 hours"
}
timezone => UTC
virtual => virtualbox


Certains facters puppet sont poussés parmi les facter system de base


une liste de fact en json est directement trouvable via la commande :
puppet facts find 

On peut sortir la liste des facts sous differents formats :
-yaml :
[vagrant@client manifests]$ facter --yaml
[vagrant@client manifests]$ puppet facts render-as-yaml
- json :
[vagrant@client manifests]$ facter --json
[vagrant@client manifests]$ puppet facts render-as-json

= Appel de fonction dans les manifests :

une fonction est du code executable qui peut prendre des entrées en paramètres et peut afficher des valeurs en sortie.
une fonction qui retourne une valeur peut être utiliser pour devenir la veleur d'une variable :

$zero_or_one = bool2num( $facts['is_virtual'] );

une fonction peut aussi être utilisée a la place d'une valeur ou interpolée dans une chaine de caracteres :
# md5() function provides the value for the message attribute
notify { 'md5_hash':
     message => md5( $facts['fqdn'] )
}
# Include the MD5 hash in the result string
$result = "The MD5 hash for the node name is ${md5( $facts['fqdn'] )}"

Puppet execute des fonctions lors de la génération du catalogue : examine les donnees de sources externes , ajoute modifie des entrees dans le catalogue ,execute du code ....

on peut ecrire les fonctions en mode prefix ou en mode ruby 'chainé' :
# Common prefix format
notice( 'this' )
# Ruby-style chained format
'this'.notice()

- Utilisation de variables dans les ressources :
rappel on ne quote que les strings simples avec des ' et les interpolées avec des " . on ne quote pas les autres variables :

notice('Beginning the program.' )
notice("Hello, ${username}" )
notice(1000000 )
notice(true )

on peut acceder à une valeur d'un tableau et on peut specifier un range : 
$first_item = $my_list[1]
$four_items = $my_list[3,6]

You can access specific items within a Hash by using the hash key within square
brackets as follows: 
$username = $my_hash['username']

Toutes les variables de tableau doivent être entourées de {} pour l'interpolation :
notice( "The user's name is ${username}" )
notice( "The second value in my list is ${my_list[1]}" )
notice( "The login username is ${my_hash['username']}" )

Best pratice : on ne doit pas entourer une variable en stadalone de {} :

file { $filename:
ensure => present,
mode
=> '0644',
replace => $replace_bool,
content => $file['content'],
}

Exemple de test de variable dans un manifest :

on recupére pour l'exemple des données via facter et on affiche un message en mode multiligne qu'on aura au prealable enregistre dans une variable 

[vagrant@client manifests]$ cat testvar.pp 
$myname = $facts['hostname']
$kind = $facts['is_virtual']
$living = $facts['uptime']

$resume = @("END")
for sure here is 
a multiline text
we claim the node is $myname
and it is a $kind server
with $living time
END


notify { 'message':
    message => "yop $resume"
    }

ici on affiche la premiere valeur du tableau qu'on aura resneigné dans une variable :
[vagrant@client manifests]$ cat hash.pp 
$joe =['lapin', 3, true]

notify {'hash':
    message => "hey this is the first index record : ${joe[0]}"
    }

[vagrant@client manifests]$ puppet apply hash.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.06 seconds
Notice: hey this is the first index record : lapin
Notice: /Stage[main]/Main/Notify[hash]/message: defined 'message' as 'hey this is the first index record : lapin'
Notice: Applied catalog in 0.01 seconds


A noter que c'est une bonne pratique de toujours travailler avec la valeur désirée du fact en utilisant la forme $fact['valeur]

Il est toujours préférable de travailler avec la conf suivante de settée :

[main]
strict_variables = true

On aura toujours dans ce cas des erreurs de type : " Evaluation error" en cas d'appels de variables non définies.
NB: que nous n'aurons pas d'erreur si nous déclarons une variable de type "undef".

_- Definition d'attribut avec les hash :
il est tout a fait possible de recupérer les noms et valeurs d'un hash pour définir les attributs d'une ressource avec "*" :

$resource_attributes = {
ensure => present,
owner => 'root',
group => 'root',
'mode' => '0644',
'replace' => true,
}

file { '/etc/config/first.cfg':
source => 'first.cfg',
* => $resource_attributes,
}

file { '/etc/config/second.cfg':
source => 'config.cfg',
* => $resource_attributes,


on voit que des patterns sont donc réutilisés plusieurs fois : cela fait parti du DRY dont repeat yourself

- Declaration multiple de resources :
il est possible de déclarer au sein du même type plusieurs resources en déclarant plusieurs noms à la suite ( cela est possible quand les attributs ne mettent pas de conflits :) 

file { ['/tmp/file_one.txt','/tmp/file_two.txt']:
ensure => present,
owner => 'vagrant',
}

 on peut déclarer plusieurs body de ressources en les separant par des ";" :

 file {
 'file_one':
 ensure => present,
 owner => 'vagrant',
 path
 => 'file_one.txt',
 ;
 'file_two':
 ensure => present,
 owner => 'vagrant',
 path => 'file_two.txt',
 ;
 }

 A noter que cette ecriture n'est pas conseillé. une definition de ressource par type est ce qui est recommandé.
 on peut a la rigeur utiliser cette forme si une valeur par défaut est déclarée :

file {
 default:
  ensure => present,
  owner => 'vagrant',
;
 'file_one': path => 'file_one.txt';
 'file_two': path => 'file_two.txt';
}


- Operations :

$added = 10 + 5
$subtracted = 10 - 5
$multiplied = 10 * 5
$divided = 10 / 5
$remainder = 10 % 5

- Ajout dans les tableaux et hash :
$my_list = [1,4,7]
$bigger_list = $my_list + [14,17]
# equals [1,4,7,14,17]

$key_pairs = {name => 'Joe', uid => 1001}
$user_definition = $key_pairs + { gid => 500 }

ex : 
[vagrant@client manifests]$ cat re.pp 
$my_list = [1,4,7]
$bigger_list = $my_list + [14,17]


notify { 'yop':
    message => "here it is ${bigger_list}"
    }

[vagrant@client manifests]$ puppet apply re.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.06 seconds
Notice: here it is [1, 4, 7, 14, 17]
Notice: /Stage[main]/Main/Notify[yop]/message: defined 'message' as 'here it is [1, 4, 7, 14, 17]'

- ajout de valeur :
on peut ajouter des  éléments dans un tableau avec la commande <<

ex : 
 $longer_list = $my_list << 33
 $unintended = $my_list << [33,35]

 [vagrant@client manifests]$ cat re.pp 
 $my_list = [1,4,7]
 $bigger_list = $my_list + [14,17]
 $longer = $bigger_list << 'lapin'

 notify { 'yop':
     message => "here it is ${bigger_list}"
     }

     notify {'yy':
         message => "now this is a longer list $longer"
         }

[vagrant@client manifests]$ puppet apply re.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.07 seconds
Notice: here it is [1, 4, 7, 14, 17]
Notice: /Stage[main]/Main/Notify[yop]/message: defined 'message' as 'here it is [1, 4, 7, 14, 17]'
Notice: now this is a longer list [1, 4, 7, 14, 17, lapin]
Notice: /Stage[main]/Main/Notify[yy]/message: defined 'message' as 'now this is a longer list [1, 4, 7, 14, 17, lapin]'
Notice: Applied catalog in 0.01 seconds

 - Suppression d'éléments dans les listes et tableaux avec "-" :

 # Remove a single value
 $names = ['jill','james','sally','sam','tigger']
 $no_tigger = $names - 'tigger'
 # Remove multiple values
 $no_boys = $names - ['james','sam']
ex :
[vagrant@client manifests]$ cat re.pp 
$my_list = [1,4,7]
$cut = $my_list - 4
notify { 'yop':
    message => "here it cut list $cut"
}

[vagrant@client manifests]$ puppet apply re.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.07 seconds
Notice: here it cut list [1, 7]
Notice: /Stage[main]/Main/Notify[yop]/message: defined 'message' as 'here it cut list [1, 7]'
Notice: Applied catalog in 0.01 seconds

 - L'ordre d'evaluation des opérations suit les regles mathématiques  de base : il faut toujours encadrer correctement avec des parentheses.

- Operateurs de comparaisons :
ce sont les mêmes que ceux utilisés classiquement en programmation.
4 != 4.1
$how_many_cups < 4
$how_many_cups >= 3

Le test sur les chaine de caracteres sont insensibles a la casse 
coffee == 'coffee'
'Coffee' == 'coffee'
tea' !in 'coffee'
mais les sous chaines de caracteres sont sensibles a la casse :
'Fee' !in 'coffee'
'fee' in 'coffee'

[1,2,5] != [1,2]
5 in [1,2,5]
{name => 'Joe'} != {name => 'Jo'} # hashes aren't identical
'Jo' !in {fname => 'Jo', lname => 'Rhett'}   is a value and doesn't match
$not_true =~ Boolean
$num_tokens =~ Integer
$my_name !~ String

true and true
true and false
true or false
true and !false
true and !true

= Evaluations conditionnelles :

if / elsif / else statements
unless / else statements
case statements
Selectors

- if : 

if ($coffee != 'drunk') {
notify { 'best-to-avoid': }
}
elsif ('scotch' == 'drunk') {
notify { 'party-time': }
}
else {
notify { 'party-time': }
}

- unless :

unless $facts['kernel'] == Linux {
notify { 'You are on an older machine.': }
}
else {
notify { 'We got you covered.': }
}

A noter que la forme else dans unless existe depuis puppet 4 . 
La forme unless n'est pas très conseillée ..car moins facile à lire.

- case :
cette forme nous permet d'eviter le rajout de condition avec else : on gagne en lisibilité.
ATTENTION : il faut toujours rajouter une clause default avec case même si elle est vide et ne sert à rien.

case $what_she_drank {
    'wine': { include state::california }
     $stumptown: { include state::portland }
     /(scotch|whisky)/: { include state::scotland }
     is_tea( $drink ): { include state::england }
     default: {}
}

- selectors :
leur usage est a peur pres identique a case mais ils retournent une valeur plutôt que d'executer un bloc de code .
C'est tres utile quand on doit definir des variables.
Comme une valeur doit être retournée lors de l'assignation il faut toujours un 'mot' même pour le default :

$native_of = $what_he_drinks ? {
'wine'            => 'california',
$stumptown        => 'portland',
/(scotch|whisky)/ => 'scotland',
is_tea( $drink )  => 'england',
default           => 'unknown',
}

exemples :

if /else /elsif 

# Explicit comparison
if( $facts['osfamily'] == 'redhat' ) {
include yum
}
# Do a substring match
elsif( $facts['osfamily'] in 'debian-ubuntu' ) {
include apt
}
# New package manager available with FreeBSD 9 and above
elsif( $facts['operatingsystem'] =~ /?i:freebsd/ )
and ( $facts['os']['release']['major'] >= 9 ) {
include pkgng
}

case : 

case $facts['osfamily'] {
    'redhat': { include yum }
    'debian', 'ubuntu': { include apt }
    'freebsd' and ($facts['os']['release']['major'] >= 9) { include pkgng }
    default: {}
}

selectors : 
$libdir = $facts['osfamily'] ? {
/(?i-mx:centos|fedora|redhat)/ => '/usr/libexec/mcollective',
/(?i-mx:ubuntu|debian)/        => '/usr/share/mcollective/plugins',
/(?i-mx:freebsd)/              => '/usr/local/share',
}

On peut aussi utiliser "*" qui transforme les elements de tableau en liste 

$redhat_based = ['RedHat','Fedora','CentOS','Scientific','Oracle','Amazon']
$libdir = $facts['osfamily'] ? {
*$redhat_based => '/usr/libexec/mcollective',
}


- REGEXPS : regexps / regular expressions :

puppet supporte les regexps de ruby 
string a gauche =~ regexp a droite entourée par des / / ou par des " " :

$what_did_you_drink =~ /tea/
$what_did_you_drink !~ /coffee/
$what_did_you_drink !~ "^coffee$"


unless $facts['operatingsystem'] !~ /(?i-mx:centos|fedora|redhat)/ {
include yum
}

case $facts['hostname'] {
/^web\d/: { include role::webserver }
/^mail/ : { include role::mailserver }
default : { include role::base}
}

$package_name = $facts['operatingsystem'] ? {
/(?i-mx:centos|fedora|redhat)/ => 'mcollective',
/(?i-mx:ubuntu|debian)/        => 'mcollective',
/(?i-mx:freebsd)/              => 'sysutils/mcollective',
}


- Lambda : block de code comme une fonction sans nom qui permet de passer des arguments.
elles sont utilisées avec les boucles :

elles sont des variables entourées de | :

| $firstvalue, $secondvalue | {
block of code that operates on these values.
}

ex : ici on recupere toutes les partitions grace a facter : chacune des entrees va etre decoupées par son nom et son point de montage . on fait ensuite une boucle qui va nous afficher le nom du serveur le nom de lz partition et la taille de cette partition qui sera recupérée par le hash fourni par facter et enregistre dans la variable device


[vagrant@client manifests]$ cat /vagrant/manifests/mountpoints.pp 
each( $facts['partitions'] ) |$name, $device| {
  notice( "${facts['hostname']} has device ${name} with size ${device['size']}" )
  }
  [vagrant@client manifests]$ sudo puppet apply /vagrant/manifests/mountpoints.pp 
  Notice: Scope(Class[main]): client has device /dev/mapper/centos-root with size 18.46 GiB
  Notice: Scope(Class[main]): client has device /dev/mapper/centos-swap with size 1.00 GiB
  Notice: Scope(Class[main]): client has device /dev/sda1 with size 500.00 MiB
  Notice: Scope(Class[main]): client has device /dev/sda2 with size 19.51 GiB
  Notice: Compiled catalog for client.example.com in environment production in 1.70 seconds
  Notice: Applied catalog in 0.01 seconds



- Looping :

ces fonctioosn puissantes vont nous permettre de parcourir des set de données dans des tableaux , hash etc..
il y a 5 fonctions qui vont nous servir a itérer et vont être passées à la fonction lambda qui renverra une valeur pour chaque entree.

each() acts on each entry in an array, or each key/value pair in a hash.
filter() returns a subset of the array or hash that were matched by the lambda.
map() returns a new array or hash from the results of the lambda.
reduce() combines array or hash values using code in the lambda.
slice() creates small chunks of an array or hash and passes it to the lambda.

each appelle lambda a chaque passage de valeur dans un tableau ou d'un hash dans une serie clé valeur 
C'est la fonction la plus utilisée pour lister des éléments.

[vagrant@client manifests]$ cat /vagrant/manifests/interface_ips.pp 
# Output a list of interfaces which have IPs
split( $facts['interfaces'], ',' ).each |$interface| { 

if( $facts["ipaddress_${interface}"] != '' ) {
      notice( sprintf( "Interface %s has IPv4 address %s", $interface, $facts["ipaddress_${interface}"] ) )
        }
        
if( $facts["ipaddress6_${interface}"] != '' ) {
              notice( sprintf( "Interface %s has IPv6 address %s", $interface, $facts["ipaddress6_${interface}"] ) )
                }
}

[vagrant@client manifests]$ puppet apply /vagrant/manifests/interface_ips.pp 
Notice: Scope(Class[main]): Interface enp0s3 has IPv4 address 10.0.2.15
Notice: Scope(Class[main]): Interface enp0s3 has IPv6 address fe80::a00:27ff:feb7:f3af
Notice: Scope(Class[main]): Interface enp0s8 has IPv4 address 192.168.250.10
Notice: Scope(Class[main]): Interface enp0s8 has IPv6 address fe80::a00:27ff:fe5e:d9ac
Notice: Scope(Class[main]): Interface lo has IPv4 address 127.0.0.1
Notice: Scope(Class[main]): Interface lo has IPv6 address ::1
Notice: Compiled catalog for client.example.com in environment production in 1.73 seconds
Notice: Applied catalog in 0.01 seconds


on peut recupérer les valeurs d'un tableau et renseigner le numéro d'index :

$ cat /vagrant/manifests/interfaces.pp
split( $facts['interfaces'], ',' ).each |$index, $interface| {
notice( "Interface #${index} is ${interface}" )
}
$ puppet apply /vagrant/manifests/interfaces.pp
Notice: Scope(Class[main]): Interface #0 is enp0s3
Notice: Scope(Class[main]): Interface #1 is enp0s8
Notice: Scope(Class[main]): Interface #2 is lo

on peut aussi utiliser each avec un hash 

si on met deux variables on aura une sortie avec le nom et la seconde avec la valeur 

[vagrant@client manifests]$ cat /vagrant/manifests/uptime.pp 
each( $facts['system_uptime'] ) |$type, $value| {
   notice( "System has been up ${value} ${type}" )
   }

ici on ne met q'une variable et on aura le même resultat : 
each( $facts['system_uptime'] ) |$uptime| {
notice( "System has been up $uptime[1] $uptime[0]" )
}

- La methode reverse_each() : nous renvoie la liste inversée de each()
[vagrant@client manifests]$ cat l.pp 
$my_list = "lapin"


reverse_each("$my_list") |$elem| {
notice("$elem")

}

[vagrant@client manifests]$ puppet apply l.pp
Notice: Scope(Class[main]): n
Notice: Scope(Class[main]): i
Notice: Scope(Class[main]): p
Notice: Scope(Class[main]): a
Notice: Scope(Class[main]): l
Notice: Compiled catalog for client.example.com in environment production in 0.06 seconds
Notice: Applied catalog in 0.01 seconds

- filter() : 
cette fonction va boucler et ne sortir que les éléments définis de tableaux ou de hash  recupérer par  lambda  après le passage de filtre définis .
ici on va définir une variable $ips dans laquelle on va injecter toutes les valeurs trouvées après le passage de notre filtre que l'on set dans la variable $key et qui contient le pattern ipaddress6 

On boucle sur les résultats $key et $value que l'on affiche :

[vagrant@client manifests]$ cat ip.pp 
$ips = $facts.filter |$key,$value| { 
  $key =~ /^ipaddress6?_/
  }

  notice("here it is ..version 6 ip proctocol : $ips")
[vagrant@client manifests]$ puppet apply ip.pp
Notice: Scope(Class[main]): here it is ..version 6 ip proctocol : {ipaddress6_enp0s3 => fe80::a00:27ff:feb7:f3af, ipaddress6_enp0s8 => fe80::a00:27ff:fe5e:d9ac, ipaddress6_lo => ::1, ipaddress_enp0s3 => 10.0.2.15, ipaddress_enp0s8 => 192.168.250.10, ipaddress_lo => 127.0.0.1}
Notice: Compiled catalog for client.example.com in environment production in 0.08 seconds



- map() :
cette fonction nous sort un tableau après le passage de lambda et peut recevoir en entrées tableau ou hash


[vagrant@client manifests]$ cat m.pp 
$ips = split( $facts['interfaces'], ',' ).map |$interface| {
$facts["ipaddress_${interface}"]
}
notice("here it is ..; $ips")

[vagrant@client manifests]$ puppet apply m.pp 
Notice: Scope(Class[main]): here it is ..; [10.0.2.15, 192.168.250.10, 127.0.0.1]
Notice: Compiled catalog for client.example.com in environment production in 0.07 seconds
Notice: Applied catalog in 0.01 seconds


- slice() :
nous permet de sortir des petits morceaux de tableaux ou de hash avec un taille déterminée.
Attention à l'usage : touchy.

on va donc decouper notre entrée en petits morceaux de tailles spécifiques :

[1,2,3,4,5,6].slice(2) |$item| {
notice( "\$item[0] = ${item[0]}" )
notice( "\$item[1] = ${item[1]}" )
}

on decoupe en bloc de deux unités notre tableau : chaque fois qu'on atteint deux on recommence à 0 :

[vagrant@client manifests]$ puppet apply s.pp
Notice: Scope(Class[main]): $item[0] = 1
Notice: Scope(Class[main]): $item[1] = 2
Notice: Scope(Class[main]): $item[0] = 3
Notice: Scope(Class[main]): $item[1] = 4
Notice: Scope(Class[main]): $item[0] = 5
Notice: Scope(Class[main]): $item[1] = 6
Notice: Compiled catalog for client.example.com in environment production in 0.07 seconds
Notice: Applied catalog in 0.01 seconds


- with() :
cette fonction va permettre de passer les arguments à la fonction lambda qui va chacun les assigner a des variables :

[vagrant@client manifests]$ cat w.pp 
with( 'austin', 'powers', 'secret agent' ) |$first,$last,$title| {
notice( "A person named ${first} ${last}, ${title} is here to see you." )
}

[vagrant@client manifests]$ puppet apply w.pp 
Notice: Scope(Class[main]): A person named austin powers, secret agent is here to see you.
Notice: Compiled catalog for client.example.com in environment production in 0.06 seconds
Notice: Applied catalog in 0.01 seconds

cette fonction sert principalement à isoler les variables dans des scopes privés.

- Capture des extra parameters : 
habituellement les variables récupérées par lambda sont au nombre de 1 ou 2.
Bien qu'avec split() et with() ont puisse passer un nombre plus importants : on peut utiliser le "*" qui va donc récupérer les arguments qui restent pour les assigner à une variable.
on récupère tout le reste des args et on l'insere dans une variable dont le contenu sera systematiquement un tableau.

[vagrant@client manifests]$ cat star.pp 
$hosts_line = '192.168.250.6 puppetserver.example.com puppet.example.com puppetserver'
$host = $hosts_line.split(' ')
with( *$host ) |$ipaddr, $hostname, *$aliases| {
  notice( "Host ${hostname} has IP ${ipaddr} and aliases ${aliases}" )
  }

[vagrant@client manifests]$ puppet apply star.pp 
Notice: Scope(Class[main]): Host puppetserver.example.com has IP 192.168.250.6 and aliases [puppet.example.com, puppetserver]
Notice: Compiled catalog for client.example.com in environment production in 0.07 seconds
Notice: Applied catalog in 0.01 seconds



== Chapitre 6 : Controle ressource processing : =

https://docs.puppet.com/puppet/latest/metaparameter.html

on peut controller comment puppet gere ses ressources en utilisant certains metacharacteres: qui sont des attributs communs que l'on peut utiliser avec les ressources built-in et celles que l'on customize soit même.

- aliases : 
comme on le sait chaque ressource du même type doit être unique.
Chaque ressource a un attribut que l'on nomme namevar qui sert à l'identifier de manière unique.Si la namevar n'est pas définie elle prend par défault le titre de la ressource
On a un namevar dedié par type de resource.
https://docs.puppet.com/puppet/latest/type.html

Pour simplifier la gestion des ressources on peut utiliser des alias qui peuvent simplifier certaines ressourses dont le comportement peut changer (ex : emplacement sur un fichier disque )
on peut mettre en place un alias soit en indiquant un 'nom' dans le 'titre' de notre ressource :

file { 'the-testfile':
ensure  => present,
path    => '/tmp/testfile.txt',
content => "holy cow!\n",
}
on peut de manière plus claire pour les personnes non habituées à puppet , rajouter à un alias en tant que metacaractere : 

file { '/tmp/testfile.txt':
ensure  => present,
alias   => 'the-testfile'
content => "holy cow!\n",
}

- noop : no operation :

on peut utiliser le metacaractere noop pour permettre de tester le fonctionnement d'une modification sans l'application du changement : cela nous permet de voir pendant le run le dérouler de ce qui se passera : 

package { 'puppet-agent':
ensure => latest,
noop   => true,
}

C'est le meme comportement que le dry run que l'on passe avec le --noop qu'on met en argument sur la ligne de commande : 
attention on ne peut pas overrider en cli ce qui est defini dans les params des ressources  : les fichiers de conf sont prioritaires.


[vagrant@client ~]$ puppet apply --noop  manifests/helloworld.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.06 seconds
Notice: /Stage[main]/Main/Notify[greeting]/message: current_value absent, should be hello, world ! (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 1 events
Notice: Stage[main]: Would have triggered 'refresh' from 1 events
Notice: Applied catalog in 0.01 seconds
- audit : auditer le changement.
cet attribut permet de suivre / tracker une liste de changement que l'on veut suivre en définissant une liste de pattern d'une ressource à suivre ou tous les  paramtres  si on definit la valeur à "all" 
ex : 

vagrant@client manifests]$ cat /vagrant/manifests/audit.pp 
file { '/etc/hosts':
  audit  => ['content','owner','group'],
  backup => 'puppet',
  noop   => true,
}

[vagrant@client manifests]$ sudo puppet apply /vagrant/manifests/audit.pp 
Notice: Compiled catalog for client.example.com in environment production in 1.69 seconds
Notice: /Stage[main]/Main/File[/etc/hosts]/content: audit change: newly-recorded value {md5}0350f101b01cdcd219ecb3bfd3a28cc0
Notice: /Stage[main]/Main/File[/etc/hosts]/owner: audit change: newly-recorded value 0
Notice: /Stage[main]/Main/File[/etc/hosts]/group: audit change: newly-recorded value 0

On fait une petite modif en rajoutant du texte et le run nous sort bien une diff : 

[vagrant@client manifests]$ echo "## dust ## " |sudo tee -a /etc/hosts
## dust ## 
[vagrant@client manifests]$ sudo puppet apply /vagrant/manifests/audit.pp 
Notice: Compiled catalog for client.example.com in environment production in 1.70 seconds
Notice: /Stage[main]/Main/File[/etc/hosts]/content: audit change: previously recorded value {md5}0350f101b01cdcd219ecb3bfd3a28cc0 has been changed to {md5}a424861f14c6bb8b00f15eb695e9eb40
Notice: Applied catalog in 0.02 seconds

- Log level :

on peut définir le log level que l'on désire dans l'idée de syslog :

debug
info (nommé aussi verbose )
notice
warning
err
alert
emerg
crit
ex : on peut set un warning quand on a une maj de packet par exemple :
package { 'puppet-agent':
    ensure => latest,
    loglevel => warning,
}

- Filtrage avec les tags :

On peut les utiliser pour renforcer la gestion des ressources: par exemple ajouter des packages sans redémarrer les services.
On peut les ajouter sous forme de strings ou de tableaux de strings.

Ici on va ajouter un tag 'packages' sur la ressource package : on va donc pouvoir dans notre cas pouvoir installer le package mais ne pas lancer le service tout de suitebien qu'il soit configurer pour dans notre manifest . On invoque notre run avec le tag en argument :

vagrant@client manifests]$ cat /vagrant/manifests/packagetag.pp 
package { 'ntpdate':
  ensure => present,
  tag    => 'packages',
}

service { 'ntpdate':
  ensure  => running,
  enable  => true,
}


[vagrant@client manifests]$ sudo puppet apply /vagrant/manifests/packagetag.pp --tags packages
Notice: Compiled catalog for client.example.com in environment production in 2.40 seconds
Notice: Applied catalog in 0.13 seconds


si on examine individuellement nos ressources : package et service -> on a bien notre package ntpdate d'installé comme configuré mais le service est stoppé : alors que le manifest decrit le service running : c'est uniquement lié au fait qu'on passe le run avec le tag du package  

grant@client ~]$ sudo puppet resource package ntpdate
package { 'ntpdate':
  ensure => '4.2.6p5-25.el7.centos',
}

[vagrant@client ~]$ sudo puppet resource service ntpdate
service { 'ntpdate':
  ensure => 'stopped',
  enable => 'false',
}
NB: puppet ajoute 'automatiquement' le tag associé à chaque ressource : on peut donc imaginer qu'on tag service, package ... est crée et donc invocable.

L'options tags peut prendre plusieurs arguments à la suite : --tags service,puppet, package ....


- skip_tags :

a l'inverse l'option skip_tags peut nous permettre d'ignorer specifiquement certaines parties de nos manifests :
on peut par exemple vouloir se passer du redemarrage d'un service particulier malgré la conf dans notre manifest :

[vagrant@client ~]$ cat /vagrant/manifests/packagetag.pp 
package { 'puppet':
  ensure => present,
  tag    => 'packages',
}

service { 'puppet':
  ensure  => running,
  enable  => true,
  tag    => 'pkg',
}
on voit apres notre run avec l'option skip_tags et l'exam avec la commande puppet resource que le service est bien stoppé :

[vagrant@client ~]$ sudo puppet apply /vagrant/manifests/packagetag.pp --skip_tags service
Notice: Compiled catalog for client.example.com in environment production in 2.22 seconds
Notice: Applied catalog in 0.13 seconds
[vagrant@client ~]$ sudo puppet resource service puppet
service { 'puppet':
  ensure => 'stopped',
  enable => 'true',

NB: on  peut utiliser conjointement l'option --skip_tags et --tags mais skip_tags est prioritaire et doit être placée avant tags.

- schedule :

on peut definir la frequence de modif des run avec le meta parametre schedule : 

schedule { 'twice-daily':
  period => daily,
  repeat => 2,  # apply twice within the period
}

on a la possibilité d'affiner nos paramètres en choissant le nombre de fois ou la modif a lieu pendant notre période avec l'attribut repeat et on peut définir les plages horaires 
ex : 

schedule { 'business-hours':
  period   => hourly,
  repeat   => 1, # apply once per hour
  range    => '08:00 - 17:00', # between 8 a.m. and 5 p.m.
  weekday  => ['Mon','Tue','Wed','Thu','Fri'], # on weekdays
} 

schedule { 'after-working-hours':
  period   => daily,
  range    => '17:00 - 08:00',
}

on peut exprimer le temps et la durée comme tel : 
• hourly
• daily  # between 5 p.m. and 8 a.m.
• weekly
• monthly
• never

 La valeur du metaparametre schedule doit contenir le nom de la ressource schedule qu'on a déclaré .
 ex pour l'upgrade d'un packet pendant un creneau precis :

 package { 'puppet-agent':
 ensure => latest,
 schedule => 'after-working-hours',
 }
avec comme définition :

schedule { 'after-working-hours':
  period   => daily,
  range    => '17:00 - 08:00',
}


- periodmatch :
attenyion ce metaparametre n'est pas simple à comprendre.
Il peut prendre deux valeurs :
-distance (default) : le run ne sera pas lancé tant que la valeur de distance (hour, day, week ...) ne sera pas passée.
On peut avoir une valeur repeat 
si elle est setté le run ne pourra être passé tant que la valeur de repeat distance ne sera pas ecoulée. ex 4 fois par jour

Attention quand periodmatch est donné sous forme numérique (plutôt que mot (day, hour ...;) la valeur ne peut être sup à 1.

Exemples : 
vagrant@client ~]$ cat /vagrant/manifests/schedule.pp 
schedule { 'once-every-hour':
  period      => hourly,
  periodmatch => number,
  repeat      => 1,
}

file { '/tmp/test-number.txt':
  ensure   => file,
  schedule => 'once-every-hour',
}

schedule { 'sixty-minutes-apart':
  period      => hourly,
  periodmatch => distance,
  repeat      => 1,
}

file { '/tmp/test-distance.txt':
  ensure   => file,
  schedule => 'sixty-minutes-apart',
}

schedule { 'every-four-minutes':
  period      => hourly,
  periodmatch => distance,
  repeat      => 15,
}

file { '/tmp/test-four.txt':
  ensure   => file,
  schedule => 'every-four-minutes',
}

exec { 'remove files':
  path    => '/bin:/usr/bin',
  command => 'rm -f /tmp/test-number.txt /tmp/test-distance.txt /tmp/test-myrepeat.txt',
  onlyif  => ['test -f /tmp/test-number.txt', 'test -f /tmp/test-distance.txt', 'test -f /tmp/test-repeat.txt'],
}



- Interdiction de dependance :

Si une resource n'est pas cree car elle tombe hors période de schedule : elle sera quand même considérée dans un process d'analyse  de dependance.
On peut dans ce cas passer une option pour bypasser le schedule en cas de dependance detectée ..et donc d'erreur de run si la dependance echous :
exmple :  on set un schedule : on creee un fichier dans ce laps de temps  . Si on veut editer le fichier pour faire une modif de conf alors qu'on est hors schedule : c'est un echec : on peut donc utiliser : 
en option :
--ignoreschedules


- Resources par default :

on peut creer des valeurs de resources par type de ressources.
Si une ressource n'a pas de valeurs définie alors elle utilisera celle defini pour son type par défaut.

Attention on doit toujours définir la ressource avec une Majuscule dans ce cas : 

Package {
 schedule => 'after-working-hours',
}

Best Practice
Declare resource defaults at the top of the manifest for easy reading
purposes.

-> en effet la declaration d'un type par default dans un manifest s'appliquera à toutes les ressources même si elles sont au dessus : c'est donc à eviter /!\ 

voir section sur le scope de variable.


== chapitre 7 : Relations : 
L'accent va être ici mis sur les metaparametres qui vont gérer les dependances entre les resources.
Des que puppet a parsé les modifications a faire un graph de dépendance est établi.
puppet utilise des metaparametres pour définir les dependances entre les ressources.

- Gestion des dependances :

-> reference de resource :

ex :
ici on s'assure que le packet est bien installé sur le systeme.
package { 'puppet-agent':
    ensure => present,
}
une fois qu'on a nommé la ressource on peut l'utiliser par son nom : c'est la référence de resource 
pour creer une reference on l'appelle par son type de resource avec une majuscule et entre [] :

service {'puppet':
ensure   => running,
enabled  => true,
require  => Package['puppet-agent'],
}

On cree une ressource en minuscule et on s'y refere en l'appellant par son type avec une maj suivi de son nom.

-> ordre des ressources : 
on va biensur devoir définir un ordre : difficile de redemarrer un service si le packet n'est pas installé ..
on peut se servir de keyword : before , require ..

package { 'puppet':
ensure => present,
before => Service['puppet'],
}

service {'puppet':
ensure    => running,
enable    => true,
require   => Package['puppet'],
}

- Dependance implicite :
certaines resources sont implicitement dépendantes d'autre : puppet rajoute automatiquement un flag autorequire: 

file { '/var/log':
ensure => directory,
}

file { '/var/log/puppet':
ensure => directory,
autorequire => File['/var/log'],  # implicit dependencies
autorequire => File['/var'],      # added by Puppet
}
Les tags autorequire n'apparaissent pas dans les manifests : puppet les gere de maniere autonome 

On a le même systeme pour les resources de type file : ici un repertoire appartient a un user si celui-ci existe : 
user { 'jill':
ensure => present,
shell => '/bin/bash',
}

file { '/home/jill':
  ensure => directory,
  owner  => 'jill',
  require => User['jill'], # implicit dependency added by Puppet
}

- Declenchement d'evenements :
notify and subscribe metaparameters vont faire une action lors d'une modif de resource.
ex : redemarrage de services apres la modif de conf. 
ici des  qu'une mise à jour de puppet-agent est dispo : le package est uploadé : à ce moment le param notify va donc envoyer une notif à la ressource Service et donc faire redémarrer le service . Ceci est possible car le service utilise le param subscribe : qui recoit donc les infos de la resource Package.

Les deux params ne sont pas nécéssaires : un seul est nécéssaire car les infos sont redondantes : notify ou subscribe seul sont suffisants : c'est juste une méthode secure d'utiliser les deux.
package { 'puppet-agent':
  ensure => latest,
  notify => Service['puppet'],
}
service { 'puppet':
  ensure => running,
  enable => true,
  subscribe => Package['puppet-agent'],
}


Refresh : cet evenement à dans le cas d'une commande exec un param refreshonly setté à true un sens particulier : la notif  d'une ressource vers une commande exec va se faire uniquement si le param refreshonly à true est posé :
Ici un upgrade de puppet-agent va envoyé un notify à  la resource Exec['update-facts'] qui va executer la commande facter grace à la présence de refreshonly :

Package { 'puppet-agent':
ensure => latest,
notify => Exec['update-facts'],
}
exec { 'update-facts':
path      => ['/bin','/usr/bin'],
command   => 'facter --puppet --yaml > /etc/mcollective/facts.yaml',
refreshonly => true,
}

- Chaining de ressources avec les "->" / arrows :

on peut facilement chainer les ressources : ex installer un package puis agir sur  le service :
Package['puppet-agent'] -> Service['puppet']
on peut envoyer un refresh entre deux resources avec ~>
Package['puppet'] ~> Service['puppet']

Ces utilisations ne sont pas conseillées.

- Collectors : on peut assembler plusieurs ressources entre elles pour en piloter d'autres.
On declare un collector avec le nom d'une ressource commencant par une maj suivie de <| , puis d'un param optrionnel et |>
ex :
User <||>
User <| groups == 'wheel' |>
Package <||>
Package <| tag == 'yum' |>
Service <||>
ervice <| enabled == true |>
on peut combiner des elements :
Service <| ( ensure == running ) or ( enabled == true ) |>
# Services other than Puppet set to be running
Service <| ( ensure == running ) and ( title != 'puppet' ) |>

on peut aussi combiner  les collectors et les arrows :
# Regenerate the facts whenever a package is added, upgraded, or removed
Package <||> ~> Exec['update-facts']

Il est important de n'utiliser les collectors que pour les ressources de même manifest : afin d'eviter des  effets de bords sur les differents scope puppet

- Comprehension de l'ordre de processing de puppet :

Pendant la compilation du catalogue et donc avant d'appliquer les modifs : puppet crée un graph de dependance avec DAG ( direct acyclic graph ) pour eviter les boucles 
L'ordre de gestion a été introduit en version 3.3 

L'ordre se fait de plusieurs manières : 
manifest (default in Puppet 4)
Orders unrelated resources by the order they are declared in the manifest.
random
Orders resources randomly and changes the order on each run. This is useful for
identifying missing dependencies in a manifest.

Il faut toujours definir toutes les dependances explicitement : surtout quand on upgrade un manifest ou un module .

On peut tester les dépendances manquantes avec l'option --ordering=random 
puppet apply --ordering=random testmanifest.pp

- Debug des cycles de dependances :
il est tres important de na pas creer de boucles dans les appels au ressources.

vagrant@client ~]$ cat /vagrant/manifests/depcycle.pp
file { '/tmp/file-exists.txt':
  ensure  => file,
  require => Cron['check-exists'],
}

cron { 'check-exists':
  user    => 'vagrant',
  command => 'cat /tmp/file-exists.txt',
  minute  => '*/5',
  require => File['/tmp/file-exists.txt'],
}


On peut donc utiliser un graph crée par puppet pour generer un graph 
[vagrant@client ~]$ puppet apply /vagrant/manifests/depcycle.pp --graph
Notice: Compiled catalog for client.example.com in environment production
Error: Failed to apply catalog: Found 1 dependency cycle:
(Cron[check-exists] => File[/tmp/file-exists.txt] => Cron[check-exists])
Cycle graph written to
/home/vagrant/.puppetlabs/opt/puppet/cache/state/graphs/cycles.dot.

Une fois qu'on recupere le graph on va utiliser un viewer :
ex : graphiz , omnigraffle , webgraphiz

C'est une bonne maniere de visualiser les dependances.

apt-get install graphviz 
ensuite on peut exporter avec l'outil dot notre fichier .dot (créee avant  avec l'option --graph) 
ex : 
dot -Tpng cycles.dot -o cycles.png 
ensuite on peut ouvrir ule fichier avec un editeur d'image classique sur notre pc .

- Prevention des problemes avec root :
beaucoup de ressources vont dépendre de conf appartenant à root et devant être crées au préalable.
on peut devoir creer des dependances dont le owner sera root . pas de souci jusqu'à la creation d'un vrai user root dans ce cas le run peut casser car il faudra eventuellement devoir toucher au mdp ....



'home':
ensure => directory,
owner => 'root',
}
mount { '/home':
ensure => 'mounted',
fstype => 'nfs',
device => 'netapp:/home',
require => File['/home'],
}
$users.each |$user,$config| {
user { $user:
uid      => $config['uid'],
password => $config['passwd'],  <<< ici notre manifest prend en compte le mdp ...celui de root ne pourra donc pas être gérer dans le cas de l'ajout du user root dans notre manifest.
home    => $config['home'],
shell   => $config['shell'],
require => Mount['/home'],
 }
}

Il est toujours important de créer le user root au debut de l'install puppet et de gérer ses ressources également au début du build.

- Utilisation des stages :
les ressources stages permettent de tester que tout nos runs se passent dans l'ordre désiré
on creee donc un stage pour gérer l'ordre .
stage { 'initialize':
	before => Stage['main'],
}
stage { 'finalize': }
	after => Stage['main'],
}

on peut donc assigner a des classes (blocs de code ) des stages.
En pratique c'est quasiment inutilisable pour des structures moyennes : immintenable.


== chapitre 8 : puppet 3 -> 4 migration ==

== chapitre 9 : Recap puppet basics = 

"Best practices for writting Puppet manifests:

-> Quote all unquoted string values.
-> ensure should be the first attribute in a resource block.
-> Align the arrows for attributes within a resource block.
-> Enable the strict_variables configuration setting to catch errors while testing.
-> Group resources by their relationship with each other.
-> Don’t use conditionals within resource declarations.
-> Provide defaults for case and select statements.
-> When something can be done multiple ways, always use the most readable
option.
You can find the Puppet Style Guide at https://docs.puppetlabs.com/guides/
style_guide.html. All of the examples in this book have been compliant with the style
guide.

=== Part 2 : puppet modules : ===

les modules sont des ensembles de code, fichier, template, data puppet : leur écriture doit être très lisible
Ils ont plusieurs avantages :
-> rassembler code et data au sein d'un même namespace 
-> contenir du code qui fait quelque chose (installer, supprimer ....)
-> fournir des fichiers, templates , fonctions , plugins utilisables pour d'autres modules.
Il est important d'utiliser des modules qui pourront être utiliser sans modifier le code mais juste en adaptant nos d
onnées à ces modules.
 
= chaptitre 10 : creation d'un environment de test : 
puppet permet de fournir diferentes version de modules et de data via l'utilisation d'environment.Un des premiers  usage est d'utiliser puppet sans perturber la productoion.
On va donc creer un environment de production et de test avant d'installer nos modules.

A l'installation puppet créee de base un environnment de production : 

[vagrant@client ~]$ ls  /etc/puppetlabs/code/environments/production/ -l
total 4
-rw-r--r-- 1 root root 879  6 déc.  00:17 environment.conf
drwxr-xr-x 2 root root   6  6 déc.  00:18 hieradata
drwxr-xr-x 2 root root   6  6 déc.  00:18 manifests
drwxr-xr-x 2 root root   6  6 déc.  00:18 modules

on va donc creer un environment pour tester nos modules. On créee une arbo et un fichier de base site.pp 
  mkdir -p /etc/puppetlabs/code/environments/test/modules
  cd /etc/puppetlabs/code/environments/test
  mkdir hieradata
  mkdir manifests
  vi manifests/site.pp
  notify { 'UsingTest':
    message => "Processing catalog from the Test environment.",
 } 
on va donc avoir un message s'afficher pour memo des qu'on utilise cet environmment.

Changement du path des modules : 
on peut utiliser une conf qui rend dispo nos modules quelques soit l'environment :

[vagrant@client test]$ sudo vi /etc/puppetlabs/puppet/puppet.conf
[main]
# these are both default values
environmentpath = /etc/puppetlabs/code/environments
basemodulepath = /etc/puppetlabs/code/modules
 
la variable environementpath va contenir une arbo dans laquelle un repertoire pour chaque env sera créee
la variable basemodulepath va contenir un repertoire modules qui servira de fallback si le repertoire module d'un env n'est pas trouvé : on pourra stocker ici tous nos modules correctement testé pour ne pas avoir à les dupliquer.
Chacun des ces repertoires sont ceux par defaut et n'auront donc  pas à être saisis dans le fichier de conf sauf si on veut specifiquement les changer


== chapitre 11 : Separation du code et des data : 
il est fondamental de separer le code des data : ce qui fonctionne en embarquant des données pour un node précis ne sera plus fonctionnel des qu'on augmente le nombre de machinnes.
En incluant des data dans le code on fera systematiquement des if / else qui rendront inevitablement le code non maintenable.
Il est impératif de séparer les data : values du code : manifests.

= hiera : 
hiera est un outil cle / valeur de configuration de data pour puppet.Puppet utilise dynamiquement hiera pour les confs de data .
Il est possible d'utiliser hiera selon nos besoins: d'un node specifique qui utilisera une conf particuliere dédiée puppet ou alors des découpages liés à notre infrastructure.
Les differents niveaux de hiearachie peuvent donc permettre de mutualiser des données communes aux nodes specifiques ou à des env dédies : on peut donc partager le code facilement.

- creation de backend hiera : 

on peut ecrire nativement de la conf hiera en json ou yaml . Les types suivants sont supportés : string, number, booleen, array, hash

- hiera en yaml : 
c'est le plus simple et le plus utilisé .il suffit d'avoir un fichier au format yaml et de le definir son extension en ".yaml" 

Un fichier yaml commence toujours par '---' et doit TOUJOURS utiliser les espaces pour la tabulation.
On utilise deux espaces en identation.
ex 
# string
agent_running: 'running'
# boolean
agent_atboot: true
# array
puppet_components:
  - facter
  - puppet
# a hash of values
puppet:
  ensure: 'present'
version: '4.4.0'
# A variable lookup
hostname: %{facts.hostname}

Il est tout a fait possible de regrouper cette conf qui concerne un agent puppet dans un seul hash : 
puppet:
  ensure: 'present'
  version: '4.4.0'
  agent:
    running: 'running'
    atboot: true
  components:
    - 'facter'
    - 'puppet'
syntaxe yaml pour ruby : 
http://bit.ly/1XAD1Yd


- Hiera en json :
.json en extention de fichier.La racine de chaque bloc de data doit être en hash . chaque key dans un hash nomme une partie de config 
ex precedent formatté en json :

{
"puppet": {
  "ensure": "present",
  "version": "4.4.0",
  "agent": {
    "running": "running",
    "atboot": true
  },
  "components": [
    "facter",
    "puppet"
    ]
  }
}
Attention la fin d'un bloc json ne doit pas contenir de virgule , contrairement à puppet dont le dernier bloc doit contenir une virgule.

- Variables puppet et fonction lookup : 
on peut recupérer les variables puppet ou executer une fonction d'interpolation de données dans hiera en utilisant une valeur préfixée par % et entourée de {} 
Ex :
pour récupérer une variable puppet :
%{facts.hostname}
pour executer une fonction d'interpolation 
%{ split([1,2,3]) }

-> Configuration de hiera :

de base puppet examine la conf hiera par la variable : hiera_config . par defaut dans ${codedir}/hiera.yaml ou /etc/puppetlabs/code/hiera.yaml
La config de base du hiera est un hash en yaml.Les items en haut sont des globales. chaque globale commence par un symbole ruby debutant par un ":" . Tous les paramétrages  sont optionnels et on tombe dans les valeurs par défaut s'il manque une conf.

---paramètres hiera  :

-backends : comme vu il s'agit de la conf de notre hiera : 
:backends:
  - yaml
  - json
- configuration de backends : pour chacun des backends on a un parametrage global du backend sous forme de hash . Il faut le faire pour tous les backends
On doit utiliser la clé  ":datadir" qui identifie l'endroit ou on place nos confs
ex : conf  par défaut si elle n'est pas overridée dans le fichier de conf : 
:yaml:
  :datadir: /etc/puppetlabs/code/environments/%{::environment}/hieradata
:json:
  :datadir: /etc/puppetlabs/code/environments/%{::environment}/hieradata
Comme chaque fichier doit porter une extention particuliere : on peut définir les datadir au même endroit. 


Cette config utilise le top scope "::environment" variable : defini par puppet (server ou agent) pour permettre l'utilisation de differentes  données par environment. Ce qui nous permet d'utiliser le rerpertoire hieradata défini pour notre env de test 


exemple de conf : 
vagrant@client ~]$ sudo cat /etc/puppetlabs/puppet/hiera.yaml 
---
:backends:
  - yaml
:hierarchy:
  - "nodes/%{::trusted.certname}"
  - common

:yaml:
# datadir is empty here, so hiera uses its defaults:
# - /etc/puppetlabs/code/environments/%{environment}/hieradata on *nix
# - %CommonAppData%\PuppetLabs\code\environments\%{environment}\hieradata on Windows
# When specifying a datadir, make sure the directory exists.
  :datadir:



par defaut hiera log sur la sortie standart.On peut modifier ce comportement
console > Emit warnings and debug on STDERR (default)
puppet  > Send messages to Puppet’s logging system
noop    > Don’t emit messages
name Utilize the Ruby class Hiera::name_logger , which must provide warn and debug
class methods that expect a single string argument
Note that this value is only used for Hiera command line-tools. Puppet overrides the
value and logs Hiera messages utilizing the Puppet internal logger.

-hierarchy : 
le dernier parametre obligatoire est :hierarchy qui va servir à definir l'ordre d'examen des data
-> pour des valeur simple hiera parse l'arbo jusqu'a ce qu'il trouve la valeur désirée et il stop
-> pour les tableaux et les hash : hiera va merger les data de chaque niveau de hierarchie comme defini dans la stratégie de la clé de merge (?).

Il y a deux types de data sources : static et dynamics. 
Les sources statiques de data  sont des fichiers explicitement nommé dans la hierarchie contenant des  data 
Les sources dynamiques de data sont des fichiers nommé en utilisant l'interpolation de la conf des data locales ( ex le hostname ou l'os d'un node)
On peut avoir des hierachies complexes dans certaines grosses entreprises.

Comme bon point de départ on peut établir des regles simples : 
-> mettre les valeurs par defaut dans un fichier common.yaml
-> rassembler toutes les infos specifiques à un os dans des fichiers de familles d'os ex : debian.yaml, redhat.yaml ..
-> definir les informations specifiques à un node dans un fichier de type fqdn.yaml
on peut donc utiliser par exemple ce type de conf qui utilise l'interpolation des données fournies par facter :
:hierarchy:
  - "fqdn/%{facts.fqdn}"
  - "os/%{facts.osfamily}"
  - common
on peut biensur faire evoluer cette hierarchie 
ex ici on va definir notre hierarchie en recupérant le "short name de notre node" pour le ranger dans un sous dossier du repertoire hostname : 
:hierarchy:
  - "hostname/%{facts.hostname}"
  - "os/%{facts.osfamily}"
  - common
NB : si on a plusieurs backend ( yaml, json ou autres) hiera evalue la hierarchie complete du backend defini en premier dans la conf puis le second etc ...

- Strategy de merge :
Il y en a plusieurs :
-> first ( strategy par defaut) : auparavant nommé priorité : dans ce cas il n'y a pas de merge ni de recursion : des la premiere occurence de data trouvée on s'arrête.
Les clés trouvées avec la priorité la plus haute retournent les valeurs de la même priorité ( definies donc en premier dans la conf hiera )
-> hash : auparavant nommé native : on a un merge des clés uniquement. Les correspondances des valeurs des priorité hautes seront exclusivement  utilisées.
-> deep : auparavant deeper : merge recursif des clés et valeurs : si une clé existe à differents niveaux de priorité : la valeur de priorité basse qui ne rentre pas en conflit sera utilisée.
-> unique : auparavant array : ecrase les valeurs des tableaux et valeurs scalaires toutes priorité confondues : les doublons sont supprimés.. Les hashes provoquent des erreurs.

Puppet permet la configuration de merge strategy sur une base par clé  avec deux methodes : 
-> un enregistrement dans le hash du lookup_options peut être definie dans la conf globale de hiera, dans les environments ou dans les modules.
Le hash des valeurs definies dans la clé vont fournir les options de lookup : incluant la strategy de merge
-> les options fournies par la fonction lookup() : toutes les options utilisées dans la fonction de lookup() peuvent overrider les lookup_options des data

Exemple complet qui servira de base pour la suite de nos tests de code . On va utiliser le yaml de notre conf /etc/puppetlabs/code/hieradata ( ce qui va nous permettre de partager notre conf hiera pour tous les environments.) . Il est conseillé de partager la conf hiera quand on veut juste tester notre code : c'est plus simple à maintenir.

on definie une priorité de conf pour nos hosts, puis par os puis dans la partie common :

vagrant@client ~]$ sudo cp /vagrant/etc-puppet/hiera.yaml /etc/puppetlabs/code/
[vagrant@client ~]$ cat /etc/puppetlabs/code/hiera.yaml 
---
:backends:
  - yaml
:hierarchy:
  - "hostname/%{facts.hostname}"
  - "os/%{facts.osfamily}"
  - common
:yaml:
  :datadir: /etc/puppetlabs/code/hieradata

- Lookup hieradata : 
il y a plusieurs manieres de valider la conf de nos données dans hiera 
ex : creation de conf hiera pour valider la gestion du service puppet 

vagrant@client ~]$ sudo mkdir /etc/puppetlabs/code/hieradata
[vagrant@client ~]$ sudo vi /etc/puppetlabs/code/hieradata/common.yaml
[vagrant@client ~]$ cat /etc/puppetlabs/code/hieradata/common.yaml 
---
puppet::status: 'running'
puppet::enabled: true
Maintenant on va overrider notre conf pour le hostname : on creee un repertoire hostname , on recupere le hostname avec facter et on fait un fichier de conf dedié avec des valeurs dédiées : 
[vagrant@client ~]$ sudo mkdir /etc/puppetlabs/code/hieradata/hostname
[vagrant@client ~]$ facter hostname 
client
[vagrant@client ~]$ sudo vi /etc/puppetlabs/code/hieradata/hostname/client.yaml
[vagrant@client ~]$ cat /etc/puppetlabs/code/hieradata/hostname/client.yaml
---
puppet::status: 'stopped'
puppet::enabled: false

- Test de configuration hiera : 

-> test de conf avec la commande hiera :
cette commande ne recupere pas les valeurs comme puppet malheureusement :
[vagrant@client ~]$ hiera puppet::enabled
true
[vagrant@client ~]$ hiera puppet::status
running
On voit ici que la conf definie par host et qui est prioritaire n'est pas recupérer par hiera car les valeurs ne sont pas remontées : c'est lié au fait que hiera ne recupere pas les infos de facter et de conf puppet : on a donc les valeurs contenues dans le fichier common.yaml

Il est donc important de tester les vaeurs en utilisant la fonction lookup() pour recupérer les valeurs de hiera :

[vagrant@client ~]$ puppet apply -e "notice(lookup('puppet::enabled'))"
Notice: Scope(Class[main]): false
Notice: Compiled catalog for client.example.com in environment production in 0.17 seconds
Notice: Applied catalog in 0.01 seconds

On a donc les infos correctes. On peut tester le retour de la fonction sans evaluer tout le code :
[vagrant@client ~]$ puppet lookup puppet::status
--- stopped
...

on va creer un manifest qui va donc utiliser la conf hiera : 
on fait un lookup de certaine valeur dans hiera : le resulat est assigné à une variable. On definie ensuite le status de notre service avec la valeur de notre variable

vagrant@client ~]$ cat /vagrant/manifests/hierasample.pp 
# Always set a default value when performing a Hiera lookup
$status  = lookup({ name => 'puppet::status',  default_value => 'running' })
$enabled = lookup({ name => 'puppet::enabled', default_value => true })

notify { 'puppet-settings': 
  message => "Status should be ${status}, start at boot ${enabled}.",
}

# Now the same code can be used regardless of the value
service { 'puppet':
  ensure => $status,
  enable => $enabled,
}

Quand on test notre manifest on a donc des modifs : 

[vagrant@client ~]$ sudo puppet apply  /vagrant/manifests/hierasample.pp 
Notice: Compiled catalog for client.example.com in environment production in 1.45 seconds
Notice: Status should be stopped, start at boot false.
Notice: /Stage[main]/Main/Notify[puppet-settings]/message: defined 'message' as 'Status should be stopped, start at boot false.'
Notice: /Stage[main]/Main/Service[puppet]/ensure: ensure changed 'running' to 'stopped'
Notice: Applied catalog in 0.11 seconds

Si maintenant on supprime notre conf de host spécifique et qu'on relance le run : on a les valeurs de fallback du common.yaml qui s'appliquent :

[vagrant@client ~]$ sudo rm /etc/puppetlabs/code/hieradata/hostname/client.yaml 
[vagrant@client ~]$ sudo puppet apply  /vagrant/manifests/hierasample.pp 
Notice: Compiled catalog for client.example.com in environment production in 2.01 seconds
Notice: Status should be running, start at boot true.
Notice: /Stage[main]/Main/Notify[puppet-settings]/message: defined 'message' as 'Status should be running, start at boot true.'
Notice: /Stage[main]/Main/Service[puppet]/ensure: ensure changed 'stopped' to 'running'
Notice: Applied catalog in 0.30 seconds


- Test de la strategy de merge :
voyons voir comment les data de hashs peuvent être mergées 
dans notre prcedent fichier de conf common on rajoute des users :

[vagrant@client ~]$ cat  /etc/puppetlabs/code/hieradata/common.yaml 
---
puppet::status: 'running'
puppet::enabled: true
# common.yaml
users:
  jill:
    uid: 1000
    home: '/home/jill'
  jack:
    uid: 1001
    home: '/home/jack'

[vagrant@client ~]$ sudo puppet lookup users
---
jill:
  uid: 1000
  home: "/home/jill"
jack:
  uid: 1001
  home: "/home/jack"
sur notre node client on a des repertoires /homes et un user jane : on va donc definir la specificité dans un fichier dédié client.yaml de notre arbo hiera 
grant@client ~]$ cat  /etc/puppetlabs/code/hieradata/hostname/client.yaml
---
# hostname/client.yaml
users:
  jill:
    home: '/homes/jill'
  jack:
    home: '/homes/jack'
  jane:
    uid : 999
    home: '/homes/jane'
On va tester et comparer le resulat de notre run sur les valeurs par defaut et celle de notre node client avec sa conf dediée :

On voit que la conf par default recupere les infos du common.yaml avec l'appel --node default :
[vagrant@client ~]$ puppet lookup --node default users
---
jill:
  uid: 1000
  home: "/home/jill"
jack:
  uid: 1001
  home: "/home/jack"
Ici la conf pour notre node client on a bien la conf dédiée definie dans notre client.yaml :
[vagrant@client ~]$ puppet lookup users
---
jill:
  home: "/homes/jill"
jack:
  home: "/homes/jack"
jane:
  uid: 999
  home: "/homes/jane"

On voit ici que l'on a pas  récupére les uid ( non definis dans client.yaml mais dans common.yaml) : puppet a recupére les infos en fonctions des priorités et a ignoré les sous clés définie dans des priorités plus basses : nous devons donc toujours repliquer nos infos pour les ressources avec des conf de data différentes quand on utilise les strategies de first et hash merging 

L'appel --node interroge les facts de la puppetdb .

Si on essaye la strategy merge on a donc un autre resultat :
[vagrant@client ~]$ puppet lookup users --merge deep
---
jill:
  uid: 1000
  home: "/homes/jill"
jack:
  uid: 1001
  home: "/homes/jack"
jane:
  uid: 999
  home: "/homes/jane"
Comme  on sait que l'on doit recupérer toutes les infos des users on peut definir notre stratégie de merge dans notre conf yaml : 

# common.yaml
lookup_options:
  users:
    merge : deep 
users:
  merge: 
    deep 
  jill:
    uid: 1000
    home: '/home/jill'
  jack:
    uid: 1001
    home: '/home/jack'
on va donc utiliser la strategy de merge par defaut sur la clé users lors de l'appel lookup
[vagrant@client ~]$ puppet lookup users
---
jill:
  uid: 1000
  home: "/homes/jill"
jack:
  uid: 1001
  home: "/homes/jack"
jane:
  uid: 999
  home: "/homes/jane"

Il est toujours important d'utiliser la strategy de merge deep pour eviter d'avoir a se repéter et dupliquer des confs

== chapitre 12 : Modules 
Il est tout a fait possible de creer un module en entier. Cependant il y a de grande chances que quelqu'un ait dejà developper quelque chose de similaire.Il va donc être possible d'utiliser ded manière "intacte" le module et de l'utiliser comme point de départ de notre dveloppement.
Ou trouver des modules ?

-La forge puppet : 
https://forge.puppetlabs.com/.
Il est possible d'interet la forge via cli :
puppet module search apache
Notice: Searching https://forgeapi.puppetlabs.com ...
NAME
DESCRIPTION
puppetlabs-apache Installs, configures, and manages ... example42-apache
Puppet module for apache
...
On a cependant plus d'informations en browsant directement via http la forge.

- repos github public : 
Il est possible de trouver beaucoup de modules sur github (ceux ci peuvent aussi être présents sur la forge .ou pas licence, doc , mainteneur ...)

- Repo interne :
Il est tout a fait possible d'avoir un repo privé de module 
Dans ce cas on recherche notre module via cli : 
puppet module search --module_repository=http://forge.example.org/ apache
On peut si on utilise uniquement des modules internes configurés puppet pour qu'il selectionne toujours  cette source : 
puppet.conf 
[main]
module_repository = http://forge.example.org/

Evaluation des modules : sur la forge une note de la qualité du module (test de code etc..) est présente sur les modules : c'est un bon indicateur de la valeur du code.
On a aussi les modules supportés par la société puppet labs entreprise : ces modules sont de tres bonnes qualités mais ne s'adapte pas tres facilement et concernent des besoins basiques.
Modules puppet approved sont de tres bonne qualité et maintenus.
Community modules peuvent être egalement interressant.

- Installation de module :

On peut interroger la forgen notre repo interne ou recupérer le code directement du dev.

- forge : 

[vagrant@client ~]$ puppet module install puppetlabs-stdlib
Notice: Preparing to install into
/etc/puppetlabs/code/environments/production/modules ...
Notice: Downloading from https://forgeapi.puppetlabs.com ...
Notice: Installing -- do not interrupt ...
/etc/puppetlabs/code/environments/production/modules
└── puppetlabs-stdlib (v4.8.0).
 On voit ici que notre module est installé pour l'environment de production.
 Il est tout a fait possible pour le test de changer cet env.
 Ex: 
 [vagrant@client ~]$ puppet module install puppetlabs-stdlib --environment test
 Notice: Preparing to install into
 /etc/puppetlabs/code/environments/test/modules ...
 Notice: Downloading from https://forgeapi.puppetlabs.com ...
 Notice: Installing -- do not interrupt ...
 /etc/puppetlabs/code/environments/test/modules
 └── puppetlabs-stdlib (v4.8.0)

L'installation de module dans un env de test est la meilleure facon de le tester sans casser la production. Une fois qu'on veut l'utiliser en production, on peut
soit recommencer la manip avec un puppet module install soit copier notre module dans l'env de production:

$ cd /etc/puppetlabs/code/environments
$ mv test/modules/stdlib production/modules/

- Installation depuis github :

On doit installer git sur notre serveur :
[vagrant@client ~]$ sudo yum install -y git
...snip...
Installed:
git.x86_64 0:1.8.3.1-4.el7
Dependency Installed:
libgnome-keyring.x86_64 0:3.8.0-3.el7
perl-Git.noarch 0:1.8.3.1-4.el7
rsync.x86_64 0:3.0.9-15.el7
Complete!

puis faire un git clone dans  notre env :

$ cd /etc/puppetlabs/code/environments/test/modules
$ git clone https://github.com/jorhett/puppet-mcollective mcollective
Initialized empty Git repository in
/etc/puppetlabs/code/environments/test/modules/mcollective/.git/
remote: Counting objects: 183, done.
Receiving objects: 100% (183/183), 51.13 KiB, done.
remote: Total 183 (delta 0), reused 0 (delta 0), pack-reused 183
Resolving deltas: 100% (98/98), done.

- Test de module :
on devra suivre les instructions fournies sur le site du module.Souvent il faut :
-> déclarer la classe du module dans la definition du node
-> definir les clé de données de hiera dans le nom du module.

Exemple d'installation du module ntp en provenancede la forge : 
cd /etc/puppetlabs/code/environments/test/modules
[vagrant@client modules]$ sudo puppet module install --modulepath=. puppetlabs-ntp
Notice: Preparing to install into /etc/puppetlabs/code/environments/test/modules ...
Notice: Downloading from https://forgeapi.puppet.com ...
Notice: Installing -- do not interrupt ...
/etc/puppetlabs/code/environments/test/modules
└─┬ puppetlabs-ntp (v6.0.0)
  └── puppetlabs-stdlib (v4.15.0)
  [vagrant@client modules]$ 

on voit dans notre repertoire modules le module ntp et le stdlib : puppet install les dépendances de notre module en même temps.
En regardant la doc on voit que ce module peut fonctionner sans données en entrée : on peut donc le tester en appliquant la conf par defaut :
sudo puppet apply --environment test --execute 'include ntp'


[vagrant@client ~]$ sudo puppet apply --environment test --execute 'include ntp' 
Notice: Compiled catalog for client.example.com in environment test in 0.37 seconds
Notice: /Stage[main]/Ntp::Install/Package[ntp]/ensure: created
Notice: /Stage[main]/Ntp::Config/File[/etc/ntp.conf]/content: content changed '{md5}dc9e5754ad2bb6f6c32b954c04431d0a' to '{md5}57349f9b5d01bd6d1f9e548cba59b0a1'
Notice: /Stage[main]/Ntp::Config/File[/etc/ntp/step-tickers]/content: content changed '{md5}9b77b3b3eb41daf0b9abb8ed01c5499b' to '{md5}413c531d0533c4dba18b9acf7a29ad5d'
Notice: /Stage[main]/Ntp::Service/Service[ntp]/ensure: ensure changed 'stopped' to 'running'
Notice: Applied catalog in 7.70 seconds


comme on le voit le module a modifier la configuration et à démarrer le service.

-Definition de config avec hiera :
imaginons que nous voulions changer la conf de notre ntp et modifier la conf de base qui autorise l'acces au ntp uniquement depuis localhost en l'etendant à notre lan.
On va pour cela mofifier notre conf dans la partie common de hiera dans notre env de test.
En regardant la conf /doc du module on voit que la securité du module se fait via les modifications des paramètres restrict  et interfaces.

/!\ Pour fournir des données en entrée à un module on doit toujours nommer ces data : modulename::paramname 

on va donc commencer par définier kes sections restrict et interfaces  dans notre conf hiera :
[vagrant@client ~]$ sudo cat /etc/puppetlabs/code/hieradata/common.yaml
---
ntp::interfaces:
ntp::restrict:

On voit dans la doc que l'on doit renseigner ces paramètres avec des tableaux de  valeurs
on utilise donc la syntaxe dediée : 

[vagrant@client ~]$ sudo cat /etc/puppetlabs/code/hieradata/common.yaml
--
# Data for the puppetlabs NTP module
# which interfaces will accept connections
ntp::interfaces:
  - '127.0.0.1'
# which nodes can connect
ntp::restrict:
  - 'default kod nomodify notrap nopeer noquery'
  - '-6 default kod nomodify notrap nopeer noquery'
  - '127.0.0.1'
  - '-6 ::1'
  - '192.168.250.0/24'
  - '-6 fe80::'

on peut maintenant overrider notre conf pour le hostname dédié :

[vagrant@client ~]$ sudo cat /etc/puppetlabs/code/hieradata/hostname/client.yaml 
---
#Data for the puppetlabs NTP module which interfaces will accept connections
ntp::interfaces:
  - '127.0.0.1'
  - '192.168.0.250'

[vagrant@client ~]$ sudo puppet apply --environment test --execute 'include ntp'


[vagrant@client ~]$ sudo puppet apply --environment test --execute 'include ntp' 
Notice: Compiled catalog for client.example.com in environment test in 0.37 seconds
Notice: /Stage[main]/Ntp::Install/Package[ntp]/ensure: created
Notice: /Stage[main]/Ntp::Config/File[/etc/ntp.conf]/content: content changed '{md5}dc9e5754ad2bb6f6c32b954c04431d0a' to '{md5}57349f9b5d01bd6d1f9e548cba59b0a1'
Notice: /Stage[main]/Ntp::Config/File[/etc/ntp/step-tickers]/content: content changed '{md5}9b77b3b3eb41daf0b9abb8ed01c5499b' to '{md5}413c531d0533c4dba18b9acf7a29ad5d'
Notice: /Stage[main]/Ntp::Service/Service[ntp]/ensure: ensure changed 'stopped' to 'running'
Notice: Applied catalog in 7.70 seconds


On voit que puppet a modifier la conf et restarté le service.
De plus on voit que la conf uniquement pour notre client a été overrider et que les param globaux sont appliqués :

[vagrant@client ~]$ grep 192.168.250 /etc/ntp.conf
restrict 192.168.250.0/24
interface listen 192.168.250.10

[vagrant@client ~]$ grep listen /etc/ntp.conf
interface listen 127.0.0.1
interface listen 192.168.250.10

-Assignation de module à nos nodes :

La meilleure best pratice pour assigner une classe de module à notre node est de définir cette classe  dans hiera.
on peut bénéficier de la hierarchie pour customiser nos listes de classes : comme on a configurer un manifest pour chaque environment pour charger les classes de hiera :

[vagrant@client modules]$ cat ../manifests/site.pp
# Look up all classes defined in Hiera and other data sources
lookup('classes', Array[String], 'unique').include

on doit configurer tout nos environments pour assigner  les modules puppet à nos nodes.
pour le faire on doit déclarer un simple manifest portant n'importe quel nom ( auparavant il fallait que ce fichier se nomme site.pp)dans notre repertoire manifest 
ex : ici on va le faire dans notre env de test :

root@client test]# cat manifests/site.pp 
notify { 'UsingTest':
  message => "Processing catalog from the Test environment.",
  }
# Look up all classes defined in Hiera and other data sources
lookup('classes', Array[String], 'unique').include

Maintenant on va pouvoir assigner des classes en utilisant hiera data : 

- Assignation de classes à tous nos nodes :

Afin d'appliquer ce module à tous les nodes on va ajouter une conf dans le fichier common.yaml
on commence par insérer la clé "classes" puis la liste de nos classes ici notre module ntp ( on retrouve donc ce que parse la fonction lookup('classes'<= notre clé , Array[String], <= ici la liste ( tableau de module représenté en string : uniquement ntp , et unique ( on ne fait qu'une seule fois l'appel)

[root@client code]# cat hieradata/common.yaml
---
classes:
  - 'ntp'

cd /etc/puppetlabs/code/environments/test/modules 

on peut tester la bonne prise en compte en arretant le service ntp pour bienvoir que le module est bien appliqué avec la conf hiera
[root@client manifests]# systemctl stop ntpd 

[root@client modules]# sudo puppet apply --environment test ../manifests/
Notice: Compiled catalog for client.example.com in environment test in 0.36 seconds
Notice: Processing catalog from the Test environment.
Notice: /Stage[main]/Main/Notify[UsingTest]/message: defined 'message' as 'Processing catalog from the Test environment.'
Notice: /Stage[main]/Ntp::Service/Service[ntp]/ensure: ensure changed 'stopped' to 'running'
Notice: Applied catalog in 0.17 seconds


- Modification de la list des classes par nodes :
on peut par exemple vouloir installer le ntp sur tout notre parc machinne mais n'installer puppet agent que sur les nodes et puppetserver sur le server puppet.
/etc/puppetlabs/code/hieradata/common.yaml 
---
classes:
  - 'ntp'
    - puppet::agent
on va creer un fichier dedié pour le server qui contiendra notre conf :
[root@client ~]# cat  /etc/puppetlabs/code/hieradata/puppetserver.yaml
---
classes:
  - ntp
  - puppet::server

L'assignement de classe se fait toujours dans un ordre de merge de tableau donc toutes les valeurs dans le tableau des classes seront mergées ensemble pour chaque niveau de hierarchie.

La possibilité d'examiner les classes depuis les données est une avancée majeure dans puppet4 via hiera :
ex : 
classes:
- apache

apache::modules:
- passenger

- Examen de module :
il est capital de s'assurer de la bonne qualité du module. Certains points sont essentiels :
-> support de l'os
-> namespace module : il est possible d'avoir des dependances de noms de modules que le module que nous utilisons.
-> environments : permettre d'avoir un fonctionnement normal dans differents environments.
-> code : peut overrider des variables globales.
-> ressource namespace peut utiliser des noms de ressources en conflit avec certaines que l'on a dejà nommées.
-> collecteurs gournmands : des collecteurs peuvent traiter accidentellement des données non reliées 

Ces précautions sont aussi à prendre si on veut creer nos propres modules.


=== chapitre 13  : customization / design de modules : 

- choix du nom :
le nom de notre module ne doit pas commencer par un chiffrer ni contenir de "-".
il est important d'eviter les conflits avec d'autres modules. Chacun crée  son namespace dédié et le catalogue puppet ne doit avoir qu'un seul module identifié par un nom a chaque fois.On ne peut donc JAMAIS utiliser deux modules du même nom.
Il peut être judicieux de regarder d'abord le noms des modules de laforge puppet pour ne pas créer de module dont le nom existe déjà chez puppet pour eviter de potentiel probleme de dépendance .
Il y a toute une serie de nom réservés :

main           This class contains any resources not contained by any other class.
facts          This namespace contains facts provided by the node’s Puppet agent.
server_facts   This namespace contains server-side facts supplied by the Puppet server.
settings       This namespace contains the Puppet configuration settings.
trusted        This namespace contains facts taken from the client’s certificate, as signed by the Puppet certificate  authority.

- generation du squelette de module :
une commande se charge de cette opération : module generate.on doit préciser dans un premier temps le user qui crée le module suivi d'un tiret et le nom du module 
ex :  on peut laisser les reponses par défaut :

[vagrant@client ~]$ puppet module generate boogie-boogieland
We need to create a metadata.json file for this module.  Please answer the
following questions; if the question is not applicable to this module, feel free
to leave it blank.

Puppet uses Semantic Versioning (semver.org) to version modules.
What version is this module?  [0.1.0]
--> 

Who wrote this module?  [boogie]
--> 

What license does this module code fall under?  [Apache-2.0]
--> 

How would you describe this module in a single sentence?
--> 

Where is this module's source code repository?
--> 

Where can others go to learn more about this module?
--> 

Where can others go to file issues about this module?
--> 

----------------------------------------
{
"name": "boogie-boogieland",
"version": "0.1.0",
"author": "boogie",
"summary": null,
"license": "Apache-2.0",
"source": "",
"project_page": null,
"issues_url": null,
"dependencies": [
   {"name":"puppetlabs-stdlib","version_requirement":">= 1.0.0"}
   ],
 "data_provider": null
 }
----------------------------------------
About to generate this metadata; continue? [n/Y]
--> Y
Notice: Generating module at /home/vagrant/boogieland...
Notice: Populating templates...
Finished; module generated in boogieland.
module/Gemfile
module/Rakefile
module/examples
module/examples/init.pp
module/manifests
module/manifests/init.pp
module/spec
module/spec/classes
module/spec/classes/init_spec.rb
module/spec/spec_helper.rb
module/README.md
module/metadata.json

on peut choisir de répondre au questions plus tard en lancant la commande avec l'option --skip-interview
on a donc notre module crée dans l'arbo ou on se trouve : 

[vagrant@client ~]$ pwd
/home/vagrant
[vagrant@client ~]$ ls
boogieland  manifests
et le detail de notre module : 
[vagrant@client ~]$ tree boogieland/
boogieland/
├── examples
│   └── init.pp
├── Gemfile
├── manifests
│   └── init.pp
├── metadata.json
├── Rakefile
├── README.md
└── spec
    ├── classes
        │   └── init_spec.rb
            └── spec_helper.rb

            4 directories, 8 files



- Modification du squelette par defaut :

on peut vouloir modifier l'arbo de notre module par défaut : dans ce cas on peut copier notre skel dans un repertoire dédié à creer si besoin :
dans le homedir de notre user on a un rerpertoire caché puppetlabs et une arbo à suivre : 
~/.puppetlabs/opt/puppet/cache/puppet-module/skeleton

on peut aussi voiloir recupérer de meillleurs skel ( plus de tests etc..) qu'on retrouve facilement sur github par exemple.
on peut aussi avoir plusieurs skel de notre choix et creeer un module utilisant un skel particulier : ex :
puppet module --module_skeleton_dir=~/skels/rails-app generate myorg-railsapp

- Structure du module :

ces arbo sont des pre-requi imperatif que puppet attend pour son fonctionnement :

manifests/ Directory where code manifests (classes) are read.
files/     Directory containing files served by your module.
templates/ Directory containing templates parsed for custom files.
lib/       Directory containing Ruby facts or functions.
specs/     Directory containing unit tests to validate the manifests.
tests/     Directory containing system tests to validate the manifests.
facts.d/   Directory containing external facts to be distributed.
metadata.json  File containing version and module dependencies.

- Installation du module :
pour tester un module on va devoir le placer dans un endroit ou puppet pourra le trouver :
quand on developpe un module le plus simple est de le deplacer dans un environment de test : $modulepath de test :
 [vagrant@client ~]$ cd /etc/puppetlabs/code/environments/test/modules
 [vagrant@client modules]$ sudo mv ~/boogieland/ .
Maintenant que notre module est en place on va rajouter une classe dans le server de test pour tester ce nouveau module :
[vagrant@client code]$ sudo cat hieradata/hostname/client.yaml 
---
classes:
  - boogieland
maintenant quand on test notre node la classe de notre nouveau module sera inclue : cela nous permet de tester de maniere secu un nouveau module.


pour la suite on crée un module puppet 
[vagrant@client]$ sudo puppet module generate boogie-puppet
et on le déplace dans l'arbo de notre env de test 
/etc/puppetlabs/code/environments/test/modules/puppet

on renseigne la classe dans notre node de test : 
[vagrant@client code]$ head hieradata/hostname/client.yaml
---
classes:
  - puppet



- creation de la classe manifest :
on va trouver dans notre module un fichier manifest de type init.pp :
/etc/puppetlabs/code/environments/test/modules/puppet/manifests
le présence de ce fichier est impérative et il doit contenir la définition de classe de base 
cette classe de base est une classe portant le même nom que notre module.
[vagrant@client manifests]$ cat  init.pp 
# Class: puppet
# ===========================
#
# Full description of class puppet here.
#
# Parameters
# ----------
#
# Document parameters here.
#
# * `sample parameter`
# Explanation of what this parameter affects and what it defaults to.
# e.g. "Specify one or more upstream ntp servers as an array."
#
# Variables
# ----------
#
# Here you should define a list of variables that this module would require.
#
# * `sample variable`
#  Explanation of how this variable affects the function of this class and if
#  it has a default. e.g. "The parameter enc_ntp_servers must be set by the
#  External Node Classifier as a comma separated list of hostnames." (Note,
#  global variables should be avoided in favor of class parameters as
#  of Puppet 2.6.)
#
# Examples
# --------
#
# @example
#    class { 'puppet':
#      servers => [ 'pool.ntp.org', 'ntp.local.company.com' ],
#    }
#
# Authors
# -------
#
# Author Name <author@domain.com>
#
# Copyright
# ---------
#
# Copyright 2017 Your name here, unless otherwise noted.
#
class puppet {


}

actuellement cette classe n'a pas de définition : elle est vide mais elle existe et ne fait rien . on voit egalement qu'il y a tout un template de définition de definition de  classe.

- Qu'est ce qu'une classe ?

pour rappel 
un manifest utilise le language de puppet pour des déclarations de configuration
un manifest contient des ressources qui décrivent l'etat de la configuration attendue de nodes
un manifest s'execute toute de suite apres l'execution de la commande puppet apply

une classe :
est un manifest avec certaines propriétés.on utilise aussi le language puppet pour créer une classe .

A class is a manifest that can be called by name.
A class has a namespace or variable scope of the same name.
A class is not used until called by name.
A class may include or be included by other modules.
A class may be passed parameters when called.




Declaration de ressources de classes :

class puppet {
# Install the Puppet agent
  package { 'puppet-agent':
    ensure => 'latest',
    notify => Service['puppet'],
  }
# Manage the Puppet service
  service { 'puppet':
    ensure  => 'running',
    enable  => true,
    subscribe => Package['puppet-agent'],
  }
}

on test notre conf :
[root@client manifests]# puppet apply --environment test ../manifests/
Notice: Compiled catalog for client.example.com in environment test in 0.03 seconds
Notice: Applied catalog in 0.02 seconds

- Authoriser les inputs :
on va maintenant ajuster notre manifest en y ajoutant des paramètres 


class puppet {

class puppet(
    #input parameters and default values for the class
    $version = 'latest',
    $status = 'running',
    $enabled , # required parameter
) {
    # echo the input provided
    notice("Install the $version version of Puppet,
    ensure it's $status, and set boot time start $enabled.")

}

Ici on va passer plusieurs paramètres à notre run : deux ont des valeurs par defaut qui ne seront chargées QUE si aucune entrée ne sera loadée quand la classe est chargée . La troisieme valeur du param n'est pas fournie et on va avoir une erreur lors de notre run.

Puppet à partir de la version 4.3 embargue une fonction très puissante lookup qui va permettre aux classes de recevoir des paramètresi en entrées  de trois façons différentes.
Si les data ne sont pas disponible dans le premier cas ,puppet passe au suivant etc dans un ordre précis : 

-> les paramètres de classes peuvent être explicitement passés quand la classe est déclarée.
on peut definir des parametres à passer quand on defini la classe dans le manifest ou la sortie d'un external node classifier.
Utiliser la déclaration de ressources dans les manifests etait la seule méthode possible avant les data lookup depuis hiera.
-> les valeurs de paramètres vont être récupérées des data providers (hiera, environment,module) : c'est la methode la plus pratique pour assigner des valeurs . LA clé va être cherchée dans le provider global de data (hiera) suivi par le provider de data de l'environement puis celui des modules. La valeur de la premiere data source sera retournée.
-> les valeurs par defaut peuvent être déclarées dans definitions de classe. Les bonnes pratiques puppet encourage l'utilisation de valeur par defaut avec des valeurs fournissant le cas global le plus général.


on voit donc que dans le manifest global de notre env de test site.pp , on 
attends de parser les classes, avec ensuite un tableau contenant des strings , de valeur uniques :
[root@client environments]# cat test/manifests/site.pp 
notify { 'UsingTest':
  message => "Processing catalog from the Test environment.",
  }

  # Look up all classes defined in Hiera and other data sources
  lookup('classes', Array[String], 'unique').include
on voit que notre node dédié possède la conf hiera suivante :

[root@client code]# cat hieradata/hostname/client.yaml 
---
classes:
  - testo
    - puppet

on retrouve donc les classes , alignées en tableau sous forme de strings


on peut pour voir le cheminement definir des Integer attendus dans notre tableau :
[root@client code]# cat environments/test/manifests/site.pp 
notify { 'UsingTest':
  message => "Processing catalog from the Test environment.",
  }

  # Look up all classes defined in Hiera and other data sources
  lookup('classes', Array[Integer], 'unique').include

en lancant notre  run on aura une erreur de typage : 

[root@client code]# puppet apply --environment test environments/test/manifests/
Error: Evaluation Error: Error while evaluating a Function Call,  Found value has wrong type, index 0 expects an Integer value, got String
  Found value has wrong type, index 1 expects an Integer value, got String at /etc/puppetlabs/code/environments/test/manifests/site.pp:6:1 on node client.example.com


on test et on voit l'erreur en invoquant le manifest principal de notre environment site.pp  


[root@client code]# puppet apply --environment test environments/test/manifests/
Notice: Scope(Class[Testo]): Install the lapin version of Puppet,
    ensure it's yopyop, and set boot time start ohyeah.
    Error: Evaluation Error: Error while evaluating a Method call, Class[Puppet]: expects a value for parameter 'enabled' at /etc/puppetlabs/code/environments/test/manifests/site.pp:6:43 on node client.example.com

On voit ici que l'on attend une valeur pour le parametre enabled : on va donc modifier notre manifest de sorte que notre param prenne une valeur par défaut : 

class puppet(
    #input parameters and default values for the class
    $version = 'latest',
    $status = 'stopped',
    $enabled  = true, # required parameter
                )


on peut donc lancer notre run qui se déroule maintenant sans souci avec nos valeurs de parametres interprétées : 

[root@client code]# puppet apply --environment test environments/test/manifests/
Notice: Scope(Class[Puppet]): Install the latest version of Puppet,
ensure it's stopped, and set boot time start true.
Notice: Compiled catalog for client.example.com in environment test in 0.37 seconds
Notice: Processing catalog from the Test environment.
Notice: /Stage[main]/Main/Notify[UsingTest]/message: defined 'message' as 'Processing catalog from the Test environment.'
Notice: Applied catalog in 0.11 seconds


- Partage de fichiers :
on va ajouter un fichier car bien souvent l'intallation d'appli et le démarrage de service ne suffit pas.
Les fichiers de puppet doivent toujours être stocker dans un repertoire files à l'interrieur de  notre module.
On peut ajouter des sous repertoires pour gérer nos fichiers.
Pour le test on va copier le fichier puppet.conf de notre install dans le repertoire files du module puppet de test dans notre env test , en y modifiant le log level :
[root@client code]# cd environments/test/modules/puppet/
[root@client puppet]# mkdir files 
[root@client puppet]# cd files/
[root@client files]# cp /etc/puppetlabs/puppet/puppet.conf .
[root@client files]# vi puppet.conf 
[main]
log_level = notice

on va maintenant ajouter ce fichier en tant que ressource dans la classe de notre manifest, à la place d'utiliser l'attribut content on utilise cette fois l'attribut source : les fichiers qvec ces attributs sont copiés de manière intacte 

[root@client manifests]# cat init.pp 
class puppet(
#input parameters and default values for the class
  $version = 'latest',
  $status = 'stopped',
  $enabled  = true, # required parameter
  ) {
    # echo the input provided
notice("Install the $version version of Puppet,ensure it's $status, and set boot time start $enabled.")
    }

file { '/etc/puppetlabs/puppet/puppet.conf':
  ensure => file,
  owner => 'root',
  group => 'wheel',
  mode  => '0644',
  source => 'puppet:///modules/puppet/puppet.conf',
}

Il y a  trois uri valides pour spécifier un fichier :

• puppet:///modules/module_name/filename
• file:///path/to/file/on/local/system
• http: or https://web-server/filename (new in Puppet 4.4)

Le download de fichier via http/https fonctionne bien si l'on fix cet attribut dans la ressource fichier 

La meilleure paratique est de toujours stocker les  fichiers utilisés par les modules dans les modules eux  même et d'utiliser la syntaxe puppet:/// comme pattern d'uri
Si on laisse l'url du server vide alors les fichiers seront downloadés depuis le server puppet avec lequel notre client communique.

Il est mieux de na pas specifier le nom d'un server puppet pour recupérer les  fichiers : car en cas de pbs reseau / comm ..les run ne passeront pas .Il est plus judicieux de synchroniser nos fichiers.

NB: on peut utiliser un tableau de fichier : puppet prendra le premier qui match dans la liste.
Il est possible de sourcer des fichiers qui ne sont pas inclus dans le module mais ce n'est pas recommandé.


 on va donc tester notre run :
on examine notre fichier avant le run .. 
[root@client puppet]# ll
total 24
-rw-r--r-- 1 root    root    4449  6 déc.  00:17 auth.conf
-rw-r--r-- 1 root    root     371  6 déc.  00:17 hiera.yaml
-rw-r--r-- 1 root    root     600 25 janv. 18:53 puppet.conf
-rw-r--r-- 1 vagrant root     463  6 déc.  00:17 puppet.conf.rpmnew
-rw-r--r-- 1 vagrant vagrant 1109  9 janv. 17:19 puppet.conf.rpmsave
drwxrwx--x 7 root    root      96  9 janv. 17:31 ssl

on lance le run : 

 [root@client code]# puppet apply --environment test environments/test/manifests/
 Notice: Scope(Class[Puppet]): Install the latest version of Puppet,
     ensure it's stopped, and set boot time start true.
     Notice: Compiled catalog for client.example.com in environment test in 0.40 seconds
     Notice: Processing catalog from the Test and blabla compagny environment.
     Notice: /Stage[main]/Main/Notify[UsingTest]/message: defined 'message' as 'Processing catalog from the Test and blabla compagny environment.'
     Notice: /Stage[main]/Puppet/File[/etc/puppetlabs/puppet/puppet.conf]/content: content changed '{md5}74d8e328cc5b72bb981be26c4c5c1ad1' to '{md5}138206adc14ea6d17dc362d249756d06'
     Notice: /Stage[main]/Puppet/File[/etc/puppetlabs/puppet/puppet.conf]/group: group changed 'root' to 'wheel'
     Notice: Applied catalog in 0.30 seconds

on voit ici que le fichier a bien été poussé : les droits ont bien été modifiés :
[root@client code]# ll /etc/puppetlabs/puppet/puppet.conf
-rw-r--r-- 1 root wheel 620  8 févr. 18:37 /etc/puppetlabs/puppet/puppet.conf

on peut vouloir changer les droits , modifier notre manifest ou bien même lancer une restauration du fichier avec filebucket :

on peut récupérer la liste des fichiers et chercher le notre 
[root@client environments]# puppet filebucket -l list |grep puppet.conf
et lancer la restauration de notre fichier en saisisant le hash cible trouvé dans notre liste.
sudo puppet restore  /etc/puppetlabs/puppet/puppet.conf c15ae72acdbd8878a6550275bc


- synchronisation de fichiers :
Nous pouvons synchroniser en mode recursif et des attributs permettent egalement une purge :

file { '/tmp/sync/':
  ensure  => directory,
  owner   => 'root',
  group   => 'wheel',
  mode    => '0444',
  recurse => true, # go into subdirectories
  replace => true, # replace any files that already exist
  purge   => false, # don't remove files that we don't have
  links   => follow, # follow symbolic links and modify the link target
  force   => false,
source    => 'puppet:///modules/puppet/sync/',
}

on peut donc lancer notre run apres avoir créer une petite arbo cible :
[root@client code]# mkdir -p environments/test/modules/puppet/files/{sync,lapin}

[root@client code]# puppet apply --environment test environments/test/manifests/
Notice: Scope(Class[Puppet]): Install the latest version of Puppet,
    ensure it's stopped, and set boot time start true.
    Notice: Compiled catalog for client.example.com in environment test in 0.36 seconds
    Notice: Processing catalog from the Test and blabla compagny environment.
    Notice: /Stage[main]/Main/Notify[UsingTest]/message: defined 'message' as 'Processing catalog from the Test and blabla compagny environment.'
    Notice: /Stage[main]/Puppet/File[/tmp/sync/]/ensure: created
    Notice: Applied catalog in 0.14 seconds
Attention puppet n'est pas du tout adapté à la synchro de gros fichiers ou de grosses  arbo .


- Parsing  de template : 

Comme aucun systeme ne va contenir les memes infos on va pouvoir créer des modeles : des templates  qui pourront être réutilisés.
Ces  modèles dans puppet doivent être stocker dans un repertoire se nommant template.
On va créer un template qui va initialiser quatres variables.
Modifions dans un premier temps le manifest de notre module en y rajoutant nos variables : 
 
environments/test/modules/puppet/manifests/init.pp
class puppet( 
    $version = 'latest',
    $status = 'stopped',
    $enabled  = true, # required parameter
    $server = 'puppet.example.com',
    $common_loglevel = 'warning', 
    $agent_loglevel = undef,
    $apply_loglevel = undef,
) {

Avec cette déclaration on a desormais 7 parametres dans notre classe que l'on va pouvoir mettre dans un template 
On a setté ici deux parametres avec des valeurs à undef : on ne va utiliser ces valeurs que quand la classe est déclarée : si on ne met aucune valeur alors une valeur sera impérativement à fournir ce qui n'est pas ce que nous souhaitons.

Il y a deux parsers puppet :
-> EPP : embedded puppet parser : utilise des variables et des fonctions puppet.
-> ERB : embeded ruby parser : utilise le language ruby et ses fonctions.

- Syntaxe commune :

chacun de ces modeles sont des fichiers textes qui contiennent de la syntaxe commune et des tags de templates.
A l'exterrieur de ces tags le  texte n'est pas interprété.
A l'interrieur de ces tags on a du code puppet ou ruby.

<%= variable or code %>   This tag is replaced with the value of the variable, or result of the code.
<% code block %>          The code is executed. Nothing is returned unless the code prints output.
<%# a comment %>          This tag is removed from the output.
<% code block -%>         Immediately trailing newlines or whitespace is removed. Use to prevent blank lines.

<%- code block %>         Leading newlines or whitespace is removed. Use when indenting template tags.
<%= variable or code -%>  Removes trailing whitespace after the result of the code. (There is no option for trimming leading whitespace.)
<%%  %%>                  Double percent signs are replaced with a single percent sign. Use to prevent interpolation.                         

- EPP : puppet template :

on va utiliser notre fichier précedent pour alimenter notre fichier de conf puppet.conf :

file { '/etc/puppetlabs/puppet/puppet.conf':
  ensure => ensure,
  owner  => 'root',
  group  => 'wheel',
  mode   => '0644',
  content => epp('puppet/puppet.conf.epp'),
}

la fonction epp() prend deux arguments :
-> l'uri du template puppet : la syntaxe est toujours la même : puppet:///module/template.epp
ce fichier doit être placé dans le repertoire templates du module et doit impérativement porter l'extension ".epp"
-> doit comporter un hash de parametres en entrées.

on va maintenant créer un template après avoir créer un repertoire templates :

[root@client puppet]# cat templates/puppet.conf.epp 

# Generated by Puppet EPP template processor
[master]
log_level = <%= $::puppet::common_loglevel %>

# This is used by "puppet agent"
[agent]
<% if $puppet::agent_loglevel != undef { -%>
log_level = <%= $::puppet::agent_loglevel %>
<% } -%>
server = <%= $::puppet::server %>

# This is used for "puppet apply"
[user]
<% if $puppet::apply_loglevel != undef { -%>
log_level = <%= $::puppet::apply_loglevel %>
<% } -%>


on a donc 4 déclarations de variables, chaque instance <%= $::class::variable %> est remplacée par la valeur  donnée dans les parametres de notre manifest.

Quand on passe notre run on voit bien que le template est utilisé pour pousser la conf et les variables définies dans le template et récupérées depuis notre manifest sont bel et bien intégrées :



[root@client code]# puppet apply --environment test environments/test/manifests/
Notice: Scope(Class[Puppet]): Install the latest version of Puppet,
    ensure it's stopped, and set boot time start true.
    Notice: Compiled catalog for client.example.com in environment test in 0.37 seconds
    Notice: Processing catalog from the Test and blabla compagny environment.
    Notice: /Stage[main]/Main/Notify[UsingTest]/message: defined 'message' as 'Processing catalog from the Test and blabla compagny environment.'
    Notice: /Stage[main]/Puppet/File[/etc/puppetlabs/puppet/puppet.conf]/content: content changed '{md5}eb40cdd7e1297edd5605615d837cbd59' to '{md5}138206adc14ea6d17dc362d249756d06'
    Notice: Applied catalog in 0.18 seconds
    [root@client code]# cat /etc/puppetlabs/puppet/puppet.conf
    # This file can be used to override the default puppet settings.
    # See the following links for more details on what settings are available:
    # - https://docs.puppetlabs.com/puppet/latest/reference/config_important_settings.html
    # - https://docs.puppetlabs.com/puppet/latest/reference/config_about_settings.html
    # - https://docs.puppetlabs.com/puppet/latest/reference/config_file_main.html
    # - https://docs.puppetlabs.com/puppet/latest/reference/configuration.html
    [main]
    # these are both default values
    environmentpath = /etc/puppetlabs/code/environments
    basemodulepath = /etc/puppetlabs/code/modules
    log_level = notice

Les templates EPP peuvent faire beaucoup plus que récupérer les variables de notre manifest.On peut mettre n'importe quel code puppet entre <% ... %>
ex de bloc avec des conditions pour limiter la duplication de conf pour les sections ayant le même log level :

[user]
<% if $::puppet::apply_loglevel != undef and
$::puppet::apply_loglevel != $::puppet::common_loglevel { -%>
log_level = <%= $::puppet::apply_loglevel %>
<% } -%>

En placant le if dans le bloc on est sur d'avoir une sortie si les deux conditions match et donc on est sur de ne pas avoir a refefinir la conf au cas ou on tombe dans le log level principal de notre conf.

- Provisionning de parametres :

On a vu qu'il pouvait être fastidueux de devoir fournir toute les différentes variable. Il est cependant possible de simplifier cette tache en modifiant le nommage et en fournissant un hash associé au nom de notre variable que l'on va alimenter dans notre template.

C'est particulierement pratique pour les variables de puppet ne matchant pas le nom des variables utilisées dans les templates.
Exemple : dans notre manifest : 

content => epp('puppet:///puppet/puppet.conf.epp', {
  'server'          => $server,
  'common_loglevel'=> $common_loglevel,
  'agent_loglevel' => $agent_loglevel,
  'apply_loglevel' => $apply_loglevel,
}),


Quand on alimente les parametres d'entrées, on doit s'assurer que la prmeiere ligne de template doit contenir une syntaxe particuliere :


<%- | String $server,
String $common_loglevel,
Optional['String'] $agent_loglevel = undef,
Optional['String'] $apply_loglevel = undef,
| -%>


Les données en entrée correspondant exactement aux valeurs dans l'assignement de notre manifest
dans lequel le valeurs de server et common_loglevel sont définis alors que les valeurs de agent_loglevel et apply_loglevel sont optionnelles.

Le hash des valeur passées à un template doivent correspondre à la definition du template au tout début du fichier sinon on systematiquement des erreurs .

Best practice : toujours placer les parametres que l'on va utiliser dans un template en debut de fichier et toujours les  envoyer explicitement au template : cela assure une bien meilleure lisibilité.


On a donc notre template défini de la sorte : 

<%- | String $server,
  String $common_loglevel,
  Optional['String'] $agent_loglevel = undef,
  Optional['String'] $apply_loglevel = undef,
| -%>


# Generated by Puppet EPP template processor - pushed by puppet
[master]
log_level = <%= $::puppet::common_loglevel %>

# This is used by "puppet agent"
[agent]
<% if $puppet::agent_loglevel != undef { -%>
log_level = <%= $::puppet::agent_loglevel %>
<% } -%>
server = <%= $::puppet::server %>

# This is used for "puppet apply"
[user]
<% if $puppet::apply_loglevel != undef { -%>
log_level = <%= $::puppet::apply_loglevel %>
<% } -%>


Notre  run passe sans souci :

[root@client ~]# view /etc/puppetlabs/code/environments/test/modules/puppet/templates/puppet.conf.epp 
[root@client ~]# puppet apply --environment test /etc/puppetlabs/code/environments/test/manifests/
Notice: Scope(Class[Puppet]): Install the latest version of Puppet,
    ensure it's stopped, and set boot time start true.
Notice: Compiled catalog for client.example.com in environment test in 0.37 seconds
Notice: Processing catalog from the Test and blabla compagny environment.
Notice: /Stage[main]/Main/Notify[UsingTest]/message: defined 'message' as 'Processing catalog from the Test and blabla compagny environment.'
Notice: /Stage[main]/Puppet/File[/etc/puppetlabs/puppet/puppet.conf]/content: content changed '{md5}719a4016fdb7dd75f4fd2c24005d2874' to '{md5}9e7961f714c09dfaff7cd9a712f5e7b8'
Notice: Applied catalog in 0.16 seconds


- Boucle /iteration de valeur dans notre template epp :

On peut utiliser n'importe quelle fonction dans les tag du template. L'opération de tres loin la plus effectuée est la boucle : itération.
ici on peut voir un exemple de boucle qui va utiliser la fonction reduce pour parser les éléments d"un tableau pour limiter l'application de ressources ; on utilise sprintf pour afficher 
les valeur remontées entre , .

[agent]
tags = <%= $taglist.reduce |$tags,$tagname| {
sprintf("%s,%s", $tags, $tagname)
} -%>

Ces templates sont  uniquement présents depuis la version 4 de puppet :
doc sur les modules epp : 
https://docs.puppet.com/puppet/latest/function.html#epp


- Utilisation des templates ruby ERB :
ces templates sont nécéssaires pour des raisons de retrocompatibilité.
on va modifier notre manifest init.pp pour maintenant renseigner la conf avec un template erb :

    file { '/etc/puppetlabs/puppet/puppet.conf':
    ensure => file,
    owner => 'root',
    group => 'wheel',
    mode  => '0644',
    content  => template('puppet/puppet.conf.erb'), 

la fonction template prend un argument l'uri du template.

Nous allons maintenant créer notre template erb :
Ce template doit également être placé dans le repertoire templates et doit porter comme extension .erb 
On va comme pour les epp , utiliser les valeurs des  variables puppet pour customiser le fichier. 
chaque instance de <%= @variable %>  est remplacé par la valeur de la variable puppet après le @ . Contrairement au template epp il n'y a pas de liste prédéfinie de variables pour les templates.
Les variables accedées avec le prefix @ DOIVENT être dans le même scope de variable ( aka classe module ) dans la déclaration de template.


[root@client code]# cat  environments/test/modules/puppet/templates/puppet.conf.erb
# Generated by Puppet ERB template processor
[main]
log_level = <%= @common_loglevel %>
# This is used by "puppet agent"
[agent]
<% if @agent_loglevel -%>
log_level = <%= @agent_loglevel %>
<% end -%>
server = <%= @server -%>
# This is used for "puppet apply"
[user]
<% if @apply_loglevel -%>
log_level = <%= @apply_loglevel %>
<% end -%>


On a donc un manifest epuré des param dédié au template epp et un tempate comme suivant :


[root@client puppet]# cat manifests/init.pp 
class puppet(
    #input parameters and default values for the class
    $version = 'latest',
    $status = 'stopped',
    $enabled  = true, # required parameter
    $server = 'puppet.example.com',
    $common_loglevel = 'warning', 
    $agent_loglevel = undef,
    $apply_loglevel = undef,
)   
	{
     		       
                # echo the input provided
               notice("Install the $version version of Puppet on === $server === ensure it's $status, and set boot time start $enabled. \n") 
                   
#    notify { 'test':
#    message => "hello ?",
#    }

    file { '/etc/puppetlabs/puppet/puppet.conf':
    ensure => file,
    owner => 'root',
    group => 'wheel',
    mode  => '0644',
    content  => template('puppet/puppet.conf.erb'),
   }
}


[root@client templates]# cat puppet.conf.erb 
# Generated by Puppet ERB template processor - ruby templating 
# erb 
[main]
log_level = <%= @common_loglevel %>
# This is used by "puppet agent"
[agent]
<% if @agent_loglevel -%>
log_level = <%= @agent_loglevel %>
<% end -%>
server = <%= @server -%>
# This is used for "puppet apply"
[user]
<% if @apply_loglevel -%>
log_level = <%= @apply_loglevel %>
<% end -%>


quand on passe notre run pas de souci :

[root@client code]# puppet apply --environment test environments/test/manifests/
Notice: Scope(Class[Puppet]): Install the latest version of Puppet on === puppet.example.com === ensure it's stopped, and set boot time start true. 

Notice: Compiled catalog for client.example.com in environment test in 0.38 seconds
Notice: Processing catalog from = test =  environment.
Notice: /Stage[main]/Main/Notify[UsingTest]/message: defined 'message' as 'Processing catalog from = test =  environment.'
Notice: /Stage[main]/Puppet/File[/etc/puppetlabs/puppet/puppet.conf]/content: content changed '{md5}9e7961f714c09dfaff7cd9a712f5e7b8' to '{md5}f0ce872f5c4a4b40bcaf350aa9031e5b'
Notice: Applied catalog in 0.12 seconds

Notre fichier de conf est donc maintenant le suivant : 
[root@client code]# cat /etc/puppetlabs/puppet/puppet.conf
# Generated by Puppet ERB template processor - ruby templating 
# erb 
[main]
log_level = warning
# This is used by "puppet agent"
[agent]
server = puppet.example.com# This is used for "puppet apply"
[user]



Il est possible d'effectuer un lookup d'une autre classe ( en utilisant la fonction scope.lookup() ou scope[]  sous forme de hash .
exemple : examen du log level de mcollective avec la fonction scope.lokup() et scope[] :

loglevel = <%= scope.lookupvar('mcollective::loglevel') -%>
loglevel = <%= scope['::mcollective::loglevel'] -%>

Il est FORTEMENT recommandé de ne pas interroger  les scopes d'autre classe au sein de notre template : ne pas recupérer les data d'autre module dans notre template .
Il faut dans ce cas recupérer les data depuis un manifest et présenter les données au template en lui fournissant par l'intermédiaire de variables.

Il est possible d'utiliser des fonctions puppet grace à la fonction scope.function.puppet_function() 
exemple générer un numéro depuis le fqdn de notre serveur : 
server = <%= scope.function_fqdn_rand( 3600 ) -%>

Attention il est possible de devoir saisir les param passés à notre fonction entre crochet comme pour un tableau :

this is it  <%= scope.function_fqdn_rand( [3600] ) -%>

Il est tout a fait possible de passer du code ruby entre les balises de templates : <%= Code %> . l'utilisation du signe "=" n'est pas obligatoire.

- Iteration dans un template ERB :
on va utiliser la fonction ruby each() pour itérer.
ex : on defini une liste dans notre manifest et on affiche les elements de celle ci dans notre template : attention exemple sans aucun interet excepter voir un mottif de boucle :

class testo (
    $yop = 'lapin',
    $yap = 'yopyop',
    $yup = 'allo?',
    $lst= [0, 1, 2, 3, 4, 5],
)

"environments/test/modules/testo/templates/testo.erb

<%= @lst.each do |i|
  puts(i)
end
%>

On note qu'il n'y a pas ici l'utilisation de @ pour la variable puisqu'on ne boucle qu'en local dans notre bloc de code et ce n'est pas un appel d'une variable du code puppet.

exemple de template erb :
appel de variable defini dans manifest
appel de variable issue d'un autre scope module
appel de variable apres passage de fonction
boucle sur un element passé dans manifest :

lulu =  <%= @yop %>
server = <%= scope['::puppet::server']-%>
this is it  <%= scope.function_fqdn_rand( [3600] ) -%>

<%= @lst.each do |i|
  sprintf( "%i", i)
end
%>
doc sur template ERB :

http://bit.ly/1SYDfct


- Ecriture de templates lisibles :

On note que par moment les blocs de templates utilisent : <%= %> ou <%= -%> : cette derniere ecriture supprime le retour chariot de notre code 
c'est regulierement utilisé pour ne pas ajouter de ligne blanche automatiquement ou concatener du code.

Best practice : il est important d'utiliser le code puppet dans les templates epp et dans les manifesets. Il est important de specifier les param pour être clair.


= Test de module :

- examun de variables et ressources d'autres classes
Nb: ces techniques sont à utiliser juste à des fins de debug ( à proscrire en production.)

Les environmments sont strcits et cloisonnées : on ne peut pas voir les données et le code différentes à notre environment loadé.
Par contre au sein du même environment on peut examiner les ressources et variables d'autres classes.

exemple pour illuster le fait que l'on récupere bien les variables d'autres classes : 

[root@client code]# cat /vagrant/manifests/peek.pp 
class other_class( String $idea ) {
  $sentence = "an idea: ${idea}"
  notify { 'announcement': message => "I have ${sentence}" }
}

class my_class {
  # I can see the other class parameter
  notice( "The idea was: ${Class['other_class']['idea']}" )

  # I can see the other class variables
  notice( "The sentence was: ${::other_class::sentence}" )

  # I can see parameters of resources in another class
  notice( "The entire message was: ${Notify['announcement']['message']}" )
}

class { 'other_class':
  idea => 'games!',
}
include my_class


[root@client code]# puppet apply /vagrant/manifests/peek.pp
Notice: Scope(Class[My_class]): The idea was: games!
Notice: Scope(Class[My_class]): The sentence was: an idea: games!
Notice: Scope(Class[My_class]): The entire message was: I have an idea: games!
Notice: Compiled catalog for client.example.com in environment production in 1.32 seconds
Notice: I have an idea: games!
Notice: /Stage[main]/Other_class/Notify[announcement]/message: defined 'message' as 'I have an idea: games!'
Notice: Applied catalog in 0.02 seconds


- Best practice  pour le design d'un module :

-> creer un squelette qui correspond a l'organisation de la societé
-> declarer dans le module une classe se nommant init.pp
-> utiliser les parametres par defaut qui sont les cas les plus usuelles.
-> utiliser les templates EPP avec des parametres additionnels permettant une  meilleure lisibilité.
-> ne pas acceder a des data exterrieures au module mais assigner ces data a des variables dans des manifests dans lequels ont peut voir les dependances de code.



== chapitre 14 : Ameliorations de module : ==

- Validation des données d'entrée avec controle de typage :


Avant puppet4 il y avait deux phases : une creation et une verification ;
ex :
class puppet(
# input parameters and default values for the class
$version = 'latest',
$status = 'running',
$enabled,
) {
validate_string( $version )
validate_string( $status )
validate_bool( $enabled )
...resources defined below...


il est possible depuis puppet4 de déclarer le type des parametres à la creation de la variable.
ceci permet de creeer la variable et son controle de type en une seule passe : 

Exemple : 
class puppet(
# input parameters and default values for the class
String $version = 'latest',
Enum['running','stopped'] $status = 'running',
Boolean $enabled = true,
) {
...class resources...
}

il est possible de creer des type pour les blocs lambda egalement.
ex :
split( $facts['interfaces'] ).each |String $interface| {
...lambda block...
}


- Types valid :

la classification des type valides se fait sous formes d'arborescence :

• Data accepts any of:
— Scalar accepts any of:
	— Boolean ( true or false )
	— String (ASCII and UTF8 characters)
	— Enum (a specified list of String values)
	— Pattern (a subset of strings that match a given Regexp )
— Numeric accepts either:
	— Float (numbers with periods; fractions)
	— Integer (whole numbers without periods)
— Regexp (a regular expression)
— Undef (a special type that only accepts undefined values)

• Collection accepts any of:
— Array (list containing Data data types)
— Hash ( Scalar keys associated with Data values)

• Catalogentry accepts any of:
— Resource (built-in, custom, and defined resources)
— Class (named manifests that are not executed until called)

- Validateur de data :

le systeme de validation permet à la fois d'evaluer les data en param mais aussi les data structurées.
ex :
Integer[13,19] # teenage years
Array[Float]   # an array containing only Float numbers
Array[ Array[String] ] # an array containing only Arrays of String values
Array[ Numeric[-10,10] ] # an array of Integer or Float values between -10 and 10

Pur des données de type strcuturées le param range indique la taille de l'intervalle et ce pour les tableau et hash : 
Array[String,0,10]    # an array of 0 to 10 string values
Hash[String,Any,2,4] ] # a hash with 2 to 4 pairs of string keys with any value

pour des structures vraiment très controllées on peut utiliser exactement le type désiré pour les clés et les valeurs : 

# This is a Hash with short string keys and floating-point values
Struct[{
  day => String[1,8],    # keys are 1-8 characters in length
temp => Float[-100,100], # values are floating-point Celsius
}]

# This is a hash that accepts only three well-known ducks as key names
Struct[{
	duck => enum['Huey','Dewey','Louie'],
	loved => Boolean,
}]

comme struct agit pour les hash , on peut utiliser Tuple pour agir sur les checks de tableau :
on va pouvoir déterminer le type de data donné à tel type de position avec un nombre minimum déterminer et un max optionnel. 

# an array with three integers followed by one string (explicit) : 
Tuple[Integer,Integer,Integer,String]

# an array with two integers followed by 0-2 strings (length 2-4) :
Tuple[Integer,Integer,String,2,4]

# an array with 1-3 integers, and 0-5 strings : 
Tuple[Integer,Integer,Integer,String,1,8]

explication su dernier exemple : 
Integer in position 1 (required minimum).
Integers in positions 2–3 are optional (above minimum length).
String in position 4 is optional (above minimum length).
The final type (String) may be added 4 times up to the maximum 8 entries.

on peut utiliser deux autres types qui peuvent permettre ue alternative : 

Variant[Integer,Float] #the same as Numeric type
Variant[String,Array[String]] #a string or an array of strings
Variant[String,undef] # a string or nothing
Optional[String] #same as the previous line 
Optional[String,Integer]

You can also check the size of the value of a given type:
String[12] # a string at least 12 characters long
String[1,40] # an string  between 1 and 40 characters long
Array[Integer,3] # an array of at least 3 integers
Array[String,1,5] # an Array with 1 to 5 strings

You can use all of these together in combination:
# An array of thumbs up or thumbs down values
Array[ Enum['thumbsup','thumbsdown'] ]
# An array of thumbs up, thumbs down, or integer from 1 to 5 values
Array[ Variant[ Integer[1,5], Enum['thumbsup','thumbsdown'] ] ]

- Test de valeurs : 

comme on peut definir des types de parametres passés dans une classe , un type ou une iteration lambda ; on peut passer des tests de valeurs sur nos manifestes en utilisant l'operateur :
" =~ "
exemple si  notre donnée peut prendre plusieurs valeurs alors on peut tester :

if( $input_value =~ String ) {
	notice( "Received string ${input_value}" )
}
elsif( $input_value  =~ Integer ) {
	notice( "Received integer ${input_value}" )
}

On peut aussi determiner si notre valeur est iterable : 
if( $variable =~ Iterable ) {
	$variable.each() |$value| {
		notice( $value )
		}
}
else {
	notice( $variable )
}

on peut aussi determniner si un type est disponible dans une collection avec l'opérateur in :

if( String in $array_of_values ) {
notice('Found a string in the list of values.')
}
else {
notice('No strings found in the list of values.')
}
