=== notes according learning puppet 4 (oreilly book) ===

== Introduction :

puppet s'occupe de la configuration des ressources d'un systeme : user, package, service, data, process.Puppet s'occupe de la conformité du système en fonction de l'état désiré.Il combine une hierarchie flexible de config de données avec des données particulières pour un node précis.On peut donc s'en servir pour :
-> déployer des nouvelles applis /composants
-> effectuer des mise à jour applicatives / secu 
-> adapter des nouvelles technos à des vieux systèmes.
-> reduire l'effort de changement sur un grand nombre de machine.
->etc ...
On doit juste utiliser le language déclaratif de puppet qui nous sert à décrire l'état dans le quel on souhaite avoir notre systeme. On veut que le résultat de notre action de config soit systematiquement identique à notre définition.
La specification doit décrire l'état désiré et laisser la résolution de ces tâches à un interpréteur.

Fonctionnement de puppet :

Tous les nodes qu'ont controle ont un puppet agent : cet agent évalue et et applique les manifests puppet : les fichiers de configuration de puppet qui contienne la description de l'etat désiré du node.
L'agent evalue l'etat de chaque composant dans le manifest et determine si un changement est à faire ou pas.
Si un chagement est à faire l'agent le fait et enregistre le changement dans un journal.
Si puppet est configuré avec un serveur central de managment de config : le serveur envoit les données de conf au serveur qui à son tour va renvoyer un catalogue des changements à effectuer si besoin afin de toujours être dans l'etat désiré.  

On peut biensur agir finement et ne passer des changements qu'a un certain nombre de machinnes grace à des systemes de clasification. (ex : hostname, os , puppet version etc ...)
Les agents puppet peuvent être invoqués avec des tag speciaux. Les nodes recoivent leur catalogue individuellement et ne sont pas soumi a des filles d'attente.Un rapport est généré à chaque run .Il est possible d'utiliser un orchestrateur pour piloter un grand nombre de node.



== Part 1 : controlling with puppet apply :

= chapitre 1 : "Pensez déclaratif" 
En developpant des scripts shell, ruby , python etc ..on utilise un language imperatif : qui va permettre le changement d'état par etapes successives : on dit aussi procedural : succession d'etapes pour le changement.
Même si cette façon de penser ou faire peut aider : pour utiliser et comprendre le language de puppet, il vaut mieux tout oublier car pour ecrire de bon manifests puppet il faut utiliser un language declaratif.

On peut voir par exemple que si on lance une commande de creation de user : la premiere execution sera ok mais en relancant la même commande on aura une erreur puisque le user existe dejà : une simple tache comme celle ci devient donc comliquée car il faut gérer des tests et conditions ...c'est evidemment difficile à maintenir des que le systeme augment en complexité : c'est pour cela qu'un language déclaratif est adapté à notre gestion de systeme : une commande lancée de multiples fois genere toujours le même resultat.
On utilise des instructions indempotent ( latin:"idem + potent":"même pouvoir" ) : résultat identique à chaque execution.  

Il est donc important pour la configuration de notre systeme d'utiliser un language pour décrire l'état désiré de notre système et non pas comment arriver à cet état.

user { 'joe':
  ensure => present,
  uid => '1001',
  gid => '1000',
  comment => 'Joe User',
  managehome => true,
}

Comme on le voit le code est très simple à lire et est independant du système d'exploitation.
Le code sera réexecutable a volonté et sera jouer tant que l'état désiré  ne sera pas atteind : c'est ce que fera le puppet agent quand il evaluera le manifest a appliqué et l'etat actuel du système.

== chapitre 2 : creation de notre environment d'apprentissage :

1/
Le set up va se faire en utilisant vagrant /virtualbox
Une fois vagrant installé sur le systeme on va downloader notre "vm" : une centos 7 issue du puppetlabs fait l'affaire.
puppet est déjà installé dessus.

ex :
 $ vagrant box add --provider virtualbox puppetlabs/centos-7.2-64-nocm
 ==> box: Loading metadata for box 'puppetlabs/centos-7.2-64-nocm'
 box: URL: https://atlas.hashicorp.com/puppetlabs/centos-7.2-64-nocm
 ==> box: Adding box 'puppetlabs/centos-7.2-64-nocm' (v1.0.2)
 for provider: virtualbox
 box: Downloading: https://atlas.hashicorp.com/puppetlabs/boxes/
 centos-7.2-64-nocm/versions/1.0.2/providers/virtualbox.box
 ==> box: Successfully added box 'puppetlabs/centos-7.2-64-nocm' (v1.0.2)

2 / clone du repo d'apprentissage :

Il va contenir les outils et l'environmment de dev :

 $ git clone https://github.com/jorhett/learning-puppet4
 Cloning into 'learning-puppet4'...
 remote: Counting objects: 64, done.
 remote: Total 64 (delta 0), reused 0 (delta 0)
 Unpacking objects: 100% (64/64), done.
 Checking connectivity... done.
 $ cd learning-puppet4

NB : on doit pouvoir acceder au contenu du repo git learning-puppet4 depuis notre vm vagrant dans le repertoire vagrant :
A noter que le repo git contient plusieurs conf pour plusieurs vm puppet .
on lancera tjs notre vm avec le nom qu'il convient :
ex vagrant up client 

[vagrant@client ~]$ ls /vagrant/
bin  etc-puppet  LICENSE  manifests  README.md  systemd-puppet  Vagrantfile

On installe ensuite le plugin  vagrant-vbguest qui va être utile pour avoir des mises a jour auto de vagrant ( notamment pour les evolutions de noyaux, access au repertoires partagés : vagrant share : qui peut être mal détecté en cas de maj ...)

$ vagrant plugin install vagrant-vbguest
Installing the 'vagrant-vbguest' plugin. This can take a few minutes...
Installed the plugin 'vagrant-vbguest (0.11.0)'!

On va initialiser notre set up avec vagrant up (qui va lire un vagrant file présent dans notre "learning repo"

En cas de souci on peut essayer de debugguer : vagrant s'intall dans notre /home et crée un repertoire par vm. Dans chacun il ya un un fichier VBox.log qui va nous aider à débuguer.


Attention il est nécessaire d'avoir la Vt d'activer dans le bios : cf manuel vagrant si besoin.

On peut utiliser le  baba de vagrant avec quelques commandes :

$ vagrant suspend client
==> client: Saving VM state and suspending execution...

$ vagrant resume client
==> client: Resuming suspended VM...
==> client: Booting VM...
==> client: Waiting for machine to boot. This may take a few minutes...
client: SSH address: 127.0.0.1:2222
client: SSH username: vagrant
client: SSH auth method: private key
client: Warning: Connection refused. Retrying...
==> client: Machine booted and ready!

$ vagrant destroy client
client: Are you sure you want to destroy the 'client' VM? [y/N] n
==> client: The VM 'client' will not be destroyed, since the confirmation
==> client: was declined.

On reboot notre vm avec un vagrant up 

Pour se connecter à notre client on va faire un :
$ vagrant ssh client
[vagrant@client ~]$

Sur notre vm on va installer des utilitaires :

[vagrant@client ~]$ sudo yum install rsync git vim 

On peut installer le plugin de syntaxe puppet pour vim :

qui se place vu que le client puppet est en 1.4 dans /opt/puppetlabs/puppet/share/vim/puppet-vimfiles/.


== chapitre 3 : installation de puppet :

On a délibérement choisi une distrib sans puppet de pré-installé.On va donc le faire.
On va installer et activer un repo puppet lab puppet collection. On peut examiner les dernières versions compatibles avec notre os sur le puppet lab. Il est possible sinon de downloader directement le pkg et l'installer :
[vagrant@client ~]$ sudo yum install -y  http://yum.puppetlabs.com/puppetlabs-release-pc1-el-7.noarch.rpm

Ceci va installer puppet4 et des outils.Ex :

vagrant@client ~]$ sudo yum repolist
Loaded plugins: fastestmirror
...snip repository checks...
puppetlabs-pc1/x86_64  Puppet Labs PC1 Repository el 7 - x86_64  41 

On voit par exemple ici qu'on a 41 packets d'installés.
On a l'ecosysteme puppet de telecharger : puppet , facter , interpreteur ruby, mcollective.
puppet agent , puppet server et puppet db sont des applis autonomes mais interdépendantes.

Il est important de faire attention a des potentiels pb : maj de secu, pb de cohabitation de differents interpreteur ruby ...
On a donc lors des install / maj : puppet core : qui embarque une version dediée de ruby ( sans conflit avec celle du systeme) : toutes les puppet collections sont faites pour eviter d'avoir des pb de compatibilités de version ( client / server ...)

Install client : 

vagrant@client ~]$ sudo yum install -y puppet-agent
Loaded plugins: fastestmirror
Loading mirror speeds from cached hos
...
...
Verifying : puppet-agent-1.4.0-1.el7.x86_64
1/1
1/1
Installed:
puppet-agent.x86_64 0:1.4.0-1.el7
Complete!

Les versions recentes de puppet4 ont une arbo nouvelle : AIO : "all in one" package . Toutes les dependances sont embarquées et visisble dans :
[vagrant@client ~]$ ls -la /opt/puppetlabs/bin/

A l'install un shell /etc/profile.d/puppet-agent.sh va sourcer le binaire puppet agent (qui n'est plus dans /usr/bin)  vers /opt/puppetlabs/bin. 

NB : si on ecrase notre $PATH il faudra bien de nouveau sourcer le binaire puppet.

-facter : va evaluer les facts d'un système (hostname, ip ....)
-hiera : va charger les données utilisées par les manifests puppet et les modules.Hiera permet de configurer des valeurs par defaut ou de les surcharger ou etendre via une hierarchie adaptable.
-mcollective : est un framework d'orchestration.

Une installation  privée de ruby et des gem est faite dans  /opt/puppetlabs/puppet
Le $confdir est maintenant dans  /etc/puppetlabs/puppet : tout ce qui est dans /etc/puppet sera ignoré.
Le $ssldir est maintenant dans le $confdir
La conf de mcollective est exclusivement dans : /etc/puppetlabs/mcollective
Le $rundir est exclusivement dans : /var/run/puppetlabs
Les manifests, modules et hiera sont dans : /etc/puppetlabs/code et sont donc maintenant dans le $codedir
Ce repertoire contient donc :
$environmentpath : les différents environments.
$basemodulepath : l'arbo des modules.
$hiera_config correspond au hiera.yaml

Pour la facilité d'apprentissage on va change rles droits pour permettre à vagrant d'être utilisé :

[vagrant@client ~]$ sudo chown -R vagrant /etc/puppetlabs


/!\ path des commandes puppet : on va utiliser les binaires puppet pour nos tests avec le user vagrant en sudo 
attention : sudo reset de base la recherche des commandes utilisées par un user et va utiliser des repertoires et path secureles binaires de puppet n'en font pas partie 
exemple :
env de notre user : 
[vagrant@client ~]$ env |grep -i path
PATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/opt/puppetlabs/bin:/home/vagrant/.local/bin:/home/vagrant/bin

env de notre user via sudo : 
[vagrant@client ~]$ sudo env |grep -i path
PATH=/sbin:/bin:/usr/sbin:/usr/bin

On va devoir rajouter notre env puppet dans le secure path de sudo :

[vagrant@client ~]$ sudo grep secure_path /etc/sudoers |sed -e 's#$#:/opt/puppetlabs/bin#' |sudo tee /etc/sudoers.d/puppet-securepath
Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/opt/puppetlabs/bin


[vagrant@client ~]$ sudo cat /etc/sudoers.d/puppet-securepath
Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/opt/puppetlabs/bin

C'est desormais ok :
[vagrant@client ~]$ sudo env |grep -i path
PATH=/sbin:/bin:/usr/sbin:/usr/bin:/opt/puppetlabs/bin


== chapitres 4 : manifests : 

Un manifest est un fichier contenant du code puppet decrivant la configuration desirée de nos ressources.C'est la base de toute la stratégie de config de nos nodes jusqu'a des blocs de config de modules très complexes.

Les ressources sont les plus petits blocs de code puppet qui nous servent à definir, modifier supprimer un element sur un systeme.Puppet embarque des resources de base telles que : users, services, packages, files , groups ...On peut egalement creer nos propres ressources.

= ressources :

On commence par notify qui va afficher un message :

notify (ressource){ 'greeting':
        message (attribut) => 'Hello, world!' (valeur)
}

on declare une ressource notify ayant pour titre greeting , ayant un attribut message auquel on donne une valeur.
les attributs sont séparées de leur valeurs par un "=>" (comme en perl , ruby)

#Exemple dans le repos cloné pour la lesson "Learning puppet4" un repertoire manifest contient des exemples de code :
#boogie@x61-boogie:~/lab/puppetlab/learning-puppet4/manifests$ cat helloworld.pp 
#notify { 'greeting':
#  message => 'Hello, world!'
#}

On creer donc pour tester un repertoire manifest dans le home de notre user vagrant et on y cree le manifest :

/home/vagrant/manifests/helloworld.pp
On test facilement notre manifest avec la commande puppet apply manifest.pp :

[vagrant@client manifests]$ sudo puppet apply helloworld.pp 
Notice: Compiled catalog for client in environment production in 0.22 seconds
Notice: Hello, world!
Notice: /Stage[main]/Main/Notify[greeting]/message: defined 'message' as 'Hello, world!'
Notice: Applied catalog in 0.03 seconds
[vagrant@client manifests]$ pwd
/home/vagrant/manifests

On voit donc la creation du build du catalogue et differente etapes jusqu'a l'affichage de notre message et du rapport de run.

on peut utiliser les manifests de notre env partages du repo git présent dans le dir /vagrant/manifests depuis la vm :

[vagrant@client ~]$ sudo puppet apply /vagrant/manifests/helloworld.pp 
Notice: Compiled catalog for client.example.com in environment production in 1.20 seconds
Notice: Hello, world!
Notice: /Stage[main]/Main/Notify[greeting]/message: defined 'message' as 'Hello, world!'
Notice: Applied catalog in 0.02 seconds

-Declaration de ressources : regles :
quelques regles sont impératives pour la déclaration de ressources puppet :

Les ressources DOIVENT être unique : il ne peut y avoir qu'une seule ressource de même nom / titre par type (file, user etc..)

resource_type { 'resource_title':
    ensure  => present, # habituellement present ou absent 
    attribute1 => 1234, # nombre
    attribute2 => 'value', # string
    attribute3 => ['red','blue'], # tableau
    noop       => false, # booleen
}


Plusieurs appels à une ressource du même nom ET du même type génère donc une erreur de déclaration :

exemple : 
[vagrant@client manifests]$ cat myfile.pp
file { 'my_file':
    ensure => present,
    path => '/tmp/my_file.txt',
}
file { 'my_file':
    ensure => present,
    path => '/tmp/my_file.yaml',
}
file { 'my_file':
    ensure => present,
    path => '/tmp/my_file.csv',
}

nous donne au run :
[vagrant@client manifests]$ sudo puppet apply myfile.pp 
Error: Evaluation Error: Error while evaluating a Resource Statement, Duplicate declaration: File[my_file] is already declared in file /home/vagrant/manifests/myfile.pp:1; cannot redeclare at /home/vagrant/manifests/myfile.pp:5 at /home/vagrant/manifests/myfile.pp:5:1 on node client.example.com

NB: on peut avoir des ressources de type differents porant le même nom : pas de souci :
[vagrant@client manifests]$ cat myfile.pp 
file { 'my_file':
    ensure => present,
    path => '/tmp/my_file.txt',
}
notify { 'my_file':
    message=> 'this is my file !!',
}
[vagrant@client manifests]$ sudo puppet apply myfile.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.06 seconds
Notice: this is my file !!
Notice: /Stage[main]/Main/Notify[my_file]/message: defined 'message' as 'this is my file !!'
Notice: Applied catalog in 0.02 seconds

-Examen de ressources :

puppet peut nous permettre d'analyser le découpage d'une ressource externe a la config puppet : cela va nous permettre de construire plus facilement notre code 
grace a la commande puppet ressource 
Ce mecanisme est le même qu'utilise puppet pour analyser et modifier les config systemes 


[vagrant@client manifests]$ sudo puppet resource mailalias postmaster
mailalias { 'postmaster':
  ensure    => 'present',
  recipient => ['root'],
  target    => '/etc/aliases',
}


exemple on voit que puppet interprete notre ressource user vagrant de cette façon :
[vagrant@client manifests]$ sudo puppet resource user vagrant
user { 'vagrant':
  ensure           => 'present',
  gid              => '1000',
  groups           => ['vagrant'],
  home             => '/home/vagrant',
  password         => '!!',
  password_max_age => '99999',
  password_min_age => '0',
  shell            => '/bin/bash',
  uid              => '1000',
}
on peut donc s'inspirer de ces retours pour creeer du code et le tester avec un puppet apply 

Attention certain attribut ne peuvent pas etre sette tel quel et génere une erreur en cas d'utilisation c'est le cas de readonly qui ne peut être sette dans une ressources : voir doc sur les ressources.


- execution de commande :

la ressource exec permet de lancer une commande au sein de notre manifest.
ex : 
exec { 'echo-holy-cow':
    path  => ['/bin'],
    cwd   => '/tmp',
    command   => 'echo "holy cow!" > testfile.txt',
    creates   => '/tmp/testfile.txt',
    returns   => [0],
    logoutput => on_failure,
}

A noter qu'en puppet on utlise toujours les simples quotes quand aucune variable n'est présente : on ne veut pas d'interpolation. Ce qui n'est pas le cas des doubles quotes quisont utilisées lors de passage de variable en param.

on a ici l'utiisation de l'attribut creates qui va donc definir le resulat de l'execution de la commande .
Si le fichier existe la commande NE sera pas executer : il faut donc être tres prudent avec cerre utilisation d'attribut de ressource et se référer à la doc puppet.

Il est clair que cette resource est importante MAIS est à utiliser le moins possible : car on est plus dans le déclaratif mais dans du procedural et qu'une modification du contenu du fichier ne sera pas corrigée car si ce fichier existe ..la commande exec ne le recrera pas.

On evite la ressource exec et souvent la présence de cette ressource peut être evitée par l'ecriture de manifest plus propre.

- gestion de fichiers :

la ressource file nous permet de gerer correctement le contenu du fichier ( le contenu est flaggué en dur et chaque changement sera efface avec replace sette a true)et sa présence

file { '/tmp/testfile.txt':
    ensure => present,
    mode   => '0644',
    replace => true,
    content => 'holy cow!',
}
[vagrant@client manifests]$ sudo cat /tmp/testfile.txt 
holy cow![vagrant@client manifests]$

A noter que si on veut rajouter un retour chariot dans du texte il faut le faire en rajoutant un \n et entourer notre texte entre " " car le \n est interprété.

file { '/tmp/testfile.txt':
    ensure => present,
    mode   => '0644',
    replace => true,
    content => "holy cow!\n",
}
nous donne :
[vagrant@client manifests]$ sudo cat /tmp/testfile.txt 
holy cow!

- backup de fichiers :

tous les fichiers passés sous puppet sont backupés et index sous forme de hash dans la directive  clientbucketdir

On peut donc backuper un fichier 
sudo puppet filebucket --local backup /tmp/testfile.txt

voir la liste des fichiers backupés :

[vagrant@client manifests]$ sudo puppet filebucket --local list
0eb429526e5e170cd9ed4f84c24e442b 2017-01-09 20:43:14 /tmp/testfile.txt
3d508c856685853ed8a168a290dd709c 2017-01-09 20:43:49 /tmp/testfile.txt
2421d24b7d984ed88425f56feb2b5201 2017-01-09 20:49:23 /tmp/testfile.txt


- restorer les fichiers :
on peut examiner le contenu d'un fichier backupé en saisissant son hash 

[vagrant@client manifests]$ sudo puppet filebucket --local get 2421d24b7d984ed88425f56feb2b5201
holy cowbow![vagrant@client manifests]$ 

On peut voir le diff entre deux fichier : le courant et un ancien backupé avec son hash 

holy cowbow![vagrant@client manifests]$ sudo puppet filebucket --local diff  2421d24b7d984ed88425f56feb2b5201  /tmp/testfile.txt 
--- /tmp/diff20170109-5248-820397   2017-01-09 21:00:35.960114772 +0000
+++ /tmp/testfile.txt   2017-01-09 20:50:56.364225000 +0000
@@ -1 +1 @@
-holy cowbow!
\ No newline at end of file
+holy cow!
\ No newline at end of file

pour restaurer :
ex notre fichier d'origine 
[vagrant@client manifests]$ sudo cat /tmp/testfile.txt 
holy cow![vagrant@client manifests]$ 

qu'on va changer et restaurer :
[vagrant@client manifests]$ sudo puppet filebucket --local restore /tmp/testfile.txt 2421d24b7d984ed88425f56feb2b5201
[vagrant@client manifests]$ sudo cat /tmp/testfile.txt 
holy cowbow![vagrant@client manifests]$ 

- Proscrire l'imperatif dans les manifests :
comme avec la commande exec 
Si le code demande a l'interpréteur quoi faire , quand le faire et comment le faire : alors on fait de l'imperatif
Si notre code decrit a l'interpreteur comment le resulat doit être alors on fait du déclaratif

La raison pour ne pas utiliser exec est simple : la commande est executée et peut faire des dégats sur le systeme sans que puppet ne puisse être au courant puisque le seul code retour de l'execution d'exec est un status normal :quelle que soit les changements sur le systeme.
Il est donc toujours possible de suivre les changements , de restaurer comaprer avec les md5 des hash de fichiers quand on utilise la ressource file.

On ne doit utiliser exec quand vraiment nous n'avons pas d'autres choix.

== chapitre 5 : language de configuration puppet :

La bonne ecriture de manifests est la chose la plus importante dans puppet : il faut donc toujours s'y attacher et s'y améliorer.

= les variables :
toutes les variables dans puppet commencent avec un $ et sont en minuscule ; composées de lettres, underscore ou chiffres. Elles ne commencent pas par des majuscules, des chiffres et ne comportent pas de tiret.
Attention : les variables qui commencent par un _ sont uniquement dédiées au scope local : $_myvar : sera uniquement interprete dans notre manifest local.

Les types sont classiques :
$my_name  = 'joe'  < string 
$my_token = 115    < number
$not_true = false  < booleen

une variable non initialisee sera considérée comme undef on peut creer une variable avec une valeur indefinie :

$my_var = undef

Le module stlib de puppetlabs peut nous permettre de voir de quel type est notre variable :
include stdlib
$myname = 'joe'
$mytype = typeof($myname)


- Numbers :
les nombres non entourés par des " ou des '  sont de type numeric
Les nombres commencant par un 0 sont des octals et sceux commencant par 0x des hexa

- Tableaux et hash :

$mylist = [1,3,5,7]
$mytab = ['yes',5,'lapin',5.3]
$mymy =['yop',['lala',5]]

on peut definir des variables a des valeurs dans des tableaux si le nombre de variables et de valeur sont identiques :

[$myvar, $yourvar , $var] = ['lapin', 3, true]   <<<< GGOD
[$myvar, $yourvar , $var] = ['lapin', 3]         <<<<< ERROR

Certaines fonctions demandent une liste de valeur en arguments a la place d'element de tableau.On peut utiliser '*' pour convertir les elements d'un tableau en éléments séparés par une virgule avec la syntaxe de type :
$myfonction(* $array_of_args) { ..}

- table de hash key/ valeur :
on peut utiliser une table de hash avec la représentation clé / valeur 

# monoligne :
$homes = { 'joe' => '/home/joe', 'jack' => '/home/jack', }

# muliligne :

$user = {
    'username' => 'joe',
    'uid'      => 1000,
    'home'     => '/home/joe',
}
Attention les  hash doivent être soient entiers soient strings . Les valeurs peuvent prendre toutes les types  possibles.

- Variables et strings :
on encadre toujours les strings avec des simple quote sauf quand il y a interpolation : on utilise dans ce cas des "
$myvar = 'hey mec !'
$my = "hey ${username} happy to see you"

-HEREDOC : pour les grands blocs de texte on utilise les commentaires heredoc :
on place une balise @(END) a la fin de notre déclaration de variable et on cloture le texte par END :

$message_text = @(END)
This is a very long message,
which will be composed over
many lines of text.
END

Idem en cas d'interpolation de variable on va entourer notre heredoc de " :

$message_text = @("END")
Dear ${user},
Your password is ${password}.
Please login at ${site_url} to continue.
END

Il est toujours conseille d'utiliser les {} pour entourer une variable de chaine de caractere :

$the_greeting = "Hello ${myname}, you have received ${num_tokens} tokens!"

- Protection : on va pouvoir proteger d'interpolation certains de nos carateres speciaux en les faisant précéder de \ ou alors en entourant le texte en entier par des ' ''


- Namespace / scope : AUCUNE variable puppet ne peut être REdeclarée au sein d'un même NAMESPACE / SCOPE 

C'est clairement pour continuer a penser en déclaratif : puppet nous jette donc une erreur si on declare plusieurs fois une variable avec des valeurs differentes.

- Mots réservés : on a comme dans beaucoup de language des mots clés réservés qu'on ne peut utiliser pour déclarer nos variables ou qu'on l'on doit encadrer de ' ou " si on veut utiliser leur valeur en tant que mot :

and elsif node
attr false private
case function or
class if
true
default in
type
define import
undef
else inherits unless


= Facter : va nous fournir des variables systemes : 

vagrant@client manifests]$ facter |grep mb
    vendor => "innotek GmbH",
  manufacturer => "innotek GmbH",
[vagrant@client manifests]$ facter |grep free
[vagrant@client manifests]$ facter |grep version
aio_agent_version => 1.8.2
  version => "1.4.0"
    version => "VirtualBox"
facterversion => 3.5.0
kernelmajversion => 3.10
kernelversion => 3.10.0
  version => "2.1.9"


certaines varibles facter vont être directement utilisée par puppet et ses modules :

facter --puppet 

io_agent_version => 1.8.2
augeas => {
  version => "1.4.0"
}
disks => {
  sda => {
    model => "VBOX HARDDISK",
    size => "20.00 GiB",
    size_bytes => 21474836480,
    vendor => "ATA"
  }
...
...
ystem_uptime => {
  days => 0,
  hours => 1,
  seconds => 7004,
  uptime => "1:56 hours"
}
timezone => UTC
virtual => virtualbox


Certains facters puppet sont poussés parmi les facter system de base


une liste de fact en json est directement trouvable via la commande :
puppet facts find 

On peut sortir la liste des facts sous differents formats :
-yaml :
[vagrant@client manifests]$ facter --yaml
[vagrant@client manifests]$ puppet facts render-as-yaml
- json :
[vagrant@client manifests]$ facter --json
[vagrant@client manifests]$ puppet facts render-as-json

= Appel de fonction dans les manifests :

une fonction est du code executable qui peut prendre des entrées en paramètres et peut afficher des valeurs en sortie.
une fonction qui retourne une valeur peut être utiliser pour devenir la veleur d'une variable :

$zero_or_one = bool2num( $facts['is_virtual'] );

une fonction peut aussi être utilisée a la place d'une valeur ou interpolée dans une chaine de caracteres :
# md5() function provides the value for the message attribute
notify { 'md5_hash':
     message => md5( $facts['fqdn'] )
}
# Include the MD5 hash in the result string
$result = "The MD5 hash for the node name is ${md5( $facts['fqdn'] )}"

Puppet execute des fonctions lors de la génération du catalogue : examine les donnees de sources externes , ajoute modifie des entrees dans le catalogue ,execute du code ....

on peut ecrire les fonctions en mode prefix ou en mode ruby 'chainé' :
# Common prefix format
notice( 'this' )
# Ruby-style chained format
'this'.notice()

- Utilisation de variables dans les ressources :
rappel on ne quote que les strings simples avec des ' et les interpolées avec des " . on ne quote pas les autres variables :

notice('Beginning the program.' )
notice("Hello, ${username}" )
notice(1000000 )
notice(true )

on peut acceder à une valeur d'un tableau et on peut specifier un range : 
$first_item = $my_list[1]
$four_items = $my_list[3,6]

You can access specific items within a Hash by using the hash key within square
brackets as follows: 
$username = $my_hash['username']

Toutes les variables de tableau doivent être entourées de {} pour l'interpolation :
notice( "The user's name is ${username}" )
notice( "The second value in my list is ${my_list[1]}" )
notice( "The login username is ${my_hash['username']}" )

Best pratice : on ne doit pas entourer une variable en stadalone de {} :

file { $filename:
ensure => present,
mode
=> '0644',
replace => $replace_bool,
content => $file['content'],
}

Exemple de test de variable dans un manifest :

on recupére pour l'exemple des données via facter et on affiche un message en mode multiligne qu'on aura au prealable enregistre dans une variable 

[vagrant@client manifests]$ cat testvar.pp 
$myname = $facts['hostname']
$kind = $facts['is_virtual']
$living = $facts['uptime']

$resume = @("END")
for sure here is 
a multiline text
we claim the node is $myname
and it is a $kind server
with $living time
END


notify { 'message':
    message => "yop $resume"
    }

ici on affiche la premiere valeur du tableau qu'on aura resneigné dans une variable :
[vagrant@client manifests]$ cat hash.pp 
$joe =['lapin', 3, true]

notify {'hash':
    message => "hey this is the first index record : ${joe[0]}"
    }

[vagrant@client manifests]$ puppet apply hash.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.06 seconds
Notice: hey this is the first index record : lapin
Notice: /Stage[main]/Main/Notify[hash]/message: defined 'message' as 'hey this is the first index record : lapin'
Notice: Applied catalog in 0.01 seconds


A noter que c'est une bonne pratique de toujours travailler avec la valeur désirée du fact en utilisant la forme $fact['valeur]

Il est toujours préférable de travailler avec la conf suivante de settée :

[main]
strict_variables = true

On aura toujours dans ce cas des erreurs de type : " Evaluation error" en cas d'appels de variables non définies.
NB: que nous n'aurons pas d'erreur si nous déclarons une variable de type "undef".

_- Definition d'attribut avec les hash :
il est tout a fait possible de recupérer les noms et valeurs d'un hash pour définir les attributs d'une ressource avec "*" :

$resource_attributes = {
ensure => present,
owner => 'root',
group => 'root',
'mode' => '0644',
'replace' => true,
}

file { '/etc/config/first.cfg':
source => 'first.cfg',
* => $resource_attributes,
}

file { '/etc/config/second.cfg':
source => 'config.cfg',
* => $resource_attributes,


on voit que des patterns sont donc réutilisés plusieurs fois : cela fait parti du DRY dont repeat yourself

- Declaration multiple de resources :
il est possible de déclarer au sein du même type plusieurs resources en déclarant plusieurs noms à la suite ( cela est possible quand les attributs ne mettent pas de conflits :) 

file { ['/tmp/file_one.txt','/tmp/file_two.txt']:
ensure => present,
owner => 'vagrant',
}

 on peut déclarer plusieurs body de ressources en les separant par des ";" :

 file {
 'file_one':
 ensure => present,
 owner => 'vagrant',
 path
 => 'file_one.txt',
 ;
 'file_two':
 ensure => present,
 owner => 'vagrant',
 path => 'file_two.txt',
 ;
 }

 A noter que cette ecriture n'est pas conseillé. une definition de ressource par type est ce qui est recommandé.
 on peut a la rigeur utiliser cette forme si une valeur par défaut est déclarée :

file {
 default:
  ensure => present,
  owner => 'vagrant',
;
 'file_one': path => 'file_one.txt';
 'file_two': path => 'file_two.txt';
}


- Operations :

$added = 10 + 5
$subtracted = 10 - 5
$multiplied = 10 * 5
$divided = 10 / 5
$remainder = 10 % 5

- Ajout dans les tableaux et hash :
$my_list = [1,4,7]
$bigger_list = $my_list + [14,17]
# equals [1,4,7,14,17]

$key_pairs = {name => 'Joe', uid => 1001}
$user_definition = $key_pairs + { gid => 500 }

ex : 
[vagrant@client manifests]$ cat re.pp 
$my_list = [1,4,7]
$bigger_list = $my_list + [14,17]


notify { 'yop':
    message => "here it is ${bigger_list}"
    }

[vagrant@client manifests]$ puppet apply re.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.06 seconds
Notice: here it is [1, 4, 7, 14, 17]
Notice: /Stage[main]/Main/Notify[yop]/message: defined 'message' as 'here it is [1, 4, 7, 14, 17]'

- ajout de valeur :
on peut ajouter des  éléments dans un tableau avec la commande <<

ex : 
 $longer_list = $my_list << 33
 $unintended = $my_list << [33,35]

 [vagrant@client manifests]$ cat re.pp 
 $my_list = [1,4,7]
 $bigger_list = $my_list + [14,17]
 $longer = $bigger_list << 'lapin'

 notify { 'yop':
     message => "here it is ${bigger_list}"
     }

     notify {'yy':
         message => "now this is a longer list $longer"
         }

[vagrant@client manifests]$ puppet apply re.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.07 seconds
Notice: here it is [1, 4, 7, 14, 17]
Notice: /Stage[main]/Main/Notify[yop]/message: defined 'message' as 'here it is [1, 4, 7, 14, 17]'
Notice: now this is a longer list [1, 4, 7, 14, 17, lapin]
Notice: /Stage[main]/Main/Notify[yy]/message: defined 'message' as 'now this is a longer list [1, 4, 7, 14, 17, lapin]'
Notice: Applied catalog in 0.01 seconds

 - Suppression d'éléments dans les listes et tableaux avec "-" :

 # Remove a single value
 $names = ['jill','james','sally','sam','tigger']
 $no_tigger = $names - 'tigger'
 # Remove multiple values
 $no_boys = $names - ['james','sam']
ex :
[vagrant@client manifests]$ cat re.pp 
$my_list = [1,4,7]
$cut = $my_list - 4
notify { 'yop':
    message => "here it cut list $cut"
}

[vagrant@client manifests]$ puppet apply re.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.07 seconds
Notice: here it cut list [1, 7]
Notice: /Stage[main]/Main/Notify[yop]/message: defined 'message' as 'here it cut list [1, 7]'
Notice: Applied catalog in 0.01 seconds

 - L'ordre d'evaluation des opérations suit les regles mathématiques  de base : il faut toujours encadrer correctement avec des parentheses.

- Operateurs de comparaisons :
ce sont les mêmes que ceux utilisés classiquement en programmation.
4 != 4.1
$how_many_cups < 4
$how_many_cups >= 3

Le test sur les chaine de caracteres sont insensibles a la casse 
coffee == 'coffee'
'Coffee' == 'coffee'
tea' !in 'coffee'
mais les sous chaines de caracteres sont sensibles a la casse :
'Fee' !in 'coffee'
'fee' in 'coffee'

[1,2,5] != [1,2]
5 in [1,2,5]
{name => 'Joe'} != {name => 'Jo'} # hashes aren't identical
'Jo' !in {fname => 'Jo', lname => 'Rhett'}   is a value and doesn't match
$not_true =~ Boolean
$num_tokens =~ Integer
$my_name !~ String

true and true
true and false
true or false
true and !false
true and !true

= Evaluations conditionnelles :

if / elsif / else statements
unless / else statements
case statements
Selectors

- if : 

if ($coffee != 'drunk') {
notify { 'best-to-avoid': }
}
elsif ('scotch' == 'drunk') {
notify { 'party-time': }
}
else {
notify { 'party-time': }
}

- unless :

unless $facts['kernel'] == Linux {
notify { 'You are on an older machine.': }
}
else {
notify { 'We got you covered.': }
}

A noter que la forme else dans unless existe depuis puppet 4 . 
La forme unless n'est pas très conseillée ..car moins facile à lire.

- case :
cette forme nous permet d'eviter le rajout de condition avec else : on gagne en lisibilité.
ATTENTION : il faut toujours rajouter une clause default avec case même si elle est vide et ne sert à rien.

case $what_she_drank {
    'wine': { include state::california }
     $stumptown: { include state::portland }
     /(scotch|whisky)/: { include state::scotland }
     is_tea( $drink ): { include state::england }
     default: {}
}

- selectors :
leur usage est a peur pres identique a case mais ils retournent une valeur plutôt que d'executer un bloc de code .
C'est tres utile quand on doit definir des variables.
Comme une valeur doit être retournée lors de l'assignation il faut toujours un 'mot' même pour le default :

$native_of = $what_he_drinks ? {
'wine'            => 'california',
$stumptown        => 'portland',
/(scotch|whisky)/ => 'scotland',
is_tea( $drink )  => 'england',
default           => 'unknown',
}

exemples :

if /else /elsif 

# Explicit comparison
if( $facts['osfamily'] == 'redhat' ) {
include yum
}
# Do a substring match
elsif( $facts['osfamily'] in 'debian-ubuntu' ) {
include apt
}
# New package manager available with FreeBSD 9 and above
elsif( $facts['operatingsystem'] =~ /?i:freebsd/ )
and ( $facts['os']['release']['major'] >= 9 ) {
include pkgng
}

case : 

case $facts['osfamily'] {
    'redhat': { include yum }
    'debian', 'ubuntu': { include apt }
    'freebsd' and ($facts['os']['release']['major'] >= 9) { include pkgng }
    default: {}
}

selectors : 
$libdir = $facts['osfamily'] ? {
/(?i-mx:centos|fedora|redhat)/ => '/usr/libexec/mcollective',
/(?i-mx:ubuntu|debian)/        => '/usr/share/mcollective/plugins',
/(?i-mx:freebsd)/              => '/usr/local/share',
}

On peut aussi utiliser "*" qui transforme les elements de tableau en liste 

$redhat_based = ['RedHat','Fedora','CentOS','Scientific','Oracle','Amazon']
$libdir = $facts['osfamily'] ? {
*$redhat_based => '/usr/libexec/mcollective',
}


- REGEXPS : regexps / regular expressions :

puppet supporte les regexps de ruby 
string a gauche =~ regexp a droite entourée par des / / ou par des " " :

$what_did_you_drink =~ /tea/
$what_did_you_drink !~ /coffee/
$what_did_you_drink !~ "^coffee$"


unless $facts['operatingsystem'] !~ /(?i-mx:centos|fedora|redhat)/ {
include yum
}

case $facts['hostname'] {
/^web\d/: { include role::webserver }
/^mail/ : { include role::mailserver }
default : { include role::base}
}

$package_name = $facts['operatingsystem'] ? {
/(?i-mx:centos|fedora|redhat)/ => 'mcollective',
/(?i-mx:ubuntu|debian)/        => 'mcollective',
/(?i-mx:freebsd)/              => 'sysutils/mcollective',
}


- Lambda : block de code comme une fonction sans nom qui permet de passer des arguments.
elles sont utilisées avec les boucles :

elles sont des variables entourées de | :

| $firstvalue, $secondvalue | {
block of code that operates on these values.
}

ex : ici on recupere toutes les partitions grace a facter : chacune des entrees va etre decoupées par son nom et son point de montage . on fait ensuite une boucle qui va nous afficher le nom du serveur le nom de lz partition et la taille de cette partition qui sera recupérée par le hash fourni par facter et enregistre dans la variable device


[vagrant@client manifests]$ cat /vagrant/manifests/mountpoints.pp 
each( $facts['partitions'] ) |$name, $device| {
  notice( "${facts['hostname']} has device ${name} with size ${device['size']}" )
  }
  [vagrant@client manifests]$ sudo puppet apply /vagrant/manifests/mountpoints.pp 
  Notice: Scope(Class[main]): client has device /dev/mapper/centos-root with size 18.46 GiB
  Notice: Scope(Class[main]): client has device /dev/mapper/centos-swap with size 1.00 GiB
  Notice: Scope(Class[main]): client has device /dev/sda1 with size 500.00 MiB
  Notice: Scope(Class[main]): client has device /dev/sda2 with size 19.51 GiB
  Notice: Compiled catalog for client.example.com in environment production in 1.70 seconds
  Notice: Applied catalog in 0.01 seconds



- Looping :

ces fonctioosn puissantes vont nous permettre de parcourir des set de données dans des tableaux , hash etc..
il y a 5 fonctions qui vont nous servir a itérer et vont être passées à la fonction lambda qui renverra une valeur pour chaque entree.

each() acts on each entry in an array, or each key/value pair in a hash.
filter() returns a subset of the array or hash that were matched by the lambda.
map() returns a new array or hash from the results of the lambda.
reduce() combines array or hash values using code in the lambda.
slice() creates small chunks of an array or hash and passes it to the lambda.

each appelle lambda a chaque passage de valeur dans un tableau ou d'un hash dans une serie clé valeur 
C'est la fonction la plus utilisée pour lister des éléments.

[vagrant@client manifests]$ cat /vagrant/manifests/interface_ips.pp 
# Output a list of interfaces which have IPs
split( $facts['interfaces'], ',' ).each |$interface| { 

if( $facts["ipaddress_${interface}"] != '' ) {
      notice( sprintf( "Interface %s has IPv4 address %s", $interface, $facts["ipaddress_${interface}"] ) )
        }
        
if( $facts["ipaddress6_${interface}"] != '' ) {
              notice( sprintf( "Interface %s has IPv6 address %s", $interface, $facts["ipaddress6_${interface}"] ) )
                }
}

[vagrant@client manifests]$ puppet apply /vagrant/manifests/interface_ips.pp 
Notice: Scope(Class[main]): Interface enp0s3 has IPv4 address 10.0.2.15
Notice: Scope(Class[main]): Interface enp0s3 has IPv6 address fe80::a00:27ff:feb7:f3af
Notice: Scope(Class[main]): Interface enp0s8 has IPv4 address 192.168.250.10
Notice: Scope(Class[main]): Interface enp0s8 has IPv6 address fe80::a00:27ff:fe5e:d9ac
Notice: Scope(Class[main]): Interface lo has IPv4 address 127.0.0.1
Notice: Scope(Class[main]): Interface lo has IPv6 address ::1
Notice: Compiled catalog for client.example.com in environment production in 1.73 seconds
Notice: Applied catalog in 0.01 seconds


on peut recupérer les valeurs d'un tableau et renseigner le numéro d'index :

$ cat /vagrant/manifests/interfaces.pp
split( $facts['interfaces'], ',' ).each |$index, $interface| {
notice( "Interface #${index} is ${interface}" )
}
$ puppet apply /vagrant/manifests/interfaces.pp
Notice: Scope(Class[main]): Interface #0 is enp0s3
Notice: Scope(Class[main]): Interface #1 is enp0s8
Notice: Scope(Class[main]): Interface #2 is lo

on peut aussi utiliser each avec un hash 

si on met deux variables on aura une sortie avec le nom et la seconde avec la valeur 

[vagrant@client manifests]$ cat /vagrant/manifests/uptime.pp 
each( $facts['system_uptime'] ) |$type, $value| {
   notice( "System has been up ${value} ${type}" )
   }

ici on ne met q'une variable et on aura le même resultat : 
each( $facts['system_uptime'] ) |$uptime| {
notice( "System has been up $uptime[1] $uptime[0]" )
}

- La methode reverse_each() : nous renvoie la liste inversée de each()
[vagrant@client manifests]$ cat l.pp 
$my_list = "lapin"


reverse_each("$my_list") |$elem| {
notice("$elem")

}

[vagrant@client manifests]$ puppet apply l.pp
Notice: Scope(Class[main]): n
Notice: Scope(Class[main]): i
Notice: Scope(Class[main]): p
Notice: Scope(Class[main]): a
Notice: Scope(Class[main]): l
Notice: Compiled catalog for client.example.com in environment production in 0.06 seconds
Notice: Applied catalog in 0.01 seconds

- filter() : 
cette fonction va boucler et ne sortir que les éléments définis de tableaux ou de hash  recupérer par  lambda  après le passage de filtre définis .
ici on va définir une variable $ips dans laquelle on va injecter toutes les valeurs trouvées après le passage de notre filtre que l'on set dans la variable $key et qui contient le pattern ipaddress6 

On boucle sur les résultats $key et $value que l'on affiche :

[vagrant@client manifests]$ cat ip.pp 
$ips = $facts.filter |$key,$value| { 
  $key =~ /^ipaddress6?_/
  }

  notice("here it is ..version 6 ip proctocol : $ips")
[vagrant@client manifests]$ puppet apply ip.pp
Notice: Scope(Class[main]): here it is ..version 6 ip proctocol : {ipaddress6_enp0s3 => fe80::a00:27ff:feb7:f3af, ipaddress6_enp0s8 => fe80::a00:27ff:fe5e:d9ac, ipaddress6_lo => ::1, ipaddress_enp0s3 => 10.0.2.15, ipaddress_enp0s8 => 192.168.250.10, ipaddress_lo => 127.0.0.1}
Notice: Compiled catalog for client.example.com in environment production in 0.08 seconds



- map() :
cette fonction nous sort un tableau après le passage de lambda et peut recevoir en entrées tableau ou hash


[vagrant@client manifests]$ cat m.pp 
$ips = split( $facts['interfaces'], ',' ).map |$interface| {
$facts["ipaddress_${interface}"]
}
notice("here it is ..; $ips")

[vagrant@client manifests]$ puppet apply m.pp 
Notice: Scope(Class[main]): here it is ..; [10.0.2.15, 192.168.250.10, 127.0.0.1]
Notice: Compiled catalog for client.example.com in environment production in 0.07 seconds
Notice: Applied catalog in 0.01 seconds


- slice() :
nous permet de sortir des petits morceaux de tableaux ou de hash avec un taille déterminée.
Attention à l'usage : touchy.

on va donc decouper notre entrée en petits morceaux de tailles spécifiques :

[1,2,3,4,5,6].slice(2) |$item| {
notice( "\$item[0] = ${item[0]}" )
notice( "\$item[1] = ${item[1]}" )
}

on decoupe en bloc de deux unités notre tableau : chaque fois qu'on atteint deux on recommence à 0 :

[vagrant@client manifests]$ puppet apply s.pp
Notice: Scope(Class[main]): $item[0] = 1
Notice: Scope(Class[main]): $item[1] = 2
Notice: Scope(Class[main]): $item[0] = 3
Notice: Scope(Class[main]): $item[1] = 4
Notice: Scope(Class[main]): $item[0] = 5
Notice: Scope(Class[main]): $item[1] = 6
Notice: Compiled catalog for client.example.com in environment production in 0.07 seconds
Notice: Applied catalog in 0.01 seconds


- with() :
cette fonction va permettre de passer les arguments à la fonction lambda qui va chacun les assigner a des variables :

[vagrant@client manifests]$ cat w.pp 
with( 'austin', 'powers', 'secret agent' ) |$first,$last,$title| {
notice( "A person named ${first} ${last}, ${title} is here to see you." )
}

[vagrant@client manifests]$ puppet apply w.pp 
Notice: Scope(Class[main]): A person named austin powers, secret agent is here to see you.
Notice: Compiled catalog for client.example.com in environment production in 0.06 seconds
Notice: Applied catalog in 0.01 seconds

cette fonction sert principalement à isoler les variables dans des scopes privés.

- Capture des extra parameters : 
habituellement les variables récupérées par lambda sont au nombre de 1 ou 2.
Bien qu'avec split() et with() ont puisse passer un nombre plus importants : on peut utiliser le "*" qui va donc récupérer les arguments qui restent pour les assigner à une variable.
on récupère tout le reste des args et on l'insere dans une variable dont le contenu sera systematiquement un tableau.

[vagrant@client manifests]$ cat star.pp 
$hosts_line = '192.168.250.6 puppetserver.example.com puppet.example.com puppetserver'
$host = $hosts_line.split(' ')
with( *$host ) |$ipaddr, $hostname, *$aliases| {
  notice( "Host ${hostname} has IP ${ipaddr} and aliases ${aliases}" )
  }

[vagrant@client manifests]$ puppet apply star.pp 
Notice: Scope(Class[main]): Host puppetserver.example.com has IP 192.168.250.6 and aliases [puppet.example.com, puppetserver]
Notice: Compiled catalog for client.example.com in environment production in 0.07 seconds
Notice: Applied catalog in 0.01 seconds



== Chapitre 6 : Controle ressource processing : =

https://docs.puppet.com/puppet/latest/metaparameter.html

on peut controller comment puppet gere ses ressources en utilisant certains metacharacteres: qui sont des attributs communs que l'on peut utiliser avec les ressources built-in et celles que l'on customize soit même.

- aliases : 
comme on le sait chaque ressource du même type doit être unique.
Chaque ressource a un attribut que l'on nomme namevar qui sert à l'identifier de manière unique.Si la namevar n'est pas définie elle prend par défault le titre de la ressource
On a un namevar dedié par type de resource.
https://docs.puppet.com/puppet/latest/type.html

Pour simplifier la gestion des ressources on peut utiliser des alias qui peuvent simplifier certaines ressourses dont le comportement peut changer (ex : emplacement sur un fichier disque )
on peut mettre en place un alias soit en indiquant un 'nom' dans le 'titre' de notre ressource :

file { 'the-testfile':
ensure  => present,
path    => '/tmp/testfile.txt',
content => "holy cow!\n",
}
on peut de manière plus claire pour les personnes non habituées à puppet , rajouter à un alias en tant que metacaractere : 

file { '/tmp/testfile.txt':
ensure  => present,
alias   => 'the-testfile'
content => "holy cow!\n",
}

- noop : no operation :

on peut utiliser le metacaractere noop pour permettre de tester le fonctionnement d'une modification sans l'application du changement : cela nous permet de voir pendant le run le dérouler de ce qui se passera : 

package { 'puppet-agent':
ensure => latest,
noop   => true,
}

C'est le meme comportement que le dry run que l'on passe avec le --noop qu'on met en argument sur la ligne de commande : 
attention on ne peut pas overrider en cli ce qui est defini dans les params des ressources  : les fichiers de conf sont prioritaires.


[vagrant@client ~]$ puppet apply --noop  manifests/helloworld.pp 
Notice: Compiled catalog for client.example.com in environment production in 0.06 seconds
Notice: /Stage[main]/Main/Notify[greeting]/message: current_value absent, should be hello, world ! (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 1 events
Notice: Stage[main]: Would have triggered 'refresh' from 1 events
Notice: Applied catalog in 0.01 seconds


