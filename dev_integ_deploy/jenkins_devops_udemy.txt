=== notes sur cours jenkins ci / cd  devops udemy : ===

== introduction : ==
jenkins est un outil de ci (continous integration) et cd (continious delivery) ecrit en java.
C'est un serveur d'automatisation pour le build et deployment d'appli.
une des grandesforces de jenkins est le nombre des plugins dispo.
Dans la pratique on va vetifier et publier le code en declenchant des builds et des tests.
Classiquement on va pousser notre code dans notre outil de versioning de code (git ..), ce code sera ensuite buildé et tester par jenkins.
NB :jenkins ne merge pas le code et ne resoud pas les conflits : cela reste a la charge du dev.
L'avantage est de pouvoir fixer imédiatement les erreurs apres les erreurs de builds : le code est encore frais dans la tête.
Il est possible de publier chaque commit par un build .

on va donc pouvoir améliorer le SDLC : software developement life cycle. (le fait de produire du code sur les envs dev/test/qa/prod ..par ex)

dev ->  build                   ->  tests                 ->   releases -> deploy / provision ->  customer
        features                    unit tests                 package                        
        master branches             integration tests
        compile                     regression tests 
                                    user acceptance tests (uat) 
                                    ...

== installation : ==
on va utiliser une vm vagrant dans laquelle on va installer docker 

vagrant 
 $ vagrant init 
 $ vagrant up
 $ vagrant ssh
puis en root sur notre vm :

apt-get update && apt-get upgrade -y
apt-get install docker.io 
systemctl enable docker
systemctl start docker
ps fauxw |grep docker
root@ubuntu-xenial:~# usermod -aG docker ubuntu


# run jenkins :

on recupere un docker contenant jenkins : https://hub.docker.com/_/jenkins/ :on a ici le repo officiel du docker jenkins : 
docker pull jenkins  
puis on applique les settings suivants :
mkdir -p /var/jenkins_home
chown -R 1000:1000 /var/jenkins_home


docker run -p 8080:8080 -p 50000:50000 -v /var/jenkins_home:/var/jenkins_home -d --name jenkins jenkins
on lance donc ici le container jenkins downloader (docker run jenkins en s'assurant que le port 8080 est bien exposé, et on mappe le volume /var/jenkins_home de notre container sur le repertoire qu'on a créer précédemment. ) 
 

NB : dans notre cas comme on est sur une vm vagrant on va rediriger le port jenkins pour cela on ajoute dans notre ficher Vagrantfile à la racine de notre projet :
 config.vm.network "forwarded_port", guest: 8080, host: 8181

pour pouvoir attaquer  depuis notre navigateur notre jenkins via :
http://localhost:8181


on doit pouvoir acceder à jenkins via notre navigateur : normalement sur une install "normale" :
curl -I http://ip:8080

on arrive sur une page qui nous demande de saisir le mdp setté dans la conf jenkins :

root@ubuntu-xenial:~# cat /var/jenkins_home/secrets/initialAdminPassword 
blabllasdqsdqdqsdq


on saisit le mdp puis on choisis select installed plugins.

on cree un nouveau user pour l'administration de jenkins :

admin
admin

puis on valide : la premiere page de jenkins apparait.


== build et deployment d'une premiere application via la gui :  ==

pour l'exemple une appli node.js va être utilisée :
javascript runtime, cross platform et executée coté server 
la force est la reactivité car ce langage implemente des events asynchrones : ex peut retourner immédiatement le resultat d'une requette a un client et en asynchrone update la db : ce qui prend plus de temps.
pour notre exemple celasera parfait car le projet est tres simple à comprendre, prend peu de ressources et ne requiert pas de temps de compilation comme pour java.
cet exemple pourra servir de bonne base pour un gros projet.

- Comment build une appli node.js :

-> installer les dependances :downloade et installer tous les compoasants npm install
-> tester tous les cas npm tests : ex si un test echoue : le build failed et les devs sont notifiés.

une fois que c'est ok il va falloir packager pour déployer 

-> package :

on va pouvoir utiliser docker : creer un container qui contiendra tous nos binaires, codes etc ...
on peut preferer cette methode plutot que faire un tgz de toute notre appli et ses dependances .
On s'assure dans ce cas que le comportement est identique quelque soit l'environement sur lequel on travail (dev/prod ...)

-> distribution :
on va pouvoir ensuite mettre a dispo sur un repo (registry, hub docket public ..etc) notre container.


- tuto :

le code de l'appli est dispo sur le repos :
https://github.com/wardviaene/docker-demo

1 / via la gui :
on va pour commencer configurer notre appli via la gui.

pour notre projet il va falloir installer des dépendances node js : il faut donc installer un plugin :

depuis la home 
administrer jenkins
gestions des plugins 
> plugins  disponibles : 
on cherche notre plugin :￼	
NodeJS Plugin
on installe sans  redemarrer puis dans la seconde page on clic sur redémarrer ( pas clair ..)

on retourne sur la home :


Avant de configurer notre job on va definir le path de nodejs pour que les binaires soient correctement utilisés par jenkins 
home 
> administration jenkins > gestion global des  outils ->  dans la section NodeJs on clic et on donne le nom nodejs :qui servira d'alias pour notre env dans le setting de notre job : on clic sur save .

creer a new job 
-> nodejs_exemple_app
freestyle project : ok

dans la nouvelle page :

dans la section gestion du code on selectionne git 
puis on rentre l'url du code du projet : 
https://github.com/wardviaene/docker-demo.git

on va ensuite selectionner nodejs dans la  section environnement de notre build :
on voit automatiquement que le path est rempli par l'alias qu'on a defini plus tôt dans la conf des outils 

on va ensuite ajouter une action a notre build 
dans la section build on va ajouter un script shell : dans notre cas 
npm install 

qui se chargera d'installer les dependances que l'on a dans le source de notre appli nodejs .
la commande est bien installée et le path bien dispo maintenant pour jenkins.

maintenant on peut sauver notre conf, puis lancer le build via le bouton built now / lancer le build . on peut voir la sortie de console : console output de notre build

on a donc si notre build se passe bien notre app de prete :

on peut aller sur le serveur jenkins et voir que notre appli est bien créee : on a recupérer les sources sur le repo, puis lancer l'install des dependances via notre commande npm install :

root@ubuntu-xenial:/var/jenkins_home/workspace/nodejs_exemple_app# ls
docker-compose.yml  index-db.js  misc          package.json       test
Dockerfile          index.js     node_modules  package-lock.json


t@ubuntu-xenial:/var/jenkins_home/workspace/nodejs_exemple_app# cat  Dockerfile FROM node:4.6
WORKDIR /app
ADD . /app
RUN npm install
EXPOSE 3000
CMD npm start
root@ubuntu-xenial:/var/jenkins_home/workspace/nodejs_exemple_app# cat package.json 
{
  "name": "myapp",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "start": "node index.js",
    "test": "mocha"
  },
  "engines": {
    "node": "^4.6.1"
  },
  "dependencies": {
    "express": "^4.14.0",
    "mysql": "^2.10.2"
  },
  "devDependencies": {
    "mocha": "^3.4.2"
  }
}

Une fois que notre build est pret nous allons pouvoir packager notre appli et enfin la distribuer.

le packaging utilisé pour notre exemple est docker : on va donc builder une image docker avec notre app et uploader cette img sur la registry docker pour la rendre accessible en la publiant.

Nous allons devoir du fait de notre installation de jenkins (elle même dockerisée ) faire des petites bidouilles pour permettre a jenkins (docker) de builder notre app (docker) : une installation jenkins classique ne demande pas ces bidouilles mais ici il va falloir rendre dispo le socket de communication docker  accessible pour jenkins docker et le build de l'image docker .

on va devoir rajouter un plugin à jenkins pour gérer docker 

on relance notre container s'il est eteint 

docker jenkins start 

administration jenkins -> manage plugins -> on recherche docker -> puis on selectionne et on installe le plugin "cloudbees docker build and publish plugin"

on va maintenant nous assurer que docker run sur notre system et puisse permettre a jenkins d'acceder au socket de l'api docker pour builder

on va tout d'abord recupérer une image docker avec la conf necessaire :

root@ubuntu-xenial:~# git clone https://github.com/wardviaene/jenkins-docker 
Cloning into 'jenkins-docker'...
remote: Counting objects: 12, done.
remote: Total 12 (delta 0), reused 0 (delta 0), pack-reused 12
Unpacking objects: 100% (12/12), done.
Checking connectivity... done.
root@ubuntu-xenial:~# ls
jenkins-docker
root@ubuntu-xenial:~# cd jenkins-docker/
root@ubuntu-xenial:~/jenkins-docker# ls
Dockerfile  README.md

on voit ici ce qui est préparé : 

root@ubuntu-xenial:~/jenkins-docker# cat Dockerfile 
FROM jenkins
USER root

RUN mkdir -p /tmp/download && \
 curl -L https://get.docker.com/builds/Linux/x86_64/docker-1.13.1.tgz | tar -xz -C /tmp/download && \
 rm -rf /tmp/download/docker/dockerd && \
 mv /tmp/download/docker/docker* /usr/local/bin/ && \
 rm -rf /tmp/download && \
 groupadd -g 999 docker && \
 usermod -aG staff,docker jenkins

user jenkins

/!\ Attention : dans notre cas une vm vagrant qui heberge le docker jenkins : il va falloir modifier le dockerfile et s'assurer que le bon id de groupe sera donné pour que jenkins ait correctement acces au commande docker.
l'id 999 present dans le dockerfile de base est deja pri par vboxnet . on va donc sette l'id 116 qui correspond au groupe docker sur notre systeme :
groupadd -g 116 docker


On va maintenant builder notre image docker :

root@ubuntu-xenial:~/jenkins-docker# docker build -t jenkins-docker .
Sending build context to Docker daemon 62.46 kB
Step 1/4 : FROM jenkins
 ---> 5fc84ab0b7ad
Step 2/4 : USER root
 ---> Running in fddc0087d5db
 ---> b45ecb5eb46f
Removing intermediate container fddc0087d5db
Step 3/4 : RUN mkdir -p /tmp/download &&  curl -L https://get.docker.com/builds/Linux/x86_64/docker-1.13.1.tgz | tar -xz -C /tmp/download &&  rm -rf /tmp/download/docker/dockerd &&  mv /tmp/download/docker/docker* /usr/local/bin/ &&  rm -rf /tmp/download &&  groupadd -g 999 docker &&  usermod -aG staff,docker jenkins
 ---> Running in b02aea74477f
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 26.5M  100 26.5M    0     0  1207k      0  0:00:22  0:00:22 --:--:-- 1212k
 ---> fdc7e0c6e919
Removing intermediate container b02aea74477f
Step 4/4 : USER jenkins
 ---> Running in 66f9ac6034d4
 ---> d5dee0036c74
Removing intermediate container 66f9ac6034d4
Successfully built d5dee0036c74

on a donc maintenant une nouvelle image docker sur notre systeme qui embarque ce qu'on avait avec jenkins de base mais qui embarque en plus le docker client.
on va pouvoir supprimer l'ancien docker : 
root@ubuntu-xenial:~/jenkins-docker# docker stop jenkins 
jenkins
root@ubuntu-xenial:~/jenkins-docker# docker rm jenkins 
jenkins

le contenu de notre appli est toujours dispo :

root@ubuntu-xenial:~/jenkins-docker# ls /var/jenkins_home/
config.xml                                          jenkins.install.UpgradeWizard.state                        queue.xml.bak
copy_reference_file.log                             jenkins.mvn.GlobalMavenConfig.xml                          secret.key
hudson.model.UpdateCenter.xml                       jenkins.plugins.nodejs.tools.NodeJSInstallation.xml        secret.key.not-so-secret
hudson.plugins.emailext.ExtendedEmailPublisher.xml  jobs                                                       secrets
hudson.plugins.git.GitTool.xml                      logs                                                       tools
hudson.plugins.gradle.Gradle.xml                    nodeMonitors.xml                                           updates
hudson.tasks.Ant.xml                                nodes                                                      userContent
hudson.tasks.Maven.xml                              org.jenkinsci.plugins.docker.commons.tools.DockerTool.xml  users
identity.key.enc                                    org.jenkinsci.plugins.gitclient.JGitApacheTool.xml         war
init.groovy.d                                       org.jenkinsci.plugins.gitclient.JGitTool.xml               workflow-libs
jenkins.CLI.xml                                     plugins                                                    workspace
jenkins.install.InstallUtil.lastExecVersion         queue.xml

on va maintenant lancer notre nouveau container en ajoutant un nouveau volume permettant la communication entre notre docker client et le docker de notre vm via le socket dédié :

docker run -p 8080:8080 -p 50000:50000 -v /var/jenkins_home:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -d --name jenkins jenkins-docker
93ff834fc5369d6e9f2db67789335d7aae1d031c726ed863ac9892ba633c8647
on voit donc que notre image docker jenkins-docker tourne sous le nom jenkins avec les ports dediés et on voit que le socket /var/run/docker.sock est bien present avec les bons droits settés dans le build : group docker present pour permettrer l'acces au socket pour le client :
t@ubuntu-xenial:~/jenkins-docker# docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                                              NAMES
93ff834fc536        jenkins-docker      "/bin/tini -- /usr..."   About a minute ago   Up About a minute   0.0.0.0:8080->8080/tcp, 0.0.0.0:50000->50000/tcp   jenkins
root@ubuntu-xenial:~/jenkins-docker# ls /var/run/docker.sock -l
srw-rw---- 1 root docker 0 Feb 11 03:51 /var/run/docker.sock

on va tester qu'on a bien acces depuis notre container : on lance le container avec bash en argument pour rentrer dedans et on voit que le socket est bien dispo :
root@ubuntu-xenial:~/jenkins-docker# docker exec -it jenkins bash 
jenkins@3988916d20e6:/$ ls -l /var/run/docker.sock 
srw-rw---- 1 root docker 0 Feb 11 03:51 /var/run/docker.sock

on peut donc avoir acces au commande docker depuis notre container et on peut donc builder nos images docker depuis un docker :)
jenkins@3988916d20e6:/$ docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                              NAMES
3988916d20e6        jenkins-docker      "/bin/tini -- /usr..."   34 seconds ago      Up 33 seconds       0.0.0.0:8080->8080/tcp, 0.0.0.0:50000->50000/tcp   jenkins


on va donc maintenant configurer notre build pour qu'il prenne en compte docker pour le packaging de notre image , et la publication .

on ajoute une etape a notre build apres npm install on ajoute :

"docker build and publish"

on ajoute le nom de notre projet : il faut le creer au prealable sur le hub docker 
docker-nodejs-dummy

on ajoute nos credentials : compte et mdp dans la section registry credentials on sauvegarde
puis on selectionne notre user nouvellement creer dans la liste 

on peut examiner les param avances mais on laisse par defaut :
il peut etre tres important de voir qu'on peut installer docker via ce biai ( nous l'avons fait au prealable sur notre server pour les gestions de partage de socket etc ...)

on sauvegarde et on lance notre build :

on a donc tout le deroulement de notre build au deployment sur la registry :

on voit tout le build se passer notre docker est builder avec l'appli puis pousser sur le hub docker : et on voit le resultat de notre push en direct sur le hub docker

latest  256 MB  4 minutes ago

on va pouvoir  tester depuis n'importe quel pc 
ex :

sudo docker pull fredsobon/docker-nodejs-dummy
on lance le docker en exposant le port 3000 pour notre appli :


sudo docker run -p 3000:3000 --name nodejs-demo fredsobon/docker-nodejs-dummy
npm info it worked if it ends with ok
npm info using npm@2.15.11
npm info using node@v4.6.2
npm info prestart myapp@0.0.1
npm info start myapp@0.0.1

> myapp@0.0.1 start /app
> node index.js

Example app listening at http://:::3000


on peut ouvrir un navigateur et voir le resultat de notre appli :
http://localhost:3000
Hello World! 


== build and publish app - methode via code : ==

L'idee est d'adopter la philosophie devops
on va coder infra as code : pour permettre de versionner, controler le code .
on va pouvoir utiliser un language interne a jenkins un dsl pour faire la conf de nos jobs et on va pouvoir utiliser le jenkins pipeline pour gérer les builds


on va d'abord s'assurer pour travailler avec le dsl de jenkins , s'assurer que le plugin dédié est bien installé :

admin jenkins -> gestion de plugins -> on recherche "jobs" et on selectionnele plugin "job dsl" pour l'installer.
 
on va créer un nouveau projet : "seed project" 
on selectionne un freestyle project

on va importer le code d'un repo git :

https://github.com/wardviaene/jenkins-course

on ajoute un process de build en selectionnant jobs dsl : "process jobs DSLs"

on va rajouter le chemin contenant la description de notre job en dsl (present sur notre systeme une fois le repo cloné) 

job-dsl/nodejs.groovy
puis on sauvegarde notre conf 
on va maintenant lancer notre  build qui va se finir par une erreur :

"Processing DSL script nodejs.groovy
ERROR: script not yet approved for use
Finished: FAILURE"

c'est un mecanisme de protection car le script doit être approuvé :

on retourne dans la config de jenkins et dans la section In-process Script Approval on va qu'on a un script a valider : 

In-process Script Approval
Allows a Jenkins administrator to review proposed scripts (written e.g. in Groovy) which run inside the Jenkins process and so could bypass security restrictions. 1 scripts pending approval.

On peut examiner le script : on voit donc la source du script qui vient de github, le schedule de build : toutes les 5 minutes lors d'un changement de conf , on voit ensuite que l'appli utilise du nodejs en "wrapper" et on remarque que le nom nodejs que l'on a sette en tout debut dans la gui est recupérer ici pour le dsl,  on voit finalement dans la section step la commandenpm install :



job('NodeJS example') {
    scm {
        git('git://github.com/wardviaene/docker-demo.git') {  node -> // is hudson.plugins.git.GitSCM
            node / gitConfigName('DSL User')
            node / gitConfigEmail('jenkins-dsl@newtech.academy')
        }
    }
    triggers {
        scm('H/5 * * * *')
    }
    wrappers {
        nodejs('nodejs') // this is the name of the NodeJS installation in 
                         // Manage Jenkins -> Configure Tools -> NodeJS Installations -> Name
    }
    steps {
        shell("npm install")
    }
}

on va cliquer sur approuver le script, on retourne dans la section de notre projet et on relance un build.
on voit que le build est ok et que sur la sortie on a la creation d'un job :

Processing DSL script nodejs.groovy
Added items:
    GeneratedJob{name='NodeJS example'}
Finished: SUCCESS

on voit sur la home de nos projets maintenant l'apparition de "NodeJS example" en nouveau job.
Si on relance le build on voit sur la sortie console que ce job existe déja et donc que jenkins ne le recrée pas :

Existing items:
    GeneratedJob{name='NodeJS example'}
Finished: SUCCESS

si on examine la conf du job en gui : on retrouve ce qui a été défini dans le script dsl .
on va lancer le build de notre job puis on va verifier en ssh sur notre serveur la presence de notre build dans le workspace de notre docker :

root@ubuntu-xenial:/var/jenkins_home/workspace# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                              NAMES
3988916d20e6        jenkins-docker      "/bin/tini -- /usr..."   5 hours ago         Up 5 hours          0.0.0.0:8080->8080/tcp, 0.0.0.0:50000->50000/tcp   jenkins
root@ubuntu-xenial:/var/jenkins_home/workspace# docker exec -it 3988916d20e6 bash
jenkins@3988916d20e6:/$ ls -l /var/jenkins_home/workspace/NodeJS\ example/
total 56
-rw-r--r--  1 jenkins jenkins    80 Feb 11 09:50 Dockerfile
-rw-r--r--  1 jenkins jenkins   356 Feb 11 09:50 docker-compose.yml
-rw-r--r--  1 jenkins jenkins  1055 Feb 11 09:50 index-db.js
-rw-r--r--  1 jenkins jenkins   325 Feb 11 09:50 index.js
drwxr-xr-x  2 jenkins jenkins  4096 Feb 11 09:50 misc
drwxr-xr-x 91 jenkins jenkins  4096 Feb 11 09:50 node_modules
-rw-r--r--  1 jenkins jenkins 23925 Feb 11 09:50 package-lock.json
-rw-r--r--  1 jenkins jenkins   298 Feb 11 09:50 package.json
drwxr-xr-x  2 jenkins jenkins  4096 Feb 11 09:50 test

on a bien la presence de notre build .
on va chercher la presence de binaire nodejs :
jenkins@3988916d20e6:/$ find ~ -name nodejs
/var/jenkins_home/tools/jenkins.plugins.nodejs.tools.NodeJSInstallation/nodejs
/var/jenkins_home/plugins/nodejs
/var/jenkins_home/plugins/nodejs/META-INF/maven/org.jenkins-ci.plugins/nodejs

 on fait ensuite un export de notre PATH pour avoir les binaires à dispo :

jenkins@3988916d20e6:/$ export PATH=$PATH:/var/jenkins_home/tools/jenkins.plugins.nodejs.tools.NodeJSInstallation/nodejs/bin
jenkins@3988916d20e6:/$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/var/jenkins_home/tools/jenkins.plugins.nodejs.tools.NodeJSInstallation/nodejs/bin

on va dans workspace de notre appli et on la lance . tout est ok :
jenkins@3988916d20e6:/$ cd /var/jenkins_home/workspace/NodeJS\ example/
jenkins@3988916d20e6:~/workspace/NodeJS example$ npm start

> myapp@0.0.1 start /var/jenkins_home/workspace/NodeJS example
> node index.js

Example app listening at http://:::3000


on peut relancer un docker et recupérer le resultat de notre requette :

root@ubuntu-xenial:~# docker exec -it 3988916d20e6 bash
jenkins@3988916d20e6:/$ curl http://localhost:3000
Hello World (v1.0.2)!jenkins@3988916d20e6:/$ 

ou directement :
root@ubuntu-xenial:~# docker exec -it 3988916d20e6 curl http://localhost:3000
Hello World (v1.0.2)!root@ubuntu-xenial:~# 


on va maintenant créer un nouveau job qui va permettre de créer l'image docker et la pousser sur le hub :


on va se baser sur le fichier : nodejsdocker.groovy du repo git clone  https://github.com/wardviaene/jenkins-course

on voit que le debut du job est identique : on defini le repo git, le trigger , le wrapper .On va cette fois en action definir un build d'image docker et on va specifier le numero de tag de notre repo en version :

cat nodejsdocker.groovy

job('NodeJS Docker example') {
    scm {
        git('git://github.com/wardviaene/docker-demo.git') {  node -> // is hudson.plugins.git.GitSCM
            node / gitConfigName('DSL User')
            node / gitConfigEmail('jenkins-dsl@newtech.academy')
        }
    }
    triggers {
        scm('H/5 * * * *')
    }
    wrappers {
        nodejs('nodejs') // this is the name of the NodeJS installation in 
                         // Manage Jenkins -> Configure Tools -> NodeJS Installations -> Name
    }
    steps {
        dockerBuildAndPublish {
            repositoryName('wardviaene/docker-nodejs-demo')
            tag('${GIT_REVISION,length=9}')
            registryCredentials('dockerhub')
            forcePull(false)
            forceTag(false)
            createFingerprints(false)
            skipDecorate()
        }
    }
}

on voit la variable GIT_REVISION utilisée dans notre dsl de job :
tag('${GIT_REVISION,length=9}')
on voit qu'on va aussi gérer nos credentials etc ...

on va modifier la conf pour faire pointer sur notre docker hub : fredsobon/docker-nodejs-dummy

on a toute la doc nécéssaire sur la gestion dsl de jenkins : 

http://jenkinsci.github.io/job-dsl-plugin/


on peut chercher dans la page docker : et on voit par exemple pour la section dockerBuildAndPublish des infos :

dockerBuildAndPublish
Requires CloudBees Docker Build and Publish plugin v1.2+ Since 1.39
dockerBuildAndPublish {}
Builds and pushes a Docker based project to the Docker registry.
Examples
job('example') {
    steps {
        dockerBuildAndPublish {
            repositoryName('example/project-a')
            tag('${BUILD_TIMESTAMP}-${GIT_REVISION,length=7}')
            registryCredentials('docker-hub')
            forcePull(false)
            createFingerprints(false)
            skipDecorate()
        }
    }
}

on voit donc que ce site est la reference si on veut gérer nos jobs en dsl 

on va donc modifier notre projet precedent :
et ajouter le fichier suivant dans notre projet : pour continuer apres le build de notre appli et packager et publier notre app dans un docker sur le hub :


job-dsl/nodejsdocker.groovy


on va ajouter des credentials :

notre user /mdp du hub docker et en ajoute dans la section credentials : dockerhub

qui sera donc utiliser par jenkins comme variable non exposée : on peut ajouter une description pour faciler la lecture en cas de nombreux users.

on relance notre build : comme precedemment se sera un echec : car il faudra approuver le script  nodejsdocker.groovy : une fois fait on relance le build et c'est ok.

on voit qu'on a un nouveau job : NodeJS Docker example
de creee : si on examine sa conf on voit tous les param definis en dsl 

 
on lance le build :

et on voit quand c'est fini sur le hub docker l'arrivée d'un nouveau container flaggué avec le tag du git :

06747d8e1     259 MB     2 minutes ago


on va pouvoir recupérer le container et l'executer en exposant le port 3000 

root@ubuntu-xenial:~# docker run -p 3000:3000 --name nodejs-demo fredsobon/docker-nodejs-dummy
npm info it worked if it ends with ok
npm info using npm@2.15.11
npm info using node@v4.6.2
npm info prestart myapp@0.0.1
npm info start myapp@0.0.1

> myapp@0.0.1 start /app
> node index.js

Example app listening at http://:::3000


si on lance le docker dans notre vm : on pourra grace à une redirection de port dans le Vagrantfile interroger via notre machine host en curl ou via navigateur :

https://localhost:3001 

Hello World (v1.0.2)!

en supposant que le port sur notre machine est le 3001 :

  config.vm.network "forwarded_port", guest: 3000, host: 3001



