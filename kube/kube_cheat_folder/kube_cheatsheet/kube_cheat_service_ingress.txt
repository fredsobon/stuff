==== cheat sheets sur service ingress === 


= services : 

- definition de service : 

on va rendre disponible un service qui au sein de notre cluster va rediriger le traffic vers un /des pods


apiVersion: v1
kind: Service
metadata:
  name: bobsvc
spec:
  ports:
  - port: 80          << port sur lequel le service sera disponible 
    targetPort: 8080    << port du container vers lequel le service enverra le traffic
  selector:
    app: bob          << tous les pods ayant le label 'bob' feront parti du service et le kubeproxy forwardera le traffic vers chacun de ses pods

examiner notre service crée :

$ kubectl get svc
NAME       CLUSTER-IP       EXTERNAL-IP    PORT(S)   AGE
kubernetes  10.111.240.1    <none>         443/TCP    30d
bobsvc       10.111.249.107  <node>         80/TCP      1m

- executer une commande curl depuis un pod pour interroger un service :  

$ kubectl exec kube-pod-1233 -- curl -s http://10.111.249.107
hello world!

on aura biensur auparavant recupérer l'ip de notre service  avec un kubectl get service (svc)  -n un name_space


Le "--" de kubectl indique la fin de l'option de commande et que tout se qui est apres est la commande a executer depuis le pod.
Ceci est optionnel si la commande que l'on passe n'a pas d'argument avec un "-" mais dans notre cas c'est necessaire : le -s d'option de curl serait interpreeté comme une option de kubectl exec et nous retournerait une erreur.


Dans le  cas ou notre service redirige vers plusieurs pods : il peut être utile de sticker les requettes d'un client sur un pod en particulier : dans ce cas on va definir dans notre service une sessionAffinity qui peut prendre  deux valeurs : None / ClientIP


apiVersion: v1
kind: Service
spec:
sessionAffinity: ClientIP

Dans le cas ou on set l'option : le kube proxy redirigera systematiquement les requettes de la même ip source vers le même pod.

/!\ Attention il n'y a pas de mecanisme de cookie : kube n'agit qu'au niveau tcp/ udp : la payload http n'est pas pri en compte.



- Multiples ports : 

Si nos pods ecountent sur plusieurs ports on peut définir un service qui expose plusieurs ports :
on peut par exemple definir un service qui va exposer les ports 80 et 443 qui seront redirigés respectivememnt vers les  pods  qui exposent les ports 80 et 443 :

apiVersion: v1
kind: Service
metadata:
  name: bobsvc
spec:
  ports:
    - name: http
      port: 80
      targetPort: 8080
    - name: https
      port: 443
      targetPort: 8443
  selector:
    app: bob

/!\ attention ici on voit qu'on a un selector qui pointe sur tous les ports : notre service sera vu comme une seule entité : si on veut agir sur les ports distinctement il faudra configfurer plusieurs services.

- Utilisation des ports nommés : on va pouvoir définir les ports exposés par leur nom : ce qui peut être utilie pour des ports pas tres connus :
ex on va definir dans notre pod des noms pour nos ports .
ex :

kind: Pod
spec:
  containers:
    - name: boss
  ports:
    - name: http
      containerPort: 8080
    - name: https
      containerPort: 8443


ce qui va pouvoir être récupéré et utilisé dans notre service : 

apiVersion: v1
kind: Service
spec:
  ports:
    - name: http
      port: 80
      targetPort: http    <<<< on va ici referencer le port de notre pod qui est en fait le 8080  : le port 80 de notre service redirige vers le http ( 8080 de notre pod)
    - name: https
      port: 443
      targetPort: https   <<<< on va ici referencer le port de notre pod qui est en fait le 8443


on va pouvoir ainsi modifier le port d"un pod de maniere transparente ..puisque notre service pointe sur un "alias" nommé de notre port .

- Decouverte de services : 

on va pouvoir decouvrit des services via différents mecanismes .

-> variables d'environnement  :

quand on crée des services avant les pods : ceux ci vont pouvoir récupérer les infos de services à leur instanciation : on peut le voir en interrogeant les variables d'environment poussées dans ces pods 

kubectl exec pod-123 env 

-> dns : 
chaque service va avoir un enregistement dns qui pourra être intérrogé depuis un pod par exmemple


/!\ Attention une ip de service n'est pas pingable : c'est une ip virtuelle qui n'a pas de sens sans le port associé.


- Service externe au cluster :

il va être utile de pouvoir acceder à des ressources externes au cluster  : du coup pas des service hébergés sur des pods mais des ips/ports externes au cluster. 


