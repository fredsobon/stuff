==  minikube notes ===


= minikube star options : = 

L’instruction start permet deux choses : le démarrage du cluster et la création de la machine Minikube.
Cette instruction accepte un certain nombre d’options comme par exemple :
 --memory Mo : quantité de mémoire à donner à la machine (par défaut 2048, soit 2 Go).
 --kubernetes-version VERSION : version de Kubernetes à déployer (exemple : v1.14.2).
 --cpus Nbre : nombre de CPU à exposer à la machine (par défaut 2).
 --vm-driver Nom : nom du driver à utiliser (exemple : kvm2, vmware, none).

Ces options ne sont pas obligatoires sauf lors du déploiement sous KVM/libvirt. Dans ce cas, il est indispensable
d’ajouter l’option --vm-driver kvm2 .


== minikube - docker context : ==

il est possible de récupérer le contexte du démon Docker afin de pouvoir communiquer avec lui. Pour cela, lancez la commande
minikube suivie de l’instruction docker-env .
Ci­dessous la commande correspondante :

$ minikube docker-env
Cette commande renvoie un ensemble d’instructions sous la forme suivante :
export DOCKER_TLS_VERIFY="1"
export DOCKER_HOST="tcp://192.168.39.4:2376"
export DOCKER_CERT_PATH="/home/yannig/.minikube/certs"
export DOCKER_API_VERSION="1.35"
# Run this command to configure your shell:
# eval $(minikube docker-env)

Cette sortie ne sert pas directement à passer sur le contexte Docker de la machine Minikube.
Pour cela, il est nécessaire d’ajouter l’évaluation du résultat de cette commande de la manière suivante :
$ eval $(minikube docker-env)



== minikube montage host : ==

il est possible de monter un repertoire dans minikube :
ex: 
minikube mount "$(pwd):/minikube-host"

le rep courant sera donc dispo dans l'arbo minikube 

== utilisation images locale ==

eval $(minikube docker-env)

# Start minikube
minikube start

# Set docker env
eval $(minikube docker-env)

cat Dockerfile 
FROM fredsobon/kuard

docker build -t boogie/kuard:0.0.1 .

# Build image
docker build -t foo:0.0.1 .   <<<<<<< /!\ attention tagger l'image est fondamentale sinon minikube ne retrouve pas  l'image 


# Run in minikube   : on va indiquer a minikube de ne pas recupérer d'image distante : 
kubectl run kuard1 --image=boogie/kuard:0.0.1 --image-pull-policy=Never
deployment "kuard1" created

# Check that it's running
kubectl get pods

NAME                             READY     STATUS    RESTARTS   AGE
hello-minikube-6c47c66d8-rczth   1/1       Running   9          227d
kuard1-68fb5b4df4-c426v          1/1       Running   0          6m
nodejs-demo                      1/1       Running   2          226d


# Tests :

on peut obtenir la description de notre pod :

kubectl describe pods kuard1-68fb5b4df4-c426v 

toute une serie d'info apparaissent ..

on va pouvoir rediriger un port de notre hostt vers le port natif de notre pod :

kubectl port-forward kuard1-68fb5b4df4-c426v 8080:8080

en ouvrant un navigateur sur http://localhost:8080 on accede bien à la webapp de notre pod  
kubectl port-forward kuard1-68fb5b4df4-c426v 8080:8080



= images :

attention pour voir les images utilisées par minikube il faut charger l'env de son docker embarqué :

eval $(minikube docker-env)

docker images                                                         [☸ minikube:default]
REPOSITORY                                TAG                 IMAGE ID            CREATED             SIZE
gcr.io/kubernetes-helm/tiller             v2.14.3             2d0a693df3ba        4 days ago          94.2MB
jenkins/jenkins                           lts                 b137a5753eb1        2 weeks ago         567MB
k8s.gcr.io/kube-proxy                     v1.15.0             d235b23c3570        6 weeks ago         82.4MB
k8s.gcr.io/kube-apiserver                 v1.15.0             201c7a840312        6 weeks ago         207MB
k8s.gcr.io/kube-scheduler                 v1.15.0             2d3813851e87        6 weeks ago         81.1MB
k8s.gcr.io/kube-controller-manager        v1.15.0             8328bb49b652        6 weeks ago         159MB
k8s.gcr.io/kube-addon-manager             v9.0                119701e77cbc        6 months ago        83.1MB
k8s.gcr.io/coredns                        1.3.1               eb516548c180        6 months ago        40.3MB
k8s.gcr.io/kubernetes-dashboard-amd64     v1.10.1             f9aed6605b81        7 months ago        122MB
k8s.gcr.io/etcd                           3.3.10              2c4adeb21b4f        8 months ago        258MB
k8s.gcr.io/k8s-dns-sidecar-amd64          1.14.13             4b2e93f0133d        10 months ago       42.9MB
k8s.gcr.io/k8s-dns-kube-dns-amd64         1.14.13             55a3c5209c5e        10 months ago       51.2MB
k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64    1.14.13             6dc8ef8287d3        10 months ago       41.4MB
k8s.gcr.io/pause                          3.1                 da86e6ba6ca1        19 months ago       742kB
gcr.io/k8s-minikube/storage-provisioner   v1.8.1              4689081edb10        21 months ago       80.8MB

si on ne le fait pas ..on ne voit pas du tout le même pool d'images :

docker images
REPOSITORY                                            TAG                 IMAGE ID            CREATED             SIZE
artifact-docker-infra.meetic.ilius.net/debian-utils   1                   b03b2d9c736a        2 weeks ago         340MB
fredsobon/debian-utils                                1                   b03b2d9c736a        2 weeks ago         340MB
debian                                                testing             85b9d0cfd7ac        3 weeks ago         114MB
nginx-local                                           1                   ea1193fd3dde        4 weeks ago         20.6MB
nginx-local                                           latest              ea1193fd3dde        4 weeks ago         20.6MB
nginx                                                 alpine              ea1193fd3dde        4 weeks ago         20.6MB
kubetool                                              latest              958ff145c359        6 weeks ago         255MB
k8s.gcr.io/coredns                                    1.5.0               7987f0908caf        3 months ago        42.5MB
fredsobon/kuard                                       latest              72b285fe4d98        4 months ago        19.6MB



===== minikube addons : ===

on va pouvoir utiliser des plugins activables / desactivables pour le travail sur minikube.

une liste est disponible :

minikube addons list              
- addon-manager: enabled
- dashboard: enabled
- default-storageclass: enabled
- efk: disabled
- freshpod: disabled
- gvisor: disabled
- heapster: disabled
- ingress: enabled
- logviewer: disabled
- metrics-server: disabled
- nvidia-driver-installer: disabled
- nvidia-gpu-device-plugin: disabled
- registry: disabled
- registry-creds: disabled
- storage-provisioner: enabled
- storage-provisioner-gluster: disabled



- ingress :

exemple on va pouvoir activer ingress pour permettre d'acceder à nos services depuis l'exterrieur de notre cluster :

minikube addons enable ingress

on va verifier que l'ingress est bien monté avec :
kubectl get pods -n kube-system

kubectl get pods -n kube-system |grep ingress
nginx-ingress-controller-7b465d9cf8-h5vrx   0/1     ImagePullBackOff   0          6m42s

-> on peut deployer une appli :

kubectl run web --image=gcr.io/google-samples/hello-app:1.0 --port=8080
deployment.apps/web created

-> on va exposer le service de l'appli 

kubectl expose deployment web --target-port=8080 --type=NodePort
service/web exposed

-> on verifie que le service est crée et dispo en tant que node port 
kubectl get service web
Output:

NAME      TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
web       NodePort   10.104.133.249   <none>        8080:31637/TCP   12m
Visit the service via NodePort:

->  on va pouvoir récupérer l'url depuis laquelle le service sera  accessble 
minikube service web --url
http://172.17.0.15:31637


la premiere partie de notre déploiement est ok, mais on va maintenant créer une ressource ingress pour permettre un access "naturel" via url ...


-> on crée un fichier example-ingress.yaml 

apiVersion: networking.k8s.io/v1beta1 # for versions before 1.14 use extensions/v1beta1
kind: Ingress
metadata:
  name: example-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
 rules:
 - host: hello-world.info
   http:
     paths:
     - path: /*
       backend:
         serviceName: web
         servicePort: 8080

-> on créer la ressource ingress avec
kubectl apply -f example-ingress.yaml
ingress.networking.k8s.io/example-ingress created

-> on verifie que le service est crée :

kubectl get ingress
NAME              HOSTS              ADDRESS       PORTS     AGE
example-ingress   hello-world.info   172.17.0.15   80        38s


-> on peut ajouter notre record dans le fichier hosts :
172.17.0.15 hello-world.info


cela envoi nos requette de l'ingress au minikube 

on peut tester naturellement notre résultat : 

curl hello-world.info

Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564



= libvirt / kvm : =

sudo apt install libvirt-clients libvirt-daemon-system qemu-kvm
sudo usermod -a -G libvirt $(whoami)
newgrp libvirt
minikube start --vm-driver kvm2


