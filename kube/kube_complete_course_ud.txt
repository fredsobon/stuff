=== notes the complete kubernetes course  ===

= ch1 intro =

- Commandes utiles  : 

- se plugger a une pod en cours d'excution : 
kubectl attach podname   

 kubectl attach nodehelloworld.example.com                                                                                                  [☸ minikube:default]
Defaulting container name to k8s-demo.
Use 'kubectl describe pod/nodehelloworld.example.com -n default' to see all of the containers in this pod.
If you don't see a command prompt, try pressing enter.

- execution de commande au sein d'un pod :

boogie$ kubectl exec debian-pod -- ip a                                                                                                        [☸ minikube:default]
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: sit0@NONE: <NOARP> mtu 1480 qdisc noop state DOWN group default qlen 1000
    link/sit 0.0.0.0 brd 0.0.0.0
12: eth0@if13: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:05 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.5/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever

boogie$ kubectl -it exec debian-pod -- bash                                                                                                        [☸ minikube:default]
root@debian-pod:/# date
Tue Sep 10 19:28:13 UTC 2019


- port forwarding : on va pouvoir rediriger un port de notre machine vers le port d'un pod ecoutant dessus :
boogie$ kubectl port-forward nodehelloworld.example.com 8080:3000                                                                [☸ minikube:default]
Forwarding from [::1]:8080 -> 3000

sur notre poste :
curl http://localhost:8080                            [☸ minikube:default]
{
  "paths": [
    "/api",
    "/api/v1",
    "/apis",
    "/apis/",
    "/apis/admissionregistration.k8s.io",
...
boogie$ kubectl logs nodehelloworld.example.com               [☸ minikube:default]
npm info it worked if it ends with ok
npm info using npm@2.15.11
npm info using node@v4.6.2
npm info prestart myapp@0.0.1
npm info start myapp@0.0.1

> myapp@0.0.1 start /app
> node index.js

Example app listening at http://:::3000






- premiers manifests :


pod :
boogie$ cat first-app/helloworld.yml                                                                                                               [☸ minikube:default]
apiVersion: v1
kind: Pod
metadata:
  name: nodehelloworld.example.com
  labels:
    app: helloworld
spec:
  containers:
  - name: k8s-demo
    image: wardviaene/k8s-demo
    ports:
    - name: nodejs-port
      containerPort: 3000

service avec node port qui va matcher le container du pod précédent 

boogie$ cat first-app/helloworld-nodeport-service.yml                                                                                              [☸ minikube:default]
apiVersion: v1
kind: Service
metadata:
  name: helloworld-service
spec:
  ports:
  - port: 31001
    nodePort: 31001
    targetPort: nodejs-port
    protocol: TCP
  selector:
    app: helloworld
  type: NodePort


=== ch2 bases ===

= nodes :

kubelet -> pilote les set up de container dans les pods
kubeproxy > va s'occuper du routage des pods : permettre a tous les pods d'être contactables depuis le cluster et hors cluster en alimentant les regles iptables 

= replication controller : 

pour un appli stateless ( qui n'ecrit dans aucun fichier local ) pas d'etat : on va facilement pouvoir scaler.
La plupart des applis web sont stateless contrairement aux dbs qui sont stateful 
Attention pour les infrmations de sessions users web doivent être stockées hors containers.
Aucun fichier ne doit être sauvegarder dans un pod qui de part leur nature sont ephémeres.

On va scaller avec un object s'appelant replication controller : on defini le nombre de pod qu'on veut et kube s'assure que le nombre de ses containers actifs est toujours présent. Le container sera toujours recréee si il est delete ou ko 

boogie$ cat replication-controller/helloworld-repl-controller.yml                                                                                  [☸ minikube:default]
apiVersion: v1
kind: ReplicationController
metadata:
  name: helloworld-controller
spec:
  replicas: 2      <<< on defini le nombre de réplica
  selector:
    app: helloworld  <<< le selector va matcher les pods ayant le label app: helloworld
  template:
    metadata:
      labels:
        app: helloworld    <<<< le label de notre pod
    spec:
      containers:
      - name: k8s-demo
        image: wardviaene/k8s-demo
        ports:
        - name: nodejs-port      <<< on defini un nom a notre port pour l'identifier plus facilement lors d'appels ulterieurs (utiles pour les ports moins connus que 80 /443 par ex)
          containerPort: 3000


On voit qu"on a bien deux pods issus de notre replication controller : 

boogie$ kubectl get pod                                                                                                                            [☸ minikube:default]
NAME                          READY   STATUS    RESTARTS   AGE
debian-pod                    1/1     Running   9          36d
helloworld-controller-dv92r   1/1     Running   1          11h
helloworld-controller-ndlrd   1/1     Running   1          11h

si on delete un pod : le controller va en réinstancier un automatiquement :

boogie$ kubectl delete pod helloworld-controller-dv92r                                                                                             [☸ minikube:default]
pod "helloworld-controller-dv92r" deleted

boogie$ kubectl get pod                                                                                                                            [☸ minikube:default]
NAME                          READY   STATUS    RESTARTS   AGE
debian-pod                    1/1     Running   9          36d
helloworld-controller-fxhs8   1/1     Running   0          36s   <<< on voit ici qu'un nouveau pod a été popé pour remplacer celui qui a été détruit.
helloworld-controller-ndlrd   1/1     Running   1          11h

on peut scale en live le nombre de réplicat :

->on peut passer le fichier de replica en argumant en specifiant le nombre de pod désiré avant : 
boogie$ kubectl scale --replicas=3 -f helloworld-repl-controller.yml                                                                               [☸ minikube:default]
replicationcontroller/helloworld-controller scaled
 ~/Documents/learn/kubernetes/learn-devops-the-complete-kubernetes-course/kubernetes-course/replication-controller (master) [10:00:37]
boogie$ kubectl get pod                                                                                                                            [☸ minikube:default]
NAME                          READY   STATUS    RESTARTS   AGE
debian-pod                    1/1     Running   9          36d
helloworld-controller-fxhs8   1/1     Running   0          5m8s
helloworld-controller-ndlrd   1/1     Running   1          11h
helloworld-controller-qw6c4   1/1     Running   0          6s

->  on peut directement modifier le type d'objet replicationcontroller ( rc ) en le passant en argument :
ex : on reduit le nombre de pod en utilisant le nom du rc qu'on recupere avant avec un get rc :
 ~ [10:17:32]
boogie$ kubectl get rc                                                                                                                             [☸ minikube:default]
NAME                    DESIRED   CURRENT   READY   AGE
helloworld-controller   3         3         3       11h


boogie$ kubectl scale --replicas=1 rc/helloworld-controller                                                                                        [☸ minikube:default]
replicationcontroller/helloworld-controller scaled
 ~ [10:19:40]
boogie$ kubectl get pod                                                                                                                            [☸ minikube:default]
NAME                          READY   STATUS             RESTARTS   AGE
debian-pod                    1/1     Running            10         36d
helloworld-controller-fxhs8   0/1     ImagePullBackOff   0          24m
boogie$ kubectl get rc                                                                                                                             [☸ minikube:default]
NAME                    DESIRED   CURRENT   READY   AGE
helloworld-controller   1         1         0       11h

Biensur nous scallons de maniere horizontale notre appli c'est qu'elle est stateless 

on peut delete notre replicationcontroller facilement :

boogie$ kubectl delete rc helloworld-controller                                                                                                    [☸ minikube:default]
replicationcontroller "helloworld-controller" deleted
 ~ [10:22:41]
boogie$ kubectl get rc                                                                                                                             [☸ minikube:default]
No resources found.
 ~ [10:22:43]
boogie$ kubectl get pod                                                                                                                            [☸ minikube:default]
NAME                          READY   STATUS        RESTARTS   AGE
debian-pod                    1/1     Running       10         36d
helloworld-controller-fxhs8   0/1     Terminating   0          27m


= Deployment : 

on va d'abord  voir le replicaset qui est la version maintenue par kube puisque le replication  controller est deprecated.
on va pouvoir dans cet object utiliser des selectors qui vont nous permettre de filtrer de manière plus étendu qu'avec les replicationcontroller qui se contentaient de pouvoir fournir des filtres d'egalite ( ex :env: prod) 

le replicaset est utilisé dans l'object deployment : le deployment va nous permettre de déployer des app, de les updater . On defini un status pour notre appli et kube assure que ce status est bien up and running.
L'object deployment est plus facile a utiliser que le replicatcontroller / replicaset , demande moins d'intervention manuelle et offre plus de possiblilitées.

-> create un deployment
-> update un deployment 
-> rolling update : deployment sans impact
-> rollback a une version donnée
-> pause / resume : deployment d'un certain pourcentage de nos pods.

cat deployment/helloworld.yml 

apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: helloworld-deployment
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: helloworld
    spec:
      containers:
      - name: k8s-demo
        image: wardviaene/k8s-demo
        ports:
        - name: nodejs-port
          containerPort: 3000

- deployments commandes :

- kubectl get deployments
- kubectl get rs ( replicaset)
- kubectl get pods --show-labels                                                                                                             [☸ minikube:default]
NAME                         READY   STATUS    RESTARTS   AGE    LABELS
debian-pod                   1/1     Running   13         38d    <none>
nodehelloworld.example.com   1/1     Running   2          2d5h   app=helloworld

- kubectl rollout status  deployment/helloworld-deployment  : etat du deployment 
- kubectl set image deployment/helloworld-deployment k8s-demo=k8s-demo:2 run k8s-demo avec l'image k8s-demo:2 du label
- kubectl edit deployment/helloworld-deployment  : edition du deployment 
- kubectl rollout history deployment/helloworld-deployment  permet de  voir l'historique des versions déployées.
- kubectl rollout undo  deployment/helloworld-deployment permet de rollback sur la version déployée précédemment.
- kubectl rollout undo  deployment/helloworld-deployment --to-revision=N permet de rollback sur la version N déployée précédemment.


apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: helloworld-deployment
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: helloworld
    spec:
      containers:
      - name: k8s-demo
        image: wardviaene/k8s-demo
        ports:
        - name: nodejs-port
          containerPort: 3000

 kubectl create -f deployment/helloworld.yml

boogie$ kubectl get deployments                                                                                                                    [☸ minikube:default]
NAME                    READY   UP-TO-DATE   AVAILABLE   AGE
helloworld-deployment   3/3     3            3           2m8s

boogie$ kubectl get replicasets                                                                                                                    [☸ minikube:default]
NAME                               DESIRED   CURRENT   READY   AGE
helloworld-deployment-748f49d795   3         3         3       2m20s


boogie$ kubectl get pods --show-labels                                                                                                             [☸ minikube:default]
NAME                                     READY   STATUS    RESTARTS   AGE     LABELS
debian-pod                               1/1     Running   13         38d     <none>
helloworld-deployment-748f49d795-56h2r   1/1     Running   0          3m26s   app=helloworld,pod-template-hash=748f49d795
helloworld-deployment-748f49d795-n4fnd   1/1     Running   0          3m26s   app=helloworld,pod-template-hash=748f49d795
helloworld-deployment-748f49d795-rvczv   1/1     Running   0          3m26s   app=helloworld,pod-template-hash=748f49d795
nodehelloworld.example.com               1/1     Running   2          2d5h    app=helloworld

-> check de l'etat du deployment : 
boogie$ kubectl rollout status deployment helloworld-deployment                                                                                    [☸ minikube:default]
deployment "helloworld-deployment" successfully rolled out

-> modification de l'image utilisée : deploy d'une nouvelle version de notre app: 
boogie$ kubectl set image deployment/helloworld-deployment k8s-demo=wardviaene/k8s-demo:2                                                          [☸ minikube:default]
deployment.extensions/helloworld-deployment image updated
boogie$ kubectl get pods  --show-labels                                                                                                            [☸ minikube:default]
NAME                                     READY   STATUS        RESTARTS   AGE    LABELS
debian-pod                               1/1     Running       13         38d    <none>
helloworld-deployment-748d88f59f-8xw74   1/1     Running       0          36s    app=helloworld,pod-template-hash=748d88f59f
helloworld-deployment-748d88f59f-pwzl9   1/1     Running       0          30s    app=helloworld,pod-template-hash=748d88f59f
helloworld-deployment-748d88f59f-zh27v   1/1     Running       0          36s    app=helloworld,pod-template-hash=748d88f59f
helloworld-deployment-748f49d795-56h2r   1/1     Terminating   0          11m    app=helloworld,pod-template-hash=748f49d795
helloworld-deployment-748f49d795-n4fnd   1/1     Terminating   0          11m    app=helloworld,pod-template-hash=748f49d795
nodehelloworld.example.com               1/1     Running       2          2d5h   app=helloworld


boogie$ kubectl describe pod helloworld-deployment-748d88f59f-pwzl9                                                                                [☸ minikube:default]
Name:           helloworld-deployment-748d88f59f-pwzl9
Namespace:      default
Priority:       0
Node:           minikube/10.0.2.15
Start Time:     Fri, 13 Sep 2019 16:24:16 +0200
Labels:         app=helloworld
                pod-template-hash=748d88f59f
Annotations:    <none>
Status:         Running
IP:             172.17.0.15
Controlled By:  ReplicaSet/helloworld-deployment-748d88f59f
Containers:
  k8s-demo:
    Container ID:   docker://6d211169aa8da1588bf5a96d01e6df1e19646e53142e41f8030a1391a25abfc4
    Image:          wardviaene/k8s-demo:2
    Image ID:       docker-pullable://wardviaene/k8s-demo@sha256:c7536949ff900fb7dc923cf9f2475d1209766c65aa07325caf880e754e7e0fae
    Port:           3000/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Fri, 13 Sep 2019 16:24:18 +0200
    Ready:          True
    Restart Count:  0
    Environment:    <none>
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-wfc8r (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  default-token-wfc8r:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-wfc8r
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  <none>
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  61s   default-scheduler  Successfully assigned default/helloworld-deployment-748d88f59f-pwzl9 to minikube
  Normal  Pulling    60s   kubelet, minikube  Pulling image "wardviaene/k8s-demo:2"
  Normal  Pulled     59s   kubelet, minikube  Successfully pulled image "wardviaene/k8s-demo:2"
  Normal  Created    59s   kubelet, minikube  Created container k8s-demo
  Normal  Started    59s   kubelet, minikube  Started container k8s-demo

on a donc notre nouvelle appli déployée.

- Eamen de l'historique des versions déployés :

boogie$ kubectl rollout history  deployment/helloworld-deployment                                                                                  [☸ minikube:default]
deployment.extensions/helloworld-deployment
REVISION  CHANGE-CAUSE
1         <none>
2         <none>

on va pouvoir rollback et revenir a notre version précédente : 
boogie$ kubectl rollout undo  deployment/helloworld-deployment                                                                                     [☸ minikube:default]
deployment.extensions/helloworld-deployment rolled back

le rollback se passe bien ; 
boogie$ kubectl rollout status  deployment/helloworld-deployment                                                                                   [☸ minikube:default]
Waiting for deployment "helloworld-deployment" rollout to finish: 2 of 3 updated replicas are available...
deployment "helloworld-deployment" successfully rolled out

on voit nos différents  pods : 
 ~/Documents/learn/kubernetes/learn-devops-the-complete-kubernetes-course/kubernetes-course (master) [04:32:27]
boogie$ kubectl get pods  --show-labels                                                                                                            [☸ minikube:default]
NAME                                     READY   STATUS        RESTARTS   AGE     LABELS
debian-pod                               1/1     Running       13         38d     <none>
helloworld-deployment-748d88f59f-8xw74   1/1     Terminating   0          8m22s   app=helloworld,pod-template-hash=748d88f59f
helloworld-deployment-748d88f59f-pwzl9   1/1     Terminating   0          8m16s   app=helloworld,pod-template-hash=748d88f59f
helloworld-deployment-748d88f59f-zh27v   1/1     Terminating   0          8m22s   app=helloworld,pod-template-hash=748d88f59f
helloworld-deployment-748f49d795-fp79k   1/1     Running       0          11s     app=helloworld,pod-template-hash=748f49d795
helloworld-deployment-748f49d795-gp8qd   1/1     Running       0          11s     app=helloworld,pod-template-hash=748f49d795
helloworld-deployment-748f49d795-lddvl   1/1     Running       0          8s      app=helloworld,pod-template-hash=748f49d795
nodehelloworld.example.com               1/1     Running       2          2d5h    app=helloworld

on peut changer le nombre d'historique de version conservé de notre déployment :
avec le param revisionHistoryLimit: XX que l'on set dans notre déployment : 
  spec:
    progressDeadlineSeconds: 2147483647
    replicas: 3
    revisionHistoryLimit: 100
    selector:
      matchLabels:
        app: helloworld

on peut rollnack 
boogie$ kubectl rollout undo  deployment/helloworld-deployment                                                                                     [☸ minikube:default]
deployment.extensions/helloworld-deployment rolled back
 ~/Documents/learn/kubernetes/learn-devops-the-complete-kubernetes-course/kubernetes-course (master) [04:42:17]
boogie$ kubectl rollout history deployment                                                                                                         [☸ minikube:default]
deployment.extensions/helloworld-deployment 
REVISION  CHANGE-CAUSE
4         <none>

- on utilise une nouvelle image : 
boogie$ kubectl set image deployment/helloworld-deployment k8s-demo=wardviaene/k8s-demo:1                                                          [☸ minikube:default]
deployment.extensions/helloworld-deployment image updated

~/Documents/learn/kubernetes/learn-devops-the-complete-kubernetes-course/kubernetes-course (master) [04:48:45]
boogie$ kubectl rollout status  deployment/helloworld-deployment                                                                                   [☸ minikube:default]
Waiting for deployment "helloworld-deployment" rollout to finish: 2 out of 3 new replicas have been updated...

on voit qu'on a plusieurs versions historisées : 
boogie$ kubectl rollout history  deployment/helloworld-deployment
deployment.extensions/helloworld-deployment 
REVISION  CHANGE-CAUSE
4         <none>
5         <none>
6         <none>
7         <none>

on peut donc forcer le rollback dans une version particulière : 
boogie$ kubectl rollout undo  deployment/helloworld-deployment --to-revision=5                                                                     [☸ minikube:default]
deployment.extensions/helloworld-deployment rolled back


= services : 

les pods sont éphémeres  par nature :( detruits pendant les déployments etc ..)  nous ne devons pas acceder directement à eux : une couche intermédiaire est défini pour relier les clients ( au sens large: services, end-users ) aux services portés par les pods .
quand on utilise kubectl expose : on crée un service popur notre pod qui pourra être atteind de l'exterrieur .
Quand on crée un service on va créer un endpoint pour nos pods 
On peut utiliser plusieurs conf :

-> clusterip : ip uniquement accésible dans notre cluster kube ( c'est la conf de base si on ne précise rien : de base on crée un service en clusterip )
-> nodeport: c'est un port identique sur tous les nodes de notre cluster pour atteindre le service de l'exterrieur : on va utiliser un port situé dans un range entre 30000et 32267 pour faire matcher le port du pod sur le nodeport qui lui sera sticker sur le /les nodes de notre cluster.
-> loadbalancer : c'est utilisé dans le cloud. on va router le traffic externe vers le nodeport de nos nodes kube 

Les options montrées permettrent uniquement le creation de virtualsip ou de ports

on peut utiliser des entrées dns 
ExternalName peut fournir un nom dns a nos services.
ex : service discovery pour le dns.

-  service demo : 

oogie$ cat first-app/helloworld.yml                                                                                                               [☸ minikube:default]
apiVersion: v1
kind: Pod
metadata:
  name: nodehelloworld.example.com
  labels:
    app: helloworld
spec:
  containers:
  - name: k8s-demo
    image: wardviaene/k8s-demo
    ports:
    - name: nodejs-port
      containerPort: 3000

boogie$ cat first-app/helloworld-nodeport-service.yml                                                                                              [☸ minikube:default]
apiVersion: v1
kind: Service
metadata:
  name: helloworld-service
spec:
  ports:
  - port: 31001
    nodePort: 31001
    targetPort: nodejs-port
    protocol: TCP
  selector:
    app: helloworld
  type: NodePort

kubectl create -f first-app/helloworld.yml
kubectl create -f first-app/helloworld-nodeport-service.yml

boogie$ kubectl get svc                                                                                                                            [☸ minikube:default]
NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)           AGE
helloworld-service   NodePort    10.106.205.39   <none>        31001:31001/TCP   13h
kubernetes           ClusterIP   10.96.0.1       <none>        443/TCP           36d

on recupere le couple ip/port exposé dans minikube 
boogie$ minikube service helloworld-service --url                                                                                                  [☸ minikube:default]
http://192.168.99.100:31001

on voit sur notre poste qu'un reseau est monté dans le range :
boogie$ ip a |grep vboxnet3                                                                                                                        [☸ minikube:default]
8: vboxnet3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    inet 192.168.99.1/24 brd 192.168.99.255 scope global vboxnet3


on voit en examinant le service crée qu'on a bien un service de type NodePort et une ClusterIp : cette ip n'est joignable que de notre cluster.

boogie$ kubectl get svc                                                                                                                            [☸ minikube:default]
NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)           AGE
helloworld-service   NodePort    10.109.171.91   <none>        31001:31001/TCP   3m14s
kubernetes           ClusterIP   10.96.0.1       <none>        443/TCP           38d

La ClusterIp est une ip virtuelle qui change si on delete et on recree notre service . On peut fixer l'ip si on veut dans le yaml de notre service .
Comme pour le port static qu'on défini si on veut dans notre yaml

= labels : 

les labels sont des paires clé /valeurs qui peuvent être attachées à un object.
Ils sont utilisés pour tagguer les objects.
On peut taguer un pod par exemple en mettant un label de type key: environment valeur: dev/ prod ...
On peut mettre plusieurs labels sur un object : on peut rajouter sur notre pod précédent un label de type key: department / valeur: finance / it ...
Une fois que le/s label/s est /sont attachés a un object on va pouvoir les utiliser pour filtrer nos besoins en utilisant un selector.
Un label selector peut utiliser des regexp pour matcher notre object
ex: on peut dire qu'un pod ne doit tourner que dur un node avec le label environment equal dev ,  ou environment equal 'dev' or 'qa'

On va pouvoir tagger un node puis dire qu'un pod ira uniquement sur un node contenant le label : ceci se fera grace au nodeSelector qu'on ajoutera dans notre config.

- nodes labels :

ex :on peut ajouter un tag en cli :

boogie$ kubectl label node minikube environment=lab                                                                                                                                                                      [☸ minikube:default]
node/minikube labeled

on peut voir notre label :

boogie$ kubectl get nodes --show-labels                                                                                                                                                                                  [☸ minikube:default]
NAME       STATUS   ROLES    AGE   VERSION   LABELS
minikube   Ready    master   39d   v1.15.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,environment=lab,kubernetes.io/arch=amd64,kubernetes.io/hostname=minikube,kubernetes.io/os=linux,node-role.kubernetes.io/master=

On va pouvoir ensuite définir un pod en specifiant qu'il doit s"executer uniquement sur les nodes flaggués lab :

  ---
  apiVersion: v1
  kind: Pod
  metadata:
    name: nodehelloworld.example.com
    labels:
      app: helloworld
  spec:
    containers:
   - name: k8s-demo
      image: wardviaene/k8s-demo
      ports:
   - name: nodejs-port
        containerPort: 3000
   nodeSelector:
      environment: lab

Tant qu'un node avec le tag environment: lab n'existe pas alors notre object ne peut pas démarré.


= healthcheck :

On peut avoir un pod démarré mais qui ne répond pas vraiment : l'appli est donc ko. Il faut pouvoir nous assurer que le pod est bien  fonctionnel.

Pour detecter et resoudre des pb de fonctionnemnt on va ajouter un healtchcheck 

2 types existent :
-> lancer une commande périodiquement 
-> executer un check http sur une url



boogie$ cat deployment/helloworld-healthcheck.yml                                               [☸ minikube:default]
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: helloworld-deployment
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: helloworld
    spec:
      containers:
      - name: k8s-demo
        image: wardviaene/k8s-demo
        ports:
        - name: nodejs-port
          containerPort: 3000
        livenessProbe:    <<< definition de la section du healthcheck 
          httpGet:        <<<< check http
            path: /       <<<<  on fait un get sur / 
            port: nodejs-port  <<< sur le port nodejs-port defini dans la section de notre notre pod 
          initialDelaySeconds: 15  <<<< on attend 15 secondes avant le premier check 
          timeoutSeconds: 30    <<<< on considere que le pod est ko apres 30 secondes sans réponse.

On voit quand on affiche la description du pod apres le deployment la section de la sonde :

..
    Liveness:       http-get http://:nodejs-port/ delay=15s timeout=30s period=10s #success=1 #failure=3
...
Quand on edite le déployment poussé dans kube on voit le detail que kube ajoute pour les healtchcheck 

    spec:
        containers:
>>      - image: wardviaene/k8s-demo
          imagePullPolicy: Always
          livenessProbe:
            failureThreshold: 3   <<< nombre d'occurence de fail conisdérer en critical : le pod sera détruit et unn ouveau lancé
            httpGet:
              path: /
              port: nodejs-port
              scheme: HTTP
            initialDelaySeconds: 15
            periodSeconds: 10  <<<< frequence de check 
            successThreshold: 1   <<< nombre de fois ou le check est considérer comme ok 
            timeoutSeconds: 30


= readiness probe :

On a vu que le healtcheck va servir a verifier l'etat du pod : si celui ci est ko alors kube en redemarre un
Une readiness probe va nous assurer que le pod est bien pret a servir les requettes . Si le test est ko alors le pod n'est pas redémarré et son ip est supprimée de la liste des ip des pods du service. 

Au demarrage de notre object ( pod ,deployment ..) : l'object pourra être running mais pas ready : tant que la sonde de readiness ne sera pas passé et aura considérer le pod ok puis que répondant aux requettes.
On va mettre conjointement readiness et healtcheck dans la def de nos objects :
boogie$ cat deployment/helloworld-liveness-readiness.yml                                        [☸ minikube:default]
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: helloworld-readiness
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: helloworld
    spec:
      containers:
      - name: k8s-demo
        image: wardviaene/k8s-demo
        ports:
        - name: nodejs-port
          containerPort: 3000
        livenessProbe:
          httpGet:
            path: /
            port: nodejs-port
          initialDelaySeconds: 15
          timeoutSeconds: 30
        readinessProbe:
          httpGet:
            path: /
            port: nodejs-port
          initialDelaySeconds: 15
          timeoutSeconds: 30

NAME                                  READY   STATUS    RESTARTS   AGE
helloworld-readiness-dc8fc5bc-d9phj   0/1     Running   0          11s
helloworld-readiness-dc8fc5bc-gm6kx   0/1     Running   0          11s
helloworld-readiness-dc8fc5bc-tcwbx   0/1     Running   0          11s


= pods states :


les pods peuvent avoir plusieurs status :


-> running : ils sont en cours d'execution
-> pending : en cours de creation ( recup d'image , attente de ressources définie dans l'object : label , memoire ,cpu .. resources ...) 
-> succeeded : tous les pods ont été correctement déployés
-> failed : les containers dans le pod sont en etat terminated et au moins un container a renvoyé un code retour d'erreur.
-> unknow : impossible de connaitre l'etat

on peut connaitre les differentes etapes que le pod a connu en faisant un 
kubectl describe pod mon pod 

- pods conditions : il y a differentes conditions 

-> podScheduled : le pod a été schedule sur un node
-> Ready : le pod est pret a servir du traffic et va etre ajouté pour matcher un service 
-> initialized : les containers du pod sont initialisés correctement
-> unschedulable : les pod ne peuvent pas être dispatcher : pb de contrainte de ressource ( ex pod devant etre sur un node avec 2T de ram de libre ...) 
-> containersready : les onctainers du pod sont prets

on peut avoir aussi l'etat du container avec :

boogie$ kubectl get pod helloworld-readiness-dc8fc5bc-tcwbx -n default -o yaml                  [☸ minikube:default]
apiVersion: v1
kind: Pod
metadata:
  ....

  containerStatuses:
  - containerID: docker://95e9a8c9afc2092471107fa066acaf567613c4c71da186f5ef3aa3016e53cbcc
    image: wardviaene/k8s-demo:latest
    imageID: docker-pullable://wardviaene/k8s-demo@sha256:2c050f462f5d0b3a6430e7869bcdfe6ac48a447a89da79a56d0ef61460c7ab9e
    lastState: {}
    name: k8s-demo
    ready: true
    restartCount: 0
    ....

Les containers  peuvent être en running / terminated ou waiting


exemple de fichier comportant deux containers , et deux hooks servant a differents moment de la vie de notre container :


-> un init container va être utiliser pour la prépartion d'element pour l'acceuil de notre pod :
ex : on lance un init container pour préparer un volume qui sera ensuite monter par le pod principal.

Ici dans notre exemple l'init container va juste tourner quelques seconde ..puis laisser la main au hook, au second container puis au second hook : 


boogie$ cat pod-lifecycle/lifecycle.yaml                                                        [☸ minikube:default]
kind: Deployment
apiVersion: apps/v1beta1
metadata:
  name: lifecycle
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: lifecycle
    spec:
      initContainers:
      - name:           init
        image:          busybox
        command:       ['sh', '-c', 'sleep 10']
      containers:
      - name: lifecycle-container
        image: busybox
        command: ['sh', '-c', 'echo $(date +%s): Running >> /timing && echo "The app is running!" && /bin/sleep 120']
        readinessProbe:
          exec:
            command: ['sh', '-c', 'echo $(date +%s): readinessProbe >> /timing']
          initialDelaySeconds: 35
        livenessProbe:
          exec:
            command: ['sh', '-c', 'echo $(date +%s): livenessProbe >> /timing']
          initialDelaySeconds: 35
          timeoutSeconds: 30
        lifecycle:
          postStart:
            exec:
              command: ['sh', '-c', 'echo $(date +%s): postStart >> /timing && sleep 10 && echo $(date +%s): end postStart >> /timing']
          preStop:
            exec:
              command: ['sh', '-c', 'echo $(date +%s): preStop >> /timing && sleep 10']


quand on lance on obtient plusieurs etats : 

-> notre init container se lance : 
NAME                         READY   STATUS     RESTARTS   AGE
lifecycle-86977b4c47-d7hh2   0/1     Init:0/1   0          5s

-> notre second container se lance : les post et pré hook s'executent : 
NAME                         READY   STATUS            RESTARTS   AGE
lifecycle-86977b4c47-d7hh2   0/1     PodInitializing   0          16s

NAME                         READY   STATUS    RESTARTS   AGE
lifecycle-86977b4c47-d7hh2   0/1     Running   0          28s

NAME                         READY   STATUS             RESTARTS   AGE
lifecycle-86977b4c47-d7hh2   0/1     CrashLoopBackOff   1          4m36s

NAME                         READY   STATUS    RESTARTS   AGE
lifecycle-86977b4c47-d7hh2   0/1     Running   2          4m55s


jusqu'a ce que le nombre de heatlcheck ko soient arrivés au max et que le pod ne soit plus redémarré.



= Secrets : 

les secrets dans kube vont permettre de passer des credentials, password , data à nos pods.
kube utilise les mêmes mecanismes pour passer des secret a l'api 
On peut utiliser des solutions externes à kube pour passer des secrets à nos apps (vault etc ...) mais les Secrets sont la méthode native de kube.

On peut utiliser les Secrets :
-> en variable d'environment 
-> en fichier plat : qui seront dans un volume monté par le pod et donc accessible 
-> utilisation d'une registry pour stocker les secrets : une image contenant les secrets sera pull et utilisée par un pod ..(?)

- generation de secret depuis un fichier :


boogie$ echo -n "root" > ./username.txt                                                         [☸ minikube:default]
 ~/Documents/learn/kubernetes/learn-devops-the-complete-kubernetes-course/kubernetes-course (master*) [11:11:13]
boogie$ echo -n "password" > ./password.tx
boogie$ kubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt
secret/db-user-pass created

- generation d'un secret depuis un cle ssh  , un cert tls : 

boogie$ kubectl create secret generic ssl-certificate --from-file=ssh-privatekey=~/.ssh/id_rsa  --ssl-cert=mysslcert.c (KO)


- Generation depuis un yaml :

on va encoder nos credentials via base64 

boogie$ echo -n "root" |base64                                                                  [☸ minikube:default]
cm9vdA==
boogie$ echo -n "password" |base64                                                              [☸ minikube:default]
cGFzc3dvcmQ=

secret-data.yaml

apiVersion: v1
kind: Secret
metadata:
  name: app-secret
data: 
   password: cGFzc3dvcmQ=
   username: cm9vdA==

Une fois qu'on a créer nos secret on va pouvoir les utiliser 

On va pouvoir les utiliser de différentes manieres 

- variables d'env :
on defini l'appel dans notre pod : 

...
 env:
   - name: SECRET USERNAME   
     ValueFrom:            <<<<<<<<  on va donc maintenant rattacher les valeurs definis dans notre secret au pod
      - secretRef:
        name: app-secret
        key: username 

- on defini un volume:

boogie$ cat deployment/helloworld-secrets-volumes.yml                                           [☸ minikube:default]
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: helloworld-deployment
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: helloworld
    spec:
      containers:
      - name: k8s-demo
        image: wardviaene/k8s-demo
        ports:
        - name: nodejs-port
          containerPort: 3000
        volumeMounts:
        - name: cred-volume
          mountPath: /etc/creds
          readOnly: true
      volumes:
      - name: cred-volume
        secret: 
          secretName: db-secrets




On peut voir quand on crée nos ressources , en examinant un pod que notre fichier secret est défini :


kubectl describe pod helloworld-deployment-6b6585d49c-d6748                             [☸ minikube:default]
Name:           helloworld-deployment-6b6585d49c-d6748
..
    Mounts:
      /etc/creds from cred-volume (ro)   <<<< c'est le point de montage 
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-wfc8r (ro)

On va examiner depuis notre pod et voir que les secrets sont présents dans le point de montage défini : 

boogie$ kubectl exec -it helloworld-deployment-6b6585d49c-d6748 -- bash                         [☸ minikube:default]
root@helloworld-deployment-6b6585d49c-d6748:/app# ls
Dockerfile  docker-compose.yml	index-db.js  index.js  misc  node_modules  package.json
passwordroot@helloworld-deployment-6b6585d49c-d6748:/app# ls /etc/creds/          
password  username



