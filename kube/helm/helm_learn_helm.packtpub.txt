===== notes learn helm packpub : =====


- chap2 : install chart :

on va set up un wordpress 
minikube 4gb de ram driver / vm-driver: kvm2

helm repo add bitnami https://charts.bitnami.com/bitnami

kubectl create namespace chapter3
namespace/chapter3 created

on va pouvoir overrider les values de base que l'on peut examiner avaec la commande suivante : 

 helm show values bitnami/wordpress --version 8.1.0
The result of this command should be a long list of possible values that you
...

on va créer un fichier contenant les valeurs que nous voulons personaliser ( user , mdp bdd, nom du blog ...
on va comme on travaille dans minikube modifier la conf reseau en modifiant la conf loadbalancer en nodeport 

cat wordpress-values.yaml
wordpressUsername: helm-user
wordpressPassword: my-pass
wordpressEmail: helm-user@example.com
wordpressFirstName: boogie
wordpressLastName: man
wordpressBlogName: Learn Helm!
service:
 type: NodePort

on lance l'install :

helm install [NAME] [CHART] [flags]

-> Name : le nom que l'on veut donner à notre release helm
-> Chart : est le nom du chart helm installer (on peut utiliser la forme  <repo name>/<chart name>
-> flags : params que l'on peut passer pour overrider des valeurs par exemple.

on lance l'install :

helm install wordpress bitnami/wordpress --values=wordpress-values.yaml --namespace chapter3 --version 8.1.0
NAME: wordpress
LAST DEPLOYED: Sun Oct  4 17:22:23 2020
NAMESPACE: chapter3
STATUS: deployed
REVISION: 1
NOTES:
1. Get the WordPress URL:

  export NODE_PORT=$(kubectl get --namespace chapter3 -o jsonpath="{.spec.ports[0].nodePort}" services wordpress)
  export NODE_IP=$(kubectl get nodes --namespace chapter3 -o jsonpath="{.items[0].status.addresses[0].address}")
  echo "WordPress URL: http://$NODE_IP:$NODE_PORT/"
  echo "WordPress Admin URL: http://$NODE_IP:$NODE_PORT/admin"

2. Login with the following credentials to see your blog

  echo Username: helm-user
  echo Password: $(kubectl get secret --namespace chapter3 wordpress -o jsonpath="{.data.wordpress-password}" | base64 --decode)


on voit le contenu du fichier note du chart  affiché 
on peut examiner le chart installé :

helm list --namespace chapter3
NAME     	NAMESPACE	REVISION	UPDATED                                 	STATUS  	CHART          	APP VERSION
wordpress	chapter3 	1       	2020-10-04 17:22:23.914776076 +0200 CEST	deployed	wordpress-8.1.0	5.3.2

The list subcommand provides the following information:
• The release name
• The release namespace
• The latest revision number of the release
• A timestamp of the latest revision
• The release status
• The chart name
• The application version

-  helm namespace variable d'environment :
on peut definir une variable d'env définissant le namespace dans lequel on travaille avec notre helm :

export HELM_NAMESPACE=chapter3-  helm namespace variable d'environment :
on peut definir une variable d'env définissant le namespace dans lequel on travaille avec notre helm :

export HELM_NAMESPACE=chapter3
verif :
helm env
HELM_BIN="helm"
HELM_DEBUG="false"
HELM_KUBEAPISERVER=""
HELM_KUBECONTEXT=""
HELM_KUBETOKEN=""
HELM_NAMESPACE="chapter3"
HELM_PLUGINS="/home/boogie/.local/share/helm/plugins"
HELM_REGISTRY_CONFIG="/home/boogie/.config/helm/registry.json"
HELM_REPOSITORY_CACHE="/home/boogie/.cache/helm/repository"
HELM_REPOSITORY_CONFIG="/home/boogie/.config/helm/repositories.yaml"


- choisir entre --set et --values :
on peut overrider des valeur en cli avec --set ,
une bonne pratique est d'utiliser un fichier de values que l'on pourra versionner par ex dans git.
Biensur on ne met pas les secret dans git et on verra plus tard comment passer des secrets dans nos charts.

= exam de notre wordpress :

export NODE_PORT=$(kubectl get --namespace chapter3 -o jsonpath="{.spec.ports[0].nodePort}" services wordpress)

export NODE_IP=$(kubectl get nodes --namespace chapter3 -o jsonpath="{.items[0].status.addresses[0].address}")

echo "WordPress URL: http://$NODE_IP:$NODE_PORT/"
WordPress URL: http://192.168.39.214:32575/


on se logge dans notre navigo :

echo "WordPress Admin URL: http://$NODE_IP:$NODE_PORT/admin"
WordPress Admin URL: http://192.168.39.214:32575/admin

on se loggue en recupérant les infos user et mdp defini dans le fichier values


echo Username: helm-user
on peut onterroger kube pour retrouver le mdpt stocké en secret : 
echo Password: $(kubectl get secret --namespace chapter3 wordpress -o jsonpath='{.data.wordpress-password}' | base64 --decode)
Password: my-pass


on va maintenant upgrader notre chart en ajoutant un replicat et definisssant des ressources pour notre appli : on modifie donc notre fichier de values :

cat wordpress-values.yaml
wordpressUsername: helm-user
wordpressPassword: my-pass
wordpressEmail: helm-user@example.com
wordpressFirstName: boogie
wordpressLastName: man
wordpressBlogName: Boogie Learn Helm!
service:
  type: NodePort
replicaCount: 2
resources:
  requests:
   memory: 256Mi
   cpu: 100m  


helm upgrade [RELEASE] [CHART] [flags]

helm upgrade wordpress bitnami/wordpress --values wordpress-values.yaml -n chapter3 --version 8.1.0
Release "wordpress" has been upgraded. Happy Helming!
NAME: wordpress
LAST DEPLOYED: Sun Oct  4 18:14:33 2020
NAMESPACE: chapter3
STATUS: deployed
REVISION: 4
NOTES:
1. Get the WordPress URL:

  export NODE_PORT=$(kubectl get --namespace chapter3 -o jsonpath="{.spec.ports[0].nodePort}" services wordpress)
  export NODE_IP=$(kubectl get nodes --namespace chapter3 -o jsonpath="{.items[0].status.addresses[0].address}")
  echo "WordPress URL: http://$NODE_IP:$NODE_PORT/"
  echo "WordPress Admin URL: http://$NODE_IP:$NODE_PORT/admin"

2. Login with the following credentials to see your blog

  echo Username: helm-user
  echo Password: $(kubectl get secret --namespace chapter3 wordpress -o jsonpath="{.data.wordpress-password}" | base64 --decode)


Reusing and resetting values during an upgrade
The helm upgrade command includes two additional flags that are used to manipulate
values that are not present in the helm install command.
Let's look at these flags now:
• --reuse-values: When upgrading, reuse the last release's values.
• --reset-values: When upgrading, reset the values to the chart defaults.


par default si on ne precise rien le reuse-values est utilisé.

si on fait un upgrade avec un --set seule la valeur modifiée est changée : le reste des valeurs definies dans notre fichier sont ignorées :
helm upgrade wordpress bitnami/wordpress --set replicaCount=1 -n chapter3 --version 8.1.0

helm get values wordpress -n chapter3
USER-SUPPLIED VALUES:
replicaCount: 1


on a donc un reset des values défnies au préalable.
Users can manually provide the --reset-values or --reuse-values flags to
explicitly determine the behavior of values during an upgrade. Use the --resetvalues flag if you would like the next upgrade to reset each value to its default before
overriding it from the command line. Provide the --reuse-values flag if you would
like to reuse each of the values from a previous revision while setting different values from
the command line. To help simplify the management of values during an upgrade, try to
keep your values in a file that can be used to declaratively set values for each upgrade

- History :

les revisions des releases sont conservées en secret dans kube ( par defautl on peut les definir en configmap ou en mémoire que l'on defini dans la var HELM_DRIVER 
ex: 

 kubectl get secrets -n chapter3
NAME                              TYPE                                  DATA   AGE
default-token-n8m5s               kubernetes.io/service-account-token   3      118m
sh.helm.release.v1.wordpress.v1   helm.sh/release.v1                    1      96m
sh.helm.release.v1.wordpress.v2   helm.sh/release.v1                    1      83m
sh.helm.release.v1.wordpress.v3   helm.sh/release.v1                    1      52m
sh.helm.release.v1.wordpress.v4   helm.sh/release.v1                    1      44m
sh.helm.release.v1.wordpress.v5   helm.sh/release.v1                    1      31m
sh.helm.release.v1.wordpress.v6   helm.sh/release.v1                    1      26m
wordpress                         Opaque                                1      96m
wordpress-mariadb                 Opaque                                2      96m

helm history wordpress -n chapter3
REVISION	UPDATED                 	STATUS    	CHART          	APP VERSION	DESCRIPTION
1       	Sun Oct  4 17:22:23 2020	superseded	wordpress-8.1.0	5.3.2      	Install complete
2       	Sun Oct  4 17:36:10 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
3       	Sun Oct  4 18:06:46 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
4       	Sun Oct  4 18:14:33 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
5       	Sun Oct  4 18:27:41 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
6       	Sun Oct  4 18:32:46 2020	deployed  	wordpress-8.1.0	5.3.2      	Upgrade complete


on peut examiner les valeurs d'une revision : 

helm get values wordpress --revision 3 -n chapter3
USER-SUPPLIED VALUES:
service:
  type: NodePort
wordpressBlogName: Learn Helm!
wordpressEmail: helm-user@example.com
wordpressFirstName: boogie
wordpressLastName: man
wordpressPassword: my-pass
wordpressUsername: helm-user


 helm get values wordpress --revision 6 -n chapter3
USER-SUPPLIED VALUES:
replicaCount: 1


- rollback :

helm rollback <RELEASE> [REVISION] [flags]

helm rollback wordpress 5 -n chapter3
Rollback was a success! Happy Helming!

on peut voir le rollback dans l'history :

helm history wordpress -n chapter3
REVISION	UPDATED                 	STATUS    	CHART          	APP VERSION	DESCRIPTION
1       	Sun Oct  4 17:22:23 2020	superseded	wordpress-8.1.0	5.3.2      	Install complete
2       	Sun Oct  4 17:36:10 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
3       	Sun Oct  4 18:06:46 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
4       	Sun Oct  4 18:14:33 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
5       	Sun Oct  4 18:27:41 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
6       	Sun Oct  4 18:32:46 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
7       	Sun Oct  4 19:09:33 2020	deployed  	wordpress-8.1.0	5.3.2      	Rollback to 5

on retrouve bien les valeurs voulues dans notre version rollbackée :

helm get values wordpress -n chapter3
USER-SUPPLIED VALUES:
replicaCount: 2
resources:
  requests:
    cpu: 100m
    memory: 256Mi
service:
  type: NodePort
wordpressBlogName: Boogie Learn Helm!
wordpressEmail: helm-user@example.com
wordpressFirstName: boogie
wordpressLastName: man
wordpressPassword: my-pass
wordpressUsername: helm-user


- Desinstallation de chart :

helm uninstall RELEASE_NAME [...] [flags]

helm uninstall wordpress -n chapter3
release "wordpress" uninstalled

helm list -n chapter3
NAME	NAMESPACE	REVISION	UPDATED	STATUS	CHART	APP VERSION


Attention il va rester un persistantvolumeclaim defini dans le statefullset qui n'est pas supprimé lors de la désinstallation du chart.
le statefullset est deleted mais le pvc associé a ce statfullset ne l'est pas.

kctl get pvc -n chapter3
NAME                       STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
data-wordpress-mariadb-0   Bound    pvc-014b0631-6f4e-4dfb-9182-068750a2cff0   8Gi        RWO            standard       114m


on va donc le supprimer manuellement :

 kubectl delete pvc -l release=wordpress -n chapter3

-suppression de notre namespace et arret de minikube :
 kubectl delete namespace chapter3
  minikube stop

== understanding helm charts : ==

= yaml format :

format utilisé entre autre dans kube et helm.
"YAML files follow a key-value format to declare configuration." 

- definition d'une simple paire clé / valeur
ex: 
name: LearnHelm

clé = name
valeur = LearnHelm

on a un separateur ":" entre les deux ET un espace qui est obligatoire.
on peut imbriquer dans yaml plusieurs blocs :
ex :
resources:
 limits:
 cpu: 100m
 memory: 512Mi

cette ressource contient une map de 2 paires de clés / valeurs
Clé                       valeur
ressources.limits.cpu     100m
ressources.limits.memory  512Mi
Les clés sont déterminées par l'indentation yaml . Chaque indentation ajoute un "." separateur au nom de la clé.
La valeur de la clé est atteinte quand il ne reste plus d'indentation dans le yaml.
De base l'indentation yaml est de 2 espaces. Attention les tabulations ne sont pas admises et font ressortir une parse error.

- types de valeurs :

-> string : en principe on peut entourer le texte de ".

Les multi lignes peuvent être construites avec un |
ex: 
configuration: |
 server.port=8443
 logging.file.path=/var/log

-> integer :
ex: 
replicas: 1

Attention si on quote la valeur elle sera considérée comme une string:
replicas: "1"

-> boolean :
ex: 
ingress:
 enable: true

 prend 2 valeurs true ou false
mais aussi yes, no, on, off, y, n, Y, and N

-> list :

les éléments d'une liste sont présentées par "-" :
ex: 
servicePorts:
 - 8080
 - 8443

autre exemple :
deployment:
  env:
   - name: MY_VAR
     value: MY_VALUE
   - name: SERVICE_NAME
     value: MY_SERVICE

dans cet exemple le tableau contient une liste d'objects contenant des champs name et value 


= json :

" JSON is a string of key-value
pairs, similar to YAML. The key difference is that while YAML relies on spacing and
indentation to properly configure key-value pairs, JSON relies on braces and brackets."

exemple precedent en json :

{
 'deployment': {
 'env': [
   {
     'name': 'MY_VAR',
     'value': 'MY_VALUE'
   },
   {
     'name': 'SERVICE_NAME',
     'value': 'MY_SERVICE'
   }
  ]
 }

Toutes les clés sont entourées de simple quote "'" précédent un ":"

"Curly braces ({) denote a block in a similar way to how indentations denote a
block in YAML.
• Square brackets ([) denote a list in a similar way to how dashes denote a list
in YAML."

= helm chart structure : =

un chart est un packaging de ressources kube permettant de déployer des applis de maniere plus ou moins complexes.
Une structure est cependant  respecter :

mychart  > le repertoire top level domaine est le nom du chart par bonne pratique.

Chart.yaml -> fichier contenant les metadata du chart. mandatory
templates -> repertoire contenant les ressources kube sous format yaml  mandatory en principe
templates/NOTES.txt -> fichier d'instruction qui donnent des informations sur l'installation d'un chart . pas mandatory 
values.yaml -> fichier contenant les valeurs par défaut du chart. Ce fichier est une best practice de helm.
.helmignore -> fichier contenant une list de fichiers et repertoire à exclure pour le packaging de helm.
charts/   -> repertoire contenant les charts dont ce chart dépend. PAs mandatory car le process de helm dependancy va créer automatiquement ce rep.
Chart.lock -> fichier pour sauvegarder la version des precedentes dépendances appliquées.PAs mandatory car le process de helm dependancy va créer automatiquement ce rep.
crds/ -> repertoire contenant des crd en yaml devant être installées avant les fichiers dans le rep templates.
README.md -> fichier contenant les consignes d'install du chart. Best practice.
LICENCE -> fichier contenant la licence d'un chart . pas mandatory
values.schema.json -> fichier contenant les données du fichier values sous format json. pas mandatory


- Charts templates :

Le principal but d'un chart est de creer et manager les ressources kube pour faire une application.Ceci est fait grace aux templates dont les valeurs passées en parametres vont customiser ces templates.
le rep template contient des ressources kube en yaml 

ex: 
templates/
 configmap.yaml
 deployment.yaml
 service.yaml

la configmap pourra être comme ceci :
apiVersion: v1
kind: ConfigMap
metadata:
 name: {{ .Release.Name }}
data:
 configuration.txt: |-
 {{ .Values.configurationData }}

Les {{ et }} sont issues du templating go et ces blocs seront remplacés et alimentés par les valeurs des éléments trouvés dans le / les fichiers values et par les variables internes builin à helm.

- Go templating :

language go initié par google en 2009, utilisé par kube, helm et autres ...
un des éléments au coeur de go est son moteur de templating qui va permettre de générer des fichiers sous différents formats.
le templating go controle et process les blocs compris entre {{ et }}, lors de l'install ou l'upgrade d'un chart ce fait ces accolades sont supprimées.

- paramétrage de base et objects builtin :

les charts helm contiennent au moins un fichier values.yaml qui contient les valeurs par défault du chart qui sont reférencées par les templates go et procéssées par helm pour générer une ressource kube.
ex: values.yaml

## chapterNumber lists the current chapter number
chapterNumber: 4
## chapterName gives a description of the current chapter
chapterName: Understanding Helm Charts

les lignes commencant par un # sont des commentaires qui peuvent nous aider à comprendre les valeurs.
Les templates go commencant par .Values vont référencer les valeurs définies dans le fichier values.yaml ou passées en argument avec les flags --set ou --values pendant l'installation ou l'upgrade d'un chart
L'exemple suivant nous montre le template avant son traitement : 

env:
 - name: CHAPTER_NUMBER
 value: {{ .Values.chapterNumber }}
 - name: CHAPTER_NAME
 values: {{ .Values.chapterName }}

Apres le traitement le code de la ressource  concernée sera donc comme suivant : 
env:
 - name: CHAPTER_NUMBER
 value: 4
 - name: CHAPTER_NAME
 values: Understanding Helm Charts



- built in :

Le .Values est un objet builtin utilisé pour le paramétrage.
cf list des built in dans la  documentation (https://helm.sh/docs/chart_template_guide/builtin_objects/)

les élément suivants sont les principaux :

.Release.Name -> nom de la release utilisé pour l'installation
.Release.Namespace -> namespace utilisé pour le déployement du chart.
.Release.Revision -> num de revision d'install ou d'upgrade
.Values -> utilisé pour pour référencer les valeurs du ou des fichiers values.yaml ou defini en param sur la ligne de cimmande par le user.

.Values -> utilisé pour pour référencer les valeurs du ou des fichiers values.yaml ou defini en param sur la ligne de commande par le user.
.Chart.Name, .Chart.Version, .Chart.AppVersion ... -> utilisés pour référencer les champs dans le fichier Chart.yaml : on peut utiliser les différents champ de ce fichier par .Chart.$Field
.Files.Get -> utilisé pour recupérer un fichier dans un rep du chart.
.Files.AsSecrets -> retourne un fichier encodé en base64 pour créer un secret depuis un fichier dans un repertoire du chart.
.Files.AsConfig -> retourne les données d'un fichier sous format yaml pour créer les data d'une configmap avec les données d'un fichier dans un rep du chart.
.Capabilities.APIversions -> retourne une liste de l&pi kube du cluster
.Template.Name -> retourne le chemin relatif du fichier utilisé par l'object.

Le "." prefixant chaque objet représente le scope de l'object.
Un "." suivi d'un nom d'object limite le scope à cet object :
ex: .Release > limite au scope .Release , .Values au scope .Values 

Le "." représente le scope global : rendant tous les objects visibles.

- fichier values.schema.json 
optionnel, il va servir en renforcer les controlles de saisies dans le fichier values.yaml

ex :
{
 '$schema': 'https://json-schema.org/draft-07/schema#',
 'properties': {
   'replicas': {
     'description': 'number of application instances to deploy',
     'minimum': 0
     'type' 'integer'
   },
 . . .
 'title': 'values',
 'type': 'object'
}
 
on voit ici que le minimum de replica a definir est de 0 et que le type attendu est un entier.

- control de flux :

if/else > utilisé pour inclure ou exlure un bloc dans un fichier 

ex: ici si la valeur definie dans .Values.probeType.httpGet est vrai ou non nulle : on defini la sonde avec un httpGet port 8080 .. si aucune valeur n'est définie dans notre values.yaml alors on défini une sonde de type tcpSocket 


readinessProbe:
{{- if .Values.probeType.httpGet }}
  httpGet:
    path: /healthz
    port: 8080
    scheme: HTTP
{{- else }}
  tcpSocket:
    port: 8080
{{- end }}
 initialDelaySeconds: 30
 periodSeconds: 10

with > va être defini pour modifier le scope des valeurs référencées
pratique pour des cascades de valeurs définies 

ex : values.yaml 
application:
  resources:
    limits:
      cpu: 100m
       memory: 512Mi

sans l'utilisation de with dans nos templates on sera obliger de définir les champs comme suivants :

cpu: {{ .Values.application.resources.limits.cpu }}
memory: {{ .Values.application.resources.limits.memory }}

avec with on aura une syntaxe plus concise et lisible 

{{- with .Values.application.resources.limits }}
cpu: {{ .cpu }}
memory: {{ .memory }}
{{- end }}
       
- range > va permettre de boucler sur une liste de valeurs :

servicePorts:
  - name: http
  port: 8080
  - name: https
  port: 8443
  - name: jolokia
  port: 8778
       
spec:
  ports:
{{- range .Values.servicePorts }}
  - name: {{ - name }}
  port: {{ .port }}
{{- end }}

Attention : with et range limitent leur action dans le scope des objets définis (ex : .Values, .Release) ..si on veut agir au niveau du scope global : on doit préfixer les références avec "$" 

ex:  ici on boucle sur les valeurs de ports de l'objet .Values mais on va ajouter le nom de notre release issu de l'objet .Release dans un autre scope en préfixant avec "$" :
{{- range .Values.servicePorts }}
 - name: {{ $.Release.Name }}-{{ .name }}
 port: {{ .port }}
{{- end }}


- Variables de templates :

on peut créer des variables dans nos templates pour ajouter des options de processing 

definition de variable :

ex : 
{{ $myvar := 'Hello World!' }}

Les variables peuvent être assignées à des objects :
ex :
{{ $myvar := .Values.greeting }}

on pourra referencer la variable par ex comme ceci :

data:
 greeting.txt: |
   {{ $myvar }}


un exemple d'utilisation est la capture des index dans une boucle sur une liste :

data:
 greetings.txt: |
{{- range $index, $value := .Values.greetings }}
 Greeting {{ $index }}: {{ $value }}
{{- end }}
Les résulats pourront donner quelque chose comme : 
data:
 greetings.txt: |
 Greeting 0: Hello
 Greeting 1: Hola
 Greeting 2: Hallo

on peut biensur aussi boucler sur une map / hash / dictionnaire :

data:
  greetings.txt: |
{{- range $key, $val := .Values.greetings }}
  Greeting in {{ $key }}: {{ $val }}
{{- end }}

avec comme résultat par exemple :

data:
 greetings.txt: |
 Greeting in English: Hello
 Greeting in Spanish: Hola
 Greeting in German: Hallo

on peut aussi utiliser les variables pour référencer des objects en dehors de notre scope : 

ex: le template suivant va echouer car .Release.Name n'est pas sous le scope de .Values.application.configuration 

{{- with .Values.application.configuration }}
My application is called {{ .Release.Name }}
{{- end }}

scope of .Values.application.configuration. One way this can be remedied is
by setting a variable to .Release.Name above the with block:
une manière de remedier à ce pb est de définir une variable avant le bloc with :
{{ $appName := .Release.Name }}
{{- with .Values.application.configuration }}
My application is called {{ $appName }}
{{- end }}

Cependant la methode utilisant le $ pour référencer le scope global est meilleure car plus lisible et moins longue a écrire. 

- process complexes avec les pipes  / pipelines :

on va pouvoir chainer les commandes avec des fonctions comme dans linux :

on peut  par exemple utiliser la fonction indent qui va ajouter des espaces :

on peut ecrire et utiliser les fonctions ( en tout cas indent de plusieurs manieres) 
ex 
data:
 application-config: |-
{{ indent 4 .Values.config }}

ou alors avec un pipe :

data:
 application-config: |-
{{ .Values.config | indent 4 }}

l'avantage du pipe est qu'on peut chainer les commandes / fonctions :
ex :
data:
 application-config: |-
{{ .Values.config | indent 4 | quote }}

la liste des fonctions Go est importante :

 https://golang.org/pkg/text/template/#hdr-Functions 
 and in the Sprig template library at http://masterminds.github.io/sprig/. 

- Reutilisation de code avec les "named template" :

quand on cree des templates on peut etre confronter à la répétition de bloc qui peut être longue 
ex :

labels:
 'app.kubernetes.io/instance': {{ .Release.Name }}
 'app.kubernetes.io/managed-by': {{ .Release.Service }}
 ....
dans certains cas ces labels doivent être inclus dans toutes les ressources helm ...ce qui peut être long , fastidieux et source d'oubli et encore plus si le label doit être modifié.
helm permet de créer des named template pour pouvoir facilement réutiliser des blocs de code.
Ils doivent être sous le repertoire templates et finir par l'extension ".tpl"
Beaucoup de charts sont crées avec le fichier  _helpers.tpl mais ce n'est pas une obligation.

pour créer un named template on utilisera le mot define dans notre fichier .tpl 
ex : pour l'exemple de nos labels : 

{{- define 'mychart.labels' }}
labels:
 'app.kubernetes.io/instance': {{ .Release.Name }}
 'app.kubernetes.io/managed-by': {{ .Release.Service }}
{{- end }}

L'action define prend un nom de template en argument.Dans notre exemple mychart.labels
La convention de nommage est que le template est $CHART_NAME.$TEMPLATE_NAME dans lequel $CHART_NAME est le nom du chart et $TEMPLATE_NAME est un nom court décrivant le but du template
mychart.labels implique que le template est natif au chart helm mychart et qu'il va générer des labels pour les ressources du chart.

pour utiliser un named template on saisira la fonction include 

include [TEMPLATE_NAME] [SCOPE]

le param TEMPLATE_NAME  est le nom du named template qui va être appliqué 
le param SCOPE est le scope des valeurs et objects builtin qui doivent être traités 
dans la plupart du temps le params est "." pour signaler le top scope level
le $ peut être utiliser si le named scope références des valeurs en dehors du scope actuel 
ex d'utilisation : 

metadata:
 name: {{ .Release.Name }}
{{- include 'mychart.labels' . | indent 2 }}

on a ici l'exemple qui defini le nom de la ressource comme le nom de la release et ensuite la fonction include qui va process les labels et les indentés de 2 espaces comme déclarer dans le pipe
a la fin du traitement on peut avoir une ressource de type :  
metadata:
 name: template-demonstration
 labels:
 'app.kubernetes.io/instance': template-demonstration
 'app.kubernetes.io/managed-by': Helm

Helm also provides a template action that can also expand named templates. This
action has the same usage as include, but with one major limitation—it cannot be used
in a pipeline to provide additional formatting and processing. The template action is
used to simply display data inline. Because of this limitation, chart developers should use
the include function over the template action since include has feature parity with
template but also provides the additional benefit of pipeline processing



!!!!! p 114 to be completed !!!!!!



== Building your first chart : ==

on va utiliser une appli fourni par la communauté kube pour comprendre notre build helm : "https://kubernetes.io/docs/
tutorials/stateless-application/guestbook/"
code php  en front et une boite de dialogue pour saisir nos data et redis pour stocker les data 

on aura une replication redis : un master qui prendra les ecritures saisies lors de l'envoi de data et un node qui servira aux lectures
 https://github.com/PacktPublishing/-Learn-Helm -> repertoire the helm-charts/charts/guestbook 

 kubectl create namespace chapter5

pour avoir un chart fonctionnel on doit avoir des éléments mandatory :
• Chart.yaml: Used to define chart metadata
• values.yaml: Used to define default chart values
• templates/: Used to define chart templates and Kubernetes resources to be
created

la commande helm create va nous créer automatiquement tous les éléments nécéssaires et même plus : 

ogie@boogieland  ~/Documents/lab/helm/guestbook   helm create guestbook                                                                                                                [☸ |minikube:chapter5]
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /home/boogie/.kube/config
WARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /home/boogie/.kube/config
Creating guestbook
 boogie@boogieland  ~/Documents/lab/helm/guestbook  tree                                                                                                                                  [☸ |minikube:chapter5]
.
└── guestbook
    ├── charts
    ├── Chart.yaml
    ├── templates
    │   ├── deployment.yaml
    │   ├── _helpers.tpl
    │   ├── hpa.yaml
    │   ├── ingress.yaml
    │   ├── NOTES.txt
    │   ├── serviceaccount.yaml
    │   ├── service.yaml
    │   └── tests
    │       └── test-connection.yaml
    └── values.yaml

on va supprimer le rep tests que l'on verra plus tard pour les tests unitaires 
 rm -rf guestbook/templates/tests
 tree                                                                                                                                  [☸ |minikube:chapter5]
.
└── guestbook
    ├── charts
    ├── Chart.yaml
    ├── templates
    │   ├── deployment.yaml
    │   ├── _helpers.tpl
    │   ├── hpa.yaml
    │   ├── ingress.yaml
    │   ├── NOTES.txt
    │   ├── serviceaccount.yaml
    │   └── service.yaml
    └── values.yaml

examen des ressources 

-  Chart.yaml 
cat Chart.yaml                                                                                                              [☸ |minikube:chapter5]


apiVersion: v2   <<<<<< version d'api : en helm3 v2 est préférable 
name: guestbook  <<<<<<  nom de notre chart 
description: A Helm chart for Kubernetes  <<<<< description rapide de notre chart

# A chart can be either an 'application' or a 'library' chart.
#
# Application charts are a collection of templates that can be packaged into versioned archives
# to be deployed.
#
# Library charts provide useful utilities or functions for the chart developer. They're included as
# a dependency of application charts to inject those utilities and functions into the rendering
# pipeline. Library charts do not define any templates and therefore cannot be deployed.
type: application  <<<<<<< type de chart application ou library ( library vient avec des addons et helpers qui peuvent être utilisés dans d'autres charts pour éviter les répétitions.

# This is the chart version. This version number should be incremented each time you make changes
# to the chart and its templates, including the app version.
# Versions are expected to follow Semantic Versioning (https://semver.org/)
version: 0.1.0   <<<< numéro de version qui doit être conforme au Semantic Versioning specifications (SemVer).


# This is the version number of the application being deployed. This version number should be
# incremented each time you make changes to the application. Versions are not expected to
# follow Semantic Versioning. They should reflect the version the application is using.
appVersion: 1.16.0    <<<<< version de l'application déployée par le chart helm

Il n'y a pas ici pour l'instant de section :

dependencies: une list de charts dont ce Helm chart depend

- Ajout de la dépendance redis :
comme on l'a vu notre appli a besoin d'une db redis pour fonctionner

on va chercher le chart redis :

helm search hub redis                                                                                                      [☸ |minikube:chapter5]
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /home/boogie/.kube/config
WARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /home/boogie/.kube/config
URL                                               	CHART VERSION	APP VERSION  	DESCRIPTION
https://hub.helm.sh/charts/drycc-canary/redis     	1.0.0        	             	A Redis database for use inside a Kubernetes cl...
https://hub.helm.sh/charts/choerodon/redis        	0.2.5        	0.2.5        	redis for Choerodon
https://hub.helm.sh/charts/drycc/redis            	1.1.0        	             	A Redis database for use inside a Kubernetes cl...
https://hub.helm.sh/charts/wener/redis            	10.8.2       	6.0.8        	Open source, advanced key-value store. It is of...
https://hub.helm.sh/charts/bitnami/redis          	11.2.2       	6.0.8        	Open source, advanced key-value store. It is of...
https://hub.helm.sh/charts/hephy/redis            	2.4.2        	             	A Redis database for use inside a Kubernetes cl...
https://hub.helm.sh/charts/helm-incubator/redis...	0.5.0        	4.0.12-alpine	A pure in-memory redis cache, using statefulset...
https://hub.helm.sh/charts/inspur/redis-cluster   	0.0.2        	5.0.6        	Highly available Kubernetes implementation of R...
https://hub.helm.sh/charts/helm-stable/redis-ha   	4.4.4        	5.0.6        	Highly available Kubernetes implementation of R...
https://hub.helm.sh/charts/hkube/redis-ha         	3.6.1005     	5.0.5        	Highly available Kubernetes implementation of R...
https://hub.helm.sh/charts/dandydeveloper/redis-ha	4.10.2       	6.0.7        	Highly available Kubernetes implementation of R...
https://hub.helm.sh/charts/softonic/redis-sharded 	0.3.0        	6.0.6        	A Helm chart for sharded redis
https://hub.helm.sh/charts/bitnami/redis-cluster  	3.2.8        	6.0.8        	Open source, advanced key-value store. It is of...
https://hub.helm.sh/charts/prometheus-community...	3.6.0        	1.11.1       	Prometheus exporter for Redis metrics
https://hub.helm.sh/charts/hmdmph/redis-pod-lab...	1.0.2        	1.0.0        	Labelling redis pods as master/slave periodical...
https://hub.helm.sh/charts/wyrihaximusnet/redis...	1.0.1        	v1.0.0       	Redis Database Assignment Operator
https://hub.helm.sh/charts/pozetron/keydb         	0.5.1        	v5.3.3       	A Helm chart for multimaster KeyDB optionally w...
https://hub.helm.sh/charts/enapter/keydb          	0.16.2       	6.0.16       	A Helm chart for KeyDB multimaster setup
https://hub.helm.sh/charts/helm-stable/sensu      	0.2.3        	0.28         	Sensu monitoring framework backed by the Redis ...

on va si nous ne l'avons pas encore ajouter le repo bitnami :
helm repo add bitnami https://charts.bitnami.com

on va chercher un num de version de chart pas d'appli : le num de l'appli correspond a la version de redis pas celle du chart.

helm search repo redis --versions --max-col-width 100 |grep bit |head                                                       [☸ |minikube:chapter5]
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /home/boogie/.kube/config
WARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /home/boogie/.kube/config
bitnami/redis                                 	11.2.1       	6.0.8          	Open source, advanced key-value store. It is often referred to as a data structure server since k...
bitnami/redis                                 	11.2.0       	6.0.8          	Open source, advanced key-value store. It is often referred to as a data structure server since k...
bitnami/redis                                 	11.1.3       	6.0.8          	Open source, advanced key-value store. It is often referred to as a data structure server since k...
bitnami/redis                                 	11.1.1       	6.0.8          	Open source, advanced key-value store. It is often referred to as a data structure server since k...
bitnami/redis                                 	11.1.0       	6.0.8          	Open source, advanced key-value store. It is often referred to as a data structure server since k...
bitnami/redis                                 	11.0.7       	6.0.8          	Open source, advanced key-value store. It is often referred to as a data structure server since k...
bitnami/redis                                 	11.0.6       	6.0.8          	Open source, advanced key-value store. It is often referred to as a data structure server since k...
bitnami/redis                                 	11.0.5       	6.0.8          	Open source, advanced key-value store. It is often referred to as a data structure server since k...
bitnami/redis                                 	11.0.4       	6.0.8          	Open source, advanced key-value store. It is often referred to as a data structure server since k...
bitnami/redis                                 	11.0.3       	6.0.8          	Open source, advanced key-value store. It is often referred to as a data structure server since k..

Dependencies allow you to choose a particular chart version, or a wildcard such
as 10.5.x. Using a wildcard allows you to easily keep your chart updated with
the latest Redis version matching that wildcard (which, in this case, is version
10.5.14). In this example, we will use version 11.x.x

en épurant notre fichier Chart.yaml on a :

cat Chart.yaml                                                                                                              [☸ |minikube:chapter5]

apiVersion: v2
name: guestbook
description: A Helm chart for Kubernetes
type: application
version: 0.1.0
appVersion: 1.16.0
dependencies:
 - name: redis
 version: 11.x.x
 repository: https://charts.bitnami.com/bitnami

on va maintenant download notre dépendance :

ceci va dl le chart redis dans le rep charts et créer le fichier Chart.lock 
helm dependency update .

tree                       [☸ |minikube:chapter5]
.
└── guestbook
    ├── Chart.lock
    ├── charts
    │   └── redis-11.2.2.tgz
    ├── Chart.yaml
    ├── templates
    │   ├── deployment.yaml
    │   ├── _helpers.tpl
    │   ├── hpa.yaml
    │   ├── ingress.yaml
    │   ├── NOTES.txt
    │   ├── serviceaccount.yaml
    │   └── service.yaml
    └── values.yaml

- modification du fichier values.yaml 

en mode interractif on peut utliser les flags : --set or --values 
on va ajouter les valeurs qui nous interressent. Un chart doit être bien autodocumenté.

on va examiner les valeurs possible dans notre chart redis : 

helm show values charts/redis-11.2.2.tgz |head                                                                              [☸ |minikube:chapter5]
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /home/boogie/.kube/config
WARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /home/boogie/.kube/config
## Global Docker image parameters
## Please, note that this will override the image parameters, including dependencies, configured to use the global value
## Current available global Docker image parameters: imageRegistry and imagePullSecrets
##
global:
  # imageRegistry: myRegistryName
  # imagePullSecrets:
  #   - myRegistryKeySecretName
  # storageClass: myStorageClass
  redis: {}
....
.......

La premiere valeur qu'on va modifier est fullnameOverride :

## String to partially override redis.fullname template (will maintain the release name)
##
# nameOverride:

## String to fully override redis.fullname template
##
# fullnameOverride:


les charts utilisent souvent cette valeur dans un named template appellé "$CHART_NAME.fullname"
quand fullnameOverride est définie le named template va definir a cette valeur sinon le resultat de ce template se basera sur l'object ".Release.Name object, ou le nom de la release utilisée pour l'install.
La dependance redis utilise redis.fullname  pour aider la conf redis avec son master et slave.

ex d'une utilisation : 
name: {{ template 'redis.fullname' . }}-master

The Guestbook application requires the Redis services to be named redismaster and redis-slave. As a result, the fullnameOverride value should
be set to redis.

on peut decompresser le chart redis et examiner le fichier _helpers.tpl qui nous montre comment est defini le named template 
....
{{- define "redis.fullname" -}}
{{- if .Values.fullnameOverride -}}
{{- .Values.fullnameOverride | trunc 63 | trimSuffix "-" -}}
{{- else -}}
{{- $name := default .Chart.Name .Values.nameOverride -}}
...
Le code source de l'appli guestbook est dispo :
https://github.com/kubernetes/examples/blob/master/guestbook/php-redis/guestbook.php

dans le fichier values on va donc définir  des valeurs mandatory pour faire fonctionner l'appli guestbook 

fullnameOverride: "redis"  <<<< c'est le nom attendu pour l'appli
usePassword: false  <<<< l'appli simple n'utilise pas d'autent
on va aussi desactiver une option d'ecriture de backup de redis dans un configmap ( nous utiliserons plus tard un snapshot) 
configmap: |-
 appendonly no


Avec ces éléments de configs déterminés on va ajouter un bloc dans notre fichier values.yaml qui sera dédié à notre dépendance redis c'est pourquoi une section redis est ajoutée avec les valeurs dédiées overridées.
redis:
 # Override the redis.fullname template
 fullnameOverride: redis
 # Enable unauthenticated access to Redis
 usePassword: false
 # Disable AOF persistence
 configmap: |-
   appendonly no

L'utilisation de helm create a auto provisionner des fichiers qui vont devoir être modifiés car ils servent d'exemple

ex : dans le fichier values.yaml on a une image nginx de définie , un num de version

on va modifier les valeurs :
..
image:
  repository: repository: gcr.io/google-samples/gb-frontend  <<< on remplace l'image nginx par celle de notre appli
...
service:
  type: NodePort  <<<<< on met NodePort à la place de ClusterIp
  port: 80

on va modifier le fichier Chart.yaml pour changer le appVersion :

appVersion: v4

on lance l'install de notre chart :

helm install my-guestbook . -n chapter5                                                                                    [☸ |minikube:chapter5]
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /home/boogie/.kube/config
WARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /home/boogie/.kube/config
Error: cannot load values.yaml: error converting YAML to JSON: yaml: line 8: mapping values are not allowed in this context
 ✘ boogie@boogieland  ~/Documents/lab/helm/guestbook/guestbook  vi values.yaml                                                                                                            [☸ |minikube:chapter5]
 boogie@boogieland  ~/Documents/lab/helm/guestbook/guestbook  helm install my-guestbook . -n chapter5                                                                                     [☸ |minikube:chapter5]
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /home/boogie/.kube/config
WARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /home/boogie/.kube/config
NAME: my-guestbook
LAST DEPLOYED: Sun Oct 25 18:42:11 2020
NAMESPACE: chapter5
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
1. Get the application URL by running these commands:
  export NODE_PORT=$(kubectl get --namespace chapter5 -o jsonpath="{.spec.ports[0].nodePort}" services my-guestbook)
  export NODE_IP=$(kubectl get nodes --namespace chapter5 -o jsonpath="{.items[0].status.addresses[0].address}")
  echo http://$NODE_IP:$NODE_PORT


on verifie notre install : 
kctl get pods                                                                                                               [☸ |minikube:chapter5]
NAME                            READY   STATUS    RESTARTS   AGE
my-guestbook-794d6fbfd7-kldj5   1/1     Running   0          79s
redis-master-0                  1/1     Running   0          79s
redis-slave-0                   1/1     Running   0          79s
redis-slave-1                   1/1     Running   0          27s

on va lancer les commandes fournies dans le NOTES de notre install pour acceder à l'appli :

  export NODE_PORT=$(kubectl get --namespace chapter5 -o jsonpath="{.spec.ports[0].nodePort}" services my-guestbook)
  export NODE_IP=$(kubectl get nodes --namespace chapter5 -o jsonpath="{.items[0].status.addresses[0].address}")
  echo http://$NODE_IP:$NODE_PORT
http://192.168.39.214:32256

curl -I http://192.168.39.214:32256                                                                                         [☸ |minikube:chapter5]

HTTP/1.1 200 OK
Date: Sun, 25 Oct 2020 17:44:58 GMT
Server: Apache/2.4.10 (Debian) PHP/5.6.20
Last-Modified: Wed, 09 Sep 2015 18:35:04 GMT
ETag: "399-51f54bdb4a600"
Accept-Ranges: bytes
Content-Length: 921
Vary: Accept-Encoding
Content-Type: text/html


si on reussi a saisir un message dans le champ c'est que tout est ok et que c'est ecrit en db

on va desinstaller notre chart et detruire le pvc manuellement pour améliorer notre chart 

helm uninstall my-guestbook -n chapter5                                                                                    [☸ |minikube:chapter5]
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /home/boogie/.kube/config
WARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /home/boogie/.kube/config
release "my-guestbook" uninstalled
 boogie@boogieland  ~/Documents/lab/helm/guestbook/guestbook  kubectl delete pvc -l app=redis -n chapter5                                                                                 [☸ |minikube:chapter5]
persistentvolumeclaim "redis-data-redis-master-0" deleted
persistentvolumeclaim "redis-data-redis-slave-0" deleted
persistentvolumeclaim "redis-data-redis-slave-1" deleted

= Amelioration du chart guestbook : =

toutes les applis peuvent être améliorées ..dans notre cas on veut ameliorer deux éléments 
> ajouter des hooks de backup et restoration de db redis 
> ajouter un controle de saisi dans le formulaire web de notre app.

- creation de hooks pré-upgrade et pré-rollback 

> pré-upgrade : ce hook intervient des que la commande upgrade est executée mais avant la modif de ressources kube. On va créer un snapshot de db au cas ou l'upgrade se passe mal.
> pre-rollback : ce hook intervient des que la commande rollback est executée mais avant le revert des ressources kube : une restoration du snap de db va être fait pour s'assurer qu'on va revenir sur les data correspondante à notre version rollbackée


- pre-upgrade hook :
dans redis les data de snapshots sont stockées dans un fichier  dump.rdb 
on peut backuper ce fichier en creant un pvc , ce hook peut créer un job qui copie le fichier dans le nouveau pvc crée

on va donc créer nous même ce hook 

dans le rep templates on crée un rep backup :
mkdir backup

on va ensuite créer deux fichiers pour nos deux taches 

touch persistentvolumeclaim.yaml ; touch job.yaml


- pvc : 

cat  persistentvolumeclaim.yaml                                                                         
{{- if .Values.redis.master.persistence.enabled }}   <<<< ici tout le bloc du if est appliqué si la valeur redis.master.persistence.enabled  est définie à vrai : ce qui est le cas quand on examine les valeurs du chart de dependance redis : helm show values charts/redis-11.2.2.tgz |grep persistence
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: redis-data-{{ .Values.redis.fullnameOverride }}-master-0-backup-{{ sub .Release.Revision 1 }} <<< ici on defini le nom de notre pvc dédié au backup il contient le mot backup et comporte le num de version qui est celui de la version de l'upgrade -1 grace a la fonction sub ..1 : on a donc un snap avec nos data fraiches au cas ou l'upgrade se passe mal. 
  labels:
    {{- include "guestbook.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": pre-upgrade <<< on crée un annotation pre upgrade 
    "helm.sh/hook-weight": "0"   <<< on donne un poid a notre hook : la valeur 0 indique que ce hook est executé avant tous les autres .
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: {{ .Values.redis.master.persistence.size }}
{{- end }}



- job :

cat job.yaml                                                                                             
{{- if .Values.redis.master.persistence.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "guestbook.fullname" . }}-backup
  labels:
    {{- include "guestbook.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": pre-upgrade   <<<<<  on defini ici une annotation de pre-upgrade 
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded  <<< on pose ici une annotation qui va permettre de delete le hook ( de base les hook ne sont pas détruit . on ajoute la policy before-hook-creation,hook-succeeded : qui va donc détruire le job pendant les phases d'upgrade : pour relancer un bacth frais , de plus le job sera delete si le run c'est bien passé.
    "helm.sh/hook-weight": "1" <<<< la valeur ici est de 1 : ce hook passe donc apres notre hook de pvc 
spec:
  template:
    spec:
      containers:
        - name: backup
          image: redis:alpine3.11
          command: ["/bin/sh", "-c"]
          args: ["redis-cli -h {{ .Values.redis.fullnameOverride }}-master save && cp /data/dump.rdb /backup/dump.rdb"]  <<<<<< ici on defini la commande qui va va se connecter au master , faire le backup et le copier sur le pvc crée pour 
          volumeMounts:
            - name: redis-data
              mountPath: /data
            - name: backup
              mountPath: /backup
      restartPolicy: Never
      volumes:                     <<<<<<  on defini ici les pvc master et backup qui seront montés pour l'operation de backup 
        - name: redis-data
          persistentVolumeClaim:
            claimName: redis-data-{{ .Values.redis.fullnameOverride }}-master-0
        - name: backup
          persistentVolumeClaim:
            claimName: redis-data-{{ .Values.redis.fullnameOverride }}-master-0-backup-{{ sub .Release.Revision 1 }}
{{- end }}



- creation du hook de pre-rollback : 

sous le rep templates : mkdir restore

cat job.yaml                                                                                            

{{- if .Values.redis.master.persistence.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "guestbook.fullname" . }}-restore
  labels:
    {{- include "guestbook.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": pre-rollback   <<<< on defini un hook de pre rollback 
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  template:
    spec:
      containers:
        - name: restore
          image: redis:alpine3.11
          command: ["/bin/sh", "-c"]
          args: ["cp /backup/dump.rdb /data/dump.rdb &&  <<<< ici on copie depuis notre pvc backup le snap et on reinjecte sur le master db , on restart la base redis.
            redis-cli -h {{ .Values.redis.fullnameOverride }}-master debug restart || true"]  <<< on s'assure que le code retour du redemarrage de la base est n'est pas ok  : on a un retour "normal" de redis qui nous dis que la connexion a la db s'est terminée ,on a un code retour different de 0 .. on rajoute un || true qui va donc sortir si on a un code retour à 0 ..ce qui prouverai que le redémarrage n'a pas eu lieu. 
          volumeMounts:
            - name: redis-data
              mountPath: /data
            - name: backup
              mountPath: /backup
      restartPolicy: Never
      volumes:
        - name: redis-data
          persistentVolumeClaim:
            claimName: redis-data-{{ .Values.redis.fullnameOverride }}-master-0
        - name: backup
          persistentVolumeClaim:
            claimName: redis-data-{{ .Values.redis.fullnameOverride }}-master-0-backup-{{ .Release.Revision }}  <<< on defini le volume de backup voulu avec le num de revision.
{{- end }}


- reinstall de notre chart avec les hooks :

helm install  guestbook .

on va tester qu'on a acces a l'appli et qu'on peut ecrire un message 

quand c'est ok on lance notre upgrade :

helm upgrade  guestbook .

on voit que notre pvc de backup  est créee :

kctl get pvc                                                                                                                [☸ |minikube:chapter5]
NAME                                 STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
redis-data-redis-master-0            Bound    pvc-fcfc75d3-c4b3-4ca7-9d47-284fe8ab06a9   8Gi        RWO            standard       2m43s
redis-data-redis-master-0-backup-1   Bound    pvc-d6369288-924a-4399-b56b-547feffc2b3b   8Gi        RWO            standard       39s
redis-data-redis-slave-0             Bound    pvc-655ed8cc-b873-4c20-a474-2b2c61e15b58   8Gi        RWO            standard       2m43s
redis-data-redis-slave-1             Bound    pvc-7d523ddf-71f5-4295-8b9d-198ff635386c   8Gi        RWO            standard       2m2s

on ajoute un message dans le champ de notre appli :
on a deux messages visibles 

on va maintenant faire un rollback pour tester la resto de notre snap :

helm rollback   guestbook 1 .                                                                                               [☸ |minikube:chapter5]
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /home/boogie/.kube/config
WARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /home/boogie/.kube/config
Rollback was a success! Happy Helming!

on a donc trigger notre rollback qui a injecté le snap ..en examinant notre frontend on a plus que le message initial présent apres l'install de notre chart


= Ajout de controle de validation de saisie :

en travaillant avec kube et helm, des controles de saisies sont effectués par l'api de kube : si une ressource crée par helm est invalide : une erreur sera retournée par l'api de kube.
Il va rester des cas ou on va vouloir pendant le developpement de notre chart s'assurer de controle avant de pousser et atteindre l'api de kube.
On peut utiliser la fonction fail dans notre chart guestbook.

- function fail :

elle est utilisée pour echouer directement dans le process de templating si un user a saisi une mauvaise valeur par ex.

ex dans notre chart guestbook on a une valeur qui défini le type de service qui sera utilisé.
cat values.yaml
...
service:
  type: NodePort
  port: 80
...

ici on a defini NodePort (pour minikube) .
On pourrait vouloir limiter la saisi à NodePort ou ClusterIP par exemple.

si on regarde le template service.yaml, on a la section :
cat templates/service.yaml
..
spec:
  type: {{ .Values.service.type }}
...

on va vouloir qu'assurer que le service est défini à ClusterIP ou NodePort avant de définir le type de service.On va pouvoir définir une variable avec la liste des bon settings puis vérifier que la valeur de service.type est bien dans la liste de bon settings : sinon le processing de chart retournera une erreur sur le type de service saisi comme invalide.
Notre template va donc être structuré comme suivant :

apiVersion: v1
kind: Service
metadata:
  name: {{ include "guestbook.fullname" . }}
  labels:
    {{- include "guestbook.labels" . | nindent 4 }}
spec:
{{- $serviceTypes := list "ClusterIP" "NodePort" }}   <<<<< on defini une variable contenant la liste des type de services authorisés.
{{- if has .Values.service.type $serviceTypes }}      <<<<< on évalue la valeur définie pour .Values.service.type et on examine si on a bien une valeur a "ClusterIP" ou "NodePort"
  type: {{ .Values.service.type }}                    <<<<< si la valeur définie dans notre fichier de values est valide ("ClusterIP" ou "NodePort") : alors on défini notre type a la valeur saisie
{{- else }}                                       
  {{- fail "value 'service.type' must be either 'ClusterIP' or 'NodePort'" }}   <<<<<< sinon on lève une erreur en précisant que nous avons saisi une mauvaise valeur dans notre fichier pour le type de service.
{{- end }}

Si on test en définissant un service de type LoadBalancer on a bien une erreur de sortie :

helm upgrade guestbook . -n chapter5 --set service.type=LoadBalancer                                                        
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /home/boogie/.kube/config
WARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /home/boogie/.kube/config
Error: UPGRADE FAILED: template: guestbook/templates/service.yaml:12:6: executing "guestbook/templates/service.yaml" at <fail "value 'service.type' must be either 'ClusterIP' or 'NodePort'">: error calling fail: value 'service.type' must be either 'ClusterIP' or 'NodePort'


- require : fonction de validation de valeur saisie
on va aussi pouvoir s'assurer que les users ont bien saisi une valeur par defaut dans le fichier de values et qu'en aucun cas une valeur vide ne peut fonctionner 

exemple : on va pouvoir s'assurer qu'une image précise sra utilisée dans notre déploiement :

cat templates/deployment.yaml                                                                                     
          ..
          image: '{{ .Values.image.repository }}:{{ .Chart.AppVersion }}'
          #image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"   <<<<< valeur definie dans le tpls de base mais ne collant pas avec l'explication du book.
on va utiliser la fonction require pour nous assurer de l'tilisation d'une image précise :

require prend deux args :
> un message d'erreur pour afficher la valeur attendue 
> la valeur attendue

on aura dans notre cas donc :

          image: "{{ required "value 'image.repository' is required" .Values.image.repository }}:{{ .Chart.AppVersion }}"

si on essaye d'upgrader avec une valeur vide on aura un message d'erreur :

helm upgrade guestbook . -n chapter5 --set image.repository=''                                                            [☸ |minikube:chapter5]
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /home/boogie/.kube/config
WARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /home/boogie/.kube/config
Error: UPGRADE FAILED: execution error at (guestbook/templates/deployment.yaml:28:21): value 'image.repository' is required

= Publication de notre chart dans un repo : 

maintenant qu'on a un chart on va pouvoir le publier dans un repo pour le rendre dispo :

- creation de repo :

un repo helm contient :
> des chart sous la forme de tgz
> un fichier index.yaml contenant les metadata des charts présents dans le repo

un repo basic nécéssite qu'un maintener s'occupe de la gestion du fichier index.yaml.
Des solutions plus élaborées comme chartmuseum gèrent automatiquement ce fichier.
on va ici utiliser github pages pour faire un repo simple.

une fois notre compte crée, on cree un repo avec un readme et on active github pages dans les settings en choississant la branche main (anciennement master) et en choississant un theme graphique qui nous plait.

on clone en local de repo  dans une arbo voulu ex /tmp 

git clone https://github.com/billbongo/helm-charts.git

on va modifier la version du chart dans le Chart.yaml :
on passe en version 1.0.0 : une majeure. 

version: 1.0.0

on va maintenant packager notre chart :
cd ..
helm package guestbook


on a maintenant un chart tgz au même niveau que le repertoire de notre chart :

tree                                                                                                                               
.
├── guestbook
│   ├── Chart.lock
│   ├── charts
│   │   └── redis-10.5.14.tgz
│   ├── Chart.yaml
│   ├── helm-charts
│   │   └── README.md
│   ├── templates
│   │   ├── backup
│   │   │   ├── job.yaml
│   │   │   └── persistentvolumeclaim.yaml
│   │   ├── deployment.yaml
│   │   ├── _helpers.tpl
│   │   ├── hpa.yaml
│   │   ├── ingress.yaml
│   │   ├── NOTES.txt
│   │   ├── restore
│   │   │   └── job.yaml
│   │   ├── serviceaccount.yaml
│   │   └── service.yaml
│   └── values.yaml
└── guestbook-1.0.0.tgz


si on a un souci on peut s'assurer que les dépendances de notre chart sont bien présentes en ajoutant :
--dependency-update flag a la commande helm package ,ce qui a download les dependance et packager le chart dans la même commande 


on va maintenant copier le tgz dans notre repo git cloné :
cp guestbook-1.0.0.tgz /tmp/helm-charts

on va maintenant créer notre fichier index :
avec la commande helm repo index <nom du repo git cloné en local> 

helm repo index helm-charts                                     
 boogie@boogieland  /tmp  cd helm-charts                                                                                                                                                  [☸ |minikube:chapter5]
 boogie@boogieland  /tmp/helm-charts   main  ls                                                                                                                                         [☸ |minikube:chapter5]
guestbook-1.0.0.tgz  index.yaml  README.md
 boogie@boogieland  /tmp/helm-charts   main  cat index.yaml                                                                                                                             [☸ |minikube:chapter5]
apiVersion: v1
entries:
  guestbook:
  - apiVersion: v2
    appVersion: v4
    created: "2020-11-01T18:11:23.696154925+01:00"
    dependencies:
    - name: redis
      repository: https://charts.bitnami.com/bitnami
      version: 10.5.x
    description: A Helm chart for Kubernetes
    digest: a1bb696d44ebb3fdb7f0823b3f394b2b093712fda426081de08fec686403a725
    name: guestbook
    type: application
    urls:
    - guestbook-1.0.0.tgz
    version: 1.0.0
generated: "2020-11-01T18:11:23.691250105+01:00"

on ajoute les fichiers, on commit et on pousse dans le repo :

git add --all
git commit -m 'feat: adding the guestbook helm chart'
git push origin main

on va maintenant ajouter notre repo dans notre liste 
on doit récupérer l'url de github pages qu'on peut voir dans les settings 

https://billbongo.github.io/helm-charts/

helm repo add billbongo https://billbongo.github.io/helm-charts
"billbongo" has been added to your repositories


== Testing helm-charts ==

on va tester pour valider le fonctionnement de notre chart et eviter les régressions de code.
on va pouvoir vérifier de plusieurs manières :

on va créer un nouveau namespace pour tester notre chart 
kctl create ns chapter6 

- helm template :


