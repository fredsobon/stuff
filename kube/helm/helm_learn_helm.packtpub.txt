===== notes learn helm packpub : =====


- chap2 : install chart :

on va set up un wordpress 
minikube 4gb de ram driver / vm-driver: kvm2

helm repo add bitnami https://charts.bitnami.com/bitnami

kubectl create namespace chapter3
namespace/chapter3 created

on va pouvoir overrider les values de base que l'on peut examiner avaec la commande suivante : 

 helm show values bitnami/wordpress --version 8.1.0
The result of this command should be a long list of possible values that you
...

on va créer un fichier contenant les valeurs que nous voulons personaliser ( user , mdp bdd, nom du blog ...
on va comme on travaille dans minikube modifier la conf reseau en modifiant la conf loadbalancer en nodeport 

cat wordpress-values.yaml
wordpressUsername: helm-user
wordpressPassword: my-pass
wordpressEmail: helm-user@example.com
wordpressFirstName: boogie
wordpressLastName: man
wordpressBlogName: Learn Helm!
service:
 type: NodePort

on lance l'install :

helm install [NAME] [CHART] [flags]

-> Name : le nom que l'on veut donner à notre release helm
-> Chart : est le nom du chart helm installer (on peut utiliser la forme  <repo name>/<chart name>
-> flags : params que l'on peut passer pour overrider des valeurs par exemple.

on lance l'install :

helm install wordpress bitnami/wordpress --values=wordpress-values.yaml --namespace chapter3 --version 8.1.0
NAME: wordpress
LAST DEPLOYED: Sun Oct  4 17:22:23 2020
NAMESPACE: chapter3
STATUS: deployed
REVISION: 1
NOTES:
1. Get the WordPress URL:

  export NODE_PORT=$(kubectl get --namespace chapter3 -o jsonpath="{.spec.ports[0].nodePort}" services wordpress)
  export NODE_IP=$(kubectl get nodes --namespace chapter3 -o jsonpath="{.items[0].status.addresses[0].address}")
  echo "WordPress URL: http://$NODE_IP:$NODE_PORT/"
  echo "WordPress Admin URL: http://$NODE_IP:$NODE_PORT/admin"

2. Login with the following credentials to see your blog

  echo Username: helm-user
  echo Password: $(kubectl get secret --namespace chapter3 wordpress -o jsonpath="{.data.wordpress-password}" | base64 --decode)


on voit le contenu du fichier note du chart  affiché 
on peut examiner le chart installé :

helm list --namespace chapter3
NAME     	NAMESPACE	REVISION	UPDATED                                 	STATUS  	CHART          	APP VERSION
wordpress	chapter3 	1       	2020-10-04 17:22:23.914776076 +0200 CEST	deployed	wordpress-8.1.0	5.3.2

The list subcommand provides the following information:
• The release name
• The release namespace
• The latest revision number of the release
• A timestamp of the latest revision
• The release status
• The chart name
• The application version

-  helm namespace variable d'environment :
on peut definir une variable d'env définissant le namespace dans lequel on travaille avec notre helm :

export HELM_NAMESPACE=chapter3-  helm namespace variable d'environment :
on peut definir une variable d'env définissant le namespace dans lequel on travaille avec notre helm :

export HELM_NAMESPACE=chapter3
verif :
helm env
HELM_BIN="helm"
HELM_DEBUG="false"
HELM_KUBEAPISERVER=""
HELM_KUBECONTEXT=""
HELM_KUBETOKEN=""
HELM_NAMESPACE="chapter3"
HELM_PLUGINS="/home/boogie/.local/share/helm/plugins"
HELM_REGISTRY_CONFIG="/home/boogie/.config/helm/registry.json"
HELM_REPOSITORY_CACHE="/home/boogie/.cache/helm/repository"
HELM_REPOSITORY_CONFIG="/home/boogie/.config/helm/repositories.yaml"


- choisir entre --set et --values :
on peut overrider des valeur en cli avec --set ,
une bonne pratique est d'utiliser un fichier de values que l'on pourra versionner par ex dans git.
Biensur on ne met pas les secret dans git et on verra plus tard comment passer des secrets dans nos charts.

= exam de notre wordpress :

export NODE_PORT=$(kubectl get --namespace chapter3 -o jsonpath="{.spec.ports[0].nodePort}" services wordpress)

export NODE_IP=$(kubectl get nodes --namespace chapter3 -o jsonpath="{.items[0].status.addresses[0].address}")

echo "WordPress URL: http://$NODE_IP:$NODE_PORT/"
WordPress URL: http://192.168.39.214:32575/


on se logge dans notre navigo :

echo "WordPress Admin URL: http://$NODE_IP:$NODE_PORT/admin"
WordPress Admin URL: http://192.168.39.214:32575/admin

on se loggue en recupérant les infos user et mdp defini dans le fichier values


echo Username: helm-user
on peut onterroger kube pour retrouver le mdpt stocké en secret : 
echo Password: $(kubectl get secret --namespace chapter3 wordpress -o jsonpath='{.data.wordpress-password}' | base64 --decode)
Password: my-pass


on va maintenant upgrader notre chart en ajoutant un replicat et definisssant des ressources pour notre appli : on modifie donc notre fichier de values :

cat wordpress-values.yaml
wordpressUsername: helm-user
wordpressPassword: my-pass
wordpressEmail: helm-user@example.com
wordpressFirstName: boogie
wordpressLastName: man
wordpressBlogName: Boogie Learn Helm!
service:
  type: NodePort
replicaCount: 2
resources:
  requests:
   memory: 256Mi
   cpu: 100m  


helm upgrade [RELEASE] [CHART] [flags]

helm upgrade wordpress bitnami/wordpress --values wordpress-values.yaml -n chapter3 --version 8.1.0
Release "wordpress" has been upgraded. Happy Helming!
NAME: wordpress
LAST DEPLOYED: Sun Oct  4 18:14:33 2020
NAMESPACE: chapter3
STATUS: deployed
REVISION: 4
NOTES:
1. Get the WordPress URL:

  export NODE_PORT=$(kubectl get --namespace chapter3 -o jsonpath="{.spec.ports[0].nodePort}" services wordpress)
  export NODE_IP=$(kubectl get nodes --namespace chapter3 -o jsonpath="{.items[0].status.addresses[0].address}")
  echo "WordPress URL: http://$NODE_IP:$NODE_PORT/"
  echo "WordPress Admin URL: http://$NODE_IP:$NODE_PORT/admin"

2. Login with the following credentials to see your blog

  echo Username: helm-user
  echo Password: $(kubectl get secret --namespace chapter3 wordpress -o jsonpath="{.data.wordpress-password}" | base64 --decode)


Reusing and resetting values during an upgrade
The helm upgrade command includes two additional flags that are used to manipulate
values that are not present in the helm install command.
Let's look at these flags now:
• --reuse-values: When upgrading, reuse the last release's values.
• --reset-values: When upgrading, reset the values to the chart defaults.


par default si on ne precise rien le reuse-values est utilisé.

si on fait un upgrade avec un --set seule la valeur modifiée est changée : le reste des valeurs definies dans notre fichier sont ignorées :
helm upgrade wordpress bitnami/wordpress --set replicaCount=1 -n chapter3 --version 8.1.0

helm get values wordpress -n chapter3
USER-SUPPLIED VALUES:
replicaCount: 1


on a donc un reset des values défnies au préalable.
Users can manually provide the --reset-values or --reuse-values flags to
explicitly determine the behavior of values during an upgrade. Use the --resetvalues flag if you would like the next upgrade to reset each value to its default before
overriding it from the command line. Provide the --reuse-values flag if you would
like to reuse each of the values from a previous revision while setting different values from
the command line. To help simplify the management of values during an upgrade, try to
keep your values in a file that can be used to declaratively set values for each upgrade

- History :

les revisions des releases sont conservées en secret dans kube ( par defautl on peut les definir en configmap ou en mémoire que l'on defini dans la var HELM_DRIVER 
ex: 

 kubectl get secrets -n chapter3
NAME                              TYPE                                  DATA   AGE
default-token-n8m5s               kubernetes.io/service-account-token   3      118m
sh.helm.release.v1.wordpress.v1   helm.sh/release.v1                    1      96m
sh.helm.release.v1.wordpress.v2   helm.sh/release.v1                    1      83m
sh.helm.release.v1.wordpress.v3   helm.sh/release.v1                    1      52m
sh.helm.release.v1.wordpress.v4   helm.sh/release.v1                    1      44m
sh.helm.release.v1.wordpress.v5   helm.sh/release.v1                    1      31m
sh.helm.release.v1.wordpress.v6   helm.sh/release.v1                    1      26m
wordpress                         Opaque                                1      96m
wordpress-mariadb                 Opaque                                2      96m

helm history wordpress -n chapter3
REVISION	UPDATED                 	STATUS    	CHART          	APP VERSION	DESCRIPTION
1       	Sun Oct  4 17:22:23 2020	superseded	wordpress-8.1.0	5.3.2      	Install complete
2       	Sun Oct  4 17:36:10 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
3       	Sun Oct  4 18:06:46 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
4       	Sun Oct  4 18:14:33 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
5       	Sun Oct  4 18:27:41 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
6       	Sun Oct  4 18:32:46 2020	deployed  	wordpress-8.1.0	5.3.2      	Upgrade complete


on peut examiner les valeurs d'une revision : 

helm get values wordpress --revision 3 -n chapter3
USER-SUPPLIED VALUES:
service:
  type: NodePort
wordpressBlogName: Learn Helm!
wordpressEmail: helm-user@example.com
wordpressFirstName: boogie
wordpressLastName: man
wordpressPassword: my-pass
wordpressUsername: helm-user


 helm get values wordpress --revision 6 -n chapter3
USER-SUPPLIED VALUES:
replicaCount: 1


- rollback :

helm rollback <RELEASE> [REVISION] [flags]

helm rollback wordpress 5 -n chapter3
Rollback was a success! Happy Helming!

on peut voir le rollback dans l'history :

helm history wordpress -n chapter3
REVISION	UPDATED                 	STATUS    	CHART          	APP VERSION	DESCRIPTION
1       	Sun Oct  4 17:22:23 2020	superseded	wordpress-8.1.0	5.3.2      	Install complete
2       	Sun Oct  4 17:36:10 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
3       	Sun Oct  4 18:06:46 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
4       	Sun Oct  4 18:14:33 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
5       	Sun Oct  4 18:27:41 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
6       	Sun Oct  4 18:32:46 2020	superseded	wordpress-8.1.0	5.3.2      	Upgrade complete
7       	Sun Oct  4 19:09:33 2020	deployed  	wordpress-8.1.0	5.3.2      	Rollback to 5

on retrouve bien les valeurs voulues dans notre version rollbackée :

helm get values wordpress -n chapter3
USER-SUPPLIED VALUES:
replicaCount: 2
resources:
  requests:
    cpu: 100m
    memory: 256Mi
service:
  type: NodePort
wordpressBlogName: Boogie Learn Helm!
wordpressEmail: helm-user@example.com
wordpressFirstName: boogie
wordpressLastName: man
wordpressPassword: my-pass
wordpressUsername: helm-user


- Desinstallation de chart :

helm uninstall RELEASE_NAME [...] [flags]

helm uninstall wordpress -n chapter3
release "wordpress" uninstalled

helm list -n chapter3
NAME	NAMESPACE	REVISION	UPDATED	STATUS	CHART	APP VERSION


Attention il va rester un persistantvolumeclaim defini dans le statefullset qui n'est pas supprimé lors de la désinstallation du chart.
le statefullset est deleted mais le pvc associé a ce statfullset ne l'est pas.

kctl get pvc -n chapter3
NAME                       STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
data-wordpress-mariadb-0   Bound    pvc-014b0631-6f4e-4dfb-9182-068750a2cff0   8Gi        RWO            standard       114m


on va donc le supprimer manuellement :

 kubectl delete pvc -l release=wordpress -n chapter3

-suppression de notre namespace et arret de minikube :
 kubectl delete namespace chapter3
  minikube stop

== understanding helm charts : ==

= yaml format :

format utilisé entre autre dans kube et helm.
"YAML files follow a key-value format to declare configuration." 

- definition d'une simple paire clé / valeur
ex: 
name: LearnHelm

clé = name
valeur = LearnHelm

on a un separateur ":" entre les deux ET un espace qui est obligatoire.
on peut imbriquer dans yaml plusieurs blocs :
ex :
resources:
 limits:
 cpu: 100m
 memory: 512Mi

cette ressource contient une map de 2 paires de clés / valeurs
Clé                       valeur
ressources.limits.cpu     100m
ressources.limits.memory  512Mi
Les clés sont déterminées par l'indentation yaml . Chaque indentation ajoute un "." separateur au nom de la clé.
La valeur de la clé est atteinte quand il ne reste plus d'indentation dans le yaml.
De base l'indentation yaml est de 2 espaces. Attention les tabulations ne sont pas admises et font ressortir une parse error.

- types de valeurs :

-> string : en principe on peut entourer le texte de ".

Les multi lignes peuvent être construites avec un |
ex: 
configuration: |
 server.port=8443
 logging.file.path=/var/log
-> integer :
ex: 
replicas: 1

Attention si on quote la valeur elle sera considérée comme une string:
replicas: "1"

-> boolean :
ex: 
ingress:
 enable: true

 prend 2 valeurs true ou false
mais aussi yes, no, on, off, y, n, Y, and N

-> list :

les éléments d'une liste sont présentées par "-" :
ex: 
servicePorts:
 - 8080
 - 8443

autre exemple :
deployment:
  env:
   - name: MY_VAR
     value: MY_VALUE
   - name: SERVICE_NAME
     value: MY_SERVICE

dans cet exemple la tableau contient une liste d'objects contenant des champs name et value 


= json :

" JSON is a string of key-value
pairs, similar to YAML. The key difference is that while YAML relies on spacing and
indentation to properly configure key-value pairs, JSON relies on braces and brackets."

exemple precedent en json :
{
 'deployment': {
 'env': [
   {
     'name': 'MY_VAR',
     'value': 'MY_VALUE'
   },
   {
     'name': 'SERVICE_NAME',
     'value': 'MY_SERVICE'
   }
  ]
 }

Toutes les clés sont entourées de simple quote "'" précédent un ":"

"Curly braces ({) denote a block in a similar way to how indentations denote a
block in YAML.
• Square brackets ([) denote a list in a similar way to how dashes denote a list
in YAML."

= helm chart structure : =

un chart est un packaging de ressources kube permettant de déployer des applis de maniere plus ou moins complexes.
Une structure est cependant  respecter :

mychart  > le repertoire top level domaine est le nom du chart par bonne pratique.

Chart.yaml -> fichier contenant les metadata du chart. mandatory
templates -> repertoire contenant les ressources kube sous format yaml  mandatory en principe
templates/NOTES.txt -> fichier d'instruction qui donnent des informations sur l'installation d'un chart . pas mandatory 
values.yaml -> fichier contenant les valeurs par défaut du chart. Ce fichier est une best practice de helm.
.helmignore -> fichier contenant une list de fichiers et repertoire à exclure pour le packaging de helm.
charts/   -> repertoire contenant les charts dont ce chart dépend. PAs mandatory car le process de helm dependancy va créer automatiquement ce rep.
Chart.lock -> fichier pour sauvegarder la version des precedentes dépendances appliquées.PAs mandatory car le process de helm dependancy va créer automatiquement ce rep.
crds/ -> repertoire contenant des crd en yaml devant être installées avant les fichiers dans le rep templates.
README.md -> fichier contenant les consignes d'install du chart. Best practice.
LICENCE -> fichier contenant la licence d'un chart . pas mandatory
values.schema.json -> fichier contenant les données du fichier values sous format json. pas mandatory


- Charts templates :

Le principal but d'un chart est de creer et manager les ressources kube pour faire une application.Ceci est fat grace aux templates dont les valeurs passées en parametres vont customiser ces templates.
le rep template contient des ressources kube en yaml 

ex: 
templates/
 configmap.yaml
 deployment.yaml
 service.yaml

la configmap pourra être comme ceci :
apiVersion: v1
kind: ConfigMap
metadata:
 name: {{ .Release.Name }}
data:
 configuration.txt: |-
 {{ .Values.configurationData }}

Les {{ et }} sont issues du templating go et ces blocs seront remplacés et alimentés par les valeurs des éléments trouvés dans le / les fichiers values et par les variables internes builin à helm.

- Go templating :

language go initié par google en 2009, utilisé par kube, helm et autres ...
un des éléments au coeur de go est son moteur de templating qui va permettre de générer des fichiers sous différents formats.
le templating go controle et process les blocs compris entre {{ et }}, lors de l'install ou l'upgrade d'un chart ce fait ces accolades sont supprimées.

- paramétrage de base et objects builtin :

les charts helm contiennent au moins un fichier values.yaml qui contient les valeurs par défault du chart qui sont reférencées par les templates go et procéssées par helm pour générer une ressource kube.
ex: values.yaml

## chapterNumber lists the current chapter number
chapterNumber: 4
## chapterName gives a description of the current chapter
chapterName: Understanding Helm Charts

les lignes commencant par un # sont des commentaires qui peuvent nous aider à comprendre les valeurs.
Les templates go commancant par .Values vont référencer les valeurs définies dans le fichier values.yaml ou passées en argument avec les flags --set ou --values pendant l'installation ou l'upgrade d'un chart
L'exemple suivant nous montre le template avant son traitement : 
env:
 - name: CHAPTER_NUMBER
 value: {{ .Values.chapterNumber }}
 - name: CHAPTER_NAME
 values: {{ .Values.chapterName }}

Apres le traitement le code de la ressource  concernée sera donc comme suivant : 
env:
 - name: CHAPTER_NUMBER
 value: 4
 - name: CHAPTER_NAME
 values: Understanding Helm Charts



- built in :

Le .Values est un objet builtin utilisé pour le paramétrage.
cf list des built in dans la  documentation (https://helm.sh/docs/chart_template_guide/builtin_objects/)

les élément suivants sont les principaux :

.Release.Name -> nom de la release utilisé pour l'installation
.Release.Namespace -> namespace utilisé pour le déployement du chart.
.Release.Revision -> num de revision d'install ou d'upgrade
.Values -> utilisé pour pour référencer les valeurs du ou des fichiers values.yaml ou defini en param sur la ligne de cimmande par le user.

.Values -> utilisé pour pour référencer les valeurs du ou des fichiers values.yaml ou defini en param sur la ligne de cimmande par le user.
.Chart.Name, .Chart.Version, .Chart.AppVersion ... -> utilisés pour référencer les champs dans le fichier Chart.yaml : on peut utiliser les différents champ de ce fichier par .Chart.$Field
.Files.Get -> utilisé pour recupérer un fichier dans un rep du chart.
.Files.AsSecrets -> retourne un fichier encodé en base64 pour créer un secret depuis un fichier dans un repertoire du chart.
.Files.AsConfig -> retourne les données d'un fichier sous format yaml pour créer les data d'une configmap avec les données d'un fichier dans un rep du chart.
.Capabilities.APIversions -> retourne une liste de l&pi kube du cluster
.Template.Name -> retourne le chemin relatif du fichier utilisé par l'object.

Le "." prefixant chaque objet représente le scope de l'object.
Un "." suivi d'un nom d'object limite le scope à cet object :
ex: .Release > limite au scope .Release , .Values au scope .Values 

Le "." représente le scope global : rendant tous les objects visibles.


 
