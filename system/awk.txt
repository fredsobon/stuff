
== Awk : ===


urls utiles :
http://nyal.developpez.com/tutoriel/gawk/?page=intro
http://www.shellunix.com/awk.html

- bases : 

Awk traite ligne par ligne sous la forme '/pattern/ {command} .On peut rajouter une section en début de travail qui ne sera afficher q'une fois ( comme un header ) ensuite le cours de notre traitement .

awk -Fs '/pattern/ {action}' input-file  
(or)
awk -Fs '{action}' intput-file
 
/pattern/ est optionnel : si on ne precise rien : l'integralité du texte est traitée.
TOUTES les commandes/actions awk doivent être entourées par des '{}'.
TOUTES les chaines de caractères doivent être encadrées par des ""


# Format d'un programme awk

-TROIS blocs : 
->BEGIN : qui sert d'affichage de 'header'  et à initialiser des variables.On peut avoir plusieurs bloc BEGIN (qui est optionnel) : BEGIN{action} 
->BODY : /pattern/ {action} : executé une fois pour chaque ligne du fichier traitée.
->END : END{action} : sert de message / rapport : footer 



BEGIN {
    print "Démarrage du programme"
}

{ print "Pas de critères. Donc ce message s'affiche autant de fois qu'il y a d'enregistrement" }

END {
    print "Fin du programme"
}

Ex ici on recherche le pattern 'boogie' dans notre fichier /etc/passwd et on l'affiche. A la fin on rajoute un bloc END qui fait office de footer. Exemple :
boogie@x61:~/lab/lab-awk$ cat /etc/passwd |awk 'BEGIN { print "== header ==" } /boogie/ {print $1} END {print "== footer =="}'
== header ==
boogie:x:1000:1000:boogie,,,:/home/boogie:/bin/bash
== footer ==

En forcant le séparateur de champ à ':' : on affine :
boogie@x61:/tmp$ cat /etc/passwd |awk 'BEGIN { FS=":" ;print "== header ==" } /boogie/ {print $1} END {print "== footer =="}'== header ==
boogie
== footer ==
Si on veut enregistrer nos commandes dans un fichier : pas de pb : on appelle awk avec l'option '-f" ensuite :

BEGIN {
 FS=":"
  print "---header---"
}
/boogie/ {
  print $1
}
END {
  print "---footer---"
}

boogie@x61:/tmp$ awk -f myscript.awk /etc/passwd
---header---
boogie
---footer---



- FS : field separator. Par défaut le séparateur est l'espace mais on peut définir ce que l'on veut avec le champ FS.
Exemple on cherche le shell du user root dans le fichier /etc/passwd :

boogie@x61:~/lab/lab-awk$ cat /etc/passwd |awk -F: '/root/{print $7 ,"=>", $5}'
/bin/bash => root

On peut encadrer notre FS entre "" ou '' :
boogie@x61:~/lab/lab-awk$ cat employee.txt |awk -F',' '/101/ {print "hey here  the uid =>", $1}'
hey here  the uid => 101

On peut utiliser l'option -F ou alors FS= MAIS il faut l'insérer dans un bloc BEGIN :

boogie@x61:/tmp$ cat employee.txt |awk -F "," '{print $2}'
John Doe
Jason Smith
Raj Reddy
Anand Ram
Jane Miller

boogie@x61:/tmp$ cat employee.txt |awk 'BEGIN{FS=","}; {print $2}'
John Doe
Jason Smith
Raj Reddy
Anand Ram
Jane Miller
L'alertnative avec FS et bloc BEGIN :
boogie@x61:/tmp$ cat employee_multi_fs.txt |awk 'BEGIN{FS="[,:%]"} {print $2}'
John Doe
Jason Smith
Raj Reddy
Anand Ram
Jane Miller

On peut utiliser les regexp dans la recherche de pattern // :

On affiche le nom des users du texte contenant des lignes finissant par CEO :
boogie@x61:/tmp$ cat employee.txt |awk -F "," '/CEO$/ {printf "hey hello " ; print $2}'
hey hello John Doe

On affiche le nom des users dont le texte commence par 10 :
boogie@x61:/tmp$ cat employee.txt |awk -F "," '/^10/ {printf "hey hello The CEO => " ; print $2}'
hey hello The CEO => John Doe
hey hello The CEO => Jason Smith
hey hello The CEO => Raj Reddy
hey hello The CEO => Anand Ram
hey hello The CEO => Jane Miller

On peut définir des intervalles même pour les field separator : 
boogie@x61:/tmp$ cat  employee_multi_fs.txt
101,John Doe:CEO%10000
102,Jason Smith:IT Manager%5000
103,Raj Reddy:Sysadmin%4500
104,Anand Ram:Developer%4500
105,Jane Miller:Sales Manager%3000
boogie@x61:/tmp$ cat employee_multi_fs.txt |awk -F "[,:%]" '{print $2}'
John Doe
Jason Smith
Raj Reddy
Anand Ram
Jane Miller

On peut utiliser des "|" pour le choix du pattern :
boogie@x61:/tmp$ cat lapin |awk '/root|resolve|boogie/ {print $1}'
root:x:0:0:root:/root:/bin/bash
root:x:3333333:0:ROOT:/root:/bin/bash
systemd-resolve:x:102:105:systemd
boogie:x:1000:1000:boogie,,,:/home/boogie:/bin/bash

-OFS : Output File Separator :
De base le caractère de séparation de champ de sortie est l'espace. C'est modifiable.



=== notes from Unix_programming.pdf ==

awk est un language de programmation qui va séparer et diviser les données reçues sur l'entrée standard en enregistrements distincts en fonction du séparateur d'enregistrement (de base il s'agit d'une marque de fin de ligne.)
Chaque enregitrement est ensuite séparé en champ distincs : le separateur de champ par défaut étant l'espace ou la tabulation.
Basé sur les patterns définis , awk va traiter le texte et l'afficher après son traitement.
en résumé : 
awk '/pattern/ {action}' file(s)

bank.lst 
101 Aditya 0     14/11/201 current
102 Anil 10000   20/05/2011 saving
103 Naman 0      20/08/2009 current
104 Rama 10000   15/08/2010 saving
105 Jyotsna 5000 16/06/2012 saving
106 Mukesh 14000 20/12/2009
107 Yashasvi 14500 30/11/2011 saving
108 Chirag 0 15/12/2012 current
109 Arya 16000 14/12/2010 current
110 Puneet 130 16/11/2009 saving

si aucun pattern n'est défini tous le texte sera parsé.

= print :
cette commande est utilisée pour afficher des messages, des champs et des variables.
A chaque lecture de ligne , awk assigne un numéro à chaque champ qui sont des champs texte séparés par un ou des caractères de separation (de base espace et tab).

print [special variables]
de base print va utiliser la "," pour séparer les variables spéciales ( $1, $2 etc..).Si aucune variable spéciale n'est définie, awk parsera tout le texte.

bogie@x61-boogie:~/lab/awk$ awk '{print $1, $2, $3}' bank.lst 
101 Aditya 0
102 Anil 10000
103 Naman 0
104 Rama 10000
105 Jyotsna 5000
106 Mukesh 14000
107 Yashasvi 14500
108 Chirag 0
109 Arya 16000
110 Puneet 130

= printf :

printf est une commande qui est utilisée pour afficher du texte formaté .
ex: "printf "format string", special_variable1, special_variable2, ..."

format specifier
%d integers
%f float
%s strings
%c caracteres
%e  exponential
ex : ici on affiche le champ 1 avec 6 chiffre : il n'y en a que trois mais des espaces completent , le champ 2 comporte max 20 caractère : on fait un alignement à gauche grâce au %-20 , le 3 eme champ lui comporte 7 chiffres max :
bogie@x61-boogie:~/lab/awk$ awk '{ printf "%6d %-20s %7d \n",$1,$2,$3 }' bank.lst
   101 Aditya                     0 
   102 Anil                   10000 
   103 Naman                      0 
   104 Rama                   10000 
   105 Jyotsna                 5000 
   106 Mukesh                 14000 
   107 Yashasvi               14500 
   108 Chirag                     0 
   109 Arya                   16000 
   110 Puneet                   130 

affichage de certains patterns : on peut filtrer l'affichage en fonction de recherche que l'on fait sur un pattern :

boogie@x61-boogie:~/lab/awk$ awk '/current/ { print  }' bank.lst
101 Aditya 0     14/11/201 current
103 Naman 0      20/08/2009 current
108 Chirag 0 15/12/2012 current
109 Arya 16000 14/12/2010 current


boogie@x61-boogie:~/lab/awk$ awk '/current/ { print  $4, $3}' bank.lst
14/11/201 0
20/08/2009 0
15/12/2012 0
14/12/2010 16000

= operateurs de comparaison :

on peut afficher certains champs qui sont filtrer par des opérateurs de comparaison.

x < y Returns true if x is less than y 
x <= y Returns true if x is less than or equal to y 
x == y Returns true if x is equal to y x > y Returns true if x is greater than y 
x >= y Returns true if x is greater than or equal to y $1 ~ /saving/
x != y Returns true if x is not equal to y 
x ~ y Returns true if string x matches the regular expression represented by y
x !~ y Returns true if string x doe not match the regular expression represented by y

= while comparing operands with comparison operators,
if both the operands are numeric, a numeric comparison is
made, otherwise the operands are compared as strings. =

Ici on va afficher les lignes si le champ de la 5eme colonne vaut "current" 

awk '$5 == "current" ' bank.lst
101 Aditya 0     14/11/201 current
103 Naman 0      20/08/2009 current
108 Chirag 0 15/12/2012 current
109 Arya 16000 14/12/2010 current

ici on affiche les lignes dont le champ numero 1 est supérrieur à 107  

awk '$1 > 107' bank.lst 
108 Chirag 0 15/12/2012 current
109 Arya 16000 14/12/2010 current
110 Puneet 130 16/11/2009 saving



= Matching de regexp :

on peut utiliser les caracteres ~ et !~ pour matcher un pattern ou pas :

- toutes  les lignes  qui contiennent le pattern  "current" 
awk '$5 ~/current/' bank.lst
101 Aditya 0     14/11/201 current
103 Naman 0      20/08/2009 current
106 Mukesh 14000 20/12/2009  current
108 Chirag 0 15/12/2012 current
109 Arya 16000 14/12/2010 current

- l'inverse : 
awk '$5 !~ /current/' bank.lst 
102 Anil 10000   20/05/2011 saving
104 Rama 10000   15/08/2010 saving
105 Jyotsna 5000 16/06/2012 saving
107 Yashasvi 14500 30/11/2011 saving
110 Puneet 130 16/11/2009 saving

On peut utiliser les meta caracteres comme ^ et $ ( debut et fin ) pour filtrer nos patterns.
On doit entourer nos patterns avec des "//"

- affichage des lignes dont le 5eme champ finit par la lettre 't' :
 awk '$5 ~/t$/' bank.lst
101 Aditya 0     14/11/201 current
103 Naman 0      20/08/2009 current
106 Mukesh 14000 20/12/2009  current
108 Chirag 0 15/12/2012 current
109 Arya 16000 14/12/2010 current

On peut utiliser les filtres classiques des regexps ( classe de categories ... )

- affichage des lignes dont le 5eme champ contient Current ou current : 
boogie@x61-boogie:~/lab/awk$ awk '$5 ~/[cC]urrent/' bank.lst
101 Aditya 0     14/11/201 current
103 Naman 0      20/08/2009 current
106 Mukesh 14000 20/12/2009  current
108 Chirag 0 15/12/2012 current
109 Arya 16000 14/12/2010 current

affichage des lignes dont le deuxieme champ contient un "A" suivi de plusieurs caractères puis un "a" : 
boogie@x61-boogie:~/lab/awk$ awk '$2 ~/A.*a/' bank.lst
101 Aditya 0     14/11/201 current
109 Arya 16000 14/12/2010 current

affichage des lignes dont le quatrieme champ commence par un "14" 
bogie@x61-boogie:~/lab/awk$ awk '$4 ~/^14/' bank.lst 
101 Aditya 0     14/11/201 current
109 Arya 16000 14/12/2010 current


=operateurs booleens :

"&& And Results true when all the expressions are true
|| Or Results true when any of the expressions is true
! Not Reverses (negates) the logical expression"

-ici on affiche les lignes de la numero 3 jusqu'a la 7 en affichant leur numero de ligne :

boogie@x61-boogie:~/lab/awk$ awk 'NR >= 3 && NR <= 7 { print NR, $0}' bank.lst 
3 103 Naman 0      20/08/2009 current
4 104 Rama 10000   15/08/2010 saving
5 105 Jyotsna 5000 16/06/2012 saving
6 106 Mukesh 14000 20/12/2009  current
7 107 Yashasvi 14500 30/11/2011 saving

-on affiche de la ligne 3 à 5 en affichant le numero de ligne : 

boogie@x61-boogie:~/lab/awk$ awk 'NR == 3, NR == 5 { print NR,$0 }' bank.lst
3 103 Naman 0      20/08/2009 current
4 104 Rama 10000   15/08/2010 saving
5 105 Jyotsna 5000 16/06/2012 saving

-on affiche la ligne 3 et  la ligne 5 avec leur numero de ligne : 

boogie@x61-boogie:~/lab/awk$ awk 'NR == 3 || NR ==5 { print NR,$0 }' bank.lst
3 103 Naman 0      20/08/2009 current
5 105 Jyotsna 5000 16/06/2012 saving

- on filtre les lignes dont les numeros sont inferrieurs à 2 et sup à 7 et on affiche leur numero de ligne et leur ligne :

boogie@x61-boogie:~/lab/awk$ awk 'NR<2 || NR>7 { print NR,$0 }' bank.lst
1 101 Aditya 0     14/11/201 current
8 108 Chirag 0 15/12/2012 current
9 109 Arya 16000 14/12/2010 current
10 110 Puneet 130 16/11/2009 saving




= Utilisation de commandes systêmes via awk :


ex :   On veut renommer des rep : “filer06-std-dc3 en filer06-dc3 ”

On declare le field separator à “-” avec comme fin dc3 si le nombre de champ est egal à 3 alors on renomme en premier champ“-'dernier champ :

root@boogieland:/mnt# ls | awk  'BEGIN {FS="-"} /.*dc3$/ {  if(NF == 3 ) print"mv "$0" "$1"-"$3" ;" ; } '
mv filer06-std-dc3 filer06-dc3 ;
mv filer07-std-dc3 filer07-dc3 ;
mv filer08-std-dc3 filer08-dc3 ;
mv filer09-std-dc3 filer09-dc3 ;
mv filer10-std-dc3 filer10-dc3 ;
mv filer11-std-dc3 filer11-dc3 ;
mv filer12-std-dc3 filer12-dc3 ;
mv filer13-std-dc3 filer13-dc3 ;

root@boogieland:/mnt# ls | awk  'BEGIN {FS="-"} /.*dc3$/ {  if(NF == 3 ) system("mv "$0" "$1"-"$3" ;") ; } '

    On veut trier , compter les connexions tcp par src :

 ss -tan 'sport = :11211' | awk '{print $(NF)" "$(NF-1)}' | sed 's/:[^ ]*//g' | sort | uniq -c



= Exemple assignation et tri de variable utilisées dans bash :


cat monrer.sh 
#!/bin/sh
 
# CONFIGURATION
URL="http://monrer.fr"
STATION="LEG"
MISSIONS="ROMI|DEBA|MONA|BALI"
#IMG=/usr/share/icons/gnome-colors-common/16x16/apps/clock.png
IMG=
 
trains=$(wget -q -4 -O - $URL/json?s=$STATION | jq '.trains|.[]| .mission,.time,.retard,.destination' | sed -e 's/$/;/' | xargs -n 4 echo | sed -e 's/; /;/g' -e 's/;$//')
 
next=$( echo "$trains" | awk -F\; -v missions="$MISSIONS" '$1 ~ missions {print $2 " " $3}' | sort | head -1 | sed 's/ /\n/')
 
trains=$(echo "$trains" | sed 's/;/\t/g')
 
if [ -n "$IMG" ] && [ -f "$IMG" ]
then
    echo "<img>$IMG</img>"
fi
echo "<txt>$next</txt>"
echo "<tool>$trains</tool>"
echo "<click>xdg-open $URL/?s=$STATION</click>"


= Calcul avec awk : incrementation de variables :
Somme d'une colonne avec AWK

Par exemple, pour connaitre la place utilisee en memoire par le processus apache2 :

    ps -ely | grep '\<apache2\>' | awk '{SUM += $8} END {print SUM}'

ou pour connaitre la place en Ko prise par tous les fichiers PNG du repertoire :

    ls -l *.png | awk '{SUM += $5} END {print SUM/1024}'


== Calcul d'une volumetrie :


du -sk * | sort -g | awk '{ 

    numBytes = $1 * 1024; 
    numUnits = split("B K M G T P", unit); 
    num = numBytes; 
    iUnit = 0; 

    while(num >= 1024 && iUnit + 1 < numUnits) { 
        num = num / 1024; 
        iUnit++; 
    } 

    $1 = sprintf( ((num == 0) ? "%6d%s " : "%6.1f%s "), num, unit[iUnit + 1]);
    print $0; 

}'


nous donne par exemple :
   7,4G  xml-data/build-dir/90374147
   7,7G  xml-data/build-dir/90374146
   8,5G  artifacts/XFR-DEPLOYTOPROD/shared
   8,6G  artifacts/AXL-DEPLOYPROD/shared
   8,8G  xml-data/build-dir/_git-repositories-cache
  10,3G  xml-data/build-dir/5046276
  12,9G  xml-data/build-dir/2949121
  16,0G  xml-data/build-dir/130547713
  27,5G  artifacts/DAT-DEPLOYPREPROD/shared



== Fonctions awk : =

conversion de caractere  lower => 'awk -F"," '{print tolower($9)}'

