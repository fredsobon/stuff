
== Awk : ===


urls utiles :
http://nyal.developpez.com/tutoriel/gawk/?page=intro
http://www.shellunix.com/awk.html

- bases : 

Awk traite ligne par ligne sous la forme '/pattern/ {command} .On peut rajouter une section en début de travail qui ne sera afficher q'une fois ( comme un header ) ensuite le cours de notre traitement .

awk -Fs '/pattern/ {action}' input-file  
(or)
awk -Fs '{action}' intput-file
 
/pattern/ est optionnel : si on ne precise rien : l'integralité du texte est traitée.
TOUTES les commandes/actions awk doivent être entourées par des '{}'.
TOUTES les chaines de caractères doivent être encadrées par des ""


# Format d'un programme awk

-TROIS blocs : 
->BEGIN : qui sert d'affichage de 'header'  et à initialiser des variables.On peut avoir plusieurs bloc BEGIN (qui est optionnel) : BEGIN{action} 
->BODY : /pattern/ {action} : executé une fois pour chaque ligne du fichier traitée.
->END : END{action} : sert de message / rapport : footer 



BEGIN {
    print "Démarrage du programme"
}

{ print "Pas de critères. Donc ce message s'affiche autant de fois qu'il y a d'enregistrement" }

END {
    print "Fin du programme"
}

Ex ici on recherche le pattern 'boogie' dans notre fichier /etc/passwd et on l'affiche. A la fin on rajoute un bloc END qui fait office de footer. Exemple :
boogie@x61:~/lab/lab-awk$ cat /etc/passwd |awk 'BEGIN { print "== header ==" } /boogie/ {print $1} END {print "== footer =="}'
== header ==
boogie:x:1000:1000:boogie,,,:/home/boogie:/bin/bash
== footer ==

En forcant le séparateur de champ à ':' : on affine :
boogie@x61:/tmp$ cat /etc/passwd |awk 'BEGIN { FS=":" ;print "== header ==" } /boogie/ {print $1} END {print "== footer =="}'== header ==
boogie
== footer ==
Si on veut enregistrer nos commandes dans un fichier : pas de pb : on appelle awk avec l'option '-f" ensuite :

BEGIN {
 FS=":"
  print "---header---"
}
/boogie/ {
  print $1
}
END {
  print "---footer---"
}

boogie@x61:/tmp$ awk -f myscript.awk /etc/passwd
---header---
boogie
---footer---



- FS : field separator. Par défaut le séparateur est l'espace mais on peut définir ce que l'on veut avec le champ FS.
Exemple on cherche le shell du user root dans le fichier /etc/passwd :

boogie@x61:~/lab/lab-awk$ cat /etc/passwd |awk -F: '/root/{print $7 ,"=>", $5}'
/bin/bash => root

On peut encadrer notre FS entre "" ou '' :
boogie@x61:~/lab/lab-awk$ cat employee.txt |awk -F',' '/101/ {print "hey here  the uid =>", $1}'
hey here  the uid => 101

On peut utiliser l'option -F ou alors FS= MAIS il faut l'insérer dans un bloc BEGIN :

boogie@x61:/tmp$ cat employee.txt |awk -F "," '{print $2}'
John Doe
Jason Smith
Raj Reddy
Anand Ram
Jane Miller

boogie@x61:/tmp$ cat employee.txt |awk 'BEGIN{FS=","}; {print $2}'
John Doe
Jason Smith
Raj Reddy
Anand Ram
Jane Miller
L'alertnative avec FS et bloc BEGIN :
boogie@x61:/tmp$ cat employee_multi_fs.txt |awk 'BEGIN{FS="[,:%]"} {print $2}'
John Doe
Jason Smith
Raj Reddy
Anand Ram
Jane Miller

On peut utiliser les regexp dans la recherche de pattern // :

On affiche le nom des users du texte contenant des lignes finissant par CEO :
boogie@x61:/tmp$ cat employee.txt |awk -F "," '/CEO$/ {printf "hey hello " ; print $2}'
hey hello John Doe

On affiche le nom des users dont le texte commence par 10 :
boogie@x61:/tmp$ cat employee.txt |awk -F "," '/^10/ {printf "hey hello The CEO => " ; print $2}'
hey hello The CEO => John Doe
hey hello The CEO => Jason Smith
hey hello The CEO => Raj Reddy
hey hello The CEO => Anand Ram
hey hello The CEO => Jane Miller

On peut définir des intervalles même pour les field separator : 
boogie@x61:/tmp$ cat  employee_multi_fs.txt
101,John Doe:CEO%10000
102,Jason Smith:IT Manager%5000
103,Raj Reddy:Sysadmin%4500
104,Anand Ram:Developer%4500
105,Jane Miller:Sales Manager%3000
boogie@x61:/tmp$ cat employee_multi_fs.txt |awk -F "[,:%]" '{print $2}'
John Doe
Jason Smith
Raj Reddy
Anand Ram
Jane Miller

On peut utiliser des "|" pour le choix du pattern :
boogie@x61:/tmp$ cat lapin |awk '/root|resolve|boogie/ {print $1}'
root:x:0:0:root:/root:/bin/bash
root:x:3333333:0:ROOT:/root:/bin/bash
systemd-resolve:x:102:105:systemd
boogie:x:1000:1000:boogie,,,:/home/boogie:/bin/bash

-OFS : Output File Separator :
De base le caractère de séparation de champ de sortie est l'espace. C'est modifiable.






= Utilisation de commandes systêmes via awk :


ex :   On veut renommer des rep : “filer06-std-dc3 en filer06-dc3 ”

On declare le field separator à “-” avec comme fin dc3 si le nombre de champ est egal à 3 alors on renomme en premier champ“-'dernier champ :

root@boogieland:/mnt# ls | awk  'BEGIN {FS="-"} /.*dc3$/ {  if(NF == 3 ) print"mv "$0" "$1"-"$3" ;" ; } '
mv filer06-std-dc3 filer06-dc3 ;
mv filer07-std-dc3 filer07-dc3 ;
mv filer08-std-dc3 filer08-dc3 ;
mv filer09-std-dc3 filer09-dc3 ;
mv filer10-std-dc3 filer10-dc3 ;
mv filer11-std-dc3 filer11-dc3 ;
mv filer12-std-dc3 filer12-dc3 ;
mv filer13-std-dc3 filer13-dc3 ;

root@boogieland:/mnt# ls | awk  'BEGIN {FS="-"} /.*dc3$/ {  if(NF == 3 ) system("mv "$0" "$1"-"$3" ;") ; } '

    On veut trier , compter les connexions tcp par src :

 ss -tan 'sport = :11211' | awk '{print $(NF)" "$(NF-1)}' | sed 's/:[^ ]*//g' | sort | uniq -c



= Exemple assignation et tri de variable utilisées dans bash :


cat monrer.sh 
#!/bin/sh
 
# CONFIGURATION
URL="http://monrer.fr"
STATION="LEG"
MISSIONS="ROMI|DEBA|MONA|BALI"
#IMG=/usr/share/icons/gnome-colors-common/16x16/apps/clock.png
IMG=
 
trains=$(wget -q -4 -O - $URL/json?s=$STATION | jq '.trains|.[]| .mission,.time,.retard,.destination' | sed -e 's/$/;/' | xargs -n 4 echo | sed -e 's/; /;/g' -e 's/;$//')
 
next=$( echo "$trains" | awk -F\; -v missions="$MISSIONS" '$1 ~ missions {print $2 " " $3}' | sort | head -1 | sed 's/ /\n/')
 
trains=$(echo "$trains" | sed 's/;/\t/g')
 
if [ -n "$IMG" ] && [ -f "$IMG" ]
then
    echo "<img>$IMG</img>"
fi
echo "<txt>$next</txt>"
echo "<tool>$trains</tool>"
echo "<click>xdg-open $URL/?s=$STATION</click>"


= Calcul avec awk : incrementation de variables :
Somme d'une colonne avec AWK

Par exemple, pour connaitre la place utilisee en memoire par le processus apache2 :

    ps -ely | grep '\<apache2\>' | awk '{SUM += $8} END {print SUM}'

ou pour connaitre la place en Ko prise par tous les fichiers PNG du repertoire :

    ls -l *.png | awk '{SUM += $5} END {print SUM/1024}'


== Calcul d'une volumetrie :


du -sk * | sort -g | awk '{ 

    numBytes = $1 * 1024; 
    numUnits = split("B K M G T P", unit); 
    num = numBytes; 
    iUnit = 0; 

    while(num >= 1024 && iUnit + 1 < numUnits) { 
        num = num / 1024; 
        iUnit++; 
    } 

    $1 = sprintf( ((num == 0) ? "%6d%s " : "%6.1f%s "), num, unit[iUnit + 1]);
    print $0; 

}'


nous donne par exemple :
   7,4G  xml-data/build-dir/90374147
   7,7G  xml-data/build-dir/90374146
   8,5G  artifacts/XFR-DEPLOYTOPROD/shared
   8,6G  artifacts/AXL-DEPLOYPROD/shared
   8,8G  xml-data/build-dir/_git-repositories-cache
  10,3G  xml-data/build-dir/5046276
  12,9G  xml-data/build-dir/2949121
  16,0G  xml-data/build-dir/130547713
  27,5G  artifacts/DAT-DEPLOYPREPROD/shared



== Fonctions awk : =

conversion de caractere  lower => 'awk -F"," '{print tolower($9)}'

