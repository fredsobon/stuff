=== notes from mooc ===


 - intro - 

the JMX architecture is, by default, composed of : 
An agent framework
An instrumentation Layer

the JMX Instrumentation Layer is composed of:
A set of managed objects

the standard JMX instrumentation allows to:
Monitor the CPU usage of a Java Virtual Machine 
Invoke a garbage collector

JMX is built in: 
Standard Edition Java Virtual Machines

An MBean becomes manageable when it is: 
Registered within the Agent


to enable a JMX agent to survive/manage the lifetime of a remote virtual machine hosting an application, the deployment model to be used is  Daemon

3 layers compose the JMX architecture

the default JMX agent level includes : 
connectors
mbeanserver
mbean

to conform to the JMX standard, each MBean must follow a given design pattern


- theorie -

The Management Interface of a Standard MBean is extracted by the Agent through INTROSPECTION
At registration time, the agent checks the name of the class of the object to be registered and if it is sufixed by MBean, searches for methods to define the attributes and operations. All this is done through INTROSPECTION.

the Standard MBean Management Operations are defined at:
Compile time ￼ In a Java interface 
Standard MBean interfaces are defined in a Java interface definition through operations. THeyr are thus defined at compile time.

The Different MBean Types are dynamic, standart, model
JMX offers three types of MBeans: Standard, Dynamic and Model. Additional MBeans which are subclasses of the above three types are defined through attributes and operations parameters types restrictions.


the following statements define a "logCount" management attribute exposed through JMX in an MBean: 
int getlogCount(); 
void setlogCount(int x); 
Both get and set operations define one operation on the logCount attribute following the JMX imposed Standard design patterns.


Let the following names refer to MBeans in a JMX agent.
eu.telecomnancy.jmx: p="2", a="5", t="interface"
eu.telecomnancy.jmx: a="5", t="interface", p="2" 
JMX follows a lexicographic order in the names. Thus the two lines up normalized refer to the same Mbean.

Once the GetMeanInfo (i.e. the creation of the management interface) is done at registration time. Therefore, it should not be changed afterwards.

the types of MBeans available within JMX differ in :
the level of dynamicity ￼the scope of possible types for attributes and parameters 
The different MBeanTypes impact the dynamics of the Mbean, especially the time of / and freedom of change of the Management Interface and the types of attributes and parameters.

In the ModelMBean principle
 the application object delegates the creation of the MBean to the MBeanServer
The entire creation of the management interface is delegated to the MbeanServer by the application object which does not "see" or deal with a MBean.

In JMX one can implement any Standard Mbean using
a Dynamic Mbean 
a ModelMbean 
A dynamic Mbean can build any management interface (but at registration time), so does the ModelMbean. Other MBeans are restricted by the type and thus cannot representany StandardMBean.

The more dynamic the Bean is :
the more code is needed by the developer the more code is needed by the developer 


- service monitoring : -

JMX offers the following built-in services:

monitoring, MBean coupling, remote Mbean loading
JMX offers 5 services among which: monitoring, relations management and remote Mbean loading in an agent.

JMX notifications follow the Observer Pattern.

To receive Notifications, an object must: 
subscribe to the emitter, implement a notification processing interface, - correct
Within an MBean Server, a consumer must subscribe to the emitter of the interested notifications. Within a JVM, there is no need to be registered as an MBean to subscribe to MBean notifications, only the Notification Listener interface has to be implemented by the listener.

The Timer Service can: (NA=2)
generate user specific notifications, manage the life-cycle of timers, - correct
The user can give its own notifications to be emitted by the timer service.
The basic service offered by the Timer Service is to manage the life-cycle of Timers (instanciation, start, stop, resume, ...).

The Gauge Monitor Service: 
issues two notification types issues two notification types - correct
The gauge monitor launches alarms on low and high threshold crossing. Those alarms are different.

String monitoring issues a notification (NA=1)
when the monitored string is identical to the reference one when the monitored string is identical to the reference one 
The string monitoring service only supporte exact matching.

The relations service: 
monitors relations cardinality consistency 
The relations service monitors the consistency of the relations. It does not enforce the values of the attributes.

The Timer service granularity is in millisecond

The Query service requires a filter and a name pattern to select objects 

Filters are composed of
logical expressions on Mbean attribute values 
logical expressions on MBean metadata 


