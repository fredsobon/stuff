=== notes sensu ===


= api sensu : ==
https://sensuapp.org/docs/latest/api/overview.html



=== notes v_oreilly et book ===


== Install ( vm test ubuntu 16/04 lts : == 


On install rabbitmq-server qui va nous servir a gerer les filles  de messages.
une "webapp" est dispo des l'install avec l'install des plugins 

root@ubuntu-xenial:~# apt-get install rabbitmq-server
root@ubuntu-xenial:~# rabbitmq-plugins enable  rabbitmq_management
The following plugins have been enabled:
  mochiweb
  webmachine
  rabbitmq_web_dispatch
  amqp_client
  rabbitmq_management_agent
  rabbitmq_management

Applying plugin configuration to rabbit@ubuntu-xenial... started 6 plugins.

on va redemmarer le service et checker :

root@ubuntu-xenial:~# service rabbitmq-server restart

on va tester notre appli :

en cli :

root@ubuntu-xenial:~# curl -I http://localhost:15672
HTTP/1.1 200 OK
Server: MochiWeb/1.0 (Any of you quaids got a smint?)
last-modified: Sat, 25 Feb 2017 17:24:03 GMT
Date: Sat, 25 Feb 2017 17:25:23 GMT
Content-Type: text/html
Content-Length: 1353

on va aussi tester depuis un browser :
pour cela on va faire une redirection de port de notre rabbitmqsur la vm vers le navigo de notre machine dans la conf vagrant :

VAGRANTFILE_API_VERSION = "2"
Vdministratoragrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.vm.box = "ubuntu/trusty64"
  config.vm.network "forwarded_port", guest: 15672, host: 15672


on va ajouter un user test avec tous les droits pour acceder 
rabbitmqctl add_user test test
rabbitmqctl set_user_tags test administrator
rabbitmqctl set_permissions -p / test ".*" ".*" ".*"

on va ajouter un virtual host dans notre webapp rabbit mq 
> a droite virtual host > new virtual host 
on rentre : /sensu 
on ajoute un nouveau user :
sensu / mdp secret 

on ajoute ensuite un user sensu avec un password secret au vhost sensu 
root@SensuServer:/etc/rabbitmq# rabbitmqctl add_user sensu secret
root@SensuServer:/etc/rabbitmq# rabbitmqctl set_user_tags sensu administrator
root@SensuServer:/etc/rabbitmq# rabbitmqctl set_permissions -p / ".*" ".*" ".*"
on rajoute le user sensu et on le grant au vhost /sensu : 
root@SensuServer:/etc/rabbitmq# rabbitmqctl set_permissions -p / ".*" ".*" ".*"




on va ensuite cliquer sur notre nouveau user et lui donner tous les droits (*) sur notre vhost /sensu en selectionnant les menus deroulant.
on sauve et c'est ok .

On install mintenant redis-server :

root@ubuntu-xenial:~# apt-get install redis-server
pour tester notre install on lance l'utilitaire :
root@ubuntu-xenial:~# redis-cli ping
PONG

On va  maintenant passé à l'install de  sensu :
-> on recupere la cle pub du repo :
wget -q https://sensu.global.ssl.fastly.net/apt/pubkey.gpg -O- | sudo apt-key add -
on va ensuite monter le repo dédié à notre distrib apres l'avoir identifiée :
. /etc/os-release && echo $VERSION
16.04.2 LTS (Xenial Xerus)

on  rajoute un source list dedié a sensu concernant notre repo
root@ubuntu-xenial:~# cat /etc/apt/sources.list.d/sensu.list
deb     https://sensu.global.ssl.fastly.net/apt xenial main
puis on update notre db :
apt-get update

on install sensu 
apt-get install sensu

on creee maintenant notre fichier de conf :
qui va repertorier les infos de conf settee : rabbitmq ,redis et le port de notre api sensu . La conf sous format json doit toujours avoir les sections entourées de { } 
root@ubuntu-xenial:~# vi /etc/sensu/config.json
{
  "rabbitmq": {
    "host": "localhost",
    "vhost": "/sensu",
    "user": "sensu",
    "password": "secret"
  },
  "redis": {
    "host": "localhost" 
  },
  "api": {
    "port": 4567
  }  
}

on demarre maintenant notre sensu-server et api :
root@ubuntu-xenial:~# systemctl start sensu-server
root@ubuntu-xenial:~# systemctl start sensu-api

on peut consulter les logs de notre appli dans /var/log/sensu : on a les logs server et api

on va maintenant configurer la partie client :
comme tout se passe sur la même machinne pas de conf particuliere 
on rentre un nom pour identifier notre client , son ip et la liste des subscriptions ( ensemble de checks)  auquels il va s'inscrire

t@ubuntu-xenial:~# cat /etc/sensu/conf.d/client.json
{
  "client": {
    "name": "SensuServer",
    "address": "10.0.2.15",
    "subscriptions": [
     "Production" 
    ] 
  }
}
puison demarre notre service : 
root@ubuntu-xenial:~# service sensu-client start
root@ubuntu-xenial:~# systemctl status sensu-client
● sensu-client.service - sensu client
   Loaded: loaded (/etc/systemd/system/sensu-client.service; disabled; vendor preset: enabled)
   Active: active (running) since Sun 2017-02-26 12:35:58 UTC; 12s ago
 Main PID: 9987 (sensu-client)
    Tasks: 24
   Memory: 16.7M
      CPU: 229ms
   CGroup: /system.slice/sensu-client.service
           └─9987 /opt/sensu/embedded/bin/ruby /opt/sensu/bin/sensu-client -c /etc/sensu/config.json -d /etc/sensu/conf.d -e /etc/sensu/extensions -p /var/run/sensu/sensu-client.pid -l /var/lo

on installe maintenant uchiwa (directement via notre distrib : ubuntu et le repo qu'on a setté font le job ou alors sur uchiwa.io : le site du projet )
root@ubuntu-xenial:~# apt-get install uchiwa
on va modifier le ficher de conf de base d'uchiwa en renseignant les infos de notre conf : 

root@ubuntu-xenial:~# cat /etc/sensu/uchiwa.json 
{
  "sensu": [
    {
      "name": "SensuServer",
      "host": "localhost",
      "port": 4567,
      "ssl": false,
      "path": "",
      "user": "sensu",
      "pass": "secret",
      "timeout": 10
    }
  ],
  "uchiwa": {
    "host": "0.0.0.0",
    "port": 3000,
    "refresh": 10
  }
}

on redemmare notre stack 
root@SensuServer:/etc/sensu# service sensu-server restart && service sensu-api restart && sleep 2 && service uchiwa restart

on peut desormais acceder a uchiwa en http://lcoalhost:3000

root@SensuServer:/etc/sensu# curl -i http://localhost:3000/clients
HTTP/1.1 200 OK
Accept-Charset: utf-8
Content-Type: application/json
Date: Sun, 26 Feb 2017 19:25:07 GMT
Content-Length: 297

[{"_id":"SensuServer/SensuServer","address":"10.0.2.15","dc":"SensuServer","name":"SensuServer","output":"No keepalive sent from client for 23862 seconds (\u003e=180)","silenced":false,"status":2,"subscriptions":["Production","client:SensuServer"],"timestamp":1.488113238e+09,"version":"0.27.1"}]


En recap on a donc une appli découpée en plusieurs briques : 

Service 	  Runs On 	Description
sensu-client  client 	Runs checks; reports results
sensu-api     server 	API for programmatic interaction
sensu-server  server 	Schedules checks; routes results
redis         server 	Persistent key-value storage
sensu-dashboard server  Visualizes results
rabbitmq-server amq server  AMQP server

On a tous les logs de splités : 
tail –f /var/log/sensu/sensu-server.log
tail –f /var/log/sensu/sensu-client.log

on peut setter le log level de sensu dans /etc/defaut/sensu

LOG_LEVEL=debug
les autres valeurs sont warning et fatal 


On peut redammer les services aussi de plusieurs manieres :
cd /etc/systemd/system && systemctl restart sensu-*


Validation de json :

quand on edite un fichier json on peut toujours lui passer un tester de syntax comme ceci :

exemple on rajoute une virgule a la fin de notre derniere valeur de hash : ce qui n'en prends pas normalement : en lancant le check on a donc une erreur :

roo@SensuServer:/tmp# cat uchiwa.json |python3 -m json.tool
Expecting property name enclosed in double quotes: line 12 column 5 (char 207)


== Architecture : == 

- rabbitmq :
est central a sensu et est un message broker : il recoit les messages à un point d'echange, les met en queues et les passe à un consummer.
Il recoit les instructions du server sensu sur les differents checks a executer , il place ces instructions dans une queue dans laquelle le client peut venir chercher ces infos.
Le broker recoit aussi les resultats des checks envoyés par les clients, les place en queue et les met donc a dispostion du sensu server 

La capacité d'envoyer les checks à une queue de soubscription est vraiment un avantage pour le deploiment de nouveaux clients.
Un nouveau server doit juste s'accrocher à une queue qui va ainsi lui fournir les checks a executer.

- sensu server : 
c'est le cerveau: il sait quel type de checks doivent être executer en lisant les fichiers de configuration et est en charge du sheduling des checks.
sensu server ecoute aussi la queue rabbitmq pour recuperer les resultats et les diriger vers les handlers corrects.
ex : un hdd full à 80% va envoyer un mail , un hdd full  90% va envoyer un sms ...

- sensu client :
Le client est à l'ecoute de rabbimq et execute les checks quand il doit le faire . Il execute donc des scripts et renvoie le resultat à rabbitmq 
On a aussi des scripts périodiques qui sont executés periodiquement sur le client sans ordre demandé par rabbitmq 
Le resultat de ces checks est envoyé à rabbitmq exactement comme les autres checks.
Le  resultat envoyé peut être le status du code retour ou d'autres info complementaires.

NB sensu peut être packagé et embarquer toutes les applis (server , client , api , dashboard  .) mais seul le client devra être installer sur notre server client.

- sensi api : api qui fourni un acess REST ( Representative State Transfer )

-Redi : systeme de clé / valeur : sensu a la notion de stashes qui sont des données persistantes sous format json . Sensu utilise redis comme stockage d'informations sur les checks et les clients.


= notes de configuration =

Attention une configuration de ntp est utile pour nos applications.


- rabbitmq : les commandes principales ont été vues dans l'installation en utilisadant l'utilitaire en cli :

rabitmqctl 

- sensu-client :

toutes les arbo server et client sont identiques mais le client n'a juste besoin que de savoir comment contacter le rabbitmq , l'acces aux diffrents check qu'il devra executer  : ceci se passe dans le repertoire plugin ou sous forme de gem ruby 
Quand sensu client demarre il examine d'abord le repertoire /etc/sensu/conf.d ..on peut donc organiser nos arbo comme on veut ..les fichiers primordiaux sont client.json et rabbitmq.json
 
La cle de subscription visible dans notre conf client, defini quelle queue rabbitmq notre client va ecouter .
ex :
"client": {
"subscriptions": [
"os"
],
..
ex ici quand le sensu server va demander à tous les clients abonnés à la queue "os" de checker leur espace disque, ils vont le faire.
si notre server héberge un nginx alors il pourra egalement s'abonner a la queue webserver qui aura des check http a faire executer sur les clients.

"client": {
"subscriptions": [
"os" "webserver" 
],


Les checks en standalone (sans schedling par le sensu server ) devront être dans /etc/sensu/conf.d/

Le nom des queues est tout à fait personnel et on les creee quand on defini nos definitions de checks sur le sensu-server.
mais avant cela il va falloir définir un élément important :

EMBEDDED_RUBY :

La plupart des checks executés sont en ruby 
l'install de base embarque un ruby : 
/opt/sensu/embedded/bin/ruby , les checks embarqués sont tous testés.
ont peut donc execute nos checks ruby de deux manieres :
1/ avec le rubyembarqué à l'install de sensu 
2/ en utilisant le ruby dejà installé sur notre systeme .

Il est possible de changer notre setting : utilisation ou nom du ruby embarqué en rajoutant un param dans le fichier de conf /etc/defaut/sensu
/etc/default/sensu :
EMBEDDED_RUBY=false
A partir de la version 0.21 la valeur par defaut est à true


- Sensu-server :

sensu-server doit savoir ou trouver rabbitmq et connaitre les checks qu'il schedule, redis et les handlers  pour savoir ou diriger une action à faire.
les  arbos importantes sont : 
le repertoire checks /api.json 
le repertoire handlers / rabbitmq.json redis.json 
les repertoires extensions / handlers / mutators 

Par defaut sensu-server va recupérer une données à la fois dans rabbitmq en cas de charge on peut augmenter ce nombre en modifiant la conf de notre broker rabbitmq.
ex : 
/etc/sensu/rabbitmq.json 
{
  "rabbitmq": {
	"host": "203.0.113.1",
	"user": "sensu",
	"port": 5672,
	"vhost": "/sensu",
	"password": "secret",
	"prefetch": 3
		}
}

On va creer des checks  et des handlers dans les arbos suivantes  /etc/sensu/conf.d/checks et /etc/sensu/conf.d/handlers 


On peut avoir plusieurs server sensu : on a par contre un master ( le premier qui demarre crée un lock dans redis). le master publie les checks, gere les keepalive 
Le slave va recupérer les checks de rabbitmq en round rubin (avec le master )et va less envoyer vers les handlers.


- Configuration de l'api :
l'api sensu est exposée au dessus du framework leger sinatra : il est possible d'herberger l'api ailleurs que sur le server sensu . comme pour le server et le client on peut avoir plusieurs api deifferentes en place : il duffit des les déclarer 
/etc/sensu/api.json
{
	"api": {
	"host": "localhost",
	"port": 4567,
	}	
}

 on peut déclarer un user / mdp pour acceder à l'api :
/etc/sensu/api.json

{
	"api": {
		"host": "localhost",
		"port": 4567,
		"user": "api_user",
		"password": "api_secret",
	}
}

Attention ci notre api est configurée ailleurs que sur le serveur il faut s'assurer que la communication se fait bien avec rabbitmq et redis.
Uchiwa est un outil de visualisation qui interreagi avec l'api

- Redis :

la config de redis est tres simple : le port suffit quasiment 

/etc/sensu/conf.d/redis.json
{
"redis": {
  "host": "localhost",
  "port": 6379,
  }
}


on peut ajouter de l'authent en configurant /etc/redis.conf
ex 
requirepass mysupersecretredispassword
on pourra ensuite declarer notre appel dans le conf de redis sensu 
ex :
{
"redis": {
	"host": "localhost",
	"port": 6379,
	"password": "mysupersecretredispassword"
	}
}

== Checks : ==

Le job le plus important est la gestion des checks.
Le check est composé en deux partie :
-> check definition : doc json qui fourni les metadata relatives au check : commande et frequence .
la commande est typiquement un script . qu'on va stocker dans le repertoire plugins
Il y a trois types de check :
-> standalone : les resultat sont envoyés au sensu server 
-> regulier  : les checks sont planifiés par le sensu server 
-> keepalive  : check d'etat de vie du node

les codes retour de nos scripts sont standarts 

2 > critical
1 > warning
0 > ok
3 > unknow 


= standalone : 
ce sont les checks les plus simple : les serveurs executent une commande et envoient le resultat au rabbitmq. le serveur sensu ecoute la queue recupere les resultats les envoie au handlers
Aucune conf n'est nécéssaire sur le server 
les checks sont uniquement definis dans le rep /etc/sensu/conf.d
ils se declarent eux même standalone en rajoutant la clé "stadalone"

le client Sensu planifie les checks standalone avec un offset particulier 

Exemple de check :

on cree un check qui va générer un critical si on est lundi et un warning si on est vendredi :

On cree la definition de notre check 

/etc/sensu/conf.d/checks/day_check.json 
{
"checks": {
	"day_check": {
		"command": "check-day.sh",
		"standalone": true,
		"interval": 3600
		}		
	}	
}

on cree notre check 

/etc/sensu/plugins/check-day.sh
#!/bin/sh
DAY=$(date '+%A')
	if [ "$DAY" == "Monday" ]; then
		echo "CRITICAL - It is Monday"
		exit 2
	elif [ "$DAY" == "Friday" ]; then
		echo "WARNING - It is Friday"
		exit 1
	else
		echo "OK - Just another day"
		exit 0
	fi

Les avantages de ces checks :
> pas de charge sur le server enterme de schedule et publication des requettes : tout est fait sur le serveur .
on place  les checks de cette façon dont on veut connaitre parfaitement la frequence 

les inconveniants :
chaque modif de script doit être faite sur les serveurs en  local (il faut donc gérer via puppet ..etc ..)
On by pass les soubscription et donc les organisations car on en utilise  pas avec les checks de ce type.
En cas de souci avec le check sensu-server n'a aucune idee du souci .;sauf si le check de keealved ne repond plus 
on ne peut pas aggreger les checks standalone .

= keepalive = 
sensu check regulierement que les clients sensu s'enregitrent regulierement : on a donc pas besoin de rajputer de check ping.
les keepalive sont envoyés toutes les 20 secondes par les clients . Si un client ne s'est pas manifesté au bout de 120 secondes : on a un warning. Un crittical est levé a partir de 180 secondes .Ceci sont les configurations par defaut mais on peut les modifier : il faut le faire pour chaque client.
ex: 
/etc/sensu/conf.d/client.json 
{
"client": {
	"subscriptions": [
	"os"
	]	,
	"address": "203.0.113.2",
	"name": "sensuclient.example.com",
	"keepalive": {
	"thresholds": {
	"warning": 120,
	"critical": 180
	},
  "handler": "default"
  }
 }
}

Il est egalement possible de modifier les handlers des checks keepalive si l'on veut.
ex :
on rajoute ce type de ligne dans le fichier de conf du client :

"handlers": [ "default", "myhandler" ] 

Rabbitmq  hearthbeat :
rabbitmq de base à un hearthbeat situé à 600secondes.
on peut le verifier avec la commande :
rabbitmqctl environment
Il est possible de definir une conf particuliere dans :
ex: 
/etc/rabbitmq/rabbitmq.config
[
	{rabbit, [
		{heartbeat,119},
		...
	]}
]

= Checks "normaux" = 
la particularité de sensu est de prermettre aux clients de s'abonner à certains groupes de checks.
Ces checks ont leur definition de configurés sur le server sensu.
Il va regulierement publier ces definitions de checks dans le rabbitmq .
Les clients qui ecoutent la queue vont recevoir la definition du check et ensuite executer en local le check / plugin et renvoyer le resultat du code à rabbitmq 

Quand on definit un check on doit donc se demander :
-> est ce que les checks / plugins qu'ont va utiliser sur le client existent dejà ( consulter les checks de la communauté sensu ) et les checks nagios.
-> quel groupe de server vont executer le check : on doit juste definir la conf correcte dans la partie subscriptiuons de /etc/sensu/conf.d/client.json
-> que va--il se passer à la reception d'une alerte : mail, sms .. c'est la qu'on dva definir nos handlers.
-> a quelle frequence devra t on executer le script : c'est la session interval 

ex : check de conso memoire :


{
"checks": {
	"free_ram": {
		"command": "check-ram.rb",
		"subscribers": [
		"webservers"
		]		,
		"handlers": [
			"default"
		],
		"interval": 60
		}
	}		
}


- Overriding de param / substitutions.



