=== notes sensu ===


= api sensu : ==
https://sensuapp.org/docs/latest/api/overview.html



=== notes v_oreilly et book ===


== Install ( vm test ubuntu 16/04 lts : == 


On install rabbitmq-server qui va nous servir a gerer les filles  de messages.
une "webapp" est dispo des l'install avec l'install des plugins 

root@ubuntu-xenial:~# apt-get install rabbitmq-server
root@ubuntu-xenial:~# rabbitmq-plugins enable  rabbitmq_management
The following plugins have been enabled:
  mochiweb
  webmachine
  rabbitmq_web_dispatch
  amqp_client
  rabbitmq_management_agent
  rabbitmq_management

Applying plugin configuration to rabbit@ubuntu-xenial... started 6 plugins.

on va redemmarer le service et checker :

root@ubuntu-xenial:~# service rabbitmq-server restart

on va tester notre appli :

en cli :

root@ubuntu-xenial:~# curl -I http://localhost:15672
HTTP/1.1 200 OK
Server: MochiWeb/1.0 (Any of you quaids got a smint?)
last-modified: Sat, 25 Feb 2017 17:24:03 GMT
Date: Sat, 25 Feb 2017 17:25:23 GMT
Content-Type: text/html
Content-Length: 1353

on va aussi tester depuis un browser :
pour cela on va faire une redirection de port de notre rabbitmqsur la vm vers le navigo de notre machine dans la conf vagrant :

VAGRANTFILE_API_VERSION = "2"
Vdministratoragrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.vm.box = "ubuntu/trusty64"
  config.vm.network "forwarded_port", guest: 15672, host: 15672


on va ajouter un user test avec tous les droits pour acceder 
rabbitmqctl add_user test test
rabbitmqctl set_user_tags test administrator
rabbitmqctl set_permissions -p / test ".*" ".*" ".*"

on va ajouter un virtual host dans notre webapp rabbit mq 
> a droite virtual host > new virtual host 
on rentre : /sensu 
on ajoute un nouveau user :
sensu / mdp secret 

on ajoute ensuite un user sensu avec un password secret au vhost sensu 
root@SensuServer:/etc/rabbitmq# rabbitmqctl add_user sensu secret
root@SensuServer:/etc/rabbitmq# rabbitmqctl set_user_tags sensu administrator
root@SensuServer:/etc/rabbitmq# rabbitmqctl set_permissions -p / ".*" ".*" ".*"
on rajoute le user sensu et on le grant au vhost /sensu : 
root@SensuServer:/etc/rabbitmq# rabbitmqctl set_permissions -p / ".*" ".*" ".*"




on va ensuite cliquer sur notre nouveau user et lui donner tous les droits (*) sur notre vhost /sensu en selectionnant les menus deroulant.
on sauve et c'est ok .

On install mintenant redis-server :

root@ubuntu-xenial:~# apt-get install redis-server
pour tester notre install on lance l'utilitaire :
root@ubuntu-xenial:~# redis-cli ping
PONG

On va  maintenant passé à l'install de  sensu :
-> on recupere la cle pub du repo :
wget -q https://sensu.global.ssl.fastly.net/apt/pubkey.gpg -O- | sudo apt-key add -
on va ensuite monter le repo dédié à notre distrib apres l'avoir identifiée :
. /etc/os-release && echo $VERSION
16.04.2 LTS (Xenial Xerus)

on  rajoute un source list dedié a sensu concernant notre repo
root@ubuntu-xenial:~# cat /etc/apt/sources.list.d/sensu.list
deb     https://sensu.global.ssl.fastly.net/apt xenial main
puis on update notre db :
apt-get update

on install sensu 
apt-get install sensu

on creee maintenant notre fichier de conf :
qui va repertorier les infos de conf settee : rabbitmq ,redis et le port de notre api sensu . La conf sous format json doit toujours avoir les sections entourées de { } 
root@ubuntu-xenial:~# vi /etc/sensu/config.json
{
  "rabbitmq": {
    "host": "localhost",
    "vhost": "/sensu",
    "user": "sensu",
    "password": "secret"
  },
  "redis": {
    "host": "localhost" 
  },
  "api": {
    "port": 4567
  }  
}

on demarre maintenant notre sensu-server et api :
root@ubuntu-xenial:~# systemctl start sensu-server
root@ubuntu-xenial:~# systemctl start sensu-api

on peut consulter les logs de notre appli dans /var/log/sensu : on a les logs server et api

on va maintenant configurer la partie client :
comme tout se passe sur la même machinne pas de conf particuliere 
on rentre un nom pour identifier notre client , son ip et la liste des subscriptions ( ensemble de checks)  auquels il va s'inscrire

t@ubuntu-xenial:~# cat /etc/sensu/conf.d/client.json
{
  "client": {
    "name": "SensuServer",
    "address": "10.0.2.15",
    "subscriptions": [
     "Production" 
    ] 
  }
}
puison demarre notre service : 
root@ubuntu-xenial:~# service sensu-client start
root@ubuntu-xenial:~# systemctl status sensu-client
● sensu-client.service - sensu client
   Loaded: loaded (/etc/systemd/system/sensu-client.service; disabled; vendor preset: enabled)
   Active: active (running) since Sun 2017-02-26 12:35:58 UTC; 12s ago
 Main PID: 9987 (sensu-client)
    Tasks: 24
   Memory: 16.7M
      CPU: 229ms
   CGroup: /system.slice/sensu-client.service
           └─9987 /opt/sensu/embedded/bin/ruby /opt/sensu/bin/sensu-client -c /etc/sensu/config.json -d /etc/sensu/conf.d -e /etc/sensu/extensions -p /var/run/sensu/sensu-client.pid -l /var/lo

on installe maintenant uchiwa (directement via notre distrib : ubuntu et le repo qu'on a setté font le job ou alors sur uchiwa.io : le site du projet )
root@ubuntu-xenial:~# apt-get install uchiwa
on va modifier le ficher de conf de base d'uchiwa en renseignant les infos de notre conf : 

root@ubuntu-xenial:~# cat /etc/sensu/uchiwa.json 
{
  "sensu": [
    {
      "name": "SensuServer",
      "host": "localhost",
      "port": 4567,
      "ssl": false,
      "path": "",
      "user": "sensu",
      "pass": "secret",
      "timeout": 10
    }
  ],
  "uchiwa": {
    "host": "0.0.0.0",
    "port": 3000,
    "refresh": 10
  }
}

on redemmare notre stack 
root@SensuServer:/etc/sensu# service sensu-server restart && service sensu-api restart && sleep 2 && service uchiwa restart

on peut desormais acceder a uchiwa en http://lcoalhost:3000

root@SensuServer:/etc/sensu# curl -i http://localhost:3000/clients
HTTP/1.1 200 OK
Accept-Charset: utf-8
Content-Type: application/json
Date: Sun, 26 Feb 2017 19:25:07 GMT
Content-Length: 297

[{"_id":"SensuServer/SensuServer","address":"10.0.2.15","dc":"SensuServer","name":"SensuServer","output":"No keepalive sent from client for 23862 seconds (\u003e=180)","silenced":false,"status":2,"subscriptions":["Production","client:SensuServer"],"timestamp":1.488113238e+09,"version":"0.27.1"}]


En recap on a donc une appli découpée en plusieurs briques : 

Service 	  Runs On 	Description
sensu-client  client 	Runs checks; reports results
sensu-api     server 	API for programmatic interaction
sensu-server  server 	Schedules checks; routes results
redis         server 	Persistent key-value storage
sensu-dashboard server  Visualizes results
rabbitmq-server amq server  AMQP server

On a tous les logs de splités : 
tail –f /var/log/sensu/sensu-server.log
tail –f /var/log/sensu/sensu-client.log

on peut setter le log level de sensu dans /etc/defaut/sensu

LOG_LEVEL=debug
les autres valeurs sont warning et fatal 


On peut redemarrer les services aussi de plusieurs manieres :
cd /etc/systemd/system && systemctl restart sensu-*


Validation de json :

quand on edite un fichier json on peut toujours lui passer un tester de syntax comme ceci :

exemple on rajoute une virgule a la fin de notre derniere valeur de hash : ce qui n'en prends pas normalement : en lancant le check on a donc une erreur :

roo@SensuServer:/tmp# cat uchiwa.json |python3 -m json.tool
Expecting property name enclosed in double quotes: line 12 column 5 (char 207)


== Architecture : == 

- rabbitmq :
est central a sensu et est un message broker : il recoit les messages à un point d'echange, les met en queues et les passe à un consummer.
Il recoit les instructions du server sensu sur les differents checks a executer , il place ces instructions dans une queue dans laquelle le client peut venir chercher ces infos.
Le broker recoit aussi les resultats des checks envoyés par les clients, les place en queue et les met donc a dispostion du sensu server 

La capacité d'envoyer les checks à une queue de soubscription est vraiment un avantage pour le deploiment de nouveaux clients.
Un nouveau server doit juste s'accrocher à une queue qui va ainsi lui fournir les checks a executer.

- sensu server : 
c'est le cerveau: il sait quel type de checks doivent être executer en lisant les fichiers de configuration et est en charge du sheduling des checks.
sensu server ecoute aussi la queue rabbitmq pour recuperer les resultats et les diriger vers les handlers corrects.
ex : un hdd full à 80% va envoyer un mail , un hdd full  90% va envoyer un sms ...

- sensu client :
Le client est à l'ecoute de rabbimq et execute les checks quand il doit le faire . Il execute donc des scripts et renvoie le resultat à rabbitmq 
On a aussi des scripts périodiques qui sont executés periodiquement sur le client sans ordre demandé par rabbitmq 
Le resultat de ces checks est envoyé à rabbitmq exactement comme les autres checks.
Le  resultat envoyé peut être le status du code retour ou d'autres info complementaires.

NB sensu peut être packagé et embarquer toutes les applis (server , client , api , dashboard  .) mais seul le client devra être installer sur notre server client.

- sensi api : api qui fourni un acess REST ( Representative State Transfer )

-Redis : systeme de clé / valeur : sensu a la notion de stashes qui sont des données persistantes sous format json . Sensu utilise redis comme stockage d'informations sur les checks et les clients.


= notes de configuration =

Attention une configuration de ntp est utile pour nos applications.


- rabbitmq : les commandes principales ont été vues dans l'installation en utilisadant l'utilitaire en cli :

rabitmqctl 

- sensu-client :

toutes les arbo server et client sont identiques mais le client n'a juste besoin que de savoir comment contacter le rabbitmq , l'acces aux diffrents check qu'il devra executer  : ceci se passe dans le repertoire plugin ou sous forme de gem ruby 
Quand sensu client demarre il examine d'abord le repertoire /etc/sensu/conf.d ..on peut donc organiser nos arbo comme on veut ..les fichiers primordiaux sont client.json et rabbitmq.json
 
La cle de subscription visible dans notre conf client, defini quelle queue rabbitmq notre client va ecouter .
ex :
"client": {
"subscriptions": [
"os"
],
..
ex ici quand le sensu server va demander à tous les clients abonnés à la queue "os" de checker leur espace disque, ils vont le faire.
si notre server héberge un nginx alors il pourra egalement s'abonner a la queue webserver qui aura des check http a faire executer sur les clients.

"client": {
"subscriptions": [
"os" "webserver" 
],


Les checks en standalone (sans schedling par le sensu server ) devront être dans /etc/sensu/conf.d/

Le nom des queues est tout à fait personnel et on les creee quand on defini nos definitions de checks sur le sensu-server.
mais avant cela il va falloir définir un élément important :

EMBEDDED_RUBY :

La plupart des checks executés sont en ruby 
l'install de base embarque un ruby : 
/opt/sensu/embedded/bin/ruby , les checks embarqués sont tous testés.
ont peut donc execute nos checks ruby de deux manieres :
1/ avec le rubyembarqué à l'install de sensu 
2/ en utilisant le ruby dejà installé sur notre systeme .

Il est possible de changer notre setting : utilisation ou nom du ruby embarqué en rajoutant un param dans le fichier de conf /etc/defaut/sensu
/etc/default/sensu :
EMBEDDED_RUBY=false
A partir de la version 0.21 la valeur par defaut est à true


- Sensu-server :

sensu-server doit savoir ou trouver rabbitmq et connaitre les checks qu'il schedule, redis et les handlers  pour savoir ou diriger une action à faire.
les  arbos importantes sont : 
le repertoire checks /api.json 
le repertoire handlers / rabbitmq.json redis.json 
les repertoires extensions / handlers / mutators 

Par defaut sensu-server va recupérer une données à la fois dans rabbitmq en cas de charge on peut augmenter ce nombre en modifiant la conf de notre broker rabbitmq.
ex : 
/etc/sensu/rabbitmq.json 
{
  "rabbitmq": {
	"host": "203.0.113.1",
	"user": "sensu",
	"port": 5672,
	"vhost": "/sensu",
	"password": "secret",
	"prefetch": 3
		}
}

On va creer des checks  et des handlers dans les arbos suivantes  /etc/sensu/conf.d/checks et /etc/sensu/conf.d/handlers 


On peut avoir plusieurs server sensu : on a par contre un master ( le premier qui demarre crée un lock dans redis). le master publie les checks, gere les keepalive 
Le slave va recupérer les checks de rabbitmq en round rubin (avec le master )et va less envoyer vers les handlers.


- Configuration de l'api :
l'api sensu est exposée au dessus du framework leger sinatra : il est possible d'herberger l'api ailleurs que sur le server sensu . comme pour le server et le client on peut avoir plusieurs api deifferentes en place : il duffit des les déclarer 
/etc/sensu/api.json
{
	"api": {
	"host": "localhost",
	"port": 4567,
	}	
}

 on peut déclarer un user / mdp pour acceder à l'api :
/etc/sensu/api.json

{
	"api": {
		"host": "localhost",
		"port": 4567,
		"user": "api_user",
		"password": "api_secret",
	}
}

Attention ci notre api est configurée ailleurs que sur le serveur il faut s'assurer que la communication se fait bien avec rabbitmq et redis.
Uchiwa est un outil de visualisation qui interreagi avec l'api

- Redis :

la config de redis est tres simple : le port suffit quasiment 

/etc/sensu/conf.d/redis.json
{
"redis": {
  "host": "localhost",
  "port": 6379,
  }
}


on peut ajouter de l'authent en configurant /etc/redis.conf
ex 
requirepass mysupersecretredispassword
on pourra ensuite declarer notre appel dans le conf de redis sensu 
ex :
{
"redis": {
	"host": "localhost",
	"port": 6379,
	"password": "mysupersecretredispassword"
	}
}

== Checks : ==

Le job le plus important est la gestion des checks.
Le check est composé en deux partie :
-> check definition : doc json qui fourni les metadata relatives au check : commande et frequence .
la commande est typiquement un script . qu'on va stocker dans le repertoire plugins
Il y a trois types de check :
-> standalone : les resultat sont envoyés au sensu server 
-> regulier  : les checks sont planifiés par le sensu server 
-> keepalive  : check d'etat de vie du node

les codes retour de nos scripts sont standarts 

2 > critical
1 > warning
0 > ok
3 > unknow 


= standalone : 
ce sont les checks les plus simple : les serveurs executent une commande et envoient le resultat au rabbitmq. le serveur sensu ecoute la queue recupere les resultats les envoie au handlers
Aucune conf n'est nécéssaire sur le server 
les checks sont uniquement definis dans le rep /etc/sensu/conf.d
ils se declarent eux même standalone en rajoutant la clé "stadalone"

le client Sensu planifie les checks standalone avec un offset particulier 

Exemple de check :

on cree un check qui va générer un critical si on est lundi et un warning si on est vendredi :

On cree la definition de notre check 

/etc/sensu/conf.d/checks/day_check.json 
{
"checks": {
	"day_check": {
		"command": "check-day.sh",
		"standalone": true,
		"interval": 3600
		}		
	}	
}

on cree notre check 

/etc/sensu/plugins/check-day.sh
#!/bin/sh
DAY=$(date '+%A')
	if [ "$DAY" == "Monday" ]; then
		echo "CRITICAL - It is Monday"
		exit 2
	elif [ "$DAY" == "Friday" ]; then
		echo "WARNING - It is Friday"
		exit 1
	else
		echo "OK - Just another day"
		exit 0
	fi

Les avantages de ces checks :
> pas de charge sur le server enterme de schedule et publication des requettes : tout est fait sur le serveur .
on place  les checks de cette façon dont on veut connaitre parfaitement la frequence 

les inconveniants :
chaque modif de script doit être faite sur les serveurs en  local (il faut donc gérer via puppet ..etc ..)
On by pass les soubscription et donc les organisations car on en utilise  pas avec les checks de ce type.
En cas de souci avec le check sensu-server n'a aucune idee du souci .;sauf si le check de keealved ne repond plus 
on ne peut pas aggreger les checks standalone .

= keepalive = 
sensu check regulierement que les clients sensu s'enregitrent regulierement : on a donc pas besoin de rajputer de check ping.
les keepalive sont envoyés toutes les 20 secondes par les clients . Si un client ne s'est pas manifesté au bout de 120 secondes : on a un warning. Un crittical est levé a partir de 180 secondes .Ceci sont les configurations par defaut mais on peut les modifier : il faut le faire pour chaque client.
ex: 
/etc/sensu/conf.d/client.json 
{
"client": {
	"subscriptions": [
	"os"
	]	,
	"address": "203.0.113.2",
	"name": "sensuclient.example.com",
	"keepalive": {
	"thresholds": {
	"warning": 120,
	"critical": 180
	},
  "handler": "default"
  }
 }
}

Il est egalement possible de modifier les handlers des checks keepalive si l'on veut.
ex :
on rajoute ce type de ligne dans le fichier de conf du client :

"handlers": [ "default", "myhandler" ] 

Rabbitmq  hearthbeat :
rabbitmq de base à un hearthbeat situé à 600secondes.
on peut le verifier avec la commande :
rabbitmqctl environment
Il est possible de definir une conf particuliere dans :
ex: 
/etc/rabbitmq/rabbitmq.config
[
	{rabbit, [
		{heartbeat,119},
		...
	]}
]

= Checks "normaux" = 
la particularité de sensu est de permettre aux clients de s'abonner à certains groupes de checks.
Ces checks ont leur definition de configurés sur le server sensu.
Il va regulierement publier ces definitions de checks dans le rabbitmq .
Les clients qui ecoutent la queue vont recevoir la definition du check et ensuite executer en local le check / plugin et renvoyer le resultat du code à rabbitmq 

Quand on definit un check on doit donc se demander :
-> est ce que les checks / plugins qu'ont va utiliser sur le client existent dejà ( consulter les checks de la communauté sensu ) et les checks nagios.
-> quel groupe de server vont executer le check : on doit juste definir la conf correcte dans la partie subscriptiuons de /etc/sensu/conf.d/client.json
-> que va--il se passer à la reception d'une alerte : mail, sms .. c'est la qu'on dva definir nos handlers.
-> a quelle frequence devra t on executer le script : c'est la session interval 

ex : check de conso memoire :


{
"checks": {
	"free_ram": {
		"command": "check-ram.rb",
		"subscribers": [
		"webservers"
		]		,
		"handlers": [
			"default"
		],
		"interval": 60
		}
	}		
}


- Overriding de param / substitutions.

Il est bien entendu classique de recevoir une alerte quand on depasse un certain seuil. Il est cependant possible de fixer des seuils particulier pour certains nodes en overridant la config
grace à des tokens de commandes de substitution 
La  definition du check fourni des valeurs par  defaut mais on peut les overrider.
ex: 
/etc/sensu/conf.d/checks/free_ram.json

{
"checks": {
	"free_ram": {
		"command": "check-ram.rb",
		"subscribers": [ "os" ],
		"interval": 60
		}	
	}
}

Quand on examine le check-ram.rb on voit les seuils settes :
ici on voit qu'on a un warning quand il reste 10% de ram dispo et un critical a 5%
/etc/sensu/conf.d/checks/free_ram.json
{
"checks": {
    "free_ram": {
        "command": "check-ram.rb -w 10 -c 5",
        "subscribers": [ "os" ],
        "interval": 60
    }
}

Pour pouvoir overrider la conf dans le client on va modifier la syntaxe :
on rajoute ":::" ce  qui va correspondre à quelque chose dans la conf client 
et va recuperer la valeur par defaut si rien n'est recupérer dans la conf client :

/etc/sensu/conf.d/checks/free_ram.json
{
"checks": {
	"free_ram": {
		"command": "check-ram.rb -w :::params.ram.warning|10::: -c :::params.ram.critical|5:::",
		"subscribers": [ "os" ],
		"interval": 60
			}
	}
}

Pour overrider la conf dans le client on va donc setter des param qui corespondront à la definition du check 
/etc/sensu/conf.d/client.json 

{
"client": {
		"name": "sensuclient.example.com",
		"subscriptions": [
		"os", "webservers"
		],
		"address": "203.0.113.2",
		"params": {
			"ram": {
				"warning": 20,
				"critical": 10
				}
			}
		}		
}

Quand le client sensu parcoure le check il voit params.ram.warning et prend donc la valeur défini au lieu de celle par defaut définie dans  le check. idem pour la valeur critical.
Le check va donc être : check-ram.rb -w 20 -c 10

Il faut garder à l'eprit que sensu est malleable et que les  param de substitution sont tres pratiques . On peut mettre le nom que l'on veut ici params mais ce n'est pas une obligation : il est important de garder du sens cependant.

On peut également definir des commandes par défaut : ex si on a une commande particuliere pour notre ram on peut la définir sinon fallbacker sur une de base.

ex :
/etc/sensu/conf.d/checks/free_ram.json
{
"checks": {
	"free_ram": {
		"command": ":::ramcheck|check-ram.rb:::",
		"subscribers": [ "os" ],
		"interval": 60
		}
	}
}

/etc/sensu/conf.d/client.json
{
"client": {
	"name": "sensuclient.example.com",
	"subscriptions": [
	"os", "webservers"
	],
	"address": "203.0.113.2",
	"ramcheck": "other-ram-check.sh"
	}
}

-  Password et données sensibles :

On a une obligation de ne pas faire transiter de données sensibles.
Sensu a un mecanisme de protection de "redaction" (suppression ) des infos sensibles.Ceci se fait de base pour :

access_key
api_key
api_token
pass
passwd
password
private_key
secret
secret_key

Des clés additionnelles peuvent être ajoutées dans notre client.json 
L'instruction redact est obligatoire . Ex on ajoute des données sensible entre la clé redact 
{
"client": {
	"name": "sensuclient.example.com",
	"subscriptions": [
	"os", "webservers"
	],
	"address": "203.0.113.2",
	"redact": [
		"secret_banana",
		"passcode"
		]
	}
}

Dans les logs les infos supprimées seront flagguées "REDACTED"

- Safe mode :

sensu permet de setter un param de safe mode qui prend en valeur un booleen 

/etc/sensu/conf.d/client.json
{
"client": {
	"name": "sensuclient.example.com",
	"safe_mode" : true,
	"subscriptions": [
	"os", "webservers"
	],
	"address": "203.0.113.2",
	}
}

Si on set un safe-mode a false : le check s'execute .Si on le set a true : le chec kne s'execute que si la definition du check est présente sur le server ET sur le client.
Si ce n'est pas le cas sensu renvoi un code d'erreur 3 et une sortie de type : "Check is not locally defined (safe mode)."

Cette option permet de s'assurer que les checks correctement declarés sont correctement executés.
NB que cette option n'est pas prise en compte sur un serveur et un client présent sur la même machinne.
Idem pour les checks en standalone : ceci n'est pas pri en compte.
*

- Aggregation de checks :

Il est possible de vouloir recevoir une multitude d'infos pour un check afin par exemple d'assurer le provisionning correct.
ex : si on veut connaitre la charge de nos dbs et qu'on voit qu'elles sont toutes à 90% de cpu on va pouvoir planifier de l'ajout 

etc/sensu/conf.d/checks/load_check.json

{
"checks": {
	"load_check": {
		"command": "check-load.rb -w 10,20,30 -c 25, 50, 75",
		"subscribers": [ "databases" ],
		"interval": 60,
		"aggregate": true,
		"handle": false
		}
	}
}


On voit ici  qu'on a à la fois l'option handle à false : on ne veut pas faire executer d'actions supplementaires 
L'option aggregate est elle à true : on va dans ce cas enregistrer de maniere persistante dans redis le resultat pour une consultation future.
NB : les checks en standalone ne fonctionnent pas en aggregate : en effet les checks fait par les clients ont tous des timestamp differents

Les  aggregés eux se stockent dans le redis en fonction du nom du check et d'un timestamp unique.
voir aggregate_check_result() dans process.rb

Les resultats stockés  dans redis vont ensuite  (à partir du deuxieme check) être executés par un autre check sensu/check-aggregate.rb" qui lui va evaluer les resultats stockés dans redis :

on a donc un check dedié pour notre load qui va permettre l'execution du check aggregé et recupérer les données stockées dans redis : 

/etc/sensu/cond.d/checks/aggregate_load_check.json
{
"checks": {
	"aggregate_load_check": {
		"command": "check-aggregate.rb -c load_check -W 75 -C 90",
		"subscribers": [ "decisionmaker" ],
		"interval": 300,
		"handlers": [
		"irc", "database_spinner_upper"
		]
	}
}
}
Ce check va être executé par les servers abonnées à la file "decisionmakert" : a priori seul le sensu server.
> le script executé check-aggregate.rb -c load_check -W 75 -C 90 ne le sera donc en principe fait que depuis une machine puisque nous voulons uniquement un seul check aggregé.

Attention les seuils (threshold) ont un sens particulier dans les checks d'aggregat 
Ex : un warning de 75% en aggregé indique que 75% des serveurs hébergeant le check ont donc reppondu a un code retour different de 0 : donc ils ont une load en warning ou critical pour 75% d'netre eux .

Si 90% des serveurs ont un code retour deifferent à 0 alors sensu levera une alerte critical.

Dans notre exemple :sensu va envoyér en cas d'alerte un message sur un canal irc et demarrer un demarrage auto de bdd ( database_spinner_upper) pour soulager la charge.

Clean des données agregées :
les datas recoltées et aggrégées sont purgées toutes les 20secondes par le server sensu et il conserve les 20 derniers resulats de check aggregés.

- Check auto-documentés :

Comme differentes clés valeurs peuvent être définies dans les checks : ont peut définir des tips qui pourront aider lors  d'astreinte ou autre ../etc/sensu/conf.d/checks/legacy_database_check.json :

{
checks": {
	"legacy_database_check": {
		"command": "check_foxpro.rb",
		"handler": "mailer",
		"subscribers": [ "antiqueservers" ],
		"interval": 60,
		"playbook": "Before restarting the legacy database server, make sure no on\
		e is using the microwave or you will trip the circuit breaker."
		}	
	}
}
Dans cet exemple le keyword "playbook" est specific au handler "mailer"

On voit ici qu'on peut ajouter des infos additionnelles dans nos definitions de check et que ces infos sont donc  consultables par nos handlers ( après une configuration )


- Utilisateur privilégié :

quand le client sensu execute un check et doit le lancer avec un user particulier : une conf additionnelle doit être mise en place dans le sudoers 

exemple : 
/etc/sudoers.d/sensu
Defaults:sensu !requiretty
Defaults:sensu secure_path = /usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin\
:/usr/bin
sensu ALL = NOPASSWD: /etc/sensu/plugins/mycheck.rb


==== Metrics ====

Les checks renvoient un code retour : ils peuvent aussi renvoyer un flux vers la sortie standart . Un check qui renvoie une donnée structurée sur la sortie standart et un code retour toujours egal à 0 est associé à unb type "metric" dans sensu.
Son but n'est pas de lever une alerte mais de rediriger les données vers sensu server qui lui même pourra router vers un outil de graphage.
 
Les checks de metric peuvent être soit de type standalone executés par le client soit publiés par le server sensu dans une file rabbitmq et executé à interval régulier par les clients à l'ecoute de cette file. 
exemple : la sortie de cette commande va nous afficher la valeur de la charge de la machinne les 15 dernieres minutes 
uptime | awk '{ print $(NF) }'
1.54
On pourra don creer un check de metric de ce type :

/etc/sensu/conf.d/checks/load_check_15_min.json
{
"checks": {
	"load_check_15_min": {
		"command": "uptime | awk '{ print $(NF) }'",
		"subscribers": [ "os" ],
		"interval": 60,
		"type": "metric",
		"handler": "default"
		}
	}
}

On note ici forcement que le code retour sera toujours 0 et que la commande renverra toujours une valeur . Nous n'avons donc pas de notion d'alerting.
On se contente donc d'ajouter un type "metric" dans la definition de notre check.

Il est aussi possible d'envoyer des metrics au client sensu : il faut qu'elles soient en format json et envoyées en udp sur le port 3030 : le port d'ecoute par defaut du client sensu.

Exemple : il est possible d'envoyer une notification de commit dans sensu 
on a deux composants qui rentrent en ligne de compte :
le post-commit subversion par exemple qui va formatter le message
le plugin sensu qui va creeer et pousser l'event vers le sensu client sur le port 3030

1/ creation d'un post commit : qui va donc être executé apres un commit réussi :

ex : creation d'un script 
Subversion post-commit hook: /var/www/svn/example/hooks/post-commit

#!/bin/sh
# Subversion passes in repository path
# and revision number.

REPOS="$1"
REV="$2"

# svnlook is a utility that queries the repository.
SVNLOOK=/usr/bin/svnlook
AUTHOR=$($SVNLOOK author -r $REV $REPOS)
LOG=$($SVNLOOK log -r $REV $REPOS)
CHANGED=$($SVNLOOK changed -r $REV $REPOS | wc -l)
REPONAME=$(basename $REPOS)
MESSAGE="$AUTHOR commit to $REPONAME $REV $LOG Changed files: $CHANGED "

# Call the Sensu plugin.
/etc/sensu/plugins/svn-commit.rb "$MESSAGE

celui-ci doit être executable :
$ ls -l /var/www/svn/example/hooks/post-commit
-r-xr--r--. 1 apache apache Nov 5 20:58 /var/www/svn/example/hooks/post-commit

2/ Plugin sensu pour pousser l'event vers le sensu client :

Le plugin suivant va donc recupérer le texte du commit puis l'envoyer au client sensu sur le port 3030 puis  dans la queue rabbitmq pour q'il soit gérer par le sensu server egalement :
/etc/sensu/plugins/svn-commit.rb

#!/usr/bin/env ruby

require 'rubygems' if RUBY_VERSION < '1.9.0'
require 'socket'
require 'json'

s = TCPSocket.new 'localhost', 3030
json = {
	'name' => 'svn',
	'output' => ARGV[0],
	'status' => 0,
	'type' => 'metric',
	'handlers' => ['irc']
}.to_json

s.puts json
s.close
Les clés name, output et status sont obligatoires pour que le client recoivent le flux.
On flaggue ensuite le type metric car le code retour d'un commit est toujours 0 donc pas de warning ni critical.
On precise a la fin un handler pour rediriger l'event.
Les checks qu'ont envoient vers le port 3030 doivent avoir une definition de handler explicite (contrairement au checks normaux et standalone )

On a donc pour résumer :
1/ un commit
2/ un post commit qui cree le message et l'envoie au plugin sensu
3/ le message est formatté en json puis envoyé au sensu client
4/ le sensu client inspect la validité du format json puis envoie le message dans la file rabbitmq
5/ le server sensu recupere le message et le passe au handler
6/ le client irc post le message 
ex : jvandyk commit to example 384 Replaced all foos with bars for better performance. Changed
files: 4

on peut examiner la façon donc c'est gérer en regardant : /lib/sensu/socket.rb


=== Handlers ===

Les handlers recuperent les infos en provenance des checks, checks standalone et metrics.
Il y a deux parties à configurer : la definition du handler et la conf du handle lui-même (comme pour les checks ou on a une definition de checks et checks en lui même)

On peut placer les conf de handlers par exemple dans cette arbo :
/etc/sensu/conf.d/handlers en donnant un nom assez explicite 
exemple ici on creer un handler de type pipe qui redirigera la sortie d'un script shell vers le json de sensu :

/etc/sensu/conf.d/metric_to_file.json
{
	"handlers": {
	"metric_to_file": {
		"type": "pipe",
		"command": "/etc/sensu/handlers/metric_to_file.sh"
		}
	}
}
A noter que le nom de notre handler devra être celui que l'on a inscrit dans notre  définition de handler : 
"handler": "metric_to_file"


Type de handlers : 
sensu embarque differents type de handlers pour couvrir le maximum de besoin , la notion d'extension de handler existe aussi notamment pour le server sensu afin de reduire la charge liée à la multiplication de fork de process de handlers à gerer en cas de beaucoup d'evenements.

-debug handler :
comme son nom l'indique ce handler va recupérer les flux et les envoyer dans les logs : 
/var/log/sensu/sensu-server.log

- pipe handler :
ce handler utilise une commande ruby popen pour lancer une nouvelle commande et envoyer le flux json de nos events sensu vers elle. Typiquement nos handlers seront en ruby et utiliseront une classe Sensu:handler . Nos handlers peuvent aussi être de diffrents type (python, php ..)
La classe Sensu:handler est disponible dans le gem sensu plugin

Attention le sensu-plugin doit être disponible pour le binaire ruby qui execute le plugin. Si on utilise le ruby embarqué donc le setting true dans /etc/defalut/sensu -> EMBEDED_RUBY = true : pas de souci.
Sinon il faudra vérifier les gems installés et proceder si besoin à l'install : 
gem list 
sudo gem install sensu-plugin

Exemple de handlers :

ruby : 
Ruby pipe handler. /etc/sensu/handlers/example_handler.rb

class ExampleHandler < Sensu::Handler
  # Override filters from Sensu::Handler.
  # Not used for metric handlers.
  def filter; end
    # Override handler from Sensu::Handler.
    def handle
      metric = @event['check']['output']
      File.open("/var/log/sensutest.log", 'a+') {|f| f.write(metric) }
    end
end

bash :
ici on reprend l'exemple de la metric du load des 15 dernieres minutes qu'on envoie dan un handler en shell qui poussera le tout dans un fichier de log :

Check definition for bash pipe handler. /etc/sensu/conf.d/checks/load_check_15_min.json
{
"checks": {
  "load_check_15_min": {
    "command": "uptime | awk '{ print $(NF) }'",
    "subscribers": [ "os" ],
    "interval": 60,
    "type": "metric",
    "handler": "metric_to_file"
    }
  }
}

notre handler : 
/etc/sensu/handlers/metric_to_file.sh

#!/bin/bash
# Read event data piped from Sensu into $sensu_event
# variable.
read sensu_event

# Parse JSON.
json=$(echo $sensu_event | tokenize | parse)

# Get value of the output key.
value=$(echo "$json" | awk -F '"' \
'/^\["check","output"\]/ { print $6 }')

# Write metric value to a file.
echo "$value" >> /var/log/sensutest.log

- python :

la version de notre handler bash cette fois en python :
on voit que le handler de type pipe utilise la commande python :
/etc/sensu/conf.d/handlers/metric_to_file.json
{
	"handlers": {
		"metric_to_file": {
		"type": "pipe",
		"command": "/etc/sensu/handlers/metric_to_file.py"
		}
	}
}

la definition de notre check reprend le même nom de handler :
{
"checks": {
  "load_check_15_min": {
    "command": "uptime | awk '{ print $(NF) }'",
    "subscribers": [ "os" ],
    "interval": 60,
    "type": "metric",
    "handler": "metric_to_file"
    }
  }
}
Notre handler va recevoir les flux du sensu server et rediriger la valeur dans un fichier de log : 

#!/usr/bin/env python
import sys
import json

# Read event data piped from Sensu into $sensu_event
# variable.
sensu_event = sys.stdin.readlines()

# Parse event into Python dictionary.
parsed_event = json.loads(sensu_event[0])

# Get value of the output key.
metric = parsed_event['check']['output']

# Write metric value to a file.
f = open('/var/log/sensutest.log', 'w')
f.write(metric)
f.close

- Testing pipe handler :
il est possible de tester nos handlers de type pipe en envoyant un event sensu directement vers eux :

cat event.json | /etc/sensu/handlers/my_handlers.rb


- TCP handlers :

sensu utilise la methode EM:connect() pour executer les handlers tcp.Il faut juste definir le host et le port vers lequel sensu va envoyer les events.
exemple : 
TCP handler definition. /etc/sensu/conf.d/handlers/tcp_logstash.json
{
	"handlers": {
		"tcp_logstash": {
		"type": "tcp",
		"socket": {
		"host": "127.0.0.1",
		"port": 5122
			}
		}
	}
}

Biensur il faut sur le host distant un process qui ecoute sur le port dédié et accepte le json en entrée.
exemple complet de fichier pour logstash qui ecrit les logs recu de sensu et les envoie egalement dans elasticsearch : 
/etc/logstash/example.conf
# Listen for JSON coming in from Sensu.
input {
	tcp {
	port => 5122
	codec => "json"
	}
}
# Write events to a file.
output {
	file {
		path => "/var/log/logstash/sensu_incoming.log"
		}
	}
# Hand to Elasticsearch for indexing.
output {
	elasticsearch {
		codec => "json"
		}
}

- UDP handler : le fonctionnement est identique au tcp mais biensur il n'y a pas de garantie de reception de message de part la nature même de udp :
ex : 
/etc/sensu/conf.d/handlers/udp_logstash.json
{
	"handlers": {
		"udp_logstash": {
			"type": "udp",
			"socket": {
				"host": "127.0.0.1",
				"port": 5123
			}
		}
	}
}


- Transport handler :
Le handler de type  transport envoie les messages au systeme de message queuing que sensu utilise (typiquement rabbitmq) 
Il est même possible d'enboyer directement à un autre rabbitmq ou à un autre systeme de queing qui ecoute et a un consummer pour archiver des messages par exemple.

/etc/sensu/conf.d/handlers/amqp_archiver.json
{
	"handlers": {
		"amqp_archiver": {
			"type": "transport",
		"exchange": {
		"name": "archive_exchange",
		"type": "direct",
		"routing_key": "archive"
			}
		}	
	}
}

ici lenom amqp_archiver est la clé utilisée par sensu ; le type transport permet de définir que ce handler sera donc  de type transport.
Ici la clé exchange va donner des infos sur  la queue de transport ici name type et routing_key seront donc des infos supplementaires 


- Handlers set :

il est possible d'envoyer des alertes, metriques etc à plusieurs handlers.
/etc/sensu/conf.d/checks/load_check_15_min.json
{
	"checks": {
		"load_check_15_min": {
			"command": "uptime | awk '{ print $(NF) }'",
			"subscribers": [ "os" ],
			"interval": 60,
			"type": "metric",
			"handlers": [ "a_handler", "another_handler" ]
			}
	}
}

cependant il est souvent plus pratique de regrouper les handlers ensemble dans une section definie : handler set :
/etc/sensu/conf.d/handlers/handler_sets.json
{
	"handlers": {
		"my_handler_set": {
		"type": "set",
		"handlers": [
		"a_handler",
		"another_handler"
			]
		}
	}	
}

On aura donc juste à mofifier l'entree de notre handler dans la definition de notre check :


/etc/sensu/conf.d/checks/load_check_15_min.json
{
	"checks": {
		"load_check_15_min": {
			"command": "uptime | awk '{ print $(NF) }'",
			"subscribers": [ "os" ],
			"interval": 60,
			"type": "metric",
			"handlers": [ "my_handler_set" ]
			}
	}
}
You can easily add the debug handler to a handler set in order to observe the events being sent to
the handler set.


=== Filters === 

sensu permet d'utiliser des filtres pour gérer les messages arrivant en utilisant des attributs.
on peut combiner ces filtres avec les handlers pour avoir une gestion fine.

- filtrage des handlers : il est possible de definir finement quoi faire lors de la reception d'un message.
on peut utiliser le keyword filter ou utiliser la methode Sensu::Handler ici du sensu-plugin.Une troisieme forme est en cours de dev et elle est basée sur le timestamp de l'evenement.

- Attributs de filtres : il est possible de définir des filtres sur la valeur des events recus.Il est possible de definir des type dans un fichier de type : /etc/sensu/conf.d/filters.json par exemple.On va donc definir des clé valeur qui seront en fonction de leur presence ou pas dans l'event traités ou pas.
exemple : ici on ne va agir que pour la presence d'un node particulier :


/etc/sensu/conf.d/filters.json
{
	"filters": {
		"only_rumpelstiltskin": {
			"attributes": {
			"client": {
			"name": "rumpelstiltskin"
					}			
			}
		}	
	}
}
ici on a dont un filtrer nommé : only_rumpelstiltskin qui donc sera activé à true quand le name rumpelstiltskin sera trouvé dans l'event d'un client.
On va donc pouvoir ensuite combiner avec un handler en settant notre filtre créee :  
/etc/sensu/conf.d/metric_to_file.json
{
	"handlers": {
		"metric_to_file": {
		"type": "pipe",
		"filter": "only_rumpelstiltskin",
		"command": "/etc/sensu/handlers/metric_to_file.sh"
		}
	}
}
la commande ne  sera executée que pour le node matchant dans notre filtre.

- Filtre negatif :
Il est possible de ne pas  executer une action si un flag de filtre particulier est détecté.

Pour reprendre l'exemple précedent on va definir une section specifique pour les nodes differents de notre serveur précedent.
{
	"filters": {
		"only_rumpelstiltskin": {
			"attributes": {
				"client": {
				"name": "rumpelstiltskin"
				}
			}
		}
"all_but_rumpelstiltskin": {
		"negate": true,
			"attributes": {
			"client": {
				"name": "rumpelstiltskin"
				}
			}		
		}
	}
} 

Le nom de notre filtre negatif sera repri dans notre handler : donc ici notre event sera traité pour tous les nodes matchant dans le filtre "all_but_rumpelstiltskin" : donc tous sauf rumpelstiltskin

/etc/sensu/conf.d/metric_to_file.json
{
	"handlers": {
			"metric_to_file": {
				"type": "pipe",
				"filter": "all_but_rumpelstiltskin",
				"command": "/etc/sensu/handlers/metric_to_file.sh"
			}
		}
}

- Filtrage sur les environments :

Il va être tout a fait possible d'ajuster nos handlers à partir de filtre sur l'environment (dev/ staging/ production ..)
exemple ici on a un node qui est flaggé en production : 
/etc/sensu/conf.d/client.json
{
	"client": {
		"subscriptions": [
		"os"
		],
		"address": "203.0.113.2",
		"name": "sensuclient.example.com",
		"environment": "production"
		}
}

on peut donc avoir un filtre qui ne va gérer que les events des nodes en production :

/etc/sensu/conf.d/filters.json
{
	"filters": {
		"only_production": {
		"attributes": {
			"client": {
			"	environment": "production"
					}
			}
		}	
	}
}
on pourra donc utiliser le filtre defini pour le passer à un handler qui ne traitera que les nodes dédiés : 

/etc/sensu/conf.d/metric_to_file.json
{
	"handlers": {
		"metric_to_file": {
			"type": "pipe",
			"filter": "only_production",
			"command": "/etc/sensu/handlers/metric_to_file.sh"
			}
	}
}

Il est tout a fait possible d'utiliser des formes négatives aussi. 
L'idée est de savoir qu'on peut utiliser des attributs defini pour notre client et ensuite adapter les comportements à nos besoins.

- Methode de filtre dans les handlers 
si un handler est une sous classe de sensu-plugin/lib/sensu-handler.rb alors il héritera automatiquement des filtres qui fonctionne avec la fonction filter.
Si un filtre decouvre q'un event ne doit pas être géré alors il executera la fonction bail et finira avec un status de code retour à 0

->filter_disabled :  il n'y a pas de  filtrage si les clés sont settées à ['check']['alert'] key is false
->filter_repeated : exemple ici on ne traitera pas un event s'il apparait trop souvent et qu'il ne doit être traiter q'a la 5eme occurence
->filter_silenced : ici l'event ne sera pas traité si un flag silence a été posé sur le node.
->filter_dependencies : ici nous n'auront pas d'action si un event ko a une dependance avec un autre check  deja ko.
-> utilisation d'un mutator pour bypasser un handler : si un mutator a un code retour different de 0 alors le handler ne s'executera pas.


=== Mutator === 




