== notes sur la section puppet dediée dans le cours intermediate sensu udemy ==

Deux modules puppet officiels existent :
-> sensu
-> uchiwa

Pour la  demo une vm ubuntu fraiche est dediée. Des ressources extra seront potentiellement à consulter dans les sections udemy.
1/ install d'une version recente de puppet

2/ installation de module officiel de rabbitmq 

puppet module install puppetlabs/rabbitmq

La doc du module est consultable sur 
http://forge.puppetlabs.com/puppetlabs/rabbitmq

3/ creation du profile sensu :
on se met dans le logic role / profile /module de puppet : 
on cree une classe et un include : 

vi profile_sensu.pp

class profile_sensu::server { 
  class { 'rabbitmq':   
    }
}
include profile_sensu::server

on lance ensuite un puppet apply sur notre manifest :

puppet apply profile_sensu.pp

on a donc l'install de rabbitmq. On peut verifier dans les process que l'appli est bien lancée (ps fauxw |grep rabbitmq) 

4/ on va maintenant charger redis : on va donc sur la forge puppet et on selectionne les modules parmi ceux qui sont flaggués "approved"
ex : puppet module install arioch-redis

on va rajouter notre module dans notre manifest sans conf supplementaire : 

vi profile_sensu.pp

class profile_sensu::server {
  class { 'rabbitmq':
    }
  class { 'redis':
    }
}
include profile_sensu::server



on relance notre apply pour l'install de redis :

puppet apply profile_sensu.pp
on test l'install avec la cmd :
redis-cli ping
PONG < est repondu c'est don ok

5 / install du module sensu : ce module puppet est géré chez sensu donc aucun pb :

puppet module install sensu-sensu 

on peut avoir un souci d'install en effet rabbitmq/ redis et sensu peuvent avoir en prerequi des versions different de puppetlabs-apt 
on peut forcer qi on connait bien le systeme  l'install sans les soucis de dépendances :

puppet module install sensu-sensu  --ignore-dependencies


on modifie ensuite notre manifest en rajoutant notre module /classe sensu et en prefixant nos classes avec un '::nom_classe' pour être  sur encas de definition multiples de classes portant le même nom qu'il n'y aura pas de souci :

vi profile_sensu.pp

class profile_sensu::server {
  class { '::rabbitmq':
    }
  class { '::redis':
    }
  class { '::sensu':
    }
}
include profile_sensu::server

on va maintenant commencer à configurer notre classe sensu avec des elements de base comme le passwd necessaire à rabbitmq, la conf de l'api et du server : 

vi profile_sensu.pp

class profile_sensu::server {
  class { '::rabbitmq':
    }
  class { '::redis':
    }
  class { '::sensu':
    rabbitmq_password => 'blablabla',
    server => true,
    api    => true,
    }
}
include profile_sensu::server

NB: Le module sensu ne configure que sensu et pas rabbitmq 
Il va donc falloir le faire et donc reproduire les actions manuelles que nous faisons lors de nos install via pupppet :



vi profile_sensu.pp

class profile_sensu::server {
  class { '::rabbitmq':
  rabbimq_user { 'sensu':password =>'blabla' }
  rabbitmq_vhost { 'sensu': ensure => present}
  rabbitmq_user_permissions {'sensu@sensu':
    configure_permission =>'.*', 
    read_permission =>'.*', 
    write_permission =>'.*', 
      }
    }
  class { '::redis':
    }
  class { '::sensu':
    rabbitmq_password => 'blablabla',
    server => true,
    api    => true,
    }
}
include profile_sensu::server

Quand on relance notre run et qu'on examine les logs rabbitmq : la connection est acceptée.


6/ installation de plugin sensu packagé en gem via puppet :

il est possible d'installer des gem avec puppet egalement . Il va faloir par contre connaitre les dependances  et essayer de les gerer avec puppet egalement  :
ex : ici on rajoute un plugin pour gérer l'envoi de mail .on note qu'on configure un sensu_gem comme provider. le packet build-essential est un prerequi qu'on installe également : 

vi profile_sensu.pp

class profile_sensu::server {
  class { '::rabbitmq':
  rabbimq_user { 'sensu':password =>'blabla' }
  rabbitmq_vhost { 'sensu': ensure => present}
  rabbitmq_user_permissions {'sensu@sensu':
    configure_permission =>'.*', 
    read_permission =>'.*', 
    write_permission =>'.*', 
      }
    }
  class { '::redis':
    }
  class { '::sensu':
    rabbitmq_password => 'blablabla',
    server => true,
    api    => true,
    }
    # pre-requi pour l'install de gem pour sensu : 
    packages {'build-essential': ensure => 'installed',}
    packages {'sensu-plugin-mailer': 
      ensure   => 'installed',
      provider => sensu_gem,
    }
}

Apres avoir lancé notre run on voit que c'est ok : on va pouvoir examiner la doc du module car on va devoir gérer la conf de notre serveur et notamment du handler que l'on vient d'installer.
Il va être necessaire de determiner le path complet de la commande notre handler (souvent les commandes sont situées dans : /opt/sensu/embeded/bin/


vi profile_sensu.pp

class profile_sensu::server {
  class { '::rabbitmq':
  rabbimq_user { 'sensu':password =>'blabla' }
  rabbitmq_vhost { 'sensu': ensure => present}
  rabbitmq_user_permissions {'sensu@sensu':
    configure_permission =>'.*', 
    read_permission =>'.*', 
    write_permission =>'.*', 
      }
    }
  class { '::redis':
    }
  class { '::sensu':
    rabbitmq_password => 'blablabla',
    server => true,
    api    => true,
    }
    # pre-requi pour l'install de gem pour sensu : 
    packages {'build-essential': ensure => 'installed',}
    packages {'sensu-plugin-mailer': 
      ensure   => 'installed',
      provider => sensu_gem,
    }
  sensu::handler {'mailer':
    command => '/opt/sensu/embeded/bin/handler-mailer.rb',
    type => 'pipe',
    config => {
      'admin_gui' => "http://admin.exemple.com:8080/",
      'mail_from' => "sensu@exemple.com", 
      'mail_to'   => "monitor@exemple.com",
      'smtp_address' => "smtp.exemple.com",
      'smtp_port' => "25",
      'smtp_domain' => "exemple.com",
    }

include profile_sensu::server

}


7/ on va maintenant s'occuper de configurer et installer des checks en provenance de sensu-plugins: dans un premier temps nous allons les installer sur notre server puis faire une conf dedié sur un client un peu plus tard : puisqu'on sais que globalement les checks sont exlusivemernt executés par les clients  en local :


vi profile_sensu.pp

class profile_sensu::server {
  class { '::rabbitmq':
  rabbimq_user { 'sensu':password =>'blabla' }
  rabbitmq_vhost { 'sensu': ensure => present}
  rabbitmq_user_permissions {'sensu@sensu':
    configure_permission =>'.*', 
    read_permission =>'.*', 
    write_permission =>'.*', 
      }
    }
  class { '::redis':
    }
  class { '::sensu':
    rabbitmq_password => 'blablabla',
    server => true,
    api    => true,
    }
    # pre-requi pour l'install de gem pour sensu : 
    packages {'build-essential': ensure => 'installed',}
    packages {'sensu-plugin-mailer': 
      ensure   => 'installed',
      provider => sensu_gem,
    }
  sensu::handler {'mailer':
    command => '/opt/sensu/embeded/bin/handler-mailer.rb',
    type => 'pipe',
    config => {
      'admin_gui' => "http://admin.exemple.com:8080/",
      'mail_from' => "sensu@exemple.com", 
      'mail_to'   => "monitor@exemple.com",
      'smtp_address' => "smtp.exemple.com",
      'smtp_port' => "25",
      'smtp_domain' => "exemple.com",
    }

  package {'sensu-plugins-disks-checks':
      ensure => 'installed',
      provider => 'sensu_gem',
    }
  
include profile_sensu::server

}


il va falloir maintenant configurer notre server pour qu'il puisse utiliser ces checks : 

on rajoute donc une section sous notre package :

...
  package {'sensu-plugins-disks-checks':
      ensure => 'installed',
      provider => 'sensu_gem',
    }
  sensu::check {'check-disks':
    command => "/optsensu/embedded/bin/check-disk-usage.rb",
   }

on a donc ensuite la creation d'une conf crée dans notre repertoire
on voit que les param par defaut sont settés.


8 / on va  maintenant installer le dashboard frontend de notre sensu-server : 

puppet module install yelp-ushiwa --ignore-dependencies
il est possible d'avoir un pb de config lié à la config du repo : on peut bypasser ce souci en ignorant specifiquement cette conf puisque le repo est installé avec notre server-sensu :

  class {'ushiwa':
    install_repo => false,
    sensu_api_endpoints  => [
      {'hosts' => '127.0.0.1', }
    ] 
  }




9/ on va maintenant modifier notre conf : on a tout ce qu'il faut pour faire tourner notre serveur mais on va définir une classe pour notre client et une meta classe comme point d'entrées :


  profile_sensu::client {}
  profile sensu (
    $server => false,
  ) {
}

on va donc rassembler dans notre classes les differents élements liés au client ( check ..) afin de modulariser notre profile :



vi profile_sensu.pp

class profile_sensu::server {
  class { '::rabbitmq':
  rabbimq_user { 'sensu':password =>'blabla' }
  rabbitmq_vhost { 'sensu': ensure => present}
  rabbitmq_user_permissions {'sensu@sensu':
    configure_permission =>'.*', 
    read_permission =>'.*', 
    write_permission =>'.*', 
      }
    }
  class { '::redis':
    }
  class { '::sensu':
    rabbitmq_password => 'blablabla',
    server => true,
    api    => true,
    }
    # pre-requi pour l'install de gem pour sensu : 
    packages {'build-essential': ensure => 'installed',}
    packages {'sensu-plugin-mailer': 
      ensure   => 'installed',
      provider => sensu_gem,
    }
  sensu::handler {'mailer':
    command => '/opt/sensu/embeded/bin/handler-mailer.rb',
    type => 'pipe',
    config => {
      'admin_gui' => "http://admin.exemple.com:8080/",
      'mail_from' => "sensu@exemple.com", 
      'mail_to'   => "monitor@exemple.com",
      'smtp_address' => "smtp.exemple.com",
      'smtp_port' => "25",
      'smtp_domain' => "exemple.com",
    }

    sensu::check {'check-disks':
      command => "/optsensu/embedded/bin/check-disk-usage.rb",
     }

  class {'ushiwa':
    install_repo => false,
    sensu_api_endpoints  => [
      {'hosts' => '127.0.0.1', }
    ] 
  }

include profile_sensu::server

Une des difficultés va être de creeer une classe partagée : "shared" classe car on ne peut pas declarer deux fois la même classe dans un manifest :

ATTENTION BRONX ===

 
vi profile_sensu.pp

class profile_sensu::server {
  class { '::rabbitmq':
  rabbimq_user { 'sensu':password =>'blabla' }
  rabbitmq_vhost { 'sensu': ensure => present}
  rabbitmq_user_permissions {'sensu@sensu':
    configure_permission =>'.*', 
    read_permission =>'.*', 
    write_permission =>'.*', 
      }
    }
  class { '::redis':
    }

  
   # meta classe : 

  class profile_sensu { 
     $server => false,
  ) {

  class { '::sensu':
    rabbitmq_password => 'blablabla',
    server => $server <<<<<  ici on set une variable qui est donc un booleen voir plus loin 
    api    => $server 
    }
    # pre-requi pour l'install de gem pour sensu : 
    packages {'build-essential': ensure => 'installed',}
    packages {'sensu-plugin-mailer': 
      ensure   => 'installed',
      provider => sensu_gem,
    }


  class {'ushiwa':
    install_repo => false,
    sensu_api_endpoints  => [
      {'hosts' => '127.0.0.1', }

    ] 
  sensu::handler {'mailer':
    command => '/opt/sensu/embeded/bin/handler-mailer.rb',
    type => 'pipe',
    config => {
      'admin_gui' => "http://admin.exemple.com:8080/",
      'mail_from' => "sensu@exemple.com", 
      'mail_to'   => "monitor@exemple.com",
      'smtp_address' => "smtp.exemple.com",
      'smtp_port' => "25",
      'smtp_domain' => "exemple.com",
    }

    sensu::check {'check-disks':
      command => "/optsensu/embedded/bin/check-disk-usage.rb",
     }

  }


ATTENTION BRONX ===


Avec sensu et puppet on va donc pouvoir si on veut installer directements la partie monitoring en fonction de notre appli :
ex si on installe apache, on va dans notre manifest installer les checks apache en même temps : il est evident que dans ce cas nous ne pourrons plus oublierd'associer le monitoring lors du deploiement de machinnes : puisque cela sera fait automatiquement :

ex : ici sette un profile_webserver dans lequel on va installer apache et les checks http associés.

class profile_webserver (
    $port = 80,
	)  {

    class { 'apache' :
	listen_on =>$port,
    }
    package {'sensu-plugins-http-checks':
      ensure => 'installed',
      provider => 'sensu_gem',
    }
    sensu::check {'check-apache':
     command => "/opt/sensu/embedded/bin/check-http.rb --port ${port} --host localhost",
    }
}
  



=== tuning checks ==


la doc de sensu est exellente et on va pouvoir examiner en détail les differents attributs.
Le "language" de sensu est extremement flexible et on va pouvoir ajouter des clé /valeurs personnalisés.

On a des attributs importants 
-> occurence : nbr de fois à partir duquel on aura l'alerte sera levé 
ex : "occurence" 1 : l'alerte sera levée dans le premier check en echec.
-> refresh : est une duree en seconde ( par defaut 1800 / 30mnts) : delai à partir duquel le handler va faire une action.Ex si on a un check qui fail , le handler email enverra une alerte toutes les 30 minutes. Ce setting est totalement independant de l'attribut occurence.
-> dependencies : va nous permettre de gerer le comportement de nos handlers et par exemple un handler ne sera pas activé si une alerte concernant un autre check est deja levée.Les blocs sont assez simples à definir : 
ex 
"dependencies" [
    "check-app",
    "db1/check-mysql"
]        

Nous pouvons  aussi faire des "custom checks attributes" :

{
  "checks": {
    "check_mysql_replication": {
      "command": "check-replication-mysql.rb --user sensu --password secret",
      "subscribers": [ "mysql" ],
      "interval": 5,
      'playbook': 'http://doc.exemple/plabook'   <<<< ici on definit un arrtibut "playbook" qui n'existe nulle part dans la doc sensu.
      }
   }
}

sensu va ignorer cet attribut mais le passer au handler.
L'information de cet attibut apparait dans l'event data et le handler lui va pouvoir faire une action si besoin.
dans cet exemple on voit en examinant le code du handler-email que si l'attibut playbook est setté alors le corps du mail contiendra la valeur de la clé "playbook" dans le corps du mail.

https://github.com/sensu-plugins/sensu-plugins-mailer :

    playbook = "Playbook:  #{@event['check']['playbook']}" if @event['check']['playbook']
    body = <<-BODY.gsub(/^\s+/, '')
            #{output}
            Admin GUI: #{admin_gui}
            Host: #{@event['client']['name']}
            Timestamp: #{Time.at(@event['check']['issued'])}
            Address:  #{@event['client']['address']}
            Check Name:  #{@event['check']['name']}
            Command:  #{command}
            Status:  #{status_to_string}
            Occurrences:  #{@event['occurrences']}
            #{playbook}

== Deploiment de checks & handlers ==
il est possible de deployer des handlers que l'on trouve sur le site de sensu mais également de trouver et deployer des  packets fournis sous forme de gem ( ex le handler sensu-plugins-mailer) on a donc du code ruby packagé qui gere les dépendances. : on va donc pouvoir en utilisant cette methode : pinneuServer:~$ /opt/sensu/embedded/bin/gem install sensu-plugins-mailer 
" 
pour installer un gem : 
ubuntu@SensuServer:~$ /opt/sensu/embedded/bin/gem install sensu-plugins-mailer 

Dans le cas présent on est absolument sur d'utiliser l'infra ruby completement dediée à sensu puisqu'on utilise le binaire gem embarqué  à sensu  

on peut lister les gems présents sur notre serveur : 

ubuntu@SensuServer:~$ /opt/sensu/embedded/bin/gem list |head -n2
activesupport (4.2.5)
amq-protocol (2.0.1)


On peut examiner le contenu d'un gem : 

ubuntu@SensuServer:~$ /opt/sensu/embedded/bin/gem content sensu-extensions-json
/opt/sensu/embedded/lib/ruby/gems/2.4.0/gems/sensu-extensions-json-1.0.0/CHANGELOG.md
/opt/sensu/embedded/lib/ruby/gems/2.4.0/gems/sensu-extensions-json-1.0.0/LICENSE
/opt/sensu/embedded/lib/ruby/gems/2.4.0/gems/sensu-extensions-json-1.0.0/README.md
/opt/sensu/embedded/lib/ruby/gems/2.4.0/gems/sensu-extensions-json-1.0.0/lib/sensu/extensions/json.rb


on peut examiner les scripts de nos gem :

ex :

ubuntu@SensuServer:~$ ls /opt/sensu/embedded/lib/ruby/gems/2.4.0/gems/amqp-1.6.0/bin/ -l
total 20
drwxr-xr-x 2 root root 4096 Apr 28 13:17 ci
-rwxr-xr-x 1 root root  982 Apr  6 22:30 cleanify.rb
-rwxr-xr-x 1 root root   40 Apr  6 22:30 docup
-rwxr-xr-x 1 root root  150 Apr  6 22:30 irb
-rwxr-xr-x 1 root root  651 Apr  6 22:30 set_test_suite_realms_up.sh


head /opt/sensu/embedded/lib/ruby/gems/2.4.0/gems/amqp-1.6.0/bin/cleanify.rb
#!/usr/bin/env ruby -i
# encoding: utf-8

# Usage:
# find . | egrep '\.rb$' | egrep -v cleanify.rb | xargs ./bin/cleanify.rb

# \n at the end of the file
# def foo a, b, &block
# no trailing whitespace
# encoding declaration

ENCODING = "utf-8"
....

 Si on essaye de lancer le script : il s'executera dans la version ruby de l'nev installé sur notre système :
ubuntu@SensuServer:/opt/sensu/embedded/lib/ruby/gems/2.4.0/gems/amqp-1.6.0/bin$ ruby --version
ruby 2.3.1p112 (2016-04-26) [x86_64-linux-gnu]

et donc on aura une diff avec la version embarquée de sensu.

Certains scripts ruby dédié à sensu ont dans leur shebang la path du ruby de sensu embarqué :

ubuntu@SensuServer:/opt/sensu/embedded/bin$ head check-socat.rb 
#!/opt/sensu/embedded/bin/ruby
#
# This file was generated by RubyGems.
#
# The application 'sensu-plugins-network-checks' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require 'rubygems'


=== creation de checks personalisés ===
l'écriture de scripts est tres simple : les codes retours sont essentiels et "classiques" :
-> 0 pour ok
-> 1 pour warning 
-> 2 pour critical
-> 3 pour quelque chose d'autres (unknown)

Un jour on devra forcement créer une sonde qui n'existe pas .
Exemple de test d'existence de fichier :

#!/bin/bash


function assert () {
    if [[ $1 -eq $2 ]]; then
		echo "pass"
	else 
		echo "fail. expected $2 but got $1 "
    fi
}

touch test_file
./check_test_files_exist test_file
assert $? 0 

rm test_file
./check_test_files_exist test_file
assert $? 2 

cat test_files_exist 

#!/bin/bash

if [[ $1 -eq ]]; then 
	echo "ok file $1 exists and is a normal file "
	exit 0
else 
	echo "pb $1 is not a file or doesnt exists"
	exit 2
fi 	


Il peut être tres simple d'utiliser un language avec des builtsin integrés : comme ruby qui lui est forcement installé et déployer sur les systemes monitorés par sensu.

lab/temp_fold>> cat check_file_exists.rb 
#!/opt/sensu/embedded/bin/ruby

require 'sensu-plugin/check/cli'

  class  CheckFileExists < Sensu::Plugin::Check::CLI

	def run 
	filename = argv[0]  ### ici on assure que notre code prend le premier argument.
	if File.exists?(filename)
	  ok "file '#{filename}' exists!"
	else
	  critical "file '#{filename}' does not exists! "
	end
  end
end

On, va pouvoir pour tester gérer lma creation d'un test inverse : 2 si le fichier existe et 0 s'il n'existe pas .

On va pouvoir alimenter notre script ruby d'une nouvelle section qui nous permettra cette gestion 


=== A completer ===

#!/opt/sensu/embedded/bin/ruby

require 'sensu-plugin/check/cli'

  option :'inverse,
    :long => "--inverse",
    :description => "Return ok if the file does not exists and critical if it exists",
    :boolean => true  


  class  CheckFileExists < Sensu::Plugin::Check::CLI

	def run 
	filename = argv[0]  ### ici on assure que notre code prend le premier argument.
	if File.exists?(filename)
	  ok "file '#{filename}' exists!"
	else
	  critical "file '#{filename}' does not exists! "
	end
  end
end



```ruby
    if File.exists?(filename)
      if not config[:inverse]
        ok "File '#{filename}' exists!"
      else
        critical "File '#{filename}'exists!"
      end
    else
      if not config[:inverse]
        critical "File '#{filename}' doesn't exist!"
      else
        ok "File '#{filename}' doesn't exist!"
      end
    end
```



=== A completer ===



== Handlers personalisés ==

Il est possible de creer des handlers dans n'importe quel language mais il est plus pratique de le faire en ruby pour gérer les methodes natives à sensu.

Un des handlers les plus simple est show.rb 

exemple : 

#!/opt/sensu/embedded/bin/ruby  # on part du principe qu'on utilise la version ruby installée 
require 'sensu-handler'  # ici on suppose que le gem sensu-handler est installé.

class Show < Sensu::Handler
  def handle
    puts 'Settings: ' + settings.to_hash.inspect
    puts 'Event: ' + @event.inspect
  end
end


 steal some example [event data](https://sensuapp.org/docs/latest/events#sensu-event-data)
from the official sensu documentation page.

    cat > test-data.json
    ...

Une fois crées on va donc rediriger le fichier d'event json vers le handler qui se contente d'afficher les "Settings" & "Event" de notre fichier grâce aux methodes decrites dans notre handler.

    cat test-data.json | ./handler.rb

== a completer ==

On va maintenant créer un handler qui va notifier notre phone sous android .
Un project existe, il est assez simple à utiliser.
https://notifymyandroid.com

on va pouvoir recupérer le gem du project 

https://github.com/slashk/ruby-notify-my-android#usage-as-a-gem


/opt/sensu/embedded/bin/gem install ruby-notify-my-android

on va donc copier le contenu de la partie usage dans notre handler :


cat notify_my_android_handler.rb 
#!/opt/sensu/embedded/bin/ruby
require 'sensu-handler'
require 'ruby-notify-my-android'

class Show < Sensu::Handler

  def handle
    NMA.notify do |n|
      n.apikey = "9d1538ab7b52360e906e0e766f34501b69edde92fe3409e9"
      n.priority = NMA::Priority::MODERATE
      n.application = "NMA"
      n.event = "Notification"
      n.description = "Your server is under attack!!!"
    end
  end

on va donc ensuite tester la redirection de notre json vers le handler :

cat test-data.json | ./notify_my_android_handler.rb et on a un resultat probant.

On va maintenant améliorer le handler :
tout d'abord on va creer un fichier de conf contenant notre clé d'api pour que ce soit plus safe ( pas besoin d'afficher ses infos sans protection) 

cat > /etc/sensu/conf.d/notify_my_android.json
{
  "notify_my_android": {
    "api_key": "abc123"
  }
}
on va ensuite modifier notre handler pour qu'il puisse recupérer les valeurs de notre clé d'api au sein du fichier nouvellement crée :
on va de plus modifier le nom de notre application en passant de NMA a sensu 
on va aussi remplacer le keyword Notfication par le nom du server et du check en erreur 
on va finalement modifier la description en utilisant les methodes fournies dans le gem sensu-handler cf dans le sensu-handler.rb : def event_summary(trim=100) : on va recupérer le nom de l'event et pouvoir afficher jusqu'a 100 caracteres pour decrire ce qu'il se passe :afin d'avoir un bon resumé de ce qu'il se passe.





cat notify_my_android_handler.rb 
#!/opt/sensu/embedded/bin/ruby
require 'sensu-handler'
require 'ruby-notify-my-android'

class NotifyMyAndroid < Sensu::Handler

  def handle
    NMA.notify do |n|
      n.apikey = settings["notify_my_android"]["api_key"]    <<<< ici on créee l'appel  à la valeur de la clé "api-key" du fichier notify_my_android.json avec la "variable" settings  qui est dédiée à la recupération des infos. 
      n.priority = NMA::Priority::MODERATE
      n.application = "sensu" # avant on avait  "NMA"
      n.event = @event['client']['name'] + '/' + @event['check']['name'] <<<<  avant on avait "Notification" : dans le contexte du handler on recupere les données via '@event' 
      n.description = event_sumary  <<<< on avait ici une description manuelle unique maintenant c'est un resumé de l'event. 
    end
  end


on va maintenant afin de pouvoir agit précisement en cas de probleme rajouter un mode debug 
On va enregitrer la reponse de notre handler , puis l'afficher : on va enregistrer la reponse ( reponse = NMA.notify do |n| puis l'afficher puts response.inspect


```ruby
  def handle
    response = NMA.notify do |n|
      n.apikey = settings["notify_my_android"]["api_key"]
      n.priority = NMA::Priority::MODERATE
      n.application = "Sensu"
      n.event = @event['client']['name'] + '/' + @event['check']['name']
      n.description = event_summary
    end
   puts response.inspect
  end
```
on test et on voit l'affichage de notre sortie : 
    cat event-data.json | ./notify_my_android.rb


On peut donc assez simplement utiliser des methodes , fonctions internes a sensu, aux gems ou a du code ruby que l'on peut mixer pour definir répondre à nos besoins.

==== Sensu omnibus package === 
come on l'a vu sensu est livré de base avec son ruby et gem embarqués.
Tout est donc parfaitement isolé du ruby du systeme .
on peut s'assurer que c'est bien le ruby interne qui est utilisé dans sensu en settant à true la variable dans  le fichier /etc/defalut/sensu 

vim /etc/default/sensu
`EMBEDDED_RUBY=true` 

Cela garant ique le ruby de sensu est setté en premier dans le path et qu'il sera donc utiliser en premier lorsqu'on aura besoin d'executer du ruby sur la machine.
Certains gem à l'install vont examiner le path de ruby et donc installer dans le bon path les differents.
Il est sinon possible de hard coder le path de sensu dans le shebang des scripts ruby.

On peut aussi invoquer directement notre code ruby avec l'interpreteur ruby de sensu :

/opt/sensu/embedded/bin/ruby my-script.rb

nous n'aurons dans ce cas pas de pb.


