### Ipython###

interpreteur python multifonction permettant une haute configuration .

- on peut utiliser l'historique des appels
- on peut completer avec "tab" les fonctions d'un module


# Interraction avec Ipython :

- on a un comportement d'affichage different  pour la sortie écran d'une variable et pour l'évaluation et l'interpretation de la variable . Ex :
In [1]: a=1

In [2]: b=2

In [3]: print(a)
1

In [4]: print(b)
2

In [5]: a
Out[5]: 1

In [6]: b
Out[6]: 2

On voit ici que la sortie est simple quand on affiche la valeur de la variable a et b . Quand on appelle directement la variable : on l'interprete et donc on a un code de sortie "[Out]" : ce système est très pratique pour le debug. 
Dans un shell classique on a pas cette notion.
L'affichage avec "print" utilise la version "unofficial"de la représentation des chaines de caractères tandis que l'appel direct de la variable permet l'affichage "official" de cette representation de chaine de caracteres.

Cette distinction est bien plus importante quand on utilise nos propres classes que quand on utilise les "builts in".  Ex :

In [8]: class DoubleRep(object):
   ...:     def __str__(self):
   ...:         return "Hi, I'm a __str__"
   ...:     def __repr__(self):
   ...:         return "Hi, I'm a __repr__"
   ...:     

In [9]: dr = DoubleRep()

In [10]: print dr
Hi, I'm a __str__

In [11]: dr
Out[11]: Hi, I'm a __repr__

On a defini une classe comportant deux methodes (ces deux methodes existent dans le builtin de python cf help(str) et help(repr) : une __str__ et une __repr__ pour montrer la difference entre l'affichage d'un objet et la representation "officielle" de cet objet.
La methode __str__ sur un objet sera appellée quand la representation "unofficial" sera nécéssaire.
La méthode __rep__ sur un objet sera elle appellée quand on aura besoin de la methode officielle.

Après avoir instancié notre objet DoubleRep et assigné sa valeur à la variable dr ; on affiche la valeur de dr et la méthode __str__ est appellée. On rentre juste le nom de notre variable par la suite et là c'est la méthode __rep__ qui est appellée.

Dans python en général __str__ est appellée a chaque fois que l'on fait un appel str(obj) sur un objet ou quand on utilise une représentation formattée de type "%s" % obj
__rep__ est appellée quand on utilise la forme rep(obj) ou la représentation "%r" % obj


On peut dans Ipython recupérer les infos d'entrées et de sorties :


object?   -> Details about 'object', use 'object??' for extra details.

In [1]: a=1

In [2]: b="lapin"

In [3]: print In
['', u'a=1', u'b="lapin"', u'print In']

In [4]: a
Out[4]: 1

In [5]: b
Out[5]: 'lapin'

In [6]: print Out
{4: 1, 5: 'lapin'}

Si ce qui est saisi dans l'interpreteur ipython est evalué à quelque chose différent de None alors il est affiché dans le promt [Out]

Ces differences entre l'affichage du shell python et de ipython ne sont pas que cosmétiques et font de ipython un "shell" beaucoup plus avancé que le shell python standart.

Deux built-in sont utilisées : pour In on a une liste et pour Out on a un dctionnaire :

In [8]: type(In)
Out[8]: list

In [9]: type(Out)
Out[9]: dict


In [11]: print(In)
['', u'main', u'help(main)', u'help', u'help()', u"get_ipython().magic(u'clear ')", u'help(str)', u'help(repr)', u'type(In)', u'type(Out)', u'print(in)', u'print(In)']

In [12]: print(Out)
{8: <type 'list'>, 9: <type 'dict'>, 3: Type help() for interactive help, or help(object) for help about object.}


On voit ici le recapitulatif des appels à In et Out qui n'ont pas été évalués à None par l'interpreteur.



# Completion avec tab :

Le shell classique python peut avoir la completion si il a été activé avec le module realine mais il faut egalement saisir dans le shell :

>>> import rlcompleter, readline
>>> readline.parse_and_bind('tab: complete')

On peut ensuite avoir la completion auto activée Ex :
>>> import os
>>> os.<TAB> : nous sort toutes les fonctions disponibles du module.

Dans Ipython la feature est de base et on peut en plus compléter sur le nom du module :

In [6]: import o
octavemagic  opcode       operator     optparse     os           os2emxpath   ossaudiodev  


# "Magic Edit" :
L'edition "magic" de ipython permet d'avoir à la fois un shell interractif et un éditeur de texte puissant : c'est un compromis qui peut être très performant.

# Configuration de Ipython :
Au premier lancement de ipython , si on a pas défini de "path" particulier : un répertoire ".ipython" a été crée dans le $HOMEDIR de notre user.
Toute la config et la personnalisation de notre éditeur ipython se fait dans ce repertoire.

# "Help" with "Magic functions" :
 




