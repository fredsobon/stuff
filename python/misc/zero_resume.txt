==== short resume python : zero ====



= if / else =

#!/usr/bin/env python3
#-*-coding: utf8 -*-
import os 


b = input("gimme a year : ")

print("ok you gave me " + str(b))
year = int(b)


if year % 4 == 0 or year % 400 == 0:
    print("you got it!")
else:
    year % 100 == 0
    print("nop")


= while =

#!/usr/bin/env python3
#-*-coding: utf8 -*-

multi = 7
digit = 0

while digit < 11:
    print(digit * multi )
    digit += 1



= for = 

#!/usr/bin/env python3
#-*-coding: utf8 -*-

word = "ragoutoutou"

for w in word:
    if w in "aeiouy":
        print("hey yougot voyel :" + w)
    else:
        print("secret char: ###")

= input / raw_input =

#!/usr/bin/env python
# -*- coding: utf8 -*-

nom=raw_input("hello, what's yo name ? ")
print("hugh ..." + nom)
raw_input("press please the touche entrée ...")



= break = 

#!/usr/bin/env python3
#-*-coding: utf8 -*-

while True:
    a = input("gimme the secret to quit :" )
    print("you gave me " + a)
    if a  in "qQ":
        print("ok bye")
        break
    else:
        print("try again")

= list = 

#!/usr/bin/env python
# -*- coding: utf8 -*-


# On defini une variable.
name="maggie"

# on commence à compter à partir de 0 : omer=0 marge=3 . On peut creeer une liste vide []. On peut melanger les types.
lst=["omer", "bart" , "lisa" , "marge"]

print(lst[2])

# va afficher lisa
# pour un intervalle on inclu la première borne et on exclu la dernière : lst[1:3]

print(lst[1:3])

# va afficher ['bart', 'lisa']

#print(lst[:2])  : on affiche tout jusqu'à 2 exclu
#print(lst[:]) : on affiche tous les elements. on peut définir une nouvelle liste qui sera une copie de notre liste:
liste2=lst[:]

#python considere le texte comme une liste de lettres :
print("texte"[1:3]) 

# on va voir qu'on peut modifier une liste. Ici on copie notre liste . On affecte la valeur de la variable name à l'element 2 de notre liste : 
simpson=lst

lst[2]=name

print(lst)

# on a donc dans la liste lst et simpson les valeurs :["omer", "bart" , "maggie" , "marge"] .Simpson est un alias de lst

# Si on affiche liste2 : elle n'aura pas changée : ["omer", "bart" , "lisa" , "marge"] . 

# il faut faire attention au copies.

# boucle for

for elem in lst:
    print("hello , in the loop")
    print elem

#hello , in the loop
#omer
#hello , in the loop
#bart
#hello , in the loop
#maggie
#hello , in the loop
#marge

#!/usr/bin/env python3
#-*-coding: utf8 -*-

i = 1
while i < 10:
    if i % 2 == 0:
        print("hey even number ... " + str(i))
        i += 1
        continue
    print("odd one : " + str(i))
    i += 3

= type /methodes =

#!/usr/bin/env python
# -*- coding: utf8 -*-

# int() ; raw_input() ; str() ... : une fonction retourne une donnée. var=fonction(truc)  print var. 
# le retour de la fonction est different en fonction de ce sur quoi elle s'applique.Exemple différence entre le len("mot") len("lapin"," "lulu") : on a d'un coté le nombre de lettre du mot et dans l'autre exemple le nombre d'élement de la liste .

print(len("monty"))
print(len(["lapin", "lulu"]))


print(range(5))
compte=3

for x in range(compte):
    print("hip")


#[0, 1, 2, 3, 4]
#hip
#hip
#hip
#

# Une methode est attachée au type . Pour appeller une fonction , on tape son nom et entre parenthese ses params: fonction(param) Pour invoquer /appeller une methode , on saisi le nom_var.nom_methode(param) . 
# On voit ici clairement les methodes associées au type str . La methode upper met tout en maj , la methode capitalize met 'initale en maj , la methode title met toutes les premieres lettres en maj ( utiles pour nom composés) :
nom="napoleon"
print(nom.upper())
print(nom.capitalize())

name="Louis-philipPE"
print(name.title())

# on peut nettoyer le code ; les entrees des users : exemple supprimer des espaces en trop avec strip :

a="          ..blabla avec plein d'espaces au debut et à la fin....       "
print(a)

print(a.strip())

#nous affiche dans un premier temps          ..blabla avec plein d'espaces au debut et à la fin....       puis clean des espaces :
#..blabla avec plein d'espaces au debut et à la fin....


#On peut transformer du texte en liste en utilisant un separateur :
b="lapin,lulu,lili"
print(b)
print(b.split(","))

# nous affiche bien les mots , puis une liste dont le sep est la ","
#lapin,lulu,lili
#['lapin', 'lulu', 'lili']



= fonction = 

#!/usr/bin/env python3
#-*-coding: utf8 -*-

def fonction(nb , max = 10):
    """ fonction affichant la table de multiplication de n par multi jusqu'à la valeur max. Ici on defini la valeur par defaut de max à 10: si le user ne saisi pas de param 'max'"""
    i = 1
    while i < max:
        print("hey let's count : ", i * nb)
        i +=1
    return 
        
#fonction(2, 11)
fonction(4)



help(fonction)


= lambda = 

#!/usr/bin/env python3
#-*-coding: utf8 -*-

f = lambda x: x * x

print(f(5))
  

= modules = 
    
#!/usr/bin/env python3
#-*-coding: utf8 -*-

import math
import math as matos
from math import fabs

print("""3 methodes d'import de modules : import module + import module as mod + from module import fonc""")


print(math.sqrt(5))
print(matos.sqrt(4))
print(fabs(-3))


#!/usr/bin/env python3
#-*- coding: utf8 -*-

import os 

year = input("gimme a year : ")
year = int(year)

if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):
    print("year is bissextile !")
else:
    print(year , "classic year")



os.system("date")
print("here's the content of tmp folder : " )
os.system("ls -lh /tmp")

 
#!/usr/bin/env python3
#-*- coding: utf8 -*-


import os

"""module multipli contenant la fonction table"""

def table (nb, max =10):
    """Fonction affichant la table de multiplication par nb de 1 * nb jusqu'à max nb """
    i = 0
    while i < max:
        print(i + 1, "*" ,nb, "=", (i + 1) * nb)
        i +=1
# on a un moyen de pouvoir tester la validité de notre fonction en utilisant la méthode suivante : tester la fonction en lancant le script lui-même permet de setter  les variables python  '__name__' et '__main__' et donc invoquer notre fonction directement au sein du script . Si l'appel est externe alors le test __name__ == "__main__" n'est pas vrai donc pas de suite. Cette méthode est TRES utilisée.

if __name__ == "__main__":
    table(5)
    os.system("date +%F")



#!/usr/bin/env python3
# -*- coding: utf8 -*-

import os 

from dix_10_multipli import *

# test de la fonction table

table(3,20)
os.system("sleep 2")
#!/usr/bin/env python3
#-*- coding: utf8 -*-

"""module multipli contenant la fonction table"""


import os

def table (nb, max =10):
    """Fonction affichant la table de multiplication par nb de 1 * nb jasqu'à max nb """
    i = 0
    while i < max:
        print(i + 1, "*" ,nb, "=", (i + 1) * nb)
        i +=1

# test de la fonction table 

if __name__ == "__main__":
    table(5)
    os.system("date +%F")



= exeption : try /except = 

#!/usr/bin/env python3
# -*- coding: utf8 -*-

import os

annee = input("hey gimme me a number plz :")

# on essaye de convertir en entier la chaine retournée par le user 
try:
    annee = int(annee) 
# si la conversion n'est pas possible ( aka si le code retour de l'instruction n'est pas ok alors on agit differement  
except:
    print("hey no way ! a number do you understand ?")

#!/usr/bin/env python3
#-*- coding: utf8 -*-

# var pour le try :
#a = 6
#b = 3

# var pour exception NameError :
##a =  
#b = 2

# var pour exception TypeError :
#a = 4
#b = "t"

# var pour exception ZeroDivisionError :
#a = 5
#b = 0


try:
    result = a / b
    print("good game ! here's the result :", result)

# on defini maintenant quelques exceptions en fonctions des valeurs saisies et du resultat 

# ici souci : a ou b ne sont pas définis : NameError
except NameError:
    print("nop there's a pb . did you give a number for the the two letter ?")

# ici : une des deux variables contient autre chose qu'un nombre
except TypeError:
    print("do you remember that a number should only contain numbers ?")

# ici on essaye de diviser par zero : l'exception dediée est levée.
except ZeroDivisionError:
    print("no way ..0 can be record for divisor")    
#!/usr/bin/env python3
#-*- coding: utf8 -*-

# var pour le try :
#a = 6
#b = 3

# var pour exception NameError :
##a =  
#b = 2

# var pour exception TypeError :
#a = 4
#b = "t"

# var pour exception ZeroDivisionError :
#a = 5
#b = 0


try:
    result = a / b
    print("good game ! here's the result :", result)

# on defini maintenant quelques exceptions en fonctions des valeurs saisies et du resultat 

# ici souci : a ou b ne sont pas définis : NameError
except NameError as pb_def :
    print("nop there's a pb . did you give a number for the the two letter ?", pb_def)

# ici : une des deux variables contient autre chose qu'un nombre
except TypeError as pb_type:
    print("do you remember that a number should only contain numbers ?", pb_type)

# ici on essaye de diviser par zero : l'exception dediée est levée.
except ZeroDivisionError as pb_zero:
    print("no way ..0 can be record for divisor", pb_zero)    



= finally =


#!/usr/bin/env python3
#-*- coding: utf8 -*-


import os

# var pour le try :
#a = 6
#b = 3

# var pour exception NameError :
##a =  
#b = 2

# var pour exception TypeError :
#a = 4
#b = "t"

# var pour exception ZeroDivisionError :
#a = 5
#b = 0

# ici on ne fait que l'opération dans le try :
try:
    result = a / b

# on defini maintenant quelques exceptions en fonctions des valeurs saisies et du resultat 

# ici souci : a ou b ne sont pas définis : NameError
except NameError as pb_def :
    print("nop there's a pb . did you give a number for the the two letter ?", pb_def)

# ici : une des deux variables contient autre chose qu'un nombre
except TypeError as pb_type:
    print("do you remember that a number should only contain numbers ?", pb_type)

# ici on essaye de diviser par zero : l'exception dediée est levée.
except ZeroDivisionError as pb_zero:
    print("no way ..0 can be record for divisor", pb_zero)    
# on pose un else qui va affcicher le resultat de l'opération  on dissocie cette instruction du try : c'est plus "propre" 
else:
    print("good game ! here's the result :", result)

# ici on execute une commande quel que soit le resultat du try et des excepts, else . Le bloc après finally sera donc toujours executé même si des erreurs ou des codes retour de fonctions apparaissent avant dans  notre  programme:

finally:
    os.system("date +%F-%H-%M")


= pass =

#!/usr/bin/env python3
#-*- coding: utf8 -*-


import os

# var pour le try :
#a = 6
#b = 3

# var pour exception NameError :
##a =  
#b = 2

# ici on ne fait que l'opération dans le try :
try:
    result = a / b


# ici on rajoute "pass" : on peut l'utiliser quand on veut tester un bloc mais ne rien faire si on rencontre une erreur. On ne peut pas le faire avec un try seul ..il faut donc rajouter pass qui ne fait rien même en cas d'exception rencontrées ( pas vraiment d'interet mais il est bon de savoir que ce mot clé existe. on peut l'avoir dans des fonctions qu'on veut vides , conditions etc ...

except: 
    pass



= assert = 
 

#!/usr/bin/env python3
#-*- coding: utf8 -*-

year = input("gimme a year upper than 0 :")

try:
    year = int(year)
    assert year > 0
except ValueError as number_plz:
    print("hey wake up !" , number_plz)
except AssertionError:
    print("did you read ?")
#!/usr/bin/env python3
#-*- coding: utf8 -*-

year = input("gimme a year upper than 0 :")

try:
    year = int(year)
    if year <= 0:
        raise ValueError("yop ..upper than 0 plz !")
except TypeError:
    print("no way ! ")




