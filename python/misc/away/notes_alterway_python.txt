# Notes jour 1 

presentation :
formateur : 11 ans de pratique 
gilles.lenfant@alterways.fr



- fichiers pdf + exemples + annonces : exos à faire pendant les quatre jours;

1/ debut :

python semi compilé comparer à perl, javascript, node js

Base de prog aux us, norvege : python

objetc multivalué , outils standartd ( debug)


Language semi compilé :

language interpreté : chaque ligne est interpreté et executée ligne apres l'autre
langage compilé : code source transformer en language machine + source machien


semi compilé : byte code fabrique : structure binaire en mémoire.

language 100% objet
heritage multiple : 
on peut hériter par exemple un type de fichier et creer un nouveau fichier exif par exemple qui aura des nouvelles particulatités.

multithreading : parallelisme d'actions

support exeption : ex si on veut acceder a un fichier auquel on a pas les droits on peut fixer des valeurs par defaut 

typage dynamique :

language reflectif : capacite d'introspection du language
ex : une ligne de python ~= 2 lignes java.

on a plein de domaine d'aplication ( page 10 )
application kivy pour faire des apps mobiles 

on peut utiliser python pour faire des macros en python dans libre office.


A / pypi : 
depot officiel de tout ce qui exister en python



Version 2 : version finale mais plus complete 
version 3 : plus simple 

Python 2 en session de cours.
Les differences majeures sont récupérer en 1 journée d'adaptation


on utilise le point pour 

>>> l=[1]
>>> l.append(6)
>>> l
[1, 6]
>>> l[0]
1
>>> print 1, l, "coucou"
1 [1, 6] coucou


>>> dir(l)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']


Installation de pip :

universel permet de gerer les installations python et les dependances

sudo pip install ipython

installation d'un ide on utilise pysharm

on download la community edition  et conf 

Les commentaires : #
# -*- coding: utf-8 -*-


les commentaires doctsring sont retrouve dans le code 
le # est introuvable dans le bytecode

identation de 4 espaces pas de tabulation

identificateur python : case sensitive

une constante est en maj : UNE_MAJ
une fonction / classe une methode : camelCase

python language fort 


tout dans python se fait par echange de reference.
page 41 

on peut quand meme faire des copies d'objets

le mot cle assert : vrifie une expression : il faut que ce cala soit vrai sinon on bloque tout.

tout est objet

Type standart  



caracteres 

Chaine d'encodage obligatoire en tout debut de ligne 
# -*- coding: utf-8 -*- 


Tous les caracteres speciaux sont prefixes par un \ 


on peut rajouter un r pour chaine brutes :


lecture imperative :


https://www.jetbrains.com/pycharm/download/download_thanks.jsp?edition=comm&os=linux
https://docs.python.org/2/library/stdtypes.html#string-methods


## tuples :

non mutables : pas assigner, ajouter etc ...
on represente les typles avec des ()

Il est important d'utiliser les tuples quand on veut garder les entrees inmodifialbles donc securisée.


## listes : pareil que tuple mais mutables

on represente une liste avec des []


## dict    p64
on parle en anglais d e"mapping" : objet multivalué : les objects ne sont pas ordonnés.
Ce sont des connections cle valeurs 
On peut utiliser toutes les clés mais en principe il faut un hashable.
pour permettre l'utilisation de parcours de liste il faut un systeme rapide : hashable.

les dict sont entre {} dont les cle sont sépares par des : et les diff elements par des ,

on peut utiliser une methode get sur les dictionnaires entre autre pour definir une cle par defaut

## set et frozenset 

comme les liste ou les tuples mais on ne peut pas avoir deux objets egaux.

## les ensembles 



## voir bissect qui permet de ranger de directement des liste 


## files 

on a les memes methode qu'en c ex : is a ttya


on doit utiliser de preference la methode with pour le traitement de fichiers.

module io :permet de faire du decodage unicode automatique. on peut decoder a la volee les caracteres venant de python3 donc en utf 8 lu en python2.7

page 72 traiter les fichiers 



import os
os.mkdir('lapin')


attention le module codec va suremenet disparaitre


## structure de controle 

attention en python elif:

#endif : n'existe pas c'est une dedentation.


##### ipython + %edit -p  >envoie dans notre editeur de texte.

break permet de sortir immediatement de la boucle.

les chaines vides sont considérées à False.

on peut generer un indice de  boucle avec la fonction enum 

Attenion quand on boucle sur un dictionnaire ce sont les cles qui sont affiches.
pareil pour les ensembles / dict : pas d'ordre donc 


#############EXERCICES J1
allez dans le rep exercice et dans les rep respectifs :
Exos :  JOUR 1
●«alternative» : print conditionnel sur test d'une valeur aléatoire
fournie par la fonction 'randint' du module 'random'.
●«boucles» :Utilisation des boucles « for » et « while »
●«multivalues» : La superette et le caddy, exploration d'objets multivalués
#################REPONSES EXERCICES J1

# -*- coding: utf-8 -*-

"""Exercice : Utilisation des boucles Suivez les énoncés en commentaires.

Pour exécuter cet exercice à la console, passez l'une des commandes :

- python -m unittest tests
- python tests.py

Pour lancer les tests à travers Pycharm :

- Clic droit sur le ficher "tests.py" de ce répertoire dans le panneau "Project"
- Activez "Run 'Unittest in tests'" ou "Debug 'Unittest in tests'"
"""

# --------
# Boucle 1
# --------
# Faites une boucle affichant les nombres entiers de 0 à 10 en remplaçant
# l'objet "bouclage"
# Utilisez "xrange" : http://docs.python.org/library/functions.html#xrange

bouclage = xrange(11)
results1 = []

for valeur in bouclage:
    results1.append(valeur)

# assert results1 == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# --------
# Boucle 2
# --------
# Faites une boucle affichant les nombres entiers de 1 à 10 en remplaçant
# l'objet "bouclage"
# Utilisez "xrange" : http://docs.python.org/library/functions.html#xrange

bouclage = xrange(1, 11)
results2 = []

for valeur in bouclage:
    results2.append(valeur)

# assert results2 == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# --------
# Boucle 3
# --------
# Une boucle générique de 'debut' à 'fin' (inclus) par pas de 'step'
# Utilisez "xrange" : http://docs.python.org/library/functions.html#xrange

debut = 10
fin = 80
step = 10
results3 = []
bouclage = xrange(debut, fin + step, step)
for valeur in bouclage:
    results3.append(valeur)

# assert results3 == [10, 20, 30, 40, 50, 60, 70, 80]

# --------
# Boucle 4
# --------
# Variante de la précédente, 'debut' peut être supérieur à 'fin', on doit alors
# boucler de 'fin' à 'debut'.
# Utilisez "xrange" : http://docs.python.org/library/functions.html#xrange

debut, fin, step = 70, 30, 10
if debut > fin:
    debut, fin = fin, debut
bouclage = xrange(debut, fin + step, step)
results4 = []

for valeur in bouclage:
    results4.append(valeur)

# assert results4 == [30, 40, 50, 60, 70]

# --------
# Boucle 5
# --------
# En utilisant une boucle 'while', afficher les valeurs de 1 à 20

fin = 20
valeur = 0
results5 = []

while valeur < fin:
    valeur += 1
    results5.append(valeur)

# assert results5 == range(1, 21)  # [1, 2, ..., 20]
# -*- coding: utf-8 -*-
"""\
Exercice sur les objets multivalués
===================================

L'objet "superette" représente le catalogue d'articles dans un supermarché.
Nous supposons pour simplifier que celui-ci a un stock infini.  Cet objet est
représenté sous la forme d'un dictionnaire structuré de la façon suivante :

- la clé est l'intitulé unique d'un article. Par exemple, "savonette"
- la valeur est le cout client de l'article. Par exemple, 1.5

L'objet"caddy" est un dictionnaire représentant un caddy de supermarché. Il est
structuré de la façon suivante :

- la clé est le nom d'un des articles se trouvant également dans "superette"
- la valeur est le nombre d'unités de cet article se trouvant dans le caddy.

Notez que tout article dans le caddy ne figurant pas dans l'inventaire de la
superette est supposé gratuit.

Suivez les instructions en commentaires et insérez les ajouts nécessaires à la
suite des lignes "# VOTRE CODE ICI". Et il est bien entendu interdit de
supprimer les lignes commençant par "assert"
"""
import sys

superette = {
    'savonette': 1.0,
    'beurre': 2.5,
    'saucisson': 3.6,
    'lessive': 4.2
    }

caddy = {
    'savonette': 2
    }

# On ajoute au stock de la superette la "baguette" à 0.80 l'unité ainsi que l'
# "essuie-tout" à 2.1 le paquet.

# VOTRE CODE ICI
superette['baguette'] = 0.8
superette['essuie-tout'] = 2.1

assert len(superette) == 6  # Nombre d'articles distincts disponibles
assert set(('baguette', 'essuie-tout')) < set(superette.iterkeys())  #
On a bien les nouveaux

# On ajoute au panier 3 'beurre', 2 'saucisson', 1 'lessive', 2 'baguette', et 2
# 'chocolat'. Notez que la superette n'a pas de 'chocolat', il est donc gratuit.

# VOTRE CODE ICI
caddy['beurre'] = 3
caddy['saucisson'] = 2
caddy['lessive'] = 1
caddy['baguette'] = 2
caddy['chocolat'] = 2

assert len(caddy) == 6  # Articles distincts dans le caddy
assert sum(caddy.itervalues()) == 12  # Nombre total d'articles

# Quel est l'article unitaire le plus cher de la superette ? Placez son nom
# dans la variable "plus_cher".
# A savoir : "sys.float_info.max" est le plus grand positif flottant possibe

# VOTRE CODE ICI
prix_maxi = -sys.float_info.max
for article, prix in superette.iteritems():
    if prix > prix_maxi:
        prix_maxi = prix
        plus_cher = article

assert plus_cher == 'lessive'

# Quel est l'article unitaire le moins cher du caddy ? Placez son nom dans la
# variable "moins_cher". Attention, seuls les articles dans le stock de la
# superette comptent. Vous en profitez pour calculer le nombre total d'articles
# tenant compte de la quantité individuelle - non facturables dans la variable
# "non_facturables".

# VOTRE CODE ICI
non_facturables = 0
prix_mini = sys.float_info.max
for article, qte in caddy.iteritems():
    if article not in superette:
        non_facturables += qte
        continue
    prix = superette[article]
    if prix < prix_mini:
        prix_mini = prix
        moins_cher = article

assert moins_cher == 'baguette'
assert non_facturables == 2

# Quels sont les articles du caddy facturables ? placer ceux-ci dans l'ensemble
# "noms_facturables".

# VOTRE CODE ICI
noms_facturables = set(caddy) & set(superette)

assert noms_facturables == set(['lessive', 'baguette', 'beurre',
                                'savonette', 'saucisson'])

# Et pour finir, quel est le prix total du caddy ? Vous pouvez réutiliser
# "noms_facturables" calculé ci-avant pour obtenir le montant "total_caddy".

# VOTRE CODE ICI
total_caddy = 0.0
for nom in noms_facturables:
    total_caddy += caddy[nom] * superette[nom]

# En une seule ligne en utilisant les listes par intention :
# total_caddy = sum([caddy[nom] * superette[nom] for nom in noms_facturables])

assert total_caddy == 22.5

################################################################################################################################# JOUR 2 #### 

 fonctions :

meme si on envoie pas de param on met des ()

Return est facultatif si il n'est pas saisi c'est comme si on avait none
tous les params d'une fonctions sont fait par reference 

return on peut avoir plusieurs return dans une fonction : il faut veiller a retourner les elem du meme type.

pass : instruction neutre : ne fait rien 

les parametres sont transmi par reference

fonction special locals :retourne le dictionnaire des toutes les variables definies.

Arguments positionels :

fichiers functions.py dans exemple a voir

on peut avoir des sublist en arguments de fonctions qui sont rarement utilisée

Notation :
* et ** sont fait derriere  le dernier argument nomme

* toujours tuple
** toujours dict

voir fichier  ligne 100 env


Namespace : 
chaque fonction a son propre name space 
variable globale ou inferieures mais pas superieure


le mot cle global permet de reecraser la valeur de notre objet defini a la base .

En python3 on peut recuperer des valeurs de variables definie plus haut dans les piles d'appels 
la premiere valeur qui match est recupérer :

ex on passe d'une f3 on cherche x dedans : s'il n'ya pas de x on remonte a f2 etc ...


namespace de fonctions imbriquées :


fonctions recursives :
fonction flatten va s'appeller elle meme et sert a mettre a plat une liste de liste de liste 


les arguments nommes ne doivent pas etre des elements modifiables.

fonctions builtin
-> voir doc officielle

Gestion memoire :

gc : ramasse miettes 
python va attendre 


Modules :

un fichier : tous les objets exportés d'apres un fichier .
 
un package est un repertoire qui contient les objets.

Chaque  rep dans un package qui contient : 
"__init__.py"


Variable name et file de module :

_name_ nom courant du module

On ne peut pas importer une module qui commence par un "_" 


### classe :

classe est un moule a partir du quel est creeer une instance .

def __init__ : initialisateur quand on invoque une classe

le premier parametre est self : l'objet instance.

class vehicule(objet) : notation en python2 uniquement . A partir de python3 on est plus obligé de rajouter le mot objet entre()

la methode __init__ d'une classe doit toujours retourner un return vide : cela sert juste à la creation de la classe.

le self represente le nom de l'objet que l'on creee .

les methodes en private ne sont pas exportées : pour prevenir les problemes de compatibilité.


####attributs de classe

tous les noms reserves en python commencent et finissent par" __"

Examiner les methodes : 
http://docs.python.org/reference/datamodel.html#special-method-names

a travers les methodes ont access a tous les attibuts 


###heritage :

on gagne beacuoup de ligne de code .
on a une classe qui fait presque tout ce qu'on veut mais on doit rajouter une petite fonctionalite .

super : on va chercher ds l'heritage de la classe courante 

heritage multiple : peu de language le font python le fait.

modeliser les classes est plus un travail d'architecte logiciel.

# heritage vs compostion 

######## Exercices J2 ####
●«fonctions » : Une variante de l'exercice précédent (caddy, superette) utilisant des fonctions.

### Reponse J2 exercice fonctions :

# -*- coding: utf-8 -*-
"""\
Exercice sur les fonctions
==========================
Ceci est une variante de l'exercice précédent. Rappel :
L'objet"superette" représente le catalogue d'articles dans un supermarché. Nous
supposons pour simplifier que celui-ci a un stock infini.  Cet objet est
représenté sous la forme d'un dictionnaire structuré de la façon suivante :
- la clé est l'intitulé unique d'un article. Par exemple, "savonette"
- la valeur est le cout client de l'article. Par exemple, 1.5
Un objet"caddy" est un dictionnaire représentant un caddy de supermarché. Il est
structuré de la façon suivante :
- la clé est le nom d'un des articles se trouvant également dans "superette"
- la valeur est le nombre d'unités de cet article se trouvant dans le caddy.
Notez que tout article dans un caddy ne figurant pas dans l'inventaire de la
superette est supposé gratuit.
Attention, cette fois ci il peut y avoir autant de caddy que nécessaire. Le
caddy à traiter est donc envoyé en paramètre à toutes les fonctions.
Suivez les instructions en commentaires et insérez les ajouts nécessaires à la
suite des lignes "# VOTRE CODE ICI". Et il est bien entendu interdit de
supprimer les lignes commençant par "assert"
Lancer les tests
================
Cet exercice utilise le module ``unittest`` (voir le fichier ``tests.py``). En
exécutant la commande ``python tests.py`` vous exécutez les tests du module
``fonctions.py`` et en affichez les erreurs restantes.
.. admonition:: Autres façons de lancer les tests
   Vous pouvez également exécuter les tests par la commande :
   .. code:: console
      $ python -m unittests tests
   Ou encore à travers **PyCharm** en sélectionnant dans le panneau
   **Project** le fichier **tests.py** avec le clic droit puis en
   sélectionnant la commande **Run (...)** ou **Debug (...)**.
"""
superette = {
    'savonette': 1.0,
    'beurre': 2.5,
    'saucisson': 3.6,
    'lessive': 4.2,
    'baguette': 0.8,
    'essuie-tout': 2.1
    }
def ajouteAuCaddy(caddy, label, qte=1):
    """Ajoute un ou plusieurs articles à un caddy. Si le nombre d'articles pour
    un label donné tombe à 0 ou moins, on supprime l'article du panier (il n'y a
    pas d'article ayant une quantité nulle).
    Paramètres :
    - caddy : le caddy à alimenter
    - label : label de l'article à ajouter ou retirer
    - qte : quantité d'articles à ajouter ou retirer si négatif. Defaut = 1
    """
    total = caddy.get(label, 0) + qte
    if total <= 0:
        caddy.pop(label, None)
        # ou: del caddy[label]
    else:
        caddy[label] = total
    return
def retireArticlesDuCaddy(caddy, label):
    """On retire tous les articles d'un label donné du caddy.
    Paramètres :
    - caddy : le caddy à alimenter
    - label : label de l'article à supprimer
    """
    caddy.pop(label, None)
    # ou del caddy[label]
    return
def leCaddyContient(caddy, label):
    """Nombre d'articles au label donné dans le caddy.
    Paramètres
    - caddy : le caddy à alimenter
    - label : label de l'article à compter
    """
    return caddy.get(label, 0)
def prixDuCaddy(caddy):
    """Prix total du caddy. Utiliser le builtin ``sum`` et une liste dynamique.
    http://docs.python.org/library/functions.html#sum
    Paramètres
    - caddy : le caddy à alimenter
    """
    return sum([superette[l] * q for l, q in caddy.items() if l in superette])
    return sum([superette.get(l, 0) * q for l, q in caddy.items()])
# Les tests
# =========
def tests():
    caddy = {}
    # On commence à remplir le caddy
    ajouteAuCaddy(caddy, 'savonette')
    ajouteAuCaddy(caddy, 'savonette', 4)
    # On ne doit avoir 5 savonettes
    assert caddy == {'savonette': 5}
    # Donc...
    assert leCaddyContient(caddy, 'savonette') == 5
    # Mais ne contient pas d'article 'nexistepas'
    assert leCaddyContient(caddy, 'nexistepas') == 0
    # On ajoute 2 'essuie-tout' mais on retire les 'savonette's
    ajouteAuCaddy(caddy, 'essuie-tout', 2)
    retireArticlesDuCaddy(caddy, 'savonette')
    # On peut également retirer des articles qui n'existent nulle part, ceci
    # n'affecte pas la composition du caddy.
    memo_caddy = caddy.copy()
    retireArticlesDuCaddy(caddy, 'nexistepas')
    assert caddy == memo_caddy
    # On peut retirer du caddy plus d'articles d'un certain type qu'on en a, ce qui
    # revient au même que d'utiliser ``retireArticlesDuCaddy``.
    autre_caddy = {}
    ajouteAuCaddy(autre_caddy, 'savonette', 2)
    ajouteAuCaddy(autre_caddy, 'savonette', -5)
    assert leCaddyContient(autre_caddy, 'savonette') == 0
    # On poursuit les courses
    ajouteAuCaddy(caddy, 'savonette')
    ajouteAuCaddy(caddy, 'beurre', 2)
    ajouteAuCaddy(caddy, 'saucisson', 3)
    ajouteAuCaddy(caddy, 'lessive', 2)
    ajouteAuCaddy(caddy, 'baguette', 2)
    # Et même le chocolat qui n'est pas dans l'inventaire de la superette.
    ajouteAuCaddy(caddy, 'chocolat', 2)
    # Et on passe à la caisse
    douloureuse = prixDuCaddy(caddy)
    assert douloureuse == 31.0
    return
if __name__ == '__main__':
    tests()

##### Exercice J2 : classes 
Exercices
● « caddy_classes » : une reprise de l'exercice « fonctions », la superette et le caddy étant représentés par des classes.
● «banque » : une gestion simplifiée de banque avec des comptes bancaires simples et des comptes rémunérés. Cet exercice introduit l'utilisation du module doctest qui, comme son nom l'indique, permet de mélanger de la documentation technique et des tests.

####################### Jour 3 

#exeptions

le declenchement d'une exeption arrête le programme si c'est prevu.
soit on arrete soit on passe par un plan B.
les exeptions sont gérees par des classes avec les buitins.
ex :
on peut definir des fichiers de log : module logging à voir -> tres bien fait.
on peut creer nos exeptions avec des messages personnelles .
dans python3 on a un module 'abc' qui empeche l'utilisation de virtual env

pour faire un plan B : 

try etc ..permet de traiter les exeptions et de poursuivre le traitement si c'est possible intentionnelment ou stopper intentionnellement 

l'nstruction finaly sera tjs faite

on peut intercepter toutes les exeptoins ou alors que certains types

pysharm :on veut tester une fonction ou quelque chose : on va mettre un point  d'arret la ou on veut finir notre test : ex avant un nouvel appel .

on avance au pas a pas avec f7 et le mode debuguer

#### Exercice J3 exeption :
 Effectuez l’exercice «exceptions»

#### Correction exercice exceptions J3 :
on definie la fonction monte pour l'avion :
    def monte(self, distance):
        """On monte d'une certaine 'distance' verticale mais on demeure toujours
        dans la fourchette [0 ... self.plafond].
        Pour ceci, on utilise la méthode ``Avion.valide_consigne`` pour
        valider la nouvelle altitude. Et on affecte celle-ci à l'attribut
        'altitude'.
        """
        # VOTRE CODE ICI
        try:
            altitude = self.valide_consigne(self.altitude + distance)
        except Crash:
            self.altitude = 0
        except Plafonnage:
            self.altitude = self.plafond
        else:
            self.altitude = altitude
####

- unicodes 

pour le format

on peut faire du padding : formatter comme on veut les sorties 

eviter de faire du print : toujours passer par du format 

On peut faire notre propre formattage ( extremement rare en  python ..)


#### EXercice J3 unicode string formating :
●«stringformatting » : A vous de fournir quelques spécifications de formats.
#### Correction J3 string formating : 
# -*- coding: utf-8 -*-
"""String formatting exercice"""
# Two comma separated values
two_values_with_comma = "{0}, {1}"
u_two_values_with_comma = u"{0}, {1}"
# Two comma separated named values
two_named_values_with_comma = "{one}, {two}"
# Variable width passed as argument
variable_width_passed_as_arg = "[{0:{width}}]"
# Formatting for a mapping (dict)
two_values_in_dict_with_comma = "{0[one]}, {0[two]}"
# Formatting for a sequence (list, tuple, ...)
twree_values_sequence_with_comma = "{0[0]}, {0[1]}, {0[2]}"
# Formatting a zero left filled monetary value (8 chars)
monetary_value_8_digits = "{0:08.2f}"
####

-  bibliotheque standart :

depuis 2.5 les strings sont des objets .

sqlite3 integré à python

exo volume.py 
#### Exercice J3 bibliotheque standard :
●«volumepy» : un utilitaire qui compte le nombre de fichiers « *.py » dans une arborescence de fichiers, la taille totale cumulée et la taille moyenne de ces fichiers.Cet exercice utilise plusieurs modules standard.
#### reponse J3 bibbiotheque standard :

def getRootFolder():
    """Le dossier racine à explorer fourni en argument de ligne de commande
    :return: le chemin absolu du répertoire à explorer
    Doit pouvoir prendre les valeurs usuelles telles que:
    '/un/deux/trois' : un chemin absolu
    'deux/trois' : un chemin relatif
    '~kiki/deux' : 'deux' dans l'espace de l'utilisateur 'kiki'
    '~/deux' : 'deux' dans l'espace de l'utilisateur courant
    Les variables d'environnement sont acceptées tel '$HOME/un' (Unix)
    ou tel '%HOME%\un' (Windows)
    Si le répertoire n'existe pas, il faut lancer une erreur 'NoSuchDirectory'
    Si le répertoire n'est pas mentionné dans la ligne de commande, la commande
    s'applique au dossier courant (pwd)
    AIDE : lire la doc du package 'os.path' ainsi que de la variable 'sys.argv'
    """
    # VOTRE CODE ICI
    args = sys.argv
    if len(args) > 1:
        root_dir = args[1]
    else:
        root_dir = '.'
    root_dir = os.path.expanduser(root_dir)  # "~toto" -> "/home/toto" "C:\User\toto"
    root_dir = os.path.expandvars(root_dir)  # "/xxx/$MACHIN/yyy" -> "/xxx/valeur_machin/yyy"
    root_dir = os.path.realpath(root_dir)    # "/x/y/../z" -> "/x/z"
    if not os.path.isdir(root_dir):
        raise NoSuchDirectory(root_dir)
    return root_dir



#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""\
volumepy.py
===========
Voir la description dans README.txt
Ajoutez votre code ou vos corrections dans les blocs suivant les marqueurs
"# VOTRE CODE ICI"
Quelques pistes :
- ``sys.argv`` fournit la liste des mots figurant dans la ligne de commandes,
  donc l'argument attendu.
- ``os.path`` fournit les mécanismes nécessaires pour construire et tester les
  noms de répertoires.
- ``fnmatch.fnmatch('machin.txt', '*.txt')`` -> True
  ``fnmatch.fnmatch('machin.cfg', '*.txt')`` -> False
- ``os.stat()`` fournit diverses informations avancées sur un fichier.
"""
import sys
import os
import fnmatch
class NoSuchDirectory(IOError):
    """Erreur pour signaler qu'un répertoire n'existe pas
    """
    pass
def getRootFolder():
    """Le dossier racine à explorer fourni en argument de ligne de commande
    :return: le chemin absolu du répertoire à explorer
    Doit pouvoir prendre les valeurs usuelles telles que:
    '/un/deux/trois' : un chemin absolu
    'deux/trois' : un chemin relatif
    '~kiki/deux' : 'deux' dans l'espace de l'utilisateur 'kiki'
    '~/deux' : 'deux' dans l'espace de l'utilisateur courant
    Les variables d'environnement sont acceptées tel '$HOME/un' (Unix)
    ou tel '%HOME%\un' (Windows)
    Si le répertoire n'existe pas, il faut lancer une erreur 'NoSuchDirectory'
    Si le répertoire n'est pas mentionné dans la ligne de commande, la commande
    s'applique au dossier courant (pwd)
    AIDE : lire la doc du package 'os.path' ainsi que de la variable 'sys.argv'
    """
    args = sys.argv
    if len(args) > 1:
        root_dir = args[1]
    else:
        root_dir = '.'
    root_dir = os.path.expanduser(root_dir)  # "~toto" -> "/home/toto" "C:\User\toto"
    root_dir = os.path.expandvars(root_dir)  # "/xxx/$MACHIN/yyy" -> "/xxx/valeur_machin/yyy"
    root_dir = os.path.realpath(root_dir)    # "/x/y/../z" -> "/x/z"
    if not os.path.isdir(root_dir):
        raise NoSuchDirectory(root_dir)
    return root_dir
class PyVolumeSummarizer(object):
    count = 0         # Nombre total de fichiers *.py
    total_size = 0    # Taille cumulée **réelle** en octets des fichiers *.py
    average_size = 0  # Taille moyenne
    def __init__(self, path):
        """Constructeur
        :param path: chemin de fichiers supposé existant
        """
        self.path = path
        return
    def process(self):
        """Effectue les calculs requis
        AIDE :
        - utiliser 'os.walk' pour parcourir le répertoire
        - utiliser 'fnmatch.fnmatch' pour tester la conformité d'un nom de fichier
        - utiliser 'os.stat' pour calculer la taille d'un fichier
        - utiliser 'os.path.join' pour composer des chemins de fichiers
        """
        for this_root, dirnames, filenames in os.walk(self.path):
            for filename in filenames:
                if not fnmatch.fnmatch(filename, '*.py'):
                    continue  # -> next
                self.count += 1
                abs_path = os.path.join(this_root, filename)
                size = os.stat(abs_path).st_size
                # size = os.path.getsize(abs_path)  # Alternative pour la ligne précédente
                self.total_size += size
        self.average_size = self.total_size / self.count
        return
def app():
    """L'application principale
    /!\ INTERDIT DE MODIFIER CETTE FONCTION /!\
    """
    root = getRootFolder()
    browser = PyVolumeSummarizer(root)
    browser.process()
    template = (
        "Dossier : {0}\n"
        "Nombre total de fichiers Python : {1.count}\n"
        "Taille totale cumulée des fichiers : {1.total_size}\n"
        "Taille moyenne d'un fichier : {1.average_size}"
        )
    print template.format(root, browser)
    return
def tests():
    """VOUS POUVEZ METTRE VOS TESTS TEMPORAIRES ICI
    """
    return
if __name__ == '__main__':
    if True:  # False pour exécuter les tests locaux
        app()
    else:
        tests()
####

- Modules tiers :

On install pip setuptools : 

boogie@x61:~$ sudo pip install -U pip setuptools wheel

pip est une fonction qui permet d'installer des extensiosn de setuptools
setuptools est une bibilio generinque de outils de packaging 

pip ne fonctionne pas sans setuptools

pip freeze

boogie@x61:~$ pip freeze |grep six
six==1.10.0
boogie@x61:~$ python -m pydoc six

pip gere les dependances pour l'install des pkgs 
mais pas pour les desinstall
On peut recupérer un env virtuel pour le distribuer :
pip freeze > requirements.txt ( le nom requirements.txt est une "best practice"
on a donc des versions iso .

Volume de test chez python tres importante

#### exercice J3 : modules tiers :
● Installez localement le package docutils (option --user)
● Testez la nouvelle commande rst2html.py en utilisant divers fichiers README.txt fournis avec les exercices.
####


-- module standart :

argparse : bien examinuer avec les options -x 
voir exemples argparslesson.py avec les options 

#### Exercice J3 argparsing : 
«argparsing » : Créez votre propre parser d'arguments
####
Correction :
#!/usr/bin/env python
# -*- coding: utf-8

"""Exercice d'utilisation de 'argparse'"""

import sys
import argparse

USAGE = """\
%(prog)s [options] file_in file_out"""
VERSION = '1.0'


def makeArgParser():
    """Construction d'un ArgumentParser supportant les options et arguments
    requis, voir README.txt
    """
    ap = argparse.ArgumentParser(description=__doc__, usage=USAGE)
    # Options
    ap.add_argument('--version', action='version',
                    version='{0} {1}'.format(sys.argv[0], VERSION),
                    help="affiche la version actuelle")
    ap.add_argument('-v', '--verbose', action='count', dest='verbosity', default=1,
                    help="ajoute de la verbosité pour chaque '-v'")
    ap.add_argument('-q', '--quiet', action='store_const', const=0, dest='verbosity',
                    help="n'affiche que les erreurs")
    ap.add_argument('-l', '--log', dest='logfile', default=None,
                    help="enregistre les messages dans FILE", metavar='FILE')

    # Arguments
    ap.add_argument('file_in', help="fichier en entrée")
    ap.add_argument('file_out', help="fichier en sortie")
    return ap


class Application(object):
    """L'application principale ne fait rien
    """
    def __init__(self):
        """Mise en place et contrôle des options et arguments
        """
        # Création de l'objet ArgumentParser
        ap = makeArgParser()
        self.args = ap.parse_args()
        return

    def run(self):
        """Activation de l'application
        """
        import pprint
        pprint.pprint(self.args)
        return "Je ne sers à rien pour le moment"


if __name__ == '__main__':
    app = Application()
    app.run()


On a toujours une option avec un tiret , un argument n'en a pas 

En theorie on ne pas pas avoir un '-v' et un '-q' en option .
On peut definir une exclusion : l'une ou l'autre

-- configparser :

on a dans le fichier ini la section DEFAUT obligatoire 
on peut interpoller la valeur de DEFAUt avec un % 


TRES BONNE IDEE pour definir les chemins qu'une appli devra utiliser ex par defaut.

yaml : bien pour faire des listes , dict .Il fait les conversion des types. Le parser yaml est bien plus puissant.

On peut faire des alias.

tres bon choix 

#### exercice J3 argparsing  : SUITE 
«argparseconfig » : On reprend le correctif de l'exercice précédent sur le module argparse , en fournissant la valeur par défaut d'une option supplémentaire avec un fichier de configuration


#################JOUR 4#####

installer pysharm edu : tutoriaux integre etc ...

-Reg :

2 methodes on utilise le module re ou on compile les re avant l'utilisation : on gagne enormemeent en temps de traitement 

-match : verif si un text correspond a un motif
-
quand on compile avec re.VERBOSE : cela annule les sauts de lignes et les reg ex sur plusieurs lignes 

on peut envoyer une fonction a une fonction : c'es tce qu'on appelle un callback

def machine(callback):
    callback(100)

def lapin(valeur):
  print valeur

machine(lapin) peut etre apelleer c'est un callback


#### Exercice J4 regex :
«regexps» : Utilisez les méthodes des expressions rationnelles.
####

-python avance 


####Exercice J4 generateur :
●«generateurs» : L'énoncé est dans les commentaires du module lui-même
####

on peut faire des decorateurs pour accelere le cache et la vitesse du traitement 

en web on met un decorateur quand on recupere des data sous formes liste , dico : qu'on va tjs renvoyer au client du json par exemple 

gestionnaires de contexttes.

-iterateurs s:

en python3 s'apelle maintence __next__ au lieu de next en python2

xml est quand meme tres interressant pour les grosses descriptions complexes : on peut le monter partiellement en memoire

json est bien pour des listes pas tres elaboree : attentin tout le doc jsson est en memore

mot cle yield

pour faire un generateur simplifié .
plus besoin de placer les methodes __iter__ et __next__

on a jamais de return quand utilise un yield : car c'est le stop iteration qui fait fois


def gege():
    yield 'lapin'
    yield 'tutu'
    yield 'lili'

for e in gege():
         print e
lapin
tutu
lili




correction exercice 2 iterable :


# -*- coding: utf-8
"""
==============
generateurs.py
==============
Exercice sur les générateurs. Ce module permet également une démonstration sur
les tests intégrés dans les docstrings du module. Voir
http://docs.python.org/library/doctest.html#module-doctest
Lancer les tests
================
Cet exercice utilise indiféfremment les modules ``doctest`` ou ``unittest``
(voir le fichier ``tests.py``). Pour lancer les tests, vous avez un large
éventail de choix :
A la console, exécutez l'une de ces commandes pour  afficher les erreurs
restantes :
.. code:: console
   $ python generateurs.py
   $ python -m doctest generateurs.py
   $ python tests.py
   $ python -m unittest tests
Ou encore à travers **PyCharm** en sélectionnant dans le panneau **Project**
le fichier **generateurs.py**, ou **tests.py** avec le clic droit puis en
sélectionnant la commande **Run (...)** ou **Debug (...)**.
Énoncés
=======
Comme pour tous les exercices, vous êtes invités à parcourir l'intégralité de
l'énoncé avant de vous jeter sur votre clavier.
``skipfirst``
-------------
Le premier générateur ``skipfirst`` est relativement simple. Il prend comme
paramètre un itérable quelconque, et un entier "skipped". L'itération doit
"sauter" les "skipped" premiers éléments de l'itérable et fournir tous les
autres.
L'utilisation de sous-listes est interdite, ainsi que l'utilisation du module
``itertools``, l'utilisation de ``yield`` est obligatoire et toutes les
antisèches sont permises :
.. code:: pycon
   >>> import types
   >>> une_liste = range(15) # [0, 1, ..., 14]
   >>> generateur = skipfirst(une_liste)
Je vérifie d'abord que vous ne trichez pas et fournissez bien un générateur :
.. code:: pycon
   >>> type(generateur) is types.GeneratorType
   True
On essaie l'utilisation par défaut :
.. code:: pycon
   >>> list(generateur) == range(15)
   True
Et si on fournit un ``skipped`` négatif, ça revient à ne pas en fournir ou
fournir un ``skipped=0`` :
.. code:: pycon
   >>> generateur = skipfirst(une_liste, -10)
   >>> list(generateur) == range(15)
   True
L'utilisation normale consiste à fournir un ``skipped`` inférieur à la taille de
l'itérable :
.. code:: pycon
   >>> generateur = skipfirst(une_liste, 10)
   >>> list(generateur)
   [10, 11, 12, 13, 14]
Mais si on dépasse la taille de l'itérable, on n'itère pas du tout :
.. code:: pycon
   >>> generateur = skipfirst(une_liste, 20)
   >>> list(generateur)
   []
``flatten``
-----------
Plus difficile : ``flatten`` est un générateur qui "aplatit" les structures
itérables imbriquées.  Des listes contenant des tuples, des chaines, des
dictionnaires, des ensembles.  Tous les objets simples (non itérables) y
figurant doivent être retournés dans l'ordre de leur apparition dans la
structure imbriquée :
.. code:: pycon
   >>> le_tas = [[1, 2], (3, 4, (5, 6, 7), [8, 9], 10), 11]
   >>> generateur = flatten(le_tas)
Je vérifie d'abord que vous ne trichez pas et fournissez bien un générateur :
.. code:: pycon
   >>> type(generateur) is types.GeneratorType
   True
Et surtout, que ce générateur effectue correctement la mission qui lui est
assignée :
.. code:: pycon
   >>> list(generateur)
   [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
Bien entendu, comme la profondeur d'imbrication des éléments itérables est
inconnue, ce générateur sera forcément récursif, c'est-à-dire que sous certaines
conditions, il sera appelé par lui-même. Ah oui, il est interdit de construire
des listes temporaires dans cette fonction, ce qui irait à l'encontre de
l'esprit des générateurs, et l'utilisation du mot-clé ``yield`` est bien entendu
obligatoire.
Pour déterminer si un élément est itérable, vous disposez de la fonction
``is_iterable``:
.. code:: pycon
   >>> is_iterable(xrange(10))
   True
   >>> is_iterable((1, 2))
   True
   >>> is_iterable(5)
   False
   >>> is_iterable("blabla")
   True
   >>> is_iterable({1:1})
   True
   >>> is_iterable(set([1, 2]))
   True
"""
import collections

solution 1 simple :

def skipfirst(iterable, skipped=0):
    """Supprime les ``skipped`` premier éléments d'un itérable
    """
    # VOTRE CODE ICI
    count=0
    for entier in iterable:
        count+=1
        if count > skipped:
            yield entier
solution 2 prof :

def skipfirst(iterable, skipped=0):
    """Supprime les ``skipped`` premier éléments d'un itérable
    """
    skipped = max(0, skipped)  # Pas de négatifs
    for i, elt in enumerate(iterable):
        if i >= skipped:
            yield elt



def flatten(root):
    """Aplatit une imbrication d'objets itérables
    """
    if is_iterable(root):
        for element in root:
            for e in flatten(element):
                yield e
    else:
        yield root
def is_iterable(object_):
    """Détermine si un élément est ou non itérable (utilisable dans une boucle
    "for"...)
    NE MODIFIEZ PAS CETTE FONCTION
    """
    return isinstance(object_, collections.Iterable)
if __name__ == '__main__':
    import doctest
    doctest.testmod(optionflags=doctest.ELLIPSIS)


decorateur : classe qui controlle une classe .


decorateur simple

decorateur property 
quasiment tout le temps accesseur defini


#### Exercice J4 decorateur :
Exercice
● «decorations» : Deux décorateurs à réaliser et à tester. A noter que ces décorateurs peuvent avoir une utilité pour une application du monde réel.
####

Descripteur 

voir modules  pickle / json pour serialiser / deserialiser les donnes

faire exo descripteur : interessant utilisation du module picke

#### Exercice J4 :descripteur :
«descripteurs» : Utilisation d'un descripteur pour créer un attribut persistent de tout type
####

gestionnaire de contexte : 
permet de locker un objet pour le rendre indispo pour les autres afin de preserver.

module threading / multiprocessing

context manager exo solutition :

cela peut etre utilisable en production :


class ChangeGlobal(object):
    """Modifie une variable globale temporairement
    """
    def __init__(self, glob_dict, glob_name, new_value):
        """Construction
        :param glob_dict: dico de globales du module
        :param glog_name: nom de la variable globale
        :param new_value: la valeur temporaire de la globale (un objet quelconque)
        """
        # VOTRE CODE ICI
        self.glob_dict, self.glob_name, self.new_value = glob_dict, glob_name, new_value
        return
    def __enter__(self):
        # VOTRE CODE ICI
        # On mémorise la valeur courante de la variable dans le dico de son module d'origine
        self.memo_value = self.glob_dict[self.glob_name]
        # Et on remplace par la nouvelle valeur
        self.glob_dict[self.glob_name] = self.new_value
        return
    def __exit__(self, exc_type, exc_value, traceback):
        # VOTRE CODE ICI
        # On inverse ce qui a été fait dans __enter__
        self.glob_dict[self.glob_name] = self.memo_value
        return

---- 


import os
class change_directory(object):
    def __init__(self, new_dir):
        self.new_dir = new_dir
    def __enter__(self):
        self.prev_dir = os.getcwd()
        os.chdir(self.new_dir)
        return self.new_dir
    def __exit__(self, exc_type, exc_value, tb):
        os.chdir(self.prev_dir)
        return False
with change_directory('..'):
    print os.listdir(os.getcwd())
with change_directory('/'):
    print os.listdir(os.getcwd())
print os.listdir(os.getcwd())


il est important d'utiliser les contextes managers ; decorateurs quand les projets commencent à etre un peu important.


#### Exercice J4 context manager :
●«contextmgr » : Un gestionnaire de contexte qui permet d'ignorer certaines exceptions, un autre qui change temporairement la valeur d'une globale.
####

ipython : a des extensions pour les graphs , maths etc ...

jupyter collection complete de ipython

- industrialisation / qualité :

un env virtual par packet

tjs utiliser setuptools : pkgs distribuables

git est conseillé.


test unitaire obligatoire.

bouchons mock : simulent des ressources qu'on  a pas pour tester ..
-> exemple pour tester la connection a un ldap.


Virtual env :

imperatif pour les projects 
boogie@x61:~/lab/away/away_4$ sudo pip install virtualenv
Collecting virtualenv
  Downloading virtualenv-13.1.2-py2.py3-none-any.whl (1.7MB)
    100% |████████████████████████████████| 1.7MB 128kB/s 
Installing collected packages: virtualenv
Successfully installed virtualenv-13.1.2

boogie@x61:~/lab/away/away_4$ virtualenv -h
Usage: virtualenv [OPTIONS] DEST_DIR

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -v, --verbose         Increase verbosity.
  -q, --quiet           Decrease verbosity.
  -p PYTHON_EXE, --python=PYTHON_EXE
                        The Python interpreter to use, e.g.,
                        --python=python2.5 will use the python2.5 interpreter
                        to create the new environment.  The default is the
                        interpreter that virtualenv was installed with
                        (/usr/bin/python)
  --clear               Clear out the non-root install and start from scratch.
  --no-site-packages    DEPRECATED. Retained only for backward compatibility.
                        Not having access to global site-packages is now the
                        default behavior.
  --system-site-packages
                        Give the virtual environment access to the global
                        site-packages.
  --always-copy         Always copy files rather than symlinking.
  --unzip-setuptools    Unzip Setuptools when installing it.
  --relocatable         Make an EXISTING virtualenv environment relocatable.
                        This fixes up scripts and makes all .pth files
                        relative.
  --no-setuptools       Do not install setuptools (or pip) in the new
                        virtualenv.
  --no-pip              Do not install pip in the new virtualenv.
  --no-wheel            Do not install wheel in the new virtualenv.
  --extra-search-dir=DIR
                        Directory to look for setuptools/pip distributions in.
                        This option can be used multiple times.
  --never-download      DEPRECATED. Retained only for backward compatibility.
                        This option has no effect. Virtualenv never downloads
                        pip or setuptools.
  --prompt=PROMPT       Provides an alternative prompt prefix for this
                        environment.
  --setuptools          DEPRECATED. Retained only for backward compatibility.
                        This option has no effect.
  --distribute          DEPRECATED. Retained only for backward compatibility.
                        This option has no effect.


on peut creer un rep par virtual env 

methode generale : on creer un rep et on initiaise le virtual env :

boogie@x61:~/lab/away/away_4$ mkdir venvs
boogie@x61:~/lab/away/away_4$ cd venvs/
boogie@x61:~/lab/away/away_4/venvs$ virtualenv projet
New python executable in projet/bin/python
Installing setuptools, pip, wheel...done.

on active notre virtualenv : 
boogie@x61:~/lab/away/away_4/venvs$ source projet/bin/activate
(projet)boogie@x61:~/lab/away/away_4/venvs$ 

on voit maintenant que notre env python est relatif :
>>> import sys
>>> sys.path
['', '/home/boogie/lab/away/away_4/venvs/projet/lib/python2.7', '/home/boogie/lab/away/away_4/venvs/projet/lib/python2.7/plat-x86_64-linux-gnu', '/home/boogie/lab/away/away_4/venvs/projet/lib/python2.7/lib-tk', '/home/boogie/lab/away/away_4/venvs/projet/lib/python2.7/lib-old', '/home/boogie/lab/away/away_4/venvs/projet/lib/python2.7/lib-dynload', '/usr/lib/python2.7', '/usr/lib/python2.7/plat-x86_64-linux-gnu', '/usr/lib/python2.7/lib-tk', '/home/boogie/lab/away/away_4/venvs/projet/local/lib/python2.7/site-packages', '/home/boogie/lab/away/away_4/venvs/projet/lib/python2.7/site-packages']
on desactive le virtualenv : 
(projet)boogie@x61:~/lab/away/away_4/venvs$ deactivate
boogie@x61:~/lab/away/away_4/venvs$ 


On peut se faire un mirroir pip avec un apache 

on a un fichier de conf pip 


le templating de packaging est important   cf bobtemplates.gillux sur pip python
 

on a tjs besoin d'un fichier setup.py

module d'autodocumentation avec sphinx 



on install shpinx
la doc est genére par les docstring que l'on renseigne dans notre code 

readthedoc est fait en sphinx


##########################
    python VIP urls :)
##########################

    https://www.python.org/
    https://docs.python.org/2.7/
    https://docs.python.org/2/library/stdtypes.html#xrange-type
    https://docs.python.org/2/library/stdtypes.html?highlight=mutable%20sequence%20type#mutable-sequence-types
    https://docs.python.org/2/library/stdtypes.html#mapping-types-dict
    https://docs.python.org/2/library/stdtypes.html#set-types-set-frozenset
    https://docs.python.org/2/library/functions.html#open
    https://docs.python.org/2/library/stdtypes.html#bltin-file-objects
    https://docs.python.org/2/library/functions.html#xrange
    https://docs.python.org/2/library/functions.html
    https://docs.python.org/2/reference/datamodel.html#special-method-names
    http://flask.pocoo.org/docs/0.10/tutorial/
    http://pythonbooks.revolunet.com/

    https://docs.python.org/2/library/exceptions.html
    https://docs.python.org/2/library/string.html#formatstrings
    https://docs.python.org/2/library/stdtypes.html#string-methods
    https://docs.python.org/2/howto/argparse.html
    https://docs.python.org/2/library/argparse.html#module-argparse

    https://www.debuggex.com/
    https://docs.python.org/2/library/itertools.html#module-itertools
    https://pymotw.com/2/
    https://www.python.org/dev/peps/pep-0008/
    https://docs.python.org/2/library/unittest.html
    https://pypi.python.org/pypi/virtualenv
    https://www.jetbrains.com/pycharm-edu/



