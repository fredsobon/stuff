

=== Boolean : 


This and That (or This, But Not That!)

Boolean operators aren't just evaluated from left to right. Just like with arithmetic operators, there's an order of operations for boolean operators:

    not is evaluated first;
    and is evaluated next;
    or is evaluated last.

For example, True or not False and False returns True. If this isn't clear, look at the Hint.

Parentheses () ensure your expressions are evaluated in the order you want. Anything in parentheses is evaluated as its own unit.
Instructions

Assign True or False as appropriate for bool_one through bool_five.

    Set bool_one equal to the result of False or not True and True
    Set bool_two equal to the result of False and not True or True
    Set bool_three equal to the result of True and not (False or False)
    Set bool_four equal to the result of not not True or False and not True
    Set bool_five equal to the result of False or not (True and True)




Mix 'n' Match

Great work! We're almost done with boolean operators.

# Make me false
bool_one = (2 <= 2) and "Alpha" == "Bravo"


Instructions

This time we'll give the expected result, and you'll use some combination of boolean operators to achieve that result.

Remember, the boolean operators are and, or, and not. Use each one at least once!

=== Conditional Statement Syntax : 

if is a conditional statement that executes some specified code after checking if its expression is True.

Here's an example of if statement syntax:

if 8 < 9:
    print "Eight is less than nine!"

In this example, 8 < 9 is the checked expression and print "Eight is less than nine!" is the specified code.
Instructions

If you think the print statement will print to the console, set response equal to 'Y'; otherwise, set response equal to 'N'.


If You're Having...

Let's get some practice with if statements. Remember, the syntax looks like this:

if some_function():
    # block line one
    # block line two
    # et cetera

Looking at the example above, in the event that some_function() returns True, then the indented block of code after it will be executed. In the event that it returns False, then the indented block will be skipped.

Also, make sure you notice the colons at the end of the if statement. We've added them for you, but they're important.
Instructions

In the editor you'll see two functions. Don't worry about anything unfamiliar. We'll explain soon enough.

    Replace the underline on line 2 with an expression that returns True.
    Replace the underline on line 6 with an expression that returns True.

If you do it successfully, then both "Success #1" and "Success #2" are printed.

#Else Problems, I Feel Bad for You, Son...

The else statement complements the if statement. An if/else pair says: "If this expression is true, run this indented code block; otherwise, run this code after the else statement."

Unlike if, else doesn't depend on an expression. For example:

if 8 > 9:
    print "I don't printed!"
else:
    print "I get printed!"

Instructions

Complete the else statements to the right. Note the indentation for each line!



#Else Problems, I Feel Bad for You, Son...

The else statement complements the if statement. An if/else pair says: "If this expression is true, run this indented code block; otherwise, run this code after the else statement."

Unlike if, else doesn't depend on an expression. For example:

if 8 > 9:
    print "I don't printed!"
else:
    print "I get printed!"

Instructions

Complete the else statements to the right. Note the indentation for each line!

#I Got 99 Problems, But a Switch Ain't One

"Elif" is short for "else if." It means exactly what it sounds like: "otherwise, if the following expression is true, do this!"

if 8 > 9:
    print "I don't get printed!"
elif 8 < 9:
    print "I get printed!"
else:
    print "I also don't get printed!"

In the example above, the elif statement is only checked if the original if statement if False.
Instructions

    On line 2, fill in the if statement to check if answer is greater than 5.
    On line 4, fill in the elif so that the function outputs -1 if answer is less than 5.


#The Big If

Really great work! Here's what you've learned in this unit:

Comparators

3 < 4
5 >= 5
10 == 10
12 != 13

Boolean operators

True or False 
(3 < 4) and (5 >= 5)
this() and not that()

Conditional statements

if this_might_be_true():
    print "This really is true."
elif that_might_be_true():
    print "That is true."
else:
    print "None of the above."

Let's get to the grand finale.
Instructions

Write an if statement in the_flying_circus(). It must include:

    if, elif, and else statements;
    At least one of and, or, or not;
    A comparator (==, !=, <, <=, >, or >=);
    Finally, the_flying_circus() must return True when evaluated.

Don't forget to include a : after your if statements!


#Break It Down

Now let's take what we've learned so far and write a Pig Latin translator.

Pig Latin is a language game, where you move the first letter of the word to the end and add "ay." So "Python" becomes "ythonpay." To write a Pig Latin translator in Python, here are the steps we'll need to take:

    Ask the user to input a word in English.
    Make sure the user entered a valid word.
    Convert the word from English to Pig Latin.
    Display the translation result.

Instructions

When you're ready to get coding, click Save and Submit. Since we took the time to write out the steps for our solution, you'll know what's coming next!


#Ahoy! (or Should I Say Ahoyay!)

Let's warm up by printing a welcome message for our translator users.
Instructions

    Please print the phrase "Pig Latin".

#Input!

Next, we need to ask the user for input.

name = raw_input("What's your name?")
print name

In the above example, raw_input() accepts a string, prints it, and then waits for the user to type something and press Enter (or Return).

In the interpreter, Python will ask:

What's your name? >

Once you type in your name and hit Enter, it will be stored in name.
Instructions

    On line 4, use raw_input("Enter a word:") to ask the user to enter a word. Save the results of raw_input() in a variable called original.
    Click Save & Submit Code
    Type a word in the console window and press Enter (or Return).

#Check Yourself!

Next we need to ensure that the user actually typed something.

empty_string = ""
if len(empty_string) > 0:
    # Run this block.
    # Maybe print something?
else:
    # That string must have been empty.

We can check that the user's string actually has characters!
Instructions

Write an if statement that verifies that the string has characters.

    Add an if statement that checks that len(original) is greater than zero. Don't forget the : at the end of the if statement!
    If the string actually has some characters in it, print the user's word.
    Otherwise (i.e. an else: statement), please print "empty".

You'll want to run your code multiple times, testing an empty string and a string with characters. When you're confident your code works, continue to the next exercise.

#Check Yourself... Some More

Now we know we have a non-empty string. Let's be even more thorough.

x = "J123"
x.isalpha()  # False

In the first line, we create a string with letters and numbers.

The second line then runs the function isalpha() which returns False since the string contains non-letter characters.

Let's make sure the word the user enters contains only alphabetical characters. You can use isalpha() to check this! For example:
Instructions

Use and to add a second condition to your if statement. In addition to your existing check that the string contains characters, you should also use .isalpha() to make sure that it only contains letters.

Don't forget to keep the colon at the end of the if statement!


Code pour exemple utilisation isalpha() methode :
print 'Welcome to the Pig Latin Translator!'

# Start coding here!
original = raw_input("Enter a word:")
if len(original) > 0 and original.isalpha():
    print(original)
else:
    print("empty")

ex ok : (chaine de caractere alphabetique : yop )

Welcome to the Pig Latin Translator!
Enter a word: yop
yop
None

ex nok ( chaine de caractere non alphabettique : lapin123 )
Welcome to the Pig Latin Translator!
Enter a word: lapin123
empty
None

#Pop Quiz!

When you finish one part of your program, it's important to test it multiple times, using a variety of inputs.
Instructions

Take some time to test your current code. Try some inputs that should pass and some that should fail. Enter some strings that contain non-alphabetical characters and an empty string.

When you're convinced your code is ready to go, click Save & Submit to move forward!


#Ay B C

Now we can get ready to start translating to Pig Latin! Let's review the rules for translation:

You move the first letter of the word to the end and then append the suffix 'ay'.
Example: python -> ythonpay

Let's create a variable to hold our translation suffix.
Instructions

Create a variable named pyg and set it equal to the suffix 'ay'.


#Word Up

Let's simplify things by making the letters in our word lowercase.

the_string = "Hello"
the_string = the_string.lower()

The .lower() function does not modify the string itself, it simply returns a lowercase-version. In the example above, we store the result back into the same variable.

We also need to grab the first letter of the word.

first_letter  = the_string[0]
second_letter = the_string[1]
third_letter  = the_string[2]

Remember that we start counting from zero, not one, so we access the first letter by asking for [0].
Instructions

Inside your if statement:

    Create a new variable called word that holds the .lower()-case conversion of original.
    Create a new variable called first that holds word[0], the first letter of word.

ex code :

pyg = 'ay'

original = raw_input('Enter a word:')

if len(original) > 0 and original.isalpha():
    word = original.lower()
    first = word[0]
    print original
else:
    print 'empty'



#Move it on Back

Now that we have the first letter stored, we need to add both the letter and the string stored in pyg to the end of the original string.

Remember how to concatenate (i.e. add) strings together?

greeting = "Hello "
name = "D. Y."
welcome = greeting + name

Instructions

On a new line after where you created the first variable:

Create a new variable called new_word and set it equal to the concatenation of word, first, and pyg.


riginal = raw_input('Enter a word:')

if len(original) > 0 and original.isalpha():
    word = original.lower()
    first = word[0]
    new_word = word + first + pyg
    print original
else:
    print 'empty'



#Ending Up

Well done! However, now we have the first letter showing up both at the beginning and near the end.

s = "Charlie"

print s[0]
# will print "C"

print s[1:4]
# will print "har"

    First we create a variable s and give it the string "Charlie"
    Next we access the first letter of "Charlie" using s[0]. Remember letter positions start at 0.
    Then we access a slice of "Charlie" using s[1:4]. This returns everything from the letter at position 1 up till position 4.

We are going to slice the string just like in the 3rd example above.
Instructions

Set new_word equal to the slice from the 1st index all the way to the end of new_word. Use [1:len(new_word)] to do this.

ex code :

yg = 'ay'

original = raw_input('Enter a word:')

if len(original) > 0 and original.isalpha():
    word = original.lower()
    first = word[0]
    new_word = word + first + pyg
    new_word = new_word[1:len(new_word)]
    print original
else:
    print 'empty'


#Testing, Testing, is This Thing On?

Yay! You should have a fully functioning Pig Latin translator. Test your code thorougly to be sure everything is working smoothly.

You'll also want to take out any print statements you were using to help debug intermediate steps of your code. Now might be a good time to add some comments too! Making sure your code is clean, commented, and fully functional is just as important as writing it in the first place.
Instructions

When you're sure your translator is working just the way you want it, click Save & Submit Code to finish this project.

ex code final :

pyg = 'ay'

original = raw_input('Enter a word:')

if len(original) > 0 and original.isalpha():
    word = original.lower()
    first = word[0]
    new_word = word + first + pyg
    new_word = new_word[1:len(new_word)]
    print new_word
else:
    print 'empty'

ex de saisi :
Enter a word: Shake
hakesay
None


#What Good are Functions?

You might have considered the situation where you would like to reuse a piece of code, just with a few different values. Instead of rewriting the whole code, it's much cleaner to define a function, which can then be used repeatedly.
Instructions

Check out the code in the editor. If you completed the [Tip Calculator][1] project, you'll remember going through and calculating tax and tip in one chunk of program. Here you can see we've defined two functions: tax to calculate the tax on a bill, and tip to compute the tip.

See how much of the code you understand at first glance (we'll explain it all soon). When you're ready, click Save & Submit to continue.


def tax(bill):
    """Adds 8% tax to a restaurant bill."""
    bill *= 1.08
    print "With tax: %f" % bill
    return bill

def tip(bill):
    """Adds 15% tip to a restaurant bill."""
    bill *= 1.15
    print "With tip: %f" % bill
    return bill
    
meal_cost = 100
meal_with_tax = tax(meal_cost)
meal_with_tip = tip(meal_with_tax)



def tax(bill):
    """Adds 8% tax to a restaurant bill."""
    bill *= 1.08
    print "With tax: %f" % bill
    return bill

def tip(bill):
    """Adds 15% tip to a restaurant bill."""
    bill *= 1.15
    print "With tip: %f" % bill
    return bill
    
meal_cost = 100
meal_with_tax = tax(meal_cost)
meal_with_tip = tip(meal_with_tax)



#Function Junction

Functions are defined with three components:

    The header, which includes the def keyword, the name of the function, and any parameters the function requires. Here's an example:

    def hello_world(): // There are no parameters

    An optional comment that explains what the function does.

    """Prints 'Hello World!' to the console."""

    The body, which describes the procedures the function carries out. The body is indented, just like for conditional statements.

    print "Hello World!"

Here's the full function pieced together:

def hello_world():
    """Prints 'Hello World!' to the console."""
    print "Hello World!"

Instructions

Go ahead and create a function, spam, that prints the string "Eggs!" to the console. Don't forget to include a comment of your own choosing (enclose it in triple quotes!).


# Define your spam function starting on line 5. You
# can leave the code on line 11 alone for now--we'll
# explain it soon!
def spam():
    '''This function's gonna print the followig strings 'Eggs!'
    '''
    print "Eggs!"
# Define the spam function above this line.
spam()


Eggs!
None


#Call and Response

After defining a function, it must be called to be implemented. In the previous exercise, spam() in the last line told the program to look for the function called spam and execute the code inside it.
Instructions

We've set up a function, square. Call it on the number 10 (by putting 10 between the parentheses of square()) on line 9!

def square(n):
    """Returns the square of a number."""
    squared = n**2
    print "%d squared is %d." % (n, squared)
    return squared
    
# Call the square function on line 9! Make sure to
# include the number 10 between the parentheses.
square(10)


10 squared is 100.
None



#Parameters and Arguments

Let's reexamine the first line that defined square in the previous exercise:

def square(n):

n is a parameter of square. A parameter acts as a variable name for a passed in argument. With the previous example, we called square with the argument 10. In this instance the function was called, n holds the value 10.

A function can require as many parameters as you'd like, but when you call the function, you should generally pass in a matching number of arguments.
Instructions

Check out the function in the editor, power. It should take two arguments, a base and an exponent, and raise the first to the power of the second. It's currently broken, however, because its parameters are missing.

Replace the ___s with the parameters base and exponent and call power on a base of 37 and a power of 4.

Empty exercice :

def power(___, ___):  # Add your parameters here!
    result = base**exponent
    print "%d to the power of %d is %d." % (base, exponent, result)

power(__,__)  # Add your arguments here!

Result :

def power(base, exponent):  # Add your parameters here!
    result = base**exponent
    print "%d to the power of %d is %d." % (base, exponent, result)

power(37,4)  # Add your arguments here!

37 to the power of 4 is 1874161.
None 


#Functions Calling Functions

We've seen functions that can print text or do simple arithmetic, but functions can be much more powerful than that. For example, a function can call another function:

def fun_one(n):
    return n * 5

def fun_two(m):
    return fun_one(m) + 7

Instructions

Let's look at the two functions in the editor: one_good_turn (which adds 1 to the number it takes in as an argument) and deserves_another (which adds 2).

Change the body of deserves_another so that it always adds 2 to the output of one_good_turn.

Question :
def one_good_turn(n):
    return n + 1
    
def deserves_another(n):
    return n + 2

Reponse :
def one_good_turn(n):
    return n + 1
    
def deserves_another(n):
    return one_good_turn(n) + 2


#Practice Makes Perfect

Let's create a few more functions just for good measure.

def shout(phrase):
    if phrase == phrase.upper():
        return "YOU'RE SHOUTING!"
    else:
        return "Can you speak up?"

shout("I'M INTERESTED IN SHOUTING")

The example above is just there to help you remember how functions are structured.

Don't forget the colon at the end of your function definition!
Instructions

    First, def a function called cube that takes an argument called number. Don't forget the parentheses and the colon!
    Make that function return the cube of that number (i.e. that number multiplied by itself and multiplied by itself once again).
    Define a second function called by_three that takes an argument called number.
    if that number is divisible by 3, by_three should call cube(number) and return its result. Otherwise, by_three should return False.

Don't forget that if and else statements need a : at the end of that line!
Exercice answer :
def cube(number):
    return number * number * number
    
def by_three(number):
    if number % 3 == 0:
        return cube(number)
    else:
        return False

#I  Know Kung Fu

Remember import this from the first exercise in this course? That was an example of importing a module. A module is a file that contains definitions—including variables and functions—that you can use once it is imported.
Instructions

Before we try any fancy importing, let's see what Python already knows about square roots. On line 3 in the editor, ask Python to

print sqrt(25)

which we would expect to equal five.

 Ask Python to print sqrt(25) on line 3.

print sqrt(25)
Avec l'erreur suivante :
Traceback (most recent call last):
  File "python", line 3, in <module>
NameError: name 'sqrt' is not defined



#Generic Imports

Did you see that? Python said: "NameError: name 'sqrt' is not defined." Python doesn't know what square roots are—yet.

There is a Python module named math that includes a number of useful variables and functions, and sqrt() is one of those functions. In order to access math, all you need is the import keyword. When you simply import a module this way, it's called a generic import.
Instructions

You'll need to do two things here:

    Type import math on line 2 in the editor.
    Insert math. before sqrt() so that it has the form math.sqrt(). This tells Python not only to import math, but to get the sqrt() function from within math.

Then hit Save & Submit to see what Python now knows.

# Ask Python to print sqrt(25) on line 3.
import math
print math.sqrt(25)

5.0
None


#Function Imports

Nice work! Now Python knows how to take the square root of a number.

However, we only really needed the sqrt function, and it can be frustrating to have to keep typing math.sqrt().

It's possible to import only certain variables or functions from a given module. Pulling in just a single function from a module is called a function import, and it's done with the from keyword:

from module import function

Now you can just type sqrt() to get the square root of a number—no more math.sqrt()!
Instructions

Let's import only the sqrt function from math this time. (You don't need the () after sqrt in the from math import sqrt bit.)

# Import *just* the sqrt function from math on line 3!
from math import sqrt
sqrt(5)

None


#Universal Imports

Great! We've found a way to handpick the variables and functions we want from modules.

What if we still want all of the variables and functions in a module but don't want to have to constantly type math.?

Universal import can handle this for you. The syntax for this is:

from module import *

Instructions

Use the power of from module import * to import everything from the math module on line 3 of the editor.

# Import *everything* from the math module on line 3!
from math import *
sqrt(5)

None

#Here Be Dragons

Universal imports may look great on the surface, but they're not a good idea for one very important reason: they fill your program with a ton of variable and function names without the safety of those names still being associated with the module(s) they came from.

If you have a function of your very own named sqrt and you import math, your function is safe: there is your sqrt and there is math.sqrt. If you do from math import *, however, you have a problem: namely, two different functions with the exact same name.

Even if your own definitions don't directly conflict with names from imported modules, if you import * from several modules at once, you won't be able to figure out which variable or function came from where.

For these reasons, it's best to stick with either import module and type module.name or just import specific variables and functions from various modules as needed.
Instructions

The code in the editor will show you everything available in the math module.

Click Save & Submit Code to check it out (you'll see sqrt, along with some other useful things like pi, factorial, and trigonometric functions).

import math            # Imports the math module
everything = dir(math) # Sets everything to a list of things from math
print everything       # Prints 'em all!

['__doc__', '__name__', '__package__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'modf', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc']
None


#On Beyond Strings

Now that you understand what functions are and how to import modules, let's look at some of the functions that are built in to Python (no modules required!).

You already know about some of the built-in functions we've used with strings, such as .upper(), .lower(), str(), and len(). These are great for doing work with strings, but what about something a little more analytic?
Instructions

What do you think the code in the editor will do? Click Save & Submit Code when you think you have an idea.

Question :
def biggest_number(*args):
    print max(args)
    return max(args)
    
def smallest_number(*args):
    print min(args)
    return min(args)

def distance_from_zero(arg):
    print abs(arg)
    return abs(arg)


biggest_number(-10, -5, 5, 10)
smallest_number(-10, -5, 5, 10)
distance_from_zero(-10)

Answer :

10
-10
10
None

#
max()

The max() function takes any number of arguments and returns the largest one. ("Largest" can have odd definitions here, so it's best to use max() on integers and floats, where the results are straightforward, and not on other objects, like strings.)

For example, max(1,2,3) will return 3 (the largest number in the set of arguments).
Instructions

Try out the max() function on line 3 of the editor. You can provide any number of integer or float arguments to max().

# Set maximum to the max value of any set of numbers on line 3!

maximum = 

print maximum

# Set maximum to the max value of any set of numbers on line 3!

maximum = max(5, 7.7, 0.2)

print maximum

7.7
None


#
min()

min() then returns the smallest of a given series of arguments.
Instructions

Go ahead and set minimum equal to the min() of any set of integers or floats you'd like.


# Set minimum to the min value of any set of numbers on line 3!

minimum = min(4, 543445566, 7777655887765)

print minimum

4
None

#
abs()

The abs() function returns the absolute value of the number it takes as an argument—that is, that number's distance from 0 on an imagined number line. For instance, 3 and -3 both have the same absolute value: 3. The abs() function always returns a positive value, and unlike max() and min(), it only takes a single number.
Instructions

Set absolute equal to the absolute value of -42 on line 2.

absolute = abs(-42)

print absolute

42
None

#
type()

Finally, the type() function returns the type of the data it receives as an argument. If you ask Python to do the following:

print type(42)
print type(4.2)
print type('spam')

Python will output:

<type 'int'>
<type 'float'>
<type 'str'>

Instructions

Have Python print out the type of an int, a float, and a str string in the editor. You can pick any values on which to call type(), so long as they produce one of each.


# Print out the types of an integer, a float,
# and a string on separate lines below.
print type(5)
print(type(4.4))
print(type("lapin"))

<type 'int'>
<type 'float'>
<type 'str'>
None

# 
Review: Functions

Okay! Let's review functions.

def speak(message):
    return message

if happy():
    speak("I'm happy!")
elif sad():
    speak("I'm sad.")
else:
    speak("I don't know what I'm feeling.")

Again, the example code above is just there for your reference!
Instructions

    First, def a function, shut_down, that takes one argument s. Don't forget the parentheses or the colon!
    Then, if the shut_down function receives an s equal to "yes", it should return "Shutting down"
    Alternatively, elif s is equal to "no", then the function should return "Shutdown aborted".
    Finally, if shut_down gets anything other than those inputs, the function should return "Sorry"

def shut_down(s):
    if s == "yes":
        return "Shutting down"
    elif s == "no" :
        return "Shutdown aborted"
    else :
        return "Sorry"

None

#Review: Modules

Good work! Now let's see what you remember about importing modules (and, specifically, what's available in the math module).
Instructions

Import the math module in whatever way you prefer. Call its sqrt function on the number 13689 and print that value to the console.

from math import sqrt
sqrt(13689)
print(sqrt(13689))

117.0
None

#
Review: Built-In Functions

Perfect! Last but not least, let's review the built-in functions you've learned about in this lesson.

def is_numeric(num):
    return type(num) == int or type(num) == float:

max(2, 3, 4) # 4
min(2, 3, 4) # 2

abs(2) # 2
abs(-2) # 2

Instructions

    First, def a function called distance_from_zero, with one argument (choose any argument name you like).
    If the type of the argument is either int or float, the function should return the absolute value of the function input.
    Otherwise, the function should return "Nope"

def distance_from_zero(number):
    if type(number) == int or type(number) == float:
        return abs(number)
    else:
        return "Nope"

None




