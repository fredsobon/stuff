==== short resume python : zero ====

=== intro /base python ===

= chaine de caracteres = 

il est possible d'ecrire des chaines de carateres str entre :
""
''
ou 
""" """ si on veut rediger du multiligne

il faudra proteger nos caractères speciaux comme le " ' "  avec un "\" ex :
>>> a = 'l\'huile'
>>> a
"l'huile"
>>> a = "\"mon beau sapin\""
>>> a
'"mon beau sapin"'

>>> a = """mon
... beau
... sapin"""
>>> a
'mon\nbeau\nsapin'
on voit ici le retour chariot "\n" qui s'affiche ...


= type =


>>> a = "lapin"
>>> type(a)
<type 'str'>
>>> a = 32
>>> type(a)
<type 'int'>
>>> a = 3.4
>>> type(a)
<type 'float'>
>>>a  = True
>>> type(a)
<type 'bool'>
>>> b = False
>>> type(b)
<type 'bool'>


= if / else / elif =

#!/usr/bin/env python3
#-*-coding: utf8 -*-
import os 


b = input("gimme a year : ")

print("ok you gave me " + str(b))
year = int(b)


if year % 4 == 0 or year % 400 == 0:
    print("you got it!")
else:
    year % 100 == 0
    print("nop")


- construction  elif 

cat elif.py 
#!/usr/bin/env python3


# -*- coding: utf8 -*-

a=int(input("gimme me a number ! " ))

if a > 0:
    print("ok you gave me a positive number !")
elif  a < 0:
    print("ok you gave me a negative number !")
else:
    print("hey for sure you gave me a zero !")


= operateurs =

+ - * / % 
> < 
>= <= 
== égalité 
!= différence 


= and /or /not =

#!/usr/bin/env python3

a = int(input("hey gimme a number smaller than 10 !"))

if  a > 4 and a < 10:
    print(a, " ..is in the upper range !!")
elif a > 0 or a < 4:
    print(a, "..is in the lower range !!")
else:
    print("did you miss something ??")


>>> a = 5
>>> type(a) is int
True

>>> type(a) is not str
True

>>> type(a) is not str and type(a) is not float and type(a) is not list and type(a) is not tuple and type(a) is not dict and type(a) is not bool
True



= while =

#!/usr/bin/env python3
#-*-coding: utf8 -*-

multi = 7
digit = 0

while digit < 11:
    print(digit * multi )
    digit += 1



= for = 

#!/usr/bin/env python3
#-*-coding: utf8 -*-

word = "ragoutoutou"

for w in word:
    if w in "aeiouy":
        print("hey yougot voyel :" + w)
    else:
        print("secret char: ###")

= input / raw_input =

#!/usr/bin/env python
# -*- coding: utf8 -*-

nom=raw_input("hello, what's yo name ? ")
print("hugh ..." + nom)
raw_input("press please the touche entrée ...")



= break = 

break va permettre de stopper une boucle 

#!/usr/bin/env python3
#-*-coding: utf8 -*-

while True:
    a = input("gimme the secret to quit :" )
    print("you gave me " + a)
    if a  in "qQ":
        print("ok bye")
        break
    else:
        print("try again")

= continue = 

continue va permettre de recommencer immédiatement au point de départ de notre boucle for ou while sans executer les lignes de code suivant ce mot clé.





= list = 

#!/usr/bin/env python
# -*- coding: utf8 -*-


# On defini une variable.
name="maggie"

# on commence à compter à partir de 0 : omer=0 marge=3 . On peut creeer une liste vide []. On peut melanger les types.
lst=["omer", "bart" , "lisa" , "marge"]

print(lst[2])

# va afficher lisa
# pour un intervalle on inclu la première borne et on exclu la dernière : lst[1:3]

print(lst[1:3])

# va afficher ['bart', 'lisa']

#print(lst[:2])  : on affiche tout jusqu'à 2 exclu
#print(lst[:]) : on affiche tous les elements. on peut définir une nouvelle liste qui sera une copie de notre liste:
liste2=lst[:]

#python considere le texte comme une liste de lettres :
print("texte"[1:3]) 

# on va voir qu'on peut modifier une liste. Ici on copie notre liste . On affecte la valeur de la variable name à l'element 2 de notre liste : 
simpson=lst

lst[2]=name

print(lst)

# on a donc dans la liste lst et simpson les valeurs :["omer", "bart" , "maggie" , "marge"] .Simpson est un alias de lst

# Si on affiche liste2 : elle n'aura pas changée : ["omer", "bart" , "lisa" , "marge"] . 

# il faut faire attention au copies.

# boucle for

for elem in lst:
    print("hello , in the loop")
    print elem

#hello , in the loop
#omer
#hello , in the loop
#bart
#hello , in the loop
#maggie
#hello , in the loop
#marge

#!/usr/bin/env python3
#-*-coding: utf8 -*-

i = 1
while i < 10:
    if i % 2 == 0:
        print("hey even number ... " + str(i))
        i += 1
        continue
    print("odd one : " + str(i))
    i += 3

= type /methodes =

#!/usr/bin/env python
# -*- coding: utf8 -*-

# int() ; raw_input() ; str() ... : une fonction retourne une donnée. var=fonction(truc)  print var. 
# le retour de la fonction est different en fonction de ce sur quoi elle s'applique.Exemple différence entre le len("mot") len("lapin"," "lulu") : on a d'un coté le nombre de lettre du mot et dans l'autre exemple le nombre d'élement de la liste .

print(len("monty"))
print(len(["lapin", "lulu"]))


print(range(5))
compte=3

for x in range(compte):
    print("hip")


#[0, 1, 2, 3, 4]
#hip
#hip
#hip
#

# Une methode est attachée au type . Pour appeller une fonction , on tape son nom et entre parenthese ses params: fonction(param) Pour invoquer /appeller une methode , on saisi le nom_var.nom_methode(param) . 
# On voit ici clairement les methodes associées au type str . La methode upper met tout en maj , la methode capitalize met 'initale en maj , la methode title met toutes les premieres lettres en maj ( utiles pour nom composés) :
nom="napoleon"
print(nom.upper())
print(nom.capitalize())

name="Louis-philipPE"
print(name.title())

# on peut nettoyer le code ; les entrees des users : exemple supprimer des espaces en trop avec strip :

a="          ..blabla avec plein d'espaces au debut et à la fin....       "
print(a)

print(a.strip())

#nous affiche dans un premier temps          ..blabla avec plein d'espaces au debut et à la fin....       puis clean des espaces :
#..blabla avec plein d'espaces au debut et à la fin....


#On peut transformer du texte en liste en utilisant un separateur :
b="lapin,lulu,lili"
print(b)
print(b.split(","))

# nous affiche bien les mots , puis une liste dont le sep est la ","
#lapin,lulu,lili
#['lapin', 'lulu', 'lili']



= fonction = 

on regroupe nos différents blocs de  code au sein de fonctions  pour les rappeller plus facilement , factoriser et eviter toute répétition inutile. 

def nom _d e_la_fonction ( parametre1 , parametre2 , parametre3 ,parametreN ) :
# Bloc d ' instructions
Les paramètres sont séparés par des "," .
>>> def test(a, b, c):
...     print(a + b + c)
... 
>>> test(1,1,1)
3
>>> test(5,7,8)
20
Il va falloir respecter le nombre d'arguments fournis sous peine d'erreurs ... 
>>> test(5,7,8,4)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: test() takes 3 positional arguments but 4 were given
>>> test(5,7)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: test() missing 1 required positional argument: 'c'

on peut définir une valeur par défaut si un arg n'est pas fourni (voir exemple aprs avec docstring :

= docstring = 

on ajoute une petite explication de texte à notre fonction que l'on encadre par des triple " , qui pourra être consulter via l'appel à la fonction help(nom_de_fonction) : c'est une très bonne habitude il faut documenter nos fonctions . 


#!/usr/bin/env python3
#-*-coding: utf8 -*-

def fonction(nb , max = 10):
    """ fonction affichant la table de multiplication de n par multi jusqu'à la valeur max. Ici on defini la valeur par defaut de max à 10: si le user ne saisi pas de param 'max'"""
    i = 1
    while i < max:
        print("hey let's count : ", i * nb)
        i +=1
    return 
        
#fonction(2, 11)
fonction(4)

l'appel a help(fonction) affiche notre docstring : 

help(fonction)

/!\ a voir : on peut mettre les param dans le désordre si on les identifie par des noms.


>>> fonc()
(' a = ', 1, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(4)
(' a = ', 4, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(a=1)
(' a = ', 1, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(a=7)
(' a = ', 7, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(b=2, c=3)
(' a = ', 1, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(b=33, c=77)
(' a = ', 1, ' b = ', 33, ' c = ', 77, ' d = ', 4, ' e = ', 5)
>>> fonc( a =1 , b =2 , c =3 , d =4 , e = 5 )
(' a = ', 1, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(88)
(' a = ', 88, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(88,43)
(' a = ', 88, ' b = ', 43, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(88,43,11,78,54)
(' a = ', 88, ' b = ', 43, ' c = ', 11, ' d = ', 78, ' e = ', 54)

La signature de fonction en python est simplement son nom.

= return = 

L'instruction return signifie qu'on va renvoyer  le resultat d'une fonction, sa valeur pour ensuite pouvoir par exemple la stocker dans une variable.
/!\ attention tout le code situé après return ne s'executera pas.

on va pouvoir envoyer des données en entrées à nos fonctions et renvoyer une information avec le keyword return.



>>> def square(val):
...     return val * val
... 
>>> new = square(4)
>>> print(new)
16

On peut renvoyer  plusieurs valeurs séparées par des virgules.


= lambda = 

ce  keyword permet de créer des fonctions  qui seront extremement courtes.
on utilise donc le keyword lambda suivi d'un nombre d'argument désiré puis un ":" et ensuite l'instruction de la lambda. 
on va stocker notre lambda dans une variable car il n'y a pas le moyen de l'appeller directement.

#!/usr/bin/env python3
#-*-coding: utf8 -*-

f = lambda x: x * x

print(f(5))
Pour utiliser deux  param dans  notre lambda on pourra par exemple faire : 

>>> z = lambda x, y: x * y
>>> z(2,4)


= modules = 

 un module est du code ecrit dans un fichier.On defini des fonctions, variables.
Si l'on veut travailler avec elles , il faut donc simplement importer le module.

On importe un module avec par exemple le keyword import.
On peut ensuite examiner les différentes fonctions et particularités du module avec la fonction help(module) 

>>> import os
>>> help(os)
...
Help on module os:

NAME
    os - OS routines for NT or Posix depending on what system we're on.

FILE
    /usr/lib/python2.7/os.py

MODULE DOCS
....


on peut egalement examiner l'aide d'une fonction d'un module :


>>> help(os.chmod)

Help on built-in function chmod in module posix:

chmod(...)
    chmod(path, mode)
    
    Change the access permissions of a file.


    
#!/usr/bin/env python3
#-*-coding: utf8 -*-

import math
import math as matos
from math import fabs

print("""3 methodes d'import de modules : import module + import module as mod + from module import fonc""")


print(math.sqrt(5))
print(matos.sqrt(4))
print(fabs(-3))


#!/usr/bin/env python3
#-*- coding: utf8 -*-

import os 

year = input("gimme a year : ")
year = int(year)

if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):
    print("year is bissextile !")
else:
    print(year , "classic year")



os.system("date")
print("here's the content of tmp folder : " )
os.system("ls -lh /tmp")

 



#!/usr/bin/env python3
# -*- coding: utf8 -*-

import os 

from dix_10_multipli import *

# test de la fonction table

table(3,20)
os.system("sleep 2")
#!/usr/bin/env python3
#-*- coding: utf8 -*-

"""module multipli contenant la fonction table"""


import os

def table (nb, max =10):
    """Fonction affichant la table de multiplication par nb de 1 * nb jasqu'à max nb """
    i = 0
    while i < max:
        print(i + 1, "*" ,nb, "=", (i + 1) * nb)
        i +=1

# test de la fonction table 

if __name__ == "__main__":
    table(5)
    os.system("date +%F")


= espace de nommage =

On doit faire attention avec le nom de nos fonctions, ou variables  afin de ne pas avoir de conflit avec des fonctions internes d'un module :
Si on defini une variable ou fonction math ...on aura un souci avec l'utilisastrion du module du même nom ..

>>> math = 2
>>> import math
>>> nombre = math * 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for *: 'module' and 'int'

 On peut importer un module sous un autre bom ( rarement utilisé )

>>> import math as mathematique
>>> mathematique.sqrt(2)
1.4142135623730951

 
on peut sinon importer uniquement le fonction d'un module dont on a besoin :

>>> from os import getcwd
>>> getcwd()
'/home/boogie/Documents/stuff/python'

= encodage =
Il est nécéssaire d'avoir une interpretation correcte des caractères (accents etc ..)

# -* - coding : ENCODAGE -*

sous linux on utilisera très souvent :

# -*- coding : utf8 -*-

sous windows on peut devoir utiliser 
# -*- coding : Latin1 -*-

= creation de module : =

les modules ne sont que des fichiers plats qui seront dans unbe arbo precise et appellés dans nos script python:
ex :
on cree deux fichiers : le premier comporte la fonction de notre module.
le second est un test de notre module de fonction. 
tree module_test/
module_test/
├── multipli.py
└── test.py


 ~/Documents/stuff/python/misc/zero  ⑂ master +  $  cat module_test/multipli.py 
#!/usr/bin/env python3

# -*- coding: utf8 -*-

""" module multipli : affiche une table de multiplication."""

def multi(nb, max = 10):
    """ fonction de table de multiplication. Un nb en param :celui qui sera l'élément à multiplier . Un second param optionnel qui sera le multiplicateur : s'il est omis par défaut 10 sera utilisé. """
    i = 0
    while i < max:
        print( nb , "x", i, "=" , nb  * i )
        i += 1

 ~/Documents/stuff/python/misc/zero  ⑂ master +  $  cat module_test/test.py 
#!/usr/bin/env python3

import os

from multipli import *

multi(4, 5)

os.getcwd()


Quand on executera le fichier test.py :

 ./test.py 
4 x 0 = 0
4 x 1 = 4
4 x 2 = 8
4 x 3 = 12
4 x 4 = 16

on aura bien nos appels à la fonctions définie dans le fichier multipli.py et importée dans test.py
On aura après l'execution l'aparition de code semi compilé dans notre repertoire : 

$  tree
.
├── multipli.py
├── __pycache__
│   └── multipli.cpython-35.pyc
└── test.py

= test de module interne : =

on va pouvoir tester notre module directement au sein de celui-ci : comme si notre module etait un programme a lui seul. 
ex: il pourrait être bon de vérifier que notre fonction 
def multi(nb, max = 10): fonctionne correctement au sein de notre module 


On peut ajouter du code qui doit être ajouter quand on lance le module directement pour le tester ou lorsque l'on cherche à l'importer.

on va rajouter dans notre module après notre fonction :


# test de la fonction multi
if __name__ == " __main__ " :
multi ( 4 )
os . system ( " pause " )


On pourra donc tester notre fonction en lancant le script python : la table de multi de 4 sera affichée. si on invoque uniquement le script de la fonction du module crée.
Si on importe le module / fonction dans le fichier test.py crée prcedemment : la table de n'apparaitra pas.

La variable __name__ est créee automatiquement au lancement de l'interpréteur python. Si elle vaut __main__ ( qui veut dire que le fichier appellé est celui qui est executé ) : on peut ajouter du code qui ne sera executé qu'a l'invocation du programme lancé comme un executable.



= package = 

moyen de regrouper plusieurs fonctions (classes aussi) : on peut regrouper des modules dans des packages .
On peut ranger plus proprement nos modules, fonctions et classes python. On va devoir fournir le chemin complet pour acceder a nos modules : ce qui permet d'eviter d'eventuels conflits.
Ceci est forcemement tres pratique lors de l'install de package / bibliotheque les objets sont de base categoriser par type , role et la hierarchisation est essentielle.

en pratique un package est un repertoire qui peut contenir d'autre packages ou des modules.
Pour l'import on utilise la même méthode que les modules 

from package import module 
import package 


pour l'acces a un sous package / module : la separation avec le point se fait comme pour les modules :

biblio.objects_graphiques
biblio.objects_graphiques.formes_carrees

Si on veut importer un seul module ou fonction d'un package on peut le faire assez intuitivement comme ceci :

from biblio.objects_graphiques import buttons

Creation de package :

on creee un rep du nom du package puis on y met nos module portant l'extension py

 tree package/
package/
└── un_1_fonctions.py

Il n'est pas rare dans le repertoire du package d'avoir un fichier de type :
__init__.py qui sera le fichier d'initialisation du package qui contiendra le code d'initialisation de notre package ( ceci n'est plus obligatoire depuis python 3.3 

pour illustrer le propos : on créee un fichier test_package.py puis au même niveau un rep package au sein duquel on ajoute notre fonction / module table de multiplication.
On va importer notre package dans notre fichier de test de package .


 tree
.
├── package
│   ├── fonction.py
└── test_package.py


 cat package/fonction.py 
#!/usr/bin/env python3


# -*- coding: utf8 -*-


def table(nb, max=5):
    """ fonction table : va nous afficher la table de multi de arg1  X arg2 (avec arg2 optionnel valant 5 si nom defini. """

    i = 1
    while i <= max:
        print(nb, "X", i, "=", nb * i)
        i += 1
if __name__ == "__main__":
    table(4,3)
    print("hey we are testing", "__main__")


cat test_package.py 
#!/usr/bin/env python3

# -*- coding: utf8 -*-

from package.fonction import table
table (5) # Appel de la fonction table

# Ou ...import package . fonctions
#fonctions.table (5) # Appel de la fonction table


#!/usr/bin/env python3
#-*- coding: utf8 -*-

import os

"""module multipli contenant la fonction table"""

def table (nb, max =10):
    """Fonction affichant la table de multiplication par nb de 1 * nb jusqu'à max nb """
    i = 0
    while i < max:
        print(i + 1, "*" ,nb, "=", (i + 1) * nb)
        i +=1
# on a un moyen de pouvoir tester la validité de notre fonction en utilisant la méthode suivante : tester la fonction en lancant le script lui-même permet de setter  les variables python  '__name__' et '__main__' et donc invoquer notre fonction directement au sein du script . Si l'appel est externe alors le test __name__ == "__main__" n'est pas vrai donc pas de suite. Cette méthode est TRES utilisée.

if __name__ == "__main__":
    table(5)
    os.system("date +%F")



= exeption : try /except = 

quand python rencontre une erreur dans le code ou dans une opération à executer : il lève une exeption.
on a différents types d'exeptions qui dependent des erreurs rencontrées.
ex : ValuesError : pb de valeur / type de données 

- forme minimale : ( utilisable pour l'exemple et quand nous n'avons pas beaucoup de tests et de cas d'erreurs possibles : 
on va donc avoir 
python qui execute une action 
si l'action est ok -> il continue
si il y a une erreur -> on peut lui demander de tester autre chose .
On utilise pour cela le bloc de forme :
try / exept : 

try:
    # bloc à essayer
except:
    # bloc qui sera executé en cas d'erreur.

exemple : 
annee = input ()
try : # On essaye de convertir l ' ann é e en entier
    annee = int ( annee )
except :
    print ( " Erreur lors de la conversion de l ' ann é e . " ) 
 
- forme complète :

c'est la forme privilégiée qu'il faudra utiliser.
On va completer notre bloc try en permet d'agir sur une type d'exeption précise lors du passage a except 


>>> a = "a"
>>> b = "b"
>>> try: 
...     res = a / b
... except: 
...     print("an error appeared ..which one ..?")
... 
an error appeared ..which one ..?

on peut avoir plusieurs type d'erreurs ex :
> NameError (var / noms : pas définis)
> TypeError : pas possible de diviser ex lettre 
> ZeroDivisionError : pb si on divise par 0
 
n va donc  pouvoir renseigner apres except la type d'exeption et cze qu'on veut traiter :

>>> a = "a"
>>> b = "b"
>>> try: 
...     res = a / b
... except TypeError: 
...     print("hey on ne divise pas des bananes par des enclumes ! ")
... 
hey on ne divise pas des bananes par des enclumes ! 

On peut cumuler et definir des actions pour différents type :

try :
    resultat = numerateur / denominateur
except NameError :
    print ("La variable numerateur ou denominateur n'a pas été définie.")
except TypeError :
    print ("La variable numerateur ou denominateur possè de untype incompatible avec la division")
except ZeroDivisionError :
    print ("La variable denominateur est égale à 0.")

On peut capturer l'exeption et afficher son message avec le keyword as :

try :
# Bloc de test
except type_de_l_exception as exception_retournee :
    print ( " Voici l ' erreur : " , exception_retournee )

dans ce cas une variable "exception_retournee" est créee si une exeption de type "type_de_l_exception" est rencontrée.

Il est très conseillé de saisir le type d'exeption après except.

= else / finally = 

else :

dans une bloc d'exeption on peut utilser else s'il n'y a pas d'erreur.

try :
    resultat = numerateur / denominateur
except NameError :
    print ( " La variable numerateur ou denominateur n 'a pas é t é dé finie . " )
except TypeError :
    print ( " La variable numerateur ou denominateur possède un type incompatible avec la division . " )
except ZeroDivisionError :
    print ( " La variable denominateur est é gale à 0 . " )
else :
    print ( " Le résultat obtenu est " , resultat )


finally :

permet d'executer du code apres l'execution du bloc try qu'il y ait des erreurs ou pas MEME si une instruction return est definie dans le bloc except

try :
# Test d ' instruction ( s )
except TypeDInstruction :
    # Traitement en cas d ' erreur
finally :
    # Instruction(s) exécutée(s) qu'il y ait eu des erreurs ou non


= pass =
on peut vouloir continuer à dérouler notre code dans un bloc try même s'il y a une erreur .
Comme l'instruction try ne peut être seule on peut la combiner avec le keyword pass 

try :
    # Test d ' instruction ( s )
except type_de_l_exception : # Rien ne doit se passer en cas d 'erreur
    pass

pas forcemment utile mais à connaitre en cas de lecture dans du code.


= les assertions = 

c'est un moyen simple de s'assurer avant de continuer que les conditions sont bien respectées : on les utilise tres souvent dans les blocs try ..except 
 
on va utiliser le keyword assert 

assert test : si le resulat est True alors on continue sinon une exeption de type : AssertionError est levée.

ex :
>>> var = 5
>>> assert var == 5
>>> assert var == 7
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError

on peut tester que pour tester si une année saisie par un user  est superrieur a 0 et lever une exeption si elle ne l'est pas.

annee = input ( " Saisissez une ann é e sup é rieure à 0 : " )
try :
    annee = int (annee) # Conversion de l'année
    assert annee > 0
except ValueError :
    print ( " Vous n 'avez pas saisi un nombre." )
except AssertionError :
    print ("L'année saisie est inférieure ou égale à 0." )


= Lever une exeption =

on va utiliser le mot clé raise : on va surtout utiliser ces methode pour tester les classes que l'on crée.

raise TypeDeLException ("message à afficher")

on va ici lever une exeption si l'annee saisie est null ou negative et on va dans la foulée l'interceptée : on peut biensur faire différemment mais c'est pour illustrer par un exemple.

annee = input () # L'utilisateur saisit l'année
try :
    annee = int (annee) # On tente de convertir l 'année
if annee <= 0 :
    raise ValueError ( "l 'année saisie est négative ou nulle ")
except ValueError :
    print("La valeur saisie est invalide (l' année est peut  être négative). " )



== FIN INTRO PYTHON ==


===  programmation objet pout utilisateur === 

L'objet est une notion fondamentale en python : en python tout est objet.
Un objet est une structure de donnée (texte, variable ...)qui peut elle même contenir des variables, fonctions etc ...

= les chaines de caractères =

on va pouvoir travailler sur des methodes ( fonctions dédiées à un type de donnée) propres aux chaines de caractère

ex : passer en minuscule du texte :

>>> a = "PLEASE SHUT UP!"
>>> a.lower()
'please shut up!'

on voit donc ici que lower est une fonction de la variable "a". C'est une fonction qui s'appliquera donc a toutes les chaines de caractères.
En saisissant type(notre_objet) on a son type :

>>> a = "lapin"
>>> type(a)
<class 'str'>

on voit qu'un objet est issu d'une classe 
Une classe est une forme de type de données , elle permet de définir des  fonctions et des variables propres aux types.
on a donc ici la fonction lower qui a été définie dans la classe "str".
 
Les fonctions définies dans des classes sont appellées des methodes.

on appelle donc une methode d'un objet par le "." : objet.methode.
Une classe est un modele qui servira a construire un objet. C'est dans la classe que l'on va définir les méthodes propres à l'objet.

exemple de methode:
# upper passe en maj :
>>> a = "testo"
>>> a.upper()
'TESTO'
# capitalize passe la premiere initiale en maj :
>>> a.capitalize()
'Testo'
>>> a = "    some space in front and at the end ...   "
# strip supprime les espaces en debut et à la fin des str :
>>> a.strip()
'some space in front and at the end ...'
>>> b = " some texte!"

# upper et center(nb) : center va permettre d'ajouter / aligner notre txt en ajoutant un nombre définie d'espace jusqu'a ce que notre chaine fasse le nombre défini dans la methode center(nb)  
>>> b.upper().center(20)
'     SOME TEXTE! 

On peut biensur cumuler :
>>> b.upper().center(20)
'     SOME TEXTE! 


= formatage de chaine = 
on va pouvoir utiliser une fonction elegante du modele objet pour afficher notre texte.

>>> name = "Bob"
>>> surname = "Kool"
>>> age = 77
>>> print("my name is {0} {1} and i'm {2} years old !!" .format(name,subname,age))
my name is Bob Kool and i'm 77 years old !!

On voitr que la methode format va remplacer chaque element present entre {} par la valeur de la variable correspondant à son ordre de définition.  ( on commence toujours en programmation a compter à partir de 0 )

On peut biensur afficher nos valeurs dans un ordre différents  






#!/usr/bin/env python3
# -*- coding: utf8 -*-

import os

annee = input("hey gimme me a number plz :")

# on essaye de convertir en entier la chaine retournée par le user 
try:
    annee = int(annee) 
# si la conversion n'est pas possible ( aka si le code retour de l'instruction n'est pas ok alors on agit differement  
except:
    print("hey no way ! a number do you understand ?")

#!/usr/bin/env python3
#-*- coding: utf8 -*-

# var pour le try :
#a = 6
#b = 3

# var pour exception NameError :
##a =  
#b = 2

# var pour exception TypeError :
#a = 4
#b = "t"

# var pour exception ZeroDivisionError :
#a = 5
#b = 0


try:
    result = a / b
    print("good game ! here's the result :", result)

# on defini maintenant quelques exceptions en fonctions des valeurs saisies et du resultat 

# ici souci : a ou b ne sont pas définis : NameError
except NameError:
    print("nop there's a pb . did you give a number for the the two letter ?")

# ici : une des deux variables contient autre chose qu'un nombre
except TypeError:
    print("do you remember that a number should only contain numbers ?")

# ici on essaye de diviser par zero : l'exception dediée est levée.
except ZeroDivisionError:
    print("no way ..0 can be record for divisor")    
#!/usr/bin/env python3
#-*- coding: utf8 -*-

# var pour le try :
#a = 6
#b = 3

# var pour exception NameError :
##a =  
#b = 2

# var pour exception TypeError :
#a = 4
#b = "t"

# var pour exception ZeroDivisionError :
#a = 5
#b = 0


try:
    result = a / b
    print("good game ! here's the result :", result)

# on defini maintenant quelques exceptions en fonctions des valeurs saisies et du resultat 

# ici souci : a ou b ne sont pas définis : NameError
except NameError as pb_def :
    print("nop there's a pb . did you give a number for the the two letter ?", pb_def)

# ici : une des deux variables contient autre chose qu'un nombre
except TypeError as pb_type:
    print("do you remember that a number should only contain numbers ?", pb_type)

# ici on essaye de diviser par zero : l'exception dediée est levée.
except ZeroDivisionError as pb_zero:
    print("no way ..0 can be record for divisor", pb_zero)    



= finally =


#!/usr/bin/env python3
#-*- coding: utf8 -*-


import os

# var pour le try :
#a = 6
#b = 3

# var pour exception NameError :
##a =  
#b = 2

# var pour exception TypeError :
#a = 4
#b = "t"

# var pour exception ZeroDivisionError :
#a = 5
#b = 0

# ici on ne fait que l'opération dans le try :
try:
    result = a / b

# on defini maintenant quelques exceptions en fonctions des valeurs saisies et du resultat 

# ici souci : a ou b ne sont pas définis : NameError
except NameError as pb_def :
    print("nop there's a pb . did you give a number for the the two letter ?", pb_def)

# ici : une des deux variables contient autre chose qu'un nombre
except TypeError as pb_type:
    print("do you remember that a number should only contain numbers ?", pb_type)

# ici on essaye de diviser par zero : l'exception dediée est levée.
except ZeroDivisionError as pb_zero:
    print("no way ..0 can be record for divisor", pb_zero)    
# on pose un else qui va affcicher le resultat de l'opération  on dissocie cette instruction du try : c'est plus "propre" 
else:
    print("good game ! here's the result :", result)

# ici on execute une commande quel que soit le resultat du try et des excepts, else . Le bloc après finally sera donc toujours executé même si des erreurs ou des codes retour de fonctions apparaissent avant dans  notre  programme:

finally:
    os.system("date +%F-%H-%M")


= pass =

#!/usr/bin/env python3
#-*- coding: utf8 -*-


import os

# var pour le try :
#a = 6
#b = 3

# var pour exception NameError :
##a =  
#b = 2

# ici on ne fait que l'opération dans le try :
try:
    result = a / b


# ici on rajoute "pass" : on peut l'utiliser quand on veut tester un bloc mais ne rien faire si on rencontre une erreur. On ne peut pas le faire avec un try seul ..il faut donc rajouter pass qui ne fait rien même en cas d'exception rencontrées ( pas vraiment d'interet mais il est bon de savoir que ce mot clé existe. on peut l'avoir dans des fonctions qu'on veut vides , conditions etc ...

except: 
    pass



= assert = 
 

#!/usr/bin/env python3
#-*- coding: utf8 -*-

year = input("gimme a year upper than 0 :")

try:
    year = int(year)
    assert year > 0
except ValueError as number_plz:
    print("hey wake up !" , number_plz)
except AssertionError:
    print("did you read ?")
#!/usr/bin/env python3
#-*- coding: utf8 -*-

year = input("gimme a year upper than 0 :")

try:
    year = int(year)
    if year <= 0:
        raise ValueError("yop ..upper than 0 plz !")
except TypeError:
    print("no way ! ")




