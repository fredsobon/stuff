==== short resume python : zero ====



= chaine de caracteres = 

il est possible d'ecrire des chaines de carateres str entre :
""
''
ou 
""" """ si on veut rediger du multiligne

il faudra proteger nos caractères speciaux comme le " ' "  avec un "\" ex :
>>> a = 'l\'huile'
>>> a
"l'huile"
>>> a = "\"mon beau sapin\""
>>> a
'"mon beau sapin"'

>>> a = """mon
... beau
... sapin"""
>>> a
'mon\nbeau\nsapin'
on voit ici le retour chariot "\n" qui s'affiche ...


= type =


>>> a = "lapin"
>>> type(a)
<type 'str'>
>>> a = 32
>>> type(a)
<type 'int'>
>>> a = 3.4
>>> type(a)
<type 'float'>
>>>a  = True
>>> type(a)
<type 'bool'>
>>> b = False
>>> type(b)
<type 'bool'>


= if / else / elif =

#!/usr/bin/env python3
#-*-coding: utf8 -*-
import os 


b = input("gimme a year : ")

print("ok you gave me " + str(b))
year = int(b)


if year % 4 == 0 or year % 400 == 0:
    print("you got it!")
else:
    year % 100 == 0
    print("nop")


- construction  elif 

cat elif.py 
#!/usr/bin/env python3


# -*- coding: utf8 -*-

a=int(input("gimme me a number ! " ))

if a > 0:
    print("ok you gave me a positive number !")
elif  a < 0:
    print("ok you gave me a negative number !")
else:
    print("hey for sure you gave me a zero !")


= operateurs =

+ - * / % 
> < 
>= <= 
== égalité 
!= différence 


= and /or /not =

#!/usr/bin/env python3

a = int(input("hey gimme a number smaller than 10 !"))

if  a > 4 and a < 10:
    print(a, " ..is in the upper range !!")
elif a > 0 or a < 4:
    print(a, "..is in the lower range !!")
else:
    print("did you miss something ??")


>>> a = 5
>>> type(a) is int
True

>>> type(a) is not str
True

>>> type(a) is not str and type(a) is not float and type(a) is not list and type(a) is not tuple and type(a) is not dict and type(a) is not bool
True



= while =

#!/usr/bin/env python3
#-*-coding: utf8 -*-

multi = 7
digit = 0

while digit < 11:
    print(digit * multi )
    digit += 1



= for = 

#!/usr/bin/env python3
#-*-coding: utf8 -*-

word = "ragoutoutou"

for w in word:
    if w in "aeiouy":
        print("hey yougot voyel :" + w)
    else:
        print("secret char: ###")

= input / raw_input =

#!/usr/bin/env python
# -*- coding: utf8 -*-

nom=raw_input("hello, what's yo name ? ")
print("hugh ..." + nom)
raw_input("press please the touche entrée ...")



= break = 

break va permettre de stopper une boucle 

#!/usr/bin/env python3
#-*-coding: utf8 -*-

while True:
    a = input("gimme the secret to quit :" )
    print("you gave me " + a)
    if a  in "qQ":
        print("ok bye")
        break
    else:
        print("try again")

= continue = 

continue va permettre de recommencer immédiatement au point de départ de notre boucle for ou while sans executer les lignes de code suivant ce mot clé.





= list = 

#!/usr/bin/env python
# -*- coding: utf8 -*-


# On defini une variable.
name="maggie"

# on commence à compter à partir de 0 : omer=0 marge=3 . On peut creeer une liste vide []. On peut melanger les types.
lst=["omer", "bart" , "lisa" , "marge"]

print(lst[2])

# va afficher lisa
# pour un intervalle on inclu la première borne et on exclu la dernière : lst[1:3]

print(lst[1:3])

# va afficher ['bart', 'lisa']

#print(lst[:2])  : on affiche tout jusqu'à 2 exclu
#print(lst[:]) : on affiche tous les elements. on peut définir une nouvelle liste qui sera une copie de notre liste:
liste2=lst[:]

#python considere le texte comme une liste de lettres :
print("texte"[1:3]) 

# on va voir qu'on peut modifier une liste. Ici on copie notre liste . On affecte la valeur de la variable name à l'element 2 de notre liste : 
simpson=lst

lst[2]=name

print(lst)

# on a donc dans la liste lst et simpson les valeurs :["omer", "bart" , "maggie" , "marge"] .Simpson est un alias de lst

# Si on affiche liste2 : elle n'aura pas changée : ["omer", "bart" , "lisa" , "marge"] . 

# il faut faire attention au copies.

# boucle for

for elem in lst:
    print("hello , in the loop")
    print elem

#hello , in the loop
#omer
#hello , in the loop
#bart
#hello , in the loop
#maggie
#hello , in the loop
#marge

#!/usr/bin/env python3
#-*-coding: utf8 -*-

i = 1
while i < 10:
    if i % 2 == 0:
        print("hey even number ... " + str(i))
        i += 1
        continue
    print("odd one : " + str(i))
    i += 3

= type /methodes =

#!/usr/bin/env python
# -*- coding: utf8 -*-

# int() ; raw_input() ; str() ... : une fonction retourne une donnée. var=fonction(truc)  print var. 
# le retour de la fonction est different en fonction de ce sur quoi elle s'applique.Exemple différence entre le len("mot") len("lapin"," "lulu") : on a d'un coté le nombre de lettre du mot et dans l'autre exemple le nombre d'élement de la liste .

print(len("monty"))
print(len(["lapin", "lulu"]))


print(range(5))
compte=3

for x in range(compte):
    print("hip")


#[0, 1, 2, 3, 4]
#hip
#hip
#hip
#

# Une methode est attachée au type . Pour appeller une fonction , on tape son nom et entre parenthese ses params: fonction(param) Pour invoquer /appeller une methode , on saisi le nom_var.nom_methode(param) . 
# On voit ici clairement les methodes associées au type str . La methode upper met tout en maj , la methode capitalize met 'initale en maj , la methode title met toutes les premieres lettres en maj ( utiles pour nom composés) :
nom="napoleon"
print(nom.upper())
print(nom.capitalize())

name="Louis-philipPE"
print(name.title())

# on peut nettoyer le code ; les entrees des users : exemple supprimer des espaces en trop avec strip :

a="          ..blabla avec plein d'espaces au debut et à la fin....       "
print(a)

print(a.strip())

#nous affiche dans un premier temps          ..blabla avec plein d'espaces au debut et à la fin....       puis clean des espaces :
#..blabla avec plein d'espaces au debut et à la fin....


#On peut transformer du texte en liste en utilisant un separateur :
b="lapin,lulu,lili"
print(b)
print(b.split(","))

# nous affiche bien les mots , puis une liste dont le sep est la ","
#lapin,lulu,lili
#['lapin', 'lulu', 'lili']



= fonction = 

on regroupe nos différents blocs de  code au sein de fonctions  pour les rappeller plus facilement , factoriser et eviter toute répétition inutile. 

def nom _d e_la_fonction ( parametre1 , parametre2 , parametre3 ,parametreN ) :
# Bloc d ' instructions
Les paramètres sont séparés par des "," .
>>> def test(a, b, c):
...     print(a + b + c)
... 
>>> test(1,1,1)
3
>>> test(5,7,8)
20
Il va falloir respecter le nombre d'arguments fournis sous peine d'erreurs ... 
>>> test(5,7,8,4)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: test() takes 3 positional arguments but 4 were given
>>> test(5,7)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: test() missing 1 required positional argument: 'c'

on peut définir une valeur par défaut si un arg n'est pas fourni (voir exemple aprs avec docstring :

= docstring = 

on ajoute une petite explication de texte à notre fonction que l'on encadre par des triple " , qui pourra être consulter via l'appel à la fonction help(nom_de_fonction) : c'est une très bonne habitude il faut documenter nos fonctions . 


#!/usr/bin/env python3
#-*-coding: utf8 -*-

def fonction(nb , max = 10):
    """ fonction affichant la table de multiplication de n par multi jusqu'à la valeur max. Ici on defini la valeur par defaut de max à 10: si le user ne saisi pas de param 'max'"""
    i = 1
    while i < max:
        print("hey let's count : ", i * nb)
        i +=1
    return 
        
#fonction(2, 11)
fonction(4)

l'appel a help(fonction) affiche notre docstring : 

help(fonction)

/!\ a voir : on peut mettre les param dans le désordre si on les identifie par des noms.


>>> fonc()
(' a = ', 1, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(4)
(' a = ', 4, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(a=1)
(' a = ', 1, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(a=7)
(' a = ', 7, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(b=2, c=3)
(' a = ', 1, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(b=33, c=77)
(' a = ', 1, ' b = ', 33, ' c = ', 77, ' d = ', 4, ' e = ', 5)
>>> fonc( a =1 , b =2 , c =3 , d =4 , e = 5 )
(' a = ', 1, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(88)
(' a = ', 88, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(88,43)
(' a = ', 88, ' b = ', 43, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(88,43,11,78,54)
(' a = ', 88, ' b = ', 43, ' c = ', 11, ' d = ', 78, ' e = ', 54)

La signature de fonction en python est simplement son nom.

= return = 

L'instruction return signifie qu'on va renvoyer  le resultat d'une fonction, sa valeur pour ensuite pouvoir par exemple la stocker dans une variable.
/!\ attention tout le code situé après return ne s'executera pas.

on va pouvoir envoyer des données en entrées à nos fonctions et renvoyer une information avec le keyword return.



>>> def square(val):
...     return val * val
... 
>>> new = square(4)
>>> print(new)
16

On peut renvoyer  plusieurs valeurs séparées par des virgules.


= lambda = 

ce  keyword permet de créer des fonctions  qui seront extremement courtes.
on utilise donc le keyword lambda suivi d'un nombre d'argument désiré puis un ":" et ensuite l'instruction de la lambda. 
on va stocker notre lambda dans une variable car il n'y a pas le moyen de l'appeller directement.

#!/usr/bin/env python3
#-*-coding: utf8 -*-

f = lambda x: x * x

print(f(5))
Pour utiliser deux  param dans  notre lambda on pourra par exemple faire : 

>>> z = lambda x, y: x * y
>>> z(2,4)


= modules = 

 un module est du code ecrit dans un fichier.On defini des fonctions, variables.
Si l'on veut travailler avec elles , il faut donc simplement importer le module.

On importe un module avec par exemple le keyword import.
On peut ensuite examiner les différentes fonctions et particularités du module avec la fonction help(module) 

>>> import os
>>> help(os)
...
Help on module os:

NAME
    os - OS routines for NT or Posix depending on what system we're on.

FILE
    /usr/lib/python2.7/os.py

MODULE DOCS
....


on peut egalement examiner l'aide d'une fonction d'un module :


>>> help(os.chmod)

Help on built-in function chmod in module posix:

chmod(...)
    chmod(path, mode)
    
    Change the access permissions of a file.


    
#!/usr/bin/env python3
#-*-coding: utf8 -*-

import math
import math as matos
from math import fabs

print("""3 methodes d'import de modules : import module + import module as mod + from module import fonc""")


print(math.sqrt(5))
print(matos.sqrt(4))
print(fabs(-3))


#!/usr/bin/env python3
#-*- coding: utf8 -*-

import os 

year = input("gimme a year : ")
year = int(year)

if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):
    print("year is bissextile !")
else:
    print(year , "classic year")



os.system("date")
print("here's the content of tmp folder : " )
os.system("ls -lh /tmp")

 



#!/usr/bin/env python3
# -*- coding: utf8 -*-

import os 

from dix_10_multipli import *

# test de la fonction table

table(3,20)
os.system("sleep 2")
#!/usr/bin/env python3
#-*- coding: utf8 -*-

"""module multipli contenant la fonction table"""


import os

def table (nb, max =10):
    """Fonction affichant la table de multiplication par nb de 1 * nb jasqu'à max nb """
    i = 0
    while i < max:
        print(i + 1, "*" ,nb, "=", (i + 1) * nb)
        i +=1

# test de la fonction table 

if __name__ == "__main__":
    table(5)
    os.system("date +%F")


= espace de nommage =

On doit faire attention avec le nom de nos fonctions, ou variables  afin de ne pas avoir de conflit avec des fonctions internes d'un module :
Si on defini une variable ou fonction math ...on aura un souci avec l'utilisastrion du module du même nom ..

>>> math = 2
>>> import math
>>> nombre = math * 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for *: 'module' and 'int'

 On peut importer un module sous un autre bom ( rarement utilisé )

>>> import math as mathematique
>>> mathematique.sqrt(2)
1.4142135623730951

 
on peut sinon importer uniquement le fonction d'un module dont on a besoin :

>>> from os import getcwd
>>> getcwd()
'/home/boogie/Documents/stuff/python'

= encodage =
Il est nécéssaire d'avoir une interpretation correcte des caractères (accents etc ..)

# -* - coding : ENCODAGE -*

sous linux on utilisera très souvent :

# -*- coding : utf8 -*-

sous windows on peut devoir utiliser 
# -*- coding : Latin1 -*-

= creation de module : =

les modules ne sont que des fichiers plats qui seront dans unbe arbo precise et appellés dans nos script python:
ex :
on cree deux fichiers : le premier comporte la fonction de notre module.
le second est un test de notre module de fonction. 
tree module_test/
module_test/
├── multipli.py
└── test.py


 ~/Documents/stuff/python/misc/zero  ⑂ master +  $  cat module_test/multipli.py 
#!/usr/bin/env python3

# -*- coding: utf8 -*-

""" module multipli : affiche une table de multiplication."""

def multi(nb, max = 10):
    """ fonction de table de multiplication. Un nb en param :celui qui sera l'élément à multiplier . Un second param optionnel qui sera le multiplicateur : s'il est omis par défaut 10 sera utilisé. """
    i = 0
    while i < max:
        print( nb , "x", i, "=" , nb  * i )
        i += 1

 ~/Documents/stuff/python/misc/zero  ⑂ master +  $  cat module_test/test.py 
#!/usr/bin/env python3

import os

from multipli import *

multi(4, 5)

os.getcwd()


Quand on executera le fichier test.py :

 ./test.py 
4 x 0 = 0
4 x 1 = 4
4 x 2 = 8
4 x 3 = 12
4 x 4 = 16

on aura bien nos appels à la fonctions définie dans le fichier multipli.py et importée dans test.py
On aura après l'execution l'aparition de code semi compilé dans notre repertoire : 

$  tree
.
├── multipli.py
├── __pycache__
│   └── multipli.cpython-35.pyc
└── test.py

= test de module interne : =

on va pouvoir tester notre module directement au sein de celui-ci : comme si notre module etait un programme a lui seul. 
ex: il pourrait être bon de vérifier que notre fonction 
def multi(nb, max = 10): fonctionne correctement au sein de notre module 


On peut ajouter du code qui doit être ajouter quand on lance le module directement pour le tester ou lorsque l'on cherche à l'importer.

on va rajouter dans notre module après notre fonction :


# test de la fonction multi
if __name__ == " __main__ " :
multi ( 4 )
os . system ( " pause " )


On pourra donc tester notre fonction en lancant le script python : la table de multi de 4 sera affichée. si on invoque uniquement le script de la fonction du module crée.
Si on importe le module / fonction dans le fichier test.py crée prcedemment : la table de n'apparaitra pas.

La variable __name__ est créee automatiquement au lancement de l'interpréteur python. Si elle vaut __main__ ( qui veut dire que le fichier appellé est celui qui est executé ) : on peut ajouter du code qui ne sera executé qu'a l'invocation du programme lancé comme un executable.



= package = 

moyen de regrouper plusieurs fonctions (classes aussi) : on peut regrouper des modules dans des packages .
On peut ranger plus proprement nos modules, fonctions et classes python. On va devoir fournir le chemin complet pour acceder a nos modules : ce qui permet d'eviter d'eventuels conflits.
Ceci est forcemement tres pratique lors de l'install de package / bibliotheque les objets sont de base categoriser par type , role et la hierarchisation est essentielle.

en pratique un package est un repertoire qui peut contenir d'autre packages ou des modules.
Pour l'import on utilise la même méthode que les modules 

from package import module 
import package 


pour l'acces a un sous package / module : la separation avec le point se fait comme pour les modules :

biblio.objects_graphiques
biblio.objects_graphiques.formes_carrees



#!/usr/bin/env python3
#-*- coding: utf8 -*-

import os

"""module multipli contenant la fonction table"""

def table (nb, max =10):
    """Fonction affichant la table de multiplication par nb de 1 * nb jusqu'à max nb """
    i = 0
    while i < max:
        print(i + 1, "*" ,nb, "=", (i + 1) * nb)
        i +=1
# on a un moyen de pouvoir tester la validité de notre fonction en utilisant la méthode suivante : tester la fonction en lancant le script lui-même permet de setter  les variables python  '__name__' et '__main__' et donc invoquer notre fonction directement au sein du script . Si l'appel est externe alors le test __name__ == "__main__" n'est pas vrai donc pas de suite. Cette méthode est TRES utilisée.

if __name__ == "__main__":
    table(5)
    os.system("date +%F")


= exeption : try /except = 

#!/usr/bin/env python3
# -*- coding: utf8 -*-

import os

annee = input("hey gimme me a number plz :")

# on essaye de convertir en entier la chaine retournée par le user 
try:
    annee = int(annee) 
# si la conversion n'est pas possible ( aka si le code retour de l'instruction n'est pas ok alors on agit differement  
except:
    print("hey no way ! a number do you understand ?")

#!/usr/bin/env python3
#-*- coding: utf8 -*-

# var pour le try :
#a = 6
#b = 3

# var pour exception NameError :
##a =  
#b = 2

# var pour exception TypeError :
#a = 4
#b = "t"

# var pour exception ZeroDivisionError :
#a = 5
#b = 0


try:
    result = a / b
    print("good game ! here's the result :", result)

# on defini maintenant quelques exceptions en fonctions des valeurs saisies et du resultat 

# ici souci : a ou b ne sont pas définis : NameError
except NameError:
    print("nop there's a pb . did you give a number for the the two letter ?")

# ici : une des deux variables contient autre chose qu'un nombre
except TypeError:
    print("do you remember that a number should only contain numbers ?")

# ici on essaye de diviser par zero : l'exception dediée est levée.
except ZeroDivisionError:
    print("no way ..0 can be record for divisor")    
#!/usr/bin/env python3
#-*- coding: utf8 -*-

# var pour le try :
#a = 6
#b = 3

# var pour exception NameError :
##a =  
#b = 2

# var pour exception TypeError :
#a = 4
#b = "t"

# var pour exception ZeroDivisionError :
#a = 5
#b = 0


try:
    result = a / b
    print("good game ! here's the result :", result)

# on defini maintenant quelques exceptions en fonctions des valeurs saisies et du resultat 

# ici souci : a ou b ne sont pas définis : NameError
except NameError as pb_def :
    print("nop there's a pb . did you give a number for the the two letter ?", pb_def)

# ici : une des deux variables contient autre chose qu'un nombre
except TypeError as pb_type:
    print("do you remember that a number should only contain numbers ?", pb_type)

# ici on essaye de diviser par zero : l'exception dediée est levée.
except ZeroDivisionError as pb_zero:
    print("no way ..0 can be record for divisor", pb_zero)    



= finally =


#!/usr/bin/env python3
#-*- coding: utf8 -*-


import os

# var pour le try :
#a = 6
#b = 3

# var pour exception NameError :
##a =  
#b = 2

# var pour exception TypeError :
#a = 4
#b = "t"

# var pour exception ZeroDivisionError :
#a = 5
#b = 0

# ici on ne fait que l'opération dans le try :
try:
    result = a / b

# on defini maintenant quelques exceptions en fonctions des valeurs saisies et du resultat 

# ici souci : a ou b ne sont pas définis : NameError
except NameError as pb_def :
    print("nop there's a pb . did you give a number for the the two letter ?", pb_def)

# ici : une des deux variables contient autre chose qu'un nombre
except TypeError as pb_type:
    print("do you remember that a number should only contain numbers ?", pb_type)

# ici on essaye de diviser par zero : l'exception dediée est levée.
except ZeroDivisionError as pb_zero:
    print("no way ..0 can be record for divisor", pb_zero)    
# on pose un else qui va affcicher le resultat de l'opération  on dissocie cette instruction du try : c'est plus "propre" 
else:
    print("good game ! here's the result :", result)

# ici on execute une commande quel que soit le resultat du try et des excepts, else . Le bloc après finally sera donc toujours executé même si des erreurs ou des codes retour de fonctions apparaissent avant dans  notre  programme:

finally:
    os.system("date +%F-%H-%M")


= pass =

#!/usr/bin/env python3
#-*- coding: utf8 -*-


import os

# var pour le try :
#a = 6
#b = 3

# var pour exception NameError :
##a =  
#b = 2

# ici on ne fait que l'opération dans le try :
try:
    result = a / b


# ici on rajoute "pass" : on peut l'utiliser quand on veut tester un bloc mais ne rien faire si on rencontre une erreur. On ne peut pas le faire avec un try seul ..il faut donc rajouter pass qui ne fait rien même en cas d'exception rencontrées ( pas vraiment d'interet mais il est bon de savoir que ce mot clé existe. on peut l'avoir dans des fonctions qu'on veut vides , conditions etc ...

except: 
    pass



= assert = 
 

#!/usr/bin/env python3
#-*- coding: utf8 -*-

year = input("gimme a year upper than 0 :")

try:
    year = int(year)
    assert year > 0
except ValueError as number_plz:
    print("hey wake up !" , number_plz)
except AssertionError:
    print("did you read ?")
#!/usr/bin/env python3
#-*- coding: utf8 -*-

year = input("gimme a year upper than 0 :")

try:
    year = int(year)
    if year <= 0:
        raise ValueError("yop ..upper than 0 plz !")
except TypeError:
    print("no way ! ")




