==== short resume python : zero ====

=== intro /base python ===

= chaine de caracteres = 

il est possible d'ecrire des chaines de carateres str entre :
""
''
ou 
""" """ si on veut rediger du multiligne

il faudra proteger nos caractères speciaux comme le " ' "  avec un "\" ex :
>>> a = 'l\'huile'
>>> a
"l'huile"
>>> a = "\"mon beau sapin\""
>>> a
'"mon beau sapin"'

>>> a = """mon
... beau
... sapin"""
>>> a
'mon\nbeau\nsapin'
on voit ici le retour chariot "\n" qui s'affiche ...


= type =


>>> a = "lapin"
>>> type(a)
<type 'str'>
>>> a = 32
>>> type(a)
<type 'int'>
>>> a = 3.4
>>> type(a)
<type 'float'>
>>>a  = True
>>> type(a)
<type 'bool'>
>>> b = False
>>> type(b)
<type 'bool'>


= if / else / elif =

#!/usr/bin/env python3
#-*-coding: utf8 -*-
import os 


b = input("gimme a year : ")

print("ok you gave me " + str(b))
year = int(b)


if year % 4 == 0 or year % 400 == 0:
    print("you got it!")
else:
    year % 100 == 0
    print("nop")


- construction  elif 

cat elif.py 
#!/usr/bin/env python3


# -*- coding: utf8 -*-

a=int(input("gimme me a number ! " ))

if a > 0:
    print("ok you gave me a positive number !")
elif  a < 0:
    print("ok you gave me a negative number !")
else:
    print("hey for sure you gave me a zero !")


= operateurs =

+ - * / % 
> < 
>= <= 
== égalité 
!= différence 


= and /or /not =

#!/usr/bin/env python3

a = int(input("hey gimme a number smaller than 10 !"))

if  a > 4 and a < 10:
    print(a, " ..is in the upper range !!")
elif a > 0 or a < 4:
    print(a, "..is in the lower range !!")
else:
    print("did you miss something ??")


>>> a = 5
>>> type(a) is int
True

>>> type(a) is not str
True

>>> type(a) is not str and type(a) is not float and type(a) is not list and type(a) is not tuple and type(a) is not dict and type(a) is not bool
True



= while =

#!/usr/bin/env python3
#-*-coding: utf8 -*-

multi = 7
digit = 0

while digit < 11:
    print(digit * multi )
    digit += 1



= for = 

#!/usr/bin/env python3
#-*-coding: utf8 -*-

word = "ragoutoutou"

for w in word:
    if w in "aeiouy":
        print("hey yougot voyel :" + w)
    else:
        print("secret char: ###")

= input / raw_input =

#!/usr/bin/env python
# -*- coding: utf8 -*-

nom=raw_input("hello, what's yo name ? ")
print("hugh ..." + nom)
raw_input("press please the touche entrée ...")



= break = 

break va permettre de stopper une boucle 

#!/usr/bin/env python3
#-*-coding: utf8 -*-

while True:
    a = input("gimme the secret to quit :" )
    print("you gave me " + a)
    if a  in "qQ":
        print("ok bye")
        break
    else:
        print("try again")

= continue = 

continue va permettre de recommencer immédiatement au point de départ de notre boucle for ou while sans executer les lignes de code suivant ce mot clé.





= list = 

#!/usr/bin/env python
# -*- coding: utf8 -*-


# On defini une variable.
name="maggie"

# on commence à compter à partir de 0 : omer=0 marge=3 . On peut creeer une liste vide []. On peut melanger les types.
lst=["omer", "bart" , "lisa" , "marge"]

print(lst[2])

# va afficher lisa
# pour un intervalle on inclu la première borne et on exclu la dernière : lst[1:3]

print(lst[1:3])

# va afficher ['bart', 'lisa']

#print(lst[:2])  : on affiche tout jusqu'à 2 exclu
#print(lst[:]) : on affiche tous les elements. on peut définir une nouvelle liste qui sera une copie de notre liste:
liste2=lst[:]

#python considere le texte comme une liste de lettres :
print("texte"[1:3]) 

# on va voir qu'on peut modifier une liste. Ici on copie notre liste . On affecte la valeur de la variable name à l'element 2 de notre liste : 
simpson=lst

lst[2]=name

print(lst)

# on a donc dans la liste lst et simpson les valeurs :["omer", "bart" , "maggie" , "marge"] .Simpson est un alias de lst

# Si on affiche liste2 : elle n'aura pas changée : ["omer", "bart" , "lisa" , "marge"] . 

# il faut faire attention au copies.

# boucle for

for elem in lst:
    print("hello , in the loop")
    print elem

#hello , in the loop
#omer
#hello , in the loop
#bart
#hello , in the loop
#maggie
#hello , in the loop
#marge

#!/usr/bin/env python3
#-*-coding: utf8 -*-

i = 1
while i < 10:
    if i % 2 == 0:
        print("hey even number ... " + str(i))
        i += 1
        continue
    print("odd one : " + str(i))
    i += 3

= type /methodes =

#!/usr/bin/env python
# -*- coding: utf8 -*-

# int() ; raw_input() ; str() ... : une fonction retourne une donnée. var=fonction(truc)  print var. 
# le retour de la fonction est different en fonction de ce sur quoi elle s'applique.Exemple différence entre le len("mot") len("lapin"," "lulu") : on a d'un coté le nombre de lettre du mot et dans l'autre exemple le nombre d'élement de la liste .

print(len("monty"))
print(len(["lapin", "lulu"]))


print(range(5))
compte=3

for x in range(compte):
    print("hip")


#[0, 1, 2, 3, 4]
#hip
#hip
#hip
#

# Une methode est attachée au type . Pour appeller une fonction , on tape son nom et entre parenthese ses params: fonction(param) Pour invoquer /appeller une methode , on saisi le nom_var.nom_methode(param) . 
# On voit ici clairement les methodes associées au type str . La methode upper met tout en maj , la methode capitalize met 'initale en maj , la methode title met toutes les premieres lettres en maj ( utiles pour nom composés) :
nom="napoleon"
print(nom.upper())
print(nom.capitalize())

name="Louis-philipPE"
print(name.title())

# on peut nettoyer le code ; les entrees des users : exemple supprimer des espaces en trop avec strip :

a="          ..blabla avec plein d'espaces au debut et à la fin....       "
print(a)

print(a.strip())

#nous affiche dans un premier temps          ..blabla avec plein d'espaces au debut et à la fin....       puis clean des espaces :
#..blabla avec plein d'espaces au debut et à la fin....


#On peut transformer du texte en liste en utilisant un separateur :
b="lapin,lulu,lili"
print(b)
print(b.split(","))

# nous affiche bien les mots , puis une liste dont le sep est la ","
#lapin,lulu,lili
#['lapin', 'lulu', 'lili']



= fonction = 

on regroupe nos différents blocs de  code au sein de fonctions  pour les rappeller plus facilement , factoriser et eviter toute répétition inutile. 

def nom _d e_la_fonction ( parametre1 , parametre2 , parametre3 ,parametreN ) :
# Bloc d ' instructions
Les paramètres sont séparés par des "," .
>>> def test(a, b, c):
...     print(a + b + c)
... 
>>> test(1,1,1)
3
>>> test(5,7,8)
20
Il va falloir respecter le nombre d'arguments fournis sous peine d'erreurs ... 
>>> test(5,7,8,4)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: test() takes 3 positional arguments but 4 were given
>>> test(5,7)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: test() missing 1 required positional argument: 'c'

on peut définir une valeur par défaut si un arg n'est pas fourni (voir exemple aprs avec docstring :

= docstring = 

on ajoute une petite explication de texte à notre fonction que l'on encadre par des triple " , qui pourra être consulter via l'appel à la fonction help(nom_de_fonction) : c'est une très bonne habitude il faut documenter nos fonctions . 


#!/usr/bin/env python3
#-*-coding: utf8 -*-

def fonction(nb , max = 10):
    """ fonction affichant la table de multiplication de n par multi jusqu'à la valeur max. Ici on defini la valeur par defaut de max à 10: si le user ne saisi pas de param 'max'"""
    i = 1
    while i < max:
        print("hey let's count : ", i * nb)
        i +=1
    return 
        
#fonction(2, 11)
fonction(4)

l'appel a help(fonction) affiche notre docstring : 

help(fonction)

/!\ a voir : on peut mettre les param dans le désordre si on les identifie par des noms.


>>> fonc()
(' a = ', 1, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(4)
(' a = ', 4, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(a=1)
(' a = ', 1, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(a=7)
(' a = ', 7, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(b=2, c=3)
(' a = ', 1, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(b=33, c=77)
(' a = ', 1, ' b = ', 33, ' c = ', 77, ' d = ', 4, ' e = ', 5)
>>> fonc( a =1 , b =2 , c =3 , d =4 , e = 5 )
(' a = ', 1, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(88)
(' a = ', 88, ' b = ', 2, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(88,43)
(' a = ', 88, ' b = ', 43, ' c = ', 3, ' d = ', 4, ' e = ', 5)
>>> fonc(88,43,11,78,54)
(' a = ', 88, ' b = ', 43, ' c = ', 11, ' d = ', 78, ' e = ', 54)

La signature de fonction en python est simplement son nom.

= return = 

L'instruction return signifie qu'on va renvoyer  le resultat d'une fonction, sa valeur pour ensuite pouvoir par exemple la stocker dans une variable.
/!\ attention tout le code situé après return ne s'executera pas.

on va pouvoir envoyer des données en entrées à nos fonctions et renvoyer une information avec le keyword return.



>>> def square(val):
...     return val * val
... 
>>> new = square(4)
>>> print(new)
16

On peut renvoyer  plusieurs valeurs séparées par des virgules.


= lambda = 

ce  keyword permet de créer des fonctions  qui seront extremement courtes.
on utilise donc le keyword lambda suivi d'un nombre d'argument désiré puis un ":" et ensuite l'instruction de la lambda. 
on va stocker notre lambda dans une variable car il n'y a pas le moyen de l'appeller directement.

#!/usr/bin/env python3
#-*-coding: utf8 -*-

f = lambda x: x * x

print(f(5))
Pour utiliser deux  param dans  notre lambda on pourra par exemple faire : 

>>> z = lambda x, y: x * y
>>> z(2,4)


= modules = 

 un module est du code ecrit dans un fichier.On defini des fonctions, variables.
Si l'on veut travailler avec elles , il faut donc simplement importer le module.

On importe un module avec par exemple le keyword import.
On peut ensuite examiner les différentes fonctions et particularités du module avec la fonction help(module) 

>>> import os
>>> help(os)
...
Help on module os:

NAME
    os - OS routines for NT or Posix depending on what system we're on.

FILE
    /usr/lib/python2.7/os.py

MODULE DOCS
....


on peut egalement examiner l'aide d'une fonction d'un module :


>>> help(os.chmod)

Help on built-in function chmod in module posix:

chmod(...)
    chmod(path, mode)
    
    Change the access permissions of a file.


    
#!/usr/bin/env python3
#-*-coding: utf8 -*-

import math
import math as matos
from math import fabs

print("""3 methodes d'import de modules : import module + import module as mod + from module import fonc""")


print(math.sqrt(5))
print(matos.sqrt(4))
print(fabs(-3))


#!/usr/bin/env python3
#-*- coding: utf8 -*-

import os 

year = input("gimme a year : ")
year = int(year)

if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):
    print("year is bissextile !")
else:
    print(year , "classic year")



os.system("date")
print("here's the content of tmp folder : " )
os.system("ls -lh /tmp")

 



#!/usr/bin/env python3
# -*- coding: utf8 -*-

import os 

from dix_10_multipli import *

# test de la fonction table

table(3,20)
os.system("sleep 2")
#!/usr/bin/env python3
#-*- coding: utf8 -*-

"""module multipli contenant la fonction table"""


import os

def table (nb, max =10):
    """Fonction affichant la table de multiplication par nb de 1 * nb jasqu'à max nb """
    i = 0
    while i < max:
        print(i + 1, "*" ,nb, "=", (i + 1) * nb)
        i +=1

# test de la fonction table 

if __name__ == "__main__":
    table(5)
    os.system("date +%F")


= espace de nommage =

On doit faire attention avec le nom de nos fonctions, ou variables  afin de ne pas avoir de conflit avec des fonctions internes d'un module :
Si on defini une variable ou fonction math ...on aura un souci avec l'utilisastrion du module du même nom ..

>>> math = 2
>>> import math
>>> nombre = math * 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for *: 'module' and 'int'

 On peut importer un module sous un autre bom ( rarement utilisé )

>>> import math as mathematique
>>> mathematique.sqrt(2)
1.4142135623730951

 
on peut sinon importer uniquement le fonction d'un module dont on a besoin :

>>> from os import getcwd
>>> getcwd()
'/home/boogie/Documents/stuff/python'

= encodage =
Il est nécéssaire d'avoir une interpretation correcte des caractères (accents etc ..)

# -* - coding : ENCODAGE -*

sous linux on utilisera très souvent :

# -*- coding : utf8 -*-

sous windows on peut devoir utiliser 
# -*- coding : Latin1 -*-

= creation de module : =

les modules ne sont que des fichiers plats qui seront dans unbe arbo precise et appellés dans nos script python:
ex :
on cree deux fichiers : le premier comporte la fonction de notre module.
le second est un test de notre module de fonction. 
tree module_test/
module_test/
├── multipli.py
└── test.py


 ~/Documents/stuff/python/misc/zero  ⑂ master +  $  cat module_test/multipli.py 
#!/usr/bin/env python3

# -*- coding: utf8 -*-

""" module multipli : affiche une table de multiplication."""

def multi(nb, max = 10):
    """ fonction de table de multiplication. Un nb en param :celui qui sera l'élément à multiplier . Un second param optionnel qui sera le multiplicateur : s'il est omis par défaut 10 sera utilisé. """
    i = 0
    while i < max:
        print( nb , "x", i, "=" , nb  * i )
        i += 1

 ~/Documents/stuff/python/misc/zero  ⑂ master +  $  cat module_test/test.py 
#!/usr/bin/env python3

import os

from multipli import *

multi(4, 5)

os.getcwd()


Quand on executera le fichier test.py :

 ./test.py 
4 x 0 = 0
4 x 1 = 4
4 x 2 = 8
4 x 3 = 12
4 x 4 = 16

on aura bien nos appels à la fonctions définie dans le fichier multipli.py et importée dans test.py
On aura après l'execution l'aparition de code semi compilé dans notre repertoire : 

$  tree
.
├── multipli.py
├── __pycache__
│   └── multipli.cpython-35.pyc
└── test.py

= test de module interne : =

on va pouvoir tester notre module directement au sein de celui-ci : comme si notre module etait un programme a lui seul. 
ex: il pourrait être bon de vérifier que notre fonction 
def multi(nb, max = 10): fonctionne correctement au sein de notre module 


On peut ajouter du code qui doit être ajouter quand on lance le module directement pour le tester ou lorsque l'on cherche à l'importer.

on va rajouter dans notre module après notre fonction :


# test de la fonction multi
if __name__ == " __main__ " :
multi ( 4 )
os . system ( " pause " )


On pourra donc tester notre fonction en lancant le script python : la table de multi de 4 sera affichée. si on invoque uniquement le script de la fonction du module crée.
Si on importe le module / fonction dans le fichier test.py crée prcedemment : la table de n'apparaitra pas.

La variable __name__ est créee automatiquement au lancement de l'interpréteur python. Si elle vaut __main__ ( qui veut dire que le fichier appellé est celui qui est executé ) : on peut ajouter du code qui ne sera executé qu'a l'invocation du programme lancé comme un executable.



= package = 

moyen de regrouper plusieurs fonctions (classes aussi) : on peut regrouper des modules dans des packages .
On peut ranger plus proprement nos modules, fonctions et classes python. On va devoir fournir le chemin complet pour acceder a nos modules : ce qui permet d'eviter d'eventuels conflits.
Ceci est forcemement tres pratique lors de l'install de package / bibliotheque les objets sont de base categoriser par type , role et la hierarchisation est essentielle.

en pratique un package est un repertoire qui peut contenir d'autre packages ou des modules.
Pour l'import on utilise la même méthode que les modules 

from package import module 
import package 


pour l'acces a un sous package / module : la separation avec le point se fait comme pour les modules :

biblio.objects_graphiques
biblio.objects_graphiques.formes_carrees

Si on veut importer un seul module ou fonction d'un package on peut le faire assez intuitivement comme ceci :

from biblio.objects_graphiques import buttons

Creation de package :

on creee un rep du nom du package puis on y met nos module portant l'extension py

 tree package/
package/
└── un_1_fonctions.py

Il n'est pas rare dans le repertoire du package d'avoir un fichier de type :
__init__.py qui sera le fichier d'initialisation du package qui contiendra le code d'initialisation de notre package ( ceci n'est plus obligatoire depuis python 3.3 

pour illustrer le propos : on créee un fichier test_package.py puis au même niveau un rep package au sein duquel on ajoute notre fonction / module table de multiplication.
On va importer notre package dans notre fichier de test de package .


 tree
.
├── package
│   ├── fonction.py
└── test_package.py


 cat package/fonction.py 
#!/usr/bin/env python3


# -*- coding: utf8 -*-


def table(nb, max=5):
    """ fonction table : va nous afficher la table de multi de arg1  X arg2 (avec arg2 optionnel valant 5 si nom defini. """

    i = 1
    while i <= max:
        print(nb, "X", i, "=", nb * i)
        i += 1
if __name__ == "__main__":
    table(4,3)
    print("hey we are testing", "__main__")


cat test_package.py 
#!/usr/bin/env python3

# -*- coding: utf8 -*-

from package.fonction import table
table (5) # Appel de la fonction table

# Ou ...import package . fonctions
#fonctions.table (5) # Appel de la fonction table


#!/usr/bin/env python3
#-*- coding: utf8 -*-

import os

"""module multipli contenant la fonction table"""

def table (nb, max =10):
    """Fonction affichant la table de multiplication par nb de 1 * nb jusqu'à max nb """
    i = 0
    while i < max:
        print(i + 1, "*" ,nb, "=", (i + 1) * nb)
        i +=1
# on a un moyen de pouvoir tester la validité de notre fonction en utilisant la méthode suivante : tester la fonction en lancant le script lui-même permet de setter  les variables python  '__name__' et '__main__' et donc invoquer notre fonction directement au sein du script . Si l'appel est externe alors le test __name__ == "__main__" n'est pas vrai donc pas de suite. Cette méthode est TRES utilisée.

if __name__ == "__main__":
    table(5)
    os.system("date +%F")



= exeption : try /except = 

quand python rencontre une erreur dans le code ou dans une opération à executer : il lève une exeption.
on a différents types d'exeptions qui dependent des erreurs rencontrées.
ex : ValuesError : pb de valeur / type de données 

- forme minimale : ( utilisable pour l'exemple et quand nous n'avons pas beaucoup de tests et de cas d'erreurs possibles : 
on va donc avoir 
python qui execute une action 
si l'action est ok -> il continue
si il y a une erreur -> on peut lui demander de tester autre chose .
On utilise pour cela le bloc de forme :
try / exept : 

try:
    # bloc à essayer
except:
    # bloc qui sera executé en cas d'erreur.

exemple : 
annee = input ()
try : # On essaye de convertir l ' ann é e en entier
    annee = int ( annee )
except :
    print ( " Erreur lors de la conversion de l ' ann é e . " ) 
 
- forme complète :

c'est la forme privilégiée qu'il faudra utiliser.
On va completer notre bloc try en permet d'agir sur une type d'exeption précise lors du passage a except 


>>> a = "a"
>>> b = "b"
>>> try: 
...     res = a / b
... except: 
...     print("an error appeared ..which one ..?")
... 
an error appeared ..which one ..?

on peut avoir plusieurs type d'erreurs ex :
> NameError (var / noms : pas définis)
> TypeError : pas possible de diviser ex lettre 
> ZeroDivisionError : pb si on divise par 0
 
n va donc  pouvoir renseigner apres except la type d'exeption et cze qu'on veut traiter :

>>> a = "a"
>>> b = "b"
>>> try: 
...     res = a / b
... except TypeError: 
...     print("hey on ne divise pas des bananes par des enclumes ! ")
... 
hey on ne divise pas des bananes par des enclumes ! 

On peut cumuler et definir des actions pour différents type :

try :
    resultat = numerateur / denominateur
except NameError :
    print ("La variable numerateur ou denominateur n'a pas été définie.")
except TypeError :
    print ("La variable numerateur ou denominateur possè de untype incompatible avec la division")
except ZeroDivisionError :
    print ("La variable denominateur est égale à 0.")

On peut capturer l'exeption et afficher son message avec le keyword as :

try :
# Bloc de test
except type_de_l_exception as exception_retournee :
    print ( " Voici l ' erreur : " , exception_retournee )

dans ce cas une variable "exception_retournee" est créee si une exeption de type "type_de_l_exception" est rencontrée.

Il est très conseillé de saisir le type d'exeption après except.

= else / finally = 

else :

dans une bloc d'exeption on peut utilser else s'il n'y a pas d'erreur.

try :
    resultat = numerateur / denominateur
except NameError :
    print ( " La variable numerateur ou denominateur n 'a pas é t é dé finie . " )
except TypeError :
    print ( " La variable numerateur ou denominateur possède un type incompatible avec la division . " )
except ZeroDivisionError :
    print ( " La variable denominateur est é gale à 0 . " )
else :
    print ( " Le résultat obtenu est " , resultat )


finally :

permet d'executer du code apres l'execution du bloc try qu'il y ait des erreurs ou pas MEME si une instruction return est definie dans le bloc except

try :
# Test d ' instruction ( s )
except TypeDInstruction :
    # Traitement en cas d ' erreur
finally :
    # Instruction(s) exécutée(s) qu'il y ait eu des erreurs ou non


= pass =
on peut vouloir continuer à dérouler notre code dans un bloc try même s'il y a une erreur .
Comme l'instruction try ne peut être seule on peut la combiner avec le keyword pass 

try :
    # Test d ' instruction ( s )
except type_de_l_exception : # Rien ne doit se passer en cas d 'erreur
    pass

pas forcemment utile mais à connaitre en cas de lecture dans du code.


= les assertions = 

c'est un moyen simple de s'assurer avant de continuer que les conditions sont bien respectées : on les utilise tres souvent dans les blocs try ..except 
 
on va utiliser le keyword assert 

assert test : si le resulat est True alors on continue sinon une exeption de type : AssertionError est levée.

ex :
>>> var = 5
>>> assert var == 5
>>> assert var == 7
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError

on peut tester que pour tester si une année saisie par un user  est superrieur a 0 et lever une exeption si elle ne l'est pas.

annee = input ( " Saisissez une ann é e sup é rieure à 0 : " )
try :
    annee = int (annee) # Conversion de l'année
    assert annee > 0
except ValueError :
    print ( " Vous n 'avez pas saisi un nombre." )
except AssertionError :
    print ("L'année saisie est inférieure ou égale à 0." )


= Lever une exeption =

on va utiliser le mot clé raise : on va surtout utiliser ces methode pour tester les classes que l'on crée.

raise TypeDeLException ("message à afficher")

on va ici lever une exeption si l'annee saisie est null ou negative et on va dans la foulée l'interceptée : on peut biensur faire différemment mais c'est pour illustrer par un exemple.

annee = input () # L'utilisateur saisit l'année
try :
    annee = int (annee) # On tente de convertir l 'année
if annee <= 0 :
    raise ValueError ( "l 'année saisie est négative ou nulle ")
except ValueError :
    print("La valeur saisie est invalide (l' année est peut  être négative). " )



== FIN INTRO PYTHON ==


===  programmation objet pour utilisateur === 

L'objet est une notion fondamentale en python : en python tout est objet.
Un objet est une structure de donnée (texte, variable ...)qui peut elle même contenir des variables, fonctions etc ...

= les chaines de caractères =

on va pouvoir travailler sur des methodes ( fonctions dédiées à un type de donnée) propres aux chaines de caractère

ex : passer en minuscule du texte :

>>> a = "PLEASE SHUT UP!"
>>> a.lower()
'please shut up!'

on voit donc ici que lower est une fonction de la variable "a". C'est une fonction qui s'appliquera donc a toutes les chaines de caractères.
En saisissant type(notre_objet) on a son type :

>>> a = "lapin"
>>> type(a)
<class 'str'>

on voit qu'un objet est issu d'une classe 
Une classe est une forme de type de données , elle permet de définir des  fonctions et des variables propres aux types.
on a donc ici la fonction lower qui a été définie dans la classe "str".
 
Les fonctions définies dans des classes sont appellées des methodes.

on appelle donc une methode d'un objet par le "." : objet.methode.
Une classe est un modele qui servira a construire un objet. C'est dans la classe que l'on va définir les méthodes propres à l'objet.

exemple de methode:
# upper passe en maj :
>>> a = "testo"
>>> a.upper()
'TESTO'
# capitalize passe la premiere initiale en maj :
>>> a.capitalize()
'Testo'
>>> a = "    some space in front and at the end ...   "
# strip supprime les espaces en debut et à la fin des str :
>>> a.strip()
'some space in front and at the end ...'
>>> b = " some texte!"

# upper et center(nb) : center va permettre d'ajouter / aligner notre txt en ajoutant un nombre définie d'espace jusqu'a ce que notre chaine fasse le nombre défini dans la methode center(nb)  
>>> b.upper().center(20)
'     SOME TEXTE! 

On peut biensur cumuler :
>>> b.upper().center(20)
'     SOME TEXTE! 


= formatage de chaine = 

on va pouvoir utiliser une fonction/ methode  elegante du modele objet pour afficher notre texte : c'est la methode format :

- utilisation 1 de format : 

>>> name = "Bob"
>>> surname = "Kool"
>>> age = 77
>>> print("my name is {0} {1} and i'm {2} years old !!" .format(name,subname,age))
my name is Bob Kool and i'm 77 years old !!

On voitr que la methode format va remplacer chaque element present entre {} par la valeur de la variable correspondant à son ordre de définition.  ( on commence toujours en programmation a compter à partir de 0 )

On peut biensur afficher nos valeurs dans un ordre différents  

>>> name = "Bebert"
>>> surname = "Chameau"
>>> age = "323"
>>> print("hello gringo {1} ..you re not so young with {2} years old ! welcome {0}".format(surname,age,name)) 
hello gringo 323 ..you re not so young with Bebert years old ! welcome Chameau

Nb : on est pas obligé de preciser le numero de variable entre les {} : l'ordre passé dans la methode format est suivi. 
On peut donc dans notre exemple utiliser la forme :

>>> print("hello gringo {} ..you re not so young with {} years old ! welcome {}".format(surname,age,name)) 
hello gringo Chameau ..you re not so young with 323 years old ! welcome Bebert


- utilisation 2 de format :

on va cette fois au lieu d'utiliser les "indices" des variables : nommer celles ci dans l'appel :

>>> print("hello gringo {surname} ..you re not so young with {age} years old ! welcome {name}".format(name = "Bebert", surname= "Chameau",age = 323)) 
hello gringo Chameau ..you re not so young with 323 years old ! welcome Bebert

= concatenation de chaine = 

on peut assembler plusieurs chaines via l'utilisation du signe "+" :
ex :
>>> a = "hello"
>>> b = "world"
>>> print("yopyop" + " " + a + b + "!!!") 
yopyop helloworld!!!

Attention python est un language au typage dynamique ( il est autonome sur la détection du type de données) mais est à fort typage .. il faudra biensur faire attention à nos type de data 
ex:  

>>> a = 21
>>> print(" yop happy birthday! you are " +a + " " + "years now!!")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Can't convert 'int' object to str implicitly
>>> print(" yop happy birthday! you are " + str(a) + " " + "years now!!")
 yop happy birthday! you are 21 years now!!

= parcours et selection de chaines =
une chaine de caractere est une serie /sequence de caractere .

- parcours par indice : 

on va donc préciser l'indice (la position ) du caractere auquel on veut acceder :

>>> a = "Bob Sponge !"
>>> a[0]
'B'
>>> a[1]
'o'
>>> a[7]
'n'
on voit donc qu'on peut acceder à des caracteres en utilisant des indices positifs et des négatifs.

Pour acceder au dernier caractere d'une chaine il suffit de saisir l'indice "-1" :

>>> a[-1]
'!'

On peut utiliser la fonction len() pour connaitre le nombre de caracteres de notre chaine :
>>> a="lapin32"
>>> len(a)
7

On peut donc parcourir les indices de nos chaines et les afficher les carateres correspondant :

ex :avec while :

>>> chaine = "salut"
>>> i = 0
>>> while i < len(chaine):
...     print(chaine[i])
...     i += 1
... 
s
a
l
u
t

ex : avec for :
>>> chaine = "salut"
>>> for i in chaine:
...     print i
... 
s
a
l
u
t

- selection de chaine :

on va pouvoir utiliser des intervals :

>>> a = "Bebert Chameau"
>>> a[:]
'Bebert Chameau'
>>> a[0:1]
'B'
>>> a[0:2]
'Be'
>>> a[1:3]
'eb'
>>> a[1:]
'ebert Chameau'
>>> a[1:-1]
'ebert Chamea'
>>> a[1:-2]
'ebert Chame'


= les listes et tuples =

- les listes :
elles sont des sequences comportant des objets de même type ou différents 
>>> lst = ["lapin", "nain" ]
>>> lst
['lapin', 'nain']
>>> lst = [2, 56]
>>> lst
[2, 56]
>>> lst = [ 3.1, 5.32]
>>> lst
[3.1, 5.32]
>>> lst = ["lapin", 4, "toto" , 4.5]
>>> lst
['lapin', 4, 'toto', 4.5]
>>> type(lst)
<type 'list'>

Une liste est un objet qui va en contenir d'autres.
Pour créer une liste vide :
>>> lst = []
>>> type(lst)
<type 'list'>


on peut acceder à differents objets d'une liste par leur indice :
>>> lst = ["lapin", [1,2], 5]
>>> len(lst)
3
>>> lst[0]
'lapin'
>>> lst[1]
[1, 2]
>>> lst[1][0]
1
>>> lst[1][2]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
>>> lst[1][1]
2

on peut modifier un element de la liste :

>>> lst = ["lapin", [1,2], 5]
>>> lst[0] = "Bob"
>>> lst
['Bob', [1, 2], 5]

Les list sont donc des éléments mutables : que l'on peut changer (contraitrement à la classe str) 

- actions sur lists :
on peut utiliser des  methodes sur les listes :

> ajout d'elements : append 

>>> lst.append("cool")
>>> lst
['Bob', [1, 2], 5, 'cool']


> suppression d'element : 

- del : 
on peut utiliser le keyword python del 

del peut permettre de supprimer une variable / un objet :

>>> a = "bob"
>>> a
'bob'
>>> del(a)
>>> a
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'a' is not defined

on peut aussi pour notre contexte supprimer un elemént d'une liste en donnant son indice : 
>>> lst
['Bob', 1, 5, 'Youki', 12]
>>> del lst[0]
>>> lst
[1, 5, 'Youki', 12]
>>> 

- remove : 

remove permet de supprimer un element d'une liste en donnant la valeur de l'objet à supprimer et pas son indice contrairement à del : 

>>> lst
[1, 5, 'Youki', 12]
>>> lst.remove("Youki")
>>> lst
[1, 5, 12]


-pop 


de base pop supprime le dernier element mais on peut specifier l'indice de l'élement d'une liste que l'on veut supprimer :
>>> lst.pop()
'cool'
>>> lst
['Bob', [1, 2], 5]
>>> lst.pop(0)
'Bob'
>>> lst
[[1, 2], 5]


> insertion d'objet dans une liste :

on peut inserer un objet dans une liste en specifiant l'endroit ou l'on veut l'ajouter : on rensigne l'indice :

>>> lst.insert(0, "Bob")
>>> lst
['Bob', 1, 5, 12]
>>> lst.insert(3, "Youki")
>>> lst
['Bob', 1, 5, 'Youki', 12]

> concatenation de liste : 
on peut assembler deux listes :

- avec extend on ajoute une liste a la fin d'une autre :

>>> a = [ "bob", 2 ]
>>> b = ["bebert", 4]
>>> a.extend(b)
>>> a
['bob', 2, 'bebert', 4]
>>> b
['bebert', 4]
>>> a
['bob', 2, 'bebert', 4]

- on peut le faire avec l'opération + également : 

>>> a = [ "bob", 2 ]
>>> b = ["bebert", 4]
>>> a + b
['bob', 2, 'bebert', 4]



Les methodes sur les chaines de caracteres ne change pas l'objet original et renvoie un nouvel objet 
Les methodes sur les listes elles modifient l'objet original mais ne renvoie rien :

>>> a = "lapin nain"
>>> b = a.upper()
>>> b
'LAPIN NAIN'
>>> a
'lapin nain'
>>> lst = [ 1, 5 ]
>>> lst2 = lst.append(12)
>>> lst
[1, 5, 12]
>>> lst2
>>> print(lst2)
None


= parcours de liste : =

on va classiquement pouvoir boucler sur les elements d'une liste :

- while :

>>> a = [2, 3, 4, 5]
>>> nb = 0
>>> while nb < len(a):
...     print(a[nb])
...     nb = nb +1
... 
2
3
4
5
 
- for  : que l'on va préférer :

>>> a
[2, 3, 4, 5]
>>> for elem in a:
...     print(elem)
... 
2
3
4
5

On peut améliorer nos boucles 
-> while n'est pas tres intuitif, permeable aux boucles infinies 

-> for capture les elements de la liste et les met dans une variable.


- enumerate : 
on va pouvoir utiliser cette méthode qui permet une grande souplesse et d'afficher finement nos params :

On va pouvoir avec enumerate recupérer les indices et les valeurs de notre liste 
enumerate prend une liste en argument et permet de récupérer une liste d'element ayant deux valeurs : l'indice et le contenu de l'element de notre liste à l'indice correspondant.


>>> for elem in enumerate(a):
...     print(elem)
... 
(0, 2)
(1, 3)
(2, 4)
(3, 5)

On voit que l'objet renvoyé par enumerate est un tuple : serie entre () immutable .


>>> a
[2, 3, 4, 5]
>>> for i , elem in enumerate(a):
...     print("on recupere les valeurs des indices et leur contenu!")
...     print(" à l'indice : {} -> on  a la valeur : {}".format(i,elem))
... 
on recupere les valeurs des indices et leur contenu!
 à l'indice : 0 -> on  a la valeur : 2
on recupere les valeurs des indices et leur contenu!
 à l'indice : 1 -> on  a la valeur : 3
on recupere les valeurs des indices et leur contenu!
 à l'indice : 2 -> on  a la valeur : 4
on recupere les valeurs des indices et leur contenu!
 à l'indice : 3 -> on  a la valeur : 5


= tuples = 

Sequence immutable.
On utilise en separateur des () au lieu des [] des listes.
Attention si on veut créer un tuple d'un seul élément il faut quand même mettre une virgule à la fin : sinon python supprime automatiquement les parentheses et on a une variable "classique"

>>> a = ()
>>> type(a)
<type 'tuple'>
>>> a = (1,)
>>> type(a)
<type 'tuple'>
>>> a = (1,2,5)
>>> a
(1, 2, 5)


C'est dont un type qu'on ne peut pas modifier 
Quand python trouve des valeurs séparées par une virgule il va les mettre entre () et les associer à des tuples.

On s'en sert quand on est sur que les data en entrées ne doivent pas être modifiées .


On s'en sert en cas d'affectation multiple : c'est très utile : 

>>> a , b = 3 , 4
>>> a
3
>>> b
4 

Un fonction peut renvoyer deux valeurs : 

>>> def compose(entier, divise_par):
...     """ cette fonction renvoie la partie entiere et le reste de entier / divise_par """
...     pe_entier = entier // divise_par
...     reste = entier % divise_par
...     return pe, reste 


on pourra recupérer la partie entiere et le reste dans deux variables au retour de la fonction :

>>>partie_entiere , reste = compose(20, 3)
>>> partie_entiere 
6
>>> reste
2



=  methodes speciales sur listes et tuples =


on va pouvoir effectuer des operations un peu speciales sur les listes  et tuples.

- des chaines aux listes :

on  va pouvoir convertir nos types de données .

on va pouvoir utiliser une méthode "split" pour passer d'une chaine de caractère à une liste :
split prend un argument : le séparateur qui sera pris en compte pour créer notre liste 

ex :  ici on defini l'escpace comme separateur et on a donc une liste de caractere séparé d'un espace en sortie : 

>>> a = "hello, World ! "
>>> a.split(" ")
['hello,', 'World', '!', '']


NB : split prend comme parametre par defaut les espaces, tab et saut de ligne.
on a donc le même résultat sur notre exmple précedent si on ne précise pas le separateur :

>>> a = "hello, World ! "
>>> a.split()
['hello,', 'World', '!']

- des listes aux chaines :
on va pouvoir transformer des listes en chaines via la methode join :

>>> b
['hello,', 'World', '!']
>>> " ".join(b)
'hello, World !'
>>> c= " ".join(b)
>>> type(c)
<type 'str'>
 

La methode join prend en parametre la liste d'objets que l'on veut "recoller".
La methode va travailler sur l'objet qui l'appelle : ici une chaine de caractere " " (espace).
 


= Listes et parametres de fonctions = 
Il est tout a fait possible d'avoir des fonctions dont le nombre de parametres à fournir est inconnu a l'avance (ex : print ..)
On va pouvoir utiliser la syntaxe :

def fonction(*param):

 on place une * devant le nom du param qui recupérera la liste d'arguments.
>>> def fonction_inconnue(*params):
...     print("jai recu : {}.".format(params))
... 
>>> fonction_inconnue()
jai recu : ().
>>> fonction_inconnue("bla")
jai recu : ('bla',).
>>> fonction_inconnue("bla", "blou")
jai recu : ('bla', 'blou').
>>> fonction_inconnue(["bla"], 1, 3.14)
jai recu : (['bla'], 1, 3.14).
>>> a = "bebert"
>>> fonction_inconnue(a)
jai recu : ('bebert',).
>>> 

on voit qu'on recupere des tuples.

->Attention: la saisie de paramètres nommés ne fonctionne pas.
>>> fonction_inconnue(a = "yop") 
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: fonction_inconnue() got an unexpected keyword argument 'a'

on peut par contre construire une fonction qui comportera des param définis suivis de parametres indéfinis :

>>> def mul(bob, youp, *lapin):
...     return bob, youp, lapin
...
>>> 
>>> a = 2
>>> b =44
>>> c = "yup"
>>> mul(a,b,c)
(2, 44, ('yup',))
>>> c = "yup"
>>> d = 55
>>> mul(a,b,c)
(2, 44, ('yup',))
>>> mul(a,b,c,d)
(2, 44, ('yup', 55)) 




Attention cependant si on veut saisir des parametres nommés ils devront être après notre param indéfini.

>>> def h(*plein, a=1, b=2):
...     print("ok here it is {} suivi de {} et de {}".format(plein,a,b))
... 
>>> h("yop","yap","yip",a,b)
ok here it is ('yop', 'yap', 'yip', 2, 44) suivi de 1 et de 2

Comme on le voit les paramètres  nommés ne sont pas dans le tuple.


exo : 
faire une fonction afficher identique à print, c’est-à-dire prenant un nombre indéterminé de paramètres, les affichant en les séparant à l’aide du paramètre nommé sep et terminant l’affichage par la variable fin.En outre, elle devra passer par print pour afficher (on ne connaît pas encore d’autres façons de faire). La seule contrainte est que l’appel à print ne doit compter qu’un seul paramètre non nommé. Autrement dit, avant l’appel à print, la chaîne devra avoir été déjà formatée, prête à l’affichage.

# on cree notre fonction : param indefinis puis separateur et fin :
>>> def afficher(*params,sep=' ',end='\n'):
# on converti de suite le tuple généré par l'appel a la fonction de params en liste :
...     params = list(params)
# on va ensuite parcourir les elements de la liste et transformér chacun en str grâce a la methode enumerate qui va nous faire parcourir les index et les valeurs : 
...     for i, p in enumerate(params):
...         params[i] = str(p)
# on va maintenant créer nos chaine qui seront separées par un espace grace a join :
...     chaine = sep.join(params)
# on ajoute la fin à notre texte 
...     chaine +=end
# on affiche donc nos paramètres et la fin : 
...     print(chaine,end='')
... 
ex : 
>>> afficher("bla", 5, 3.4,"yop")
bla 5 3.4 yop
>>> afficher(4, "bebert", "bob", 55.4)
4 bebert bob 55.4



= Transformer une liste en parametres de fonctions = 
si on a un tuple ou une liste qu'on doit passer en param à une fonction ;
on peut simplement les envoyer en params avec la syntaxe * 

>>> lst = ["lapin", "dodu", 77]
>>> print("elems en params" ,*lst)
elems en params lapin dodu 77


En utilisant * on a donc deux comportements :
-> en definition de fonction : en param non connus : on recupera un tuple
-> en appel a une fonction : la variable sera decomposée en plusieurs params envoyés à la fonction.
 
= Compréhension de liste = 
moyen tres puissant de filtrer  ou modifier une liste.
Attention la syntaxe est troublante .

-> parcours simple :

on parcourt une liste et on renvoie une seconde filtree ou modifiee :

>>> lst = [ 1,2,3,4]
>>> [nb * nb for nb in lst ]
[1, 4, 9, 16]

on a donc les [] qui sont les delimiteurs de compréhension de liste.
la valeur de retour (ici nb * nb)
notre variable ici nb dans une boucle for classique

-> filtrage avec branchement conitionnel : 
on va pouvoir ajouter une condition et donc avoir une liste en sortie dépendante de cette condition : 

>>> lst = [ 1,2,3,4]
>>> [nb * nb for nb in lst if nb%2==0]
[4, 16]


ex : on a une liste de fruits. toutes les semaines  on va prendre dans le stock une quantité à mettre en vente .Le stock diminue et on supprime de la vente un fruit plus en stock.

>>> qtt_a_retirer = 7 # On retire chaque semaine 7 fruits de
chaque sorte
>>> fruits_stockes = [15 , 3 , 18 , 21] # Par exemple 15 pommes , 3
melons ...
>>> [ nb_fruits - qtt_a_retirer for nb_fruits in fruits_stockes if
nb_fruits > qtt_a_retirer ]
[8 , 11 , 14]


La puissance des compréhension de liste est très importante pour toute transformation de liste : 
ex : on a une liste de fruits avec chacun une quantité on doit trier  la liste par combre de fruits decroissants :

>>> inventory = [ (" pommes " , 22) ,(" melons " , 4) ,(" poires " , 18) ,(" fraises " , 76) ,(" prunes " , 51) ,]

# tout d'abord on va transformer notre liste pour que les nombres soient afficher en premier :
>>> new_inventory = [ (nb, fruit) for fruit, nb in inventory ]
>>> new_inventory
[(22, ' pommes '), (4, ' melons '), (18, ' poires '), (76, ' fraises '), (51, ' prunes ')]
# on va maintenant reconstituer l'inventaire décroissant en utilisant fonction sorted et une methode reverse définie à True :
>>> inventory = [(fruit, nb) for nb, fruit in sorted(new_inventory ,reverse=True)]
>>> inventory
[(' fraises ', 76), (' prunes ', 51), (' pommes ', 22), (' poires ', 18), (' melons ', 4)]
>>> 

 
= les dictionnaires =

les dictionnaires sont des objects pouvant en contenir d'autres (comme les listes) mais cette fois ils assoccient chaque object contenus à une clé (la plupart du temps une chaine de caracteres).
ex : un carnet d'adresse ou on accede aux infos par le nom du contact.

/!\ Attention un dictionnaire n'est pas ordonné (contrairement aux listes ou l'on doit connaitre la cpoistion(l'indice) d'un object pour acceder à son contenu. De plus on utilise la clé des dictionnaire pour acceder aux valeurs des objects.

on utilise le keyword dict pour la classe dictionnaire.
>>> a = dict()
>>> type(a)
<class 'dict'>
>>> a
{}

on peut donc créer un dict vide :
>>> a = {}
>>> a
{}
pour ajouter des clés et des valeurs à un dictionnaire vide :

>>> blaze = {}
>>> blaze["surname"] = "bebert"
>>> blaze["age"] = 27
>>> blaze
{'age': 27, 'surname': 'bebert'}
On peut appeller un objet par sa clé :
>>> blaze["surname"]
'bebert'
si on ajoute une clé /valeur : le dico est compléter :
>>> blaze["adresse"] = "stadium"
>>> blaze
{'age': 27, 'surname': 'bebert', 'adresse': 'stadium'
si on ajoute une nouvelle valeur a une clé , l'ancienne est supprimée :
>>> blaze["surname"] = "bob"
>>> blaze
{'age': 27, 'surname': 'bob', 'adresse': 'stadium'}

Si on essaye d'acceder a une valeur dont la clé n'existe pas on a une keyerror :
>>> blaze["player"]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'player'
Les clés peuvent être de différents type (str,int list ...)
On est obligé d'avoir des clés uniques, mais on peut avoir des valeurs identiques :
>>> a[1] = "bobo"
>>> a[2] = "bibi"
>>> a[3] = "bobo"
>>> a
{1: 'bobo', 2: 'bibi', 3: 'bobo'}

On peut créer des clés sous forme de tuples : ex pour représenter les coordonnées de pieces sur un jeu d'echecs : ( colonne de a à h et ligne de 1 à 8 )
on peut créer directement une entrée dans un dictionnaire en séparant la clé de sa valeur par un ":" 
>>> echec = {("a",1): "white tower"}
>>> echec
{('a', 1): 'white tower'}
# ici on complete le dico en rajoutant une clé ( un tuple ) et une valeur
>>> echec[("b",2)] = "white queen"
>>> echec
{('a', 1): 'white tower', ('b', 2): 'white queen'}
# ici le tuple est implicite on doit toujours considérer que c'est un tuple même si les parenthèses ne sont pas présentes :
>>> echec["c",3] = "white horse"
>>> echec
{('a', 1): 'white tower', ('c', 3): 'white horse', ('b', 2): 'white queen'}

on voit que les couples clés/ valeurs sont séparées par des "," .
 


/!\ attention un construction du type :
b = { "lapin" , "nain" } : n'est pas un dico mais un set : qui est un object conteneur qui ne peut pas  contenir d'objet en double.

- Delete des clés d'un dictionnaire : 

> del 

>>> echec
{('a', 1): 'white tower', ('c', 3): 'white horse', ('b', 2): 'white queen'}

on utilise la fonction del :
>>> del(echec["a",1])
>>> echec
{('c', 3): 'white horse', ('b', 2): 'white queen'}

> pop : 
la méthode pop des dico fonctionne egalement : 
>>> echec.pop(("b",2))
'white queen'
>>> echec
{('c', 3): 'white horse'}

- Parcours de dictionnaire :

# on set un dico :
>>> fruits = {" pommes ":21 , " melons ":3 , " poires ":31}
# on va parcourir notre dico et afficher les clés : 
>>> for  key in fruits:
...     print(key)
... 
 pommes 
 poires 
 melons 

Ici on note que l'ordre n'est pas respecté : c'est normal pour un dico : non ordonné.

-> parcours des clés : 
on va pouvoir utiliser la méthode keys pour récupérer les clés du dico explicitement :

>>> for  key in fruits.keys():
...     print(key)
... 
 pommes 
 poires 
 melons 

-> parcours des valeurs :
on va pouvoir récupérer explicitement les valeurs de nos objects grâce à la méthode values :

>>> for val in fruits.values():
...     print(val)
... 
21
31
3

on peut se servir de cette methode avec des condition ex :
# si on a un des fruits dont la valeur vaut 21 :
>>> if 21 in fruits.values():
...     print("hey ! we got a twentyone fruit number !")
... 
hey ! we got a twentyone fruit number !

-> recupération des clés et valeurs : 
On va utiliser la methode items pour recupérer les clés et valeurs d'un dico (comme on utilise enumerate pour récupérer les indices et les objects d'une liste.)
>>> fruits
{' pommes ': 21, ' poires ': 31, ' melons ': 3}
>>> for fruit, number in fruits.items():
...     print("hey we got {} for this kind  of fruit {}".format(number,fruit))
... 
hey we got 21 for this kind  of fruit  pommes 
hey we got 31 for this kind  of fruit  poires 
hey we got 3 for this kind  of fruit  melons 


- Dictionnaire et parametre de fonction :
on peut recupérer les parametres nommés d'une fonction : dans ce cas ils sont placés dans un dico.
on ne pouvait pas le faire avec les listes comme on l'avait vu précédemment . ici on peut on utilise pour cela la syntaxe : "**" pour notre fonction : 


on va pouvoir injecter dans un dico nos clés et valeurs via une fonction 
>>> def fonction_inconnue(**parametres_nommes):
...     """ Fonction permettant de voir comment récupérer les \
...     parametres nommés dans un dico"""
        print ("J’ai reçu en paramètres nommés:{}.".format (
...     parametres_nommes) )

>>> fonction_inconnue()
J’ai reçu en paramètres nommés:{}.
>>> fonction_inconnue(p=4,j=8)
J’ai reçu en paramètres nommés:{'j': 8, 'p': 4}.


Si on passe des parametres non nommés à notre fonction on aura une erreur : python levera une exeption.


Pour avoir une fonction qui accepte n'importe quel type de parametres (nommés ou non) : il faut la déclarer de cette manière :
def fonc(*lst,**dico):
tous les params non nommés seront dans la variable lst et tous les params nommés dans la variable dico.

- Tranformer un dictionnaire en parametres nommés d'une fonction :

>>> parametres = {"sep":">>","end":"-\n"}
>>> print ("Voici "," un "," exemple "," d’appel ",**parametres)
Voici >> un >> exemple >> d’appel-
les params sont transmis a la fonction par un dico. pour indiquer que le dico doit être transmis en param nommés on place ** avant son nom.
C'est comme si nous avions ecrit : 
>>> print ("Voici "," un ", " exemple "," d’appel",sep =">>",end ="-\n")
Voici >> un >> exemple >> d ’ appel -

== les fichiers ==

- Changer de repertoire courant :
il va être forcement utile quand on veut travailler sur les fichiers de définir un repertoire de travail courant .
Pour cela on va importer le module os et indiquer le repertoire de dest dans lequel on veut aller . Noter que le chemin se précise avec des "/" même sous microsoft.

>>> import os
>>> os.chdir("/tmp")
>>>

- chemins absolus et relatifs :

-> le chemin absolus partira du debut de l'arborescence systeme (ex :"/" sous unix) 
on precisera donc le chemin complet du debut de la'arbo à la fin 

/home/boogie/test_dir


-> le chemin relatif : sera lui defini en fonction de l'endroit ou l'on se trouve :
ex : je suis dans /home/boogie je veurx aller dans test_dir 
test_dir 

Pour verifier le repertoire dans lequel on va travailler on utilise la methode getcwd() 

>>> import os
>>> os.chdir("/tmp")
>>> os.getcwd()
'/tmp'


- Lecture et ecriture dans un fichier :
on va creer avec un interpreteur un fichier dans un rep :
 ~/Documents/lab/python/zero  $  pwd
/home/boogie/Documents/lab/python/zero
 ~/Documents/lab/python/zero  $  cat test_file.py 
testo

Nous devons pour lire un fichier l'ouvrir : on utilise donc  la fonction open qui prend en param 
-> le path (relatif ou absolu du fichier à ouvrir) 
-> le mode d'ouverture qui est préciser sous forme de caractères :
- 'r' : read - lecture 
- 'w' : write - ecriture : le contenu du fichier est ecrasé.Si le fichier n'existe pas il est créee
- 'a' : append - ajout : le texte saisi sera ajouté au contenu du fichier existant. Si le fichier n'existe pas il sera créee.
- 'b' : binary on va ici utiliser conjointement à  w et a le mode binaire b si nos data doivent être sous forme bruts ( cf module pickle plus bas )  

->pour lire simplement le fichier  :

>>> open = open("test_file.py","r")
>>> open
<_io.TextIOWrapper name='test_file.py' mode='r' encoding='UTF-8'>

 on voit l'encodage du fichier 
on voit que le type de notre object est un fichier texte (TextIOWrapper) 
>>> type(open)
<class '_io.TextIOWrapper'>

Il est impératif de fermer le fichier quand on a fini de l'utiliser ( même en lecture seule c'est une bonne habitude à prendre) 
on utilise la méthode close :
>>> open.close()

-> pour lire l'integralité de notre fichier : 
on utilise la méthode read de la classe TextIOWrapper 
# on defini une var pour notre fichier qu'on ouvre en lecture seule : 
>>> file = open("test_file.py", "r")
# on associe une nouvelle variable en lui donnant le resultat de la methode read sur notre object precedent :
>>> content = file.read()
# on affiche notre nouvel object : qui contient notre texte : 
>>> print(content)
testo

- Ecriture dans un fichier :

on doit biensur ouvrir le fichier d'abord . On peut utiliser le mode "w" ou "a" en fonction de nos besoins.
Puis on utilise la methode write qui va nous servir à inserer du contenu. Une fois saisi on a le nombre caractère inséré dans le texte : qui peut donc être récupérer si besoin .
Attention la méthode write ne permet de saisir que des chaines de caractères : il faudra donc convertir nos autres types si besoin .

# on passe en mode append :
>>> file = open("test_file.py", "a")
# on rajoute le texte voulu à notre fichier 
>>> file.write("okokok ! let's gonna write in our python file from python code ! ")
65
# on ferme 
>>> file.close()
# on check l'ecriture : 
>>> file = open("test_file.py", "r")
>>> content = file.read()
>>> print(content)
testo
okokok ! let's gonna write in our python file from python code !

- keyword "with" :

il est fondamental de toujours fermer le fichier sur lequel on a travailler.
On peut faire des erreurs en ecriture etc..Si notre programme a besoin d'acceder au fichier et que celui ci est deja ouvert : il ne pourra pas le faire.
Le mot clé "with" permet d'eviter ce pb.
on va donc créer si elle n'existe pas une  variable apres avoir utiliser le keyword with , ouvert notre fichier dans le mode que l'on veut et utiliser le keyword "as" devant le nom de la variable que l'on veut utiliser : 

le keyword "with" permet de créer un context manager qui vérifie que le fichier est ouvert ou fermé même si des erreurs apparaissent pendant le bloc.
Le fichier sera automatiquement fermé à la fin du bloc et on peut le vérifier avec la méthode  closed.

>>> with open("test_file.py", "r") as file:
...     content = file.read()
... 
>>> content
'hey!!welcome[1, 4]'
# on vérifie que le fichier a bien été fermé par le contexte manager : 
>>> file.closed
True

Cela va nous permettre de garantir que si une exeption se produit : notre fichier sera quand même fermé à la fin du bloc.
python le fait automatiquement.

- Enregistrer des objets dans un fichier : module pickle.

on va pouvoir enregistrer nos objects dans un fichier pour les récupérer plus tard.
on va utiliser deux classes du module : Pickler et Unpickler 

/!\ Attention on va devoir écrire nos data en mode binaire : on passe donc en mode b apres w 


On créer d'abord notre pickler :
>>> import pickle
>>> with open("data","wb") as file:
...     my_pickle = pickle.Pickler(file)
... 
>>>

On va maintenant pouvoir injecter un object  avec la méthode dump 
ex : dico = {"singer": "bob", "guitar": "bebert"}

>>> dico = {"singer": "bob", "guitar": "bebert"}
>>> with open("data","wb") as file:
...     my_pickle = pickle.Pickler(file)
...     my_pickle.dump(dico)
...
>>>
on a maintenant quand on examine un fichier nommé data dans notre repertoire courant :

>>> os.listdir()
['tp_casino', 'test_file.py', 'algo_tp', 'data', 'test_dir', 'casino.py']

- Recupérer un objet enregistré : 

on va cette fois utiliser la classe Unpickler : on va créer un object "deplicker"
on va ouvrir notre fichier data en mode lecture binaire ( c'est le format dans lequel sont ecrites nos data), on creer un objet deplickler et on utilise la méthode load pour charger le contenu de notre fichier.
Quand on appelle notre variable on voit quelle contient les data en provenance de notre fichier : 
>>> with open("data","rb") as file:
...     my_depickler = pickle.Unpickler(file)
...     get_member = my_depickler.load()
... 
>>> get_member
{'guitar': 'bebert', 'singer': 'bob'}



== portée de variables et références  ==


- portée des variables :
en gros : comment les variables sont accessibles ? 
quand on crée une fonction, quelle variables sont utilisables dans son corps ? 
est ce qu'on peut créer dans notre corps de fonction des variables utilisablesen dehors ?

-> dans nos fonctions quelles variables sont accessibles ?

ex : on defini une variable :puis on l'affiche via une fonction . On change la valeur de la variable puis on rappelle la fonction :
>>> a = 5
>>> def fonct():
...     print("hey ! dans notre fonction le nb vaut  {}".format(a))
... 
>>> fonct()
hey ! dans notre fonction le nb vaut  5
>>> a = 8 
>>> fonct()
hey ! dans notre fonction le nb vaut  8

Ici on voit que la variable a n'est  pas passée en parametres de la fonction ..et pourtant python la trouve : c'est parce que cette variable a été définie avant l'appel .
c'est là qu'intervienne les différents espaces :

-> espace local  :

quand on fait reference à une variable dans la fonction : python va regarder si elle est définie dans l'espace local de la fonction ( cet espace contient les param passés à la fonction et les variables définies dans son corps. 
Python voit que cette variable n'existe pas dans l'espace local de la fonction.Il va donc regarder dans l'espace local dans lequel la fonction a été appellée : et là il trouve la variable : il peut donc l'afficher. 

Il est déconseiller d'appeller des variables qui ne sont pas dans l'espace local : dans l'absolu il vaut mieux travailler avec une variable globale.

-> portée des variables :
Que deviennent les variables définies dans une fonction ?

>>> def set_var(x):
...     try: 
...         print("avant affectation notre variable var vaut {}".format(var))
...     except NameError:
...         print("la variable n'existe pas encore!")
...     var = x
...     print("apres la nouvelle affectation var vaut {}".format(var))
... 
>>> set_var(4)
la variable n'existe pas encore!
apres la nouvelle affectation var vaut 4
>>> var
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'var' is not defined


Decomposition : 
quand on appelle la premiere fois la fonction set_var : la variable n'existe pas encore: on ne l'a pas défini dans le corps de la fonction ou du programme.
ensuite python affecte 4 à la variable var , l'affiche et s'arrête.
Quand on essaye d'afficher la variable var après la sortie de la fonction : python ne la trouve pas : c'est  normal elle n'est présente que dans la fonction et est détruite ensuite.

python a une regle pour les acces exterrieurs aux variables locales : on peut les afficher mais pas les modifier.Si on modifie une valeur dans le corps de notre fonction : on ne modifiera en aucun cas la variable exterrieure à la fonction portant le même nom.

Une fonction ne peut modifier par affectation la valeur d'une variable exterrieure a son espace local.

->  une fonction modifiant un object :

quand on passe des params à une fonction : on passe des objects (pas des valeurs).on pourrait donc essayer d'appeller une methode  qui modifie l'object que l'on passe à notre fonction ...

>>> def add(liste, valeur_to_add):
...     liste.append(valeur_to_add)
... 
>>> m = ["a","e","i","o"]
>>> add(m,"u")
>>> m
['a', 'e', 'i', 'o', 'u']

Pour résumer on aura donc :
parametre = nouvelle_valeur, le paramètre ne sera modifié que dans le corps de la fonction. Alors que si vous faites parametre.methode_pour_modifier(...), l’objet
derrière le paramètre sera bel et bien modifié.

- les reférences : 

en fait une variable est un nom identifiant pointant vers la référence d'un object : sa position en mémoire.
donc deux variables ne peuvent pas pointer sur le même object.

>>> m = ["a","e","i","o"]
>>> n = m
>>> n.append("Z")
>>> print(n)
['a', 'e', 'i', 'o', 'Z']
>>> print(m)
['a', 'e', 'i', 'o', 'Z']

 on voit ici que m et n contiennent une reférence vers le même object ( puisque m est aussi modifier quand on change n)

Cela ne fonctionne pas sur les entiers, chaine et float qui n'ont pas de methode pour modifier l'objet.

Si on veut modifier une liste sans toucher à l'autre on va devoir faire autrement : 
>>> m = ["a","e","i","o"]
# cela revient a copier le contenu de la liste dans un nouvel object :
>>> n = list(m)
>>> n.append("Z")
>>> print(n)
['a', 'e', 'i', 'o', 'Z']
>>> print(m)
['a', 'e', 'i', 'o']

les deux objects ne pointent plus sur la même référence.
On utilise les constructeurs pour faire une copie : ex list, dict ..

on peut vérifier la reference d'un object avec la fonction id qui prend en param nun objet et renvoie un nombre entier représentant la position de l'objet en mémoire : 
# on creee deux listes et on verifie laref de l'object :
>> a = [1,2]
>>> b = [1,2]
>>> id(a)
140074665253896
>>> id(b)
140074665272648
# on associe une liste à l'autre ( on copie son contenu) et on verifie les references : cette fois elles sont identiques : 
>>> b = a
>>> id(b)
140074665253896
>>> id(a)
140074665253896
# on recrée un nouvel objet : on retrouve deux references diff"érentes : 
>>> b = list(a)
>>> id(b)
140074665273224
>>> id(a)
140074665253896

/!\ Attention pour la comparaison de liste :
-> avec "==" on va comparer le contenu des listes : 
>>> a == b
True
-> avec is on compare la réference des objects : 
>>> a is  b
False


Bien être prudent avec l'utilisation de is  :


- les variables globales : 

il est tout a fait possible dans une fonction de modifier les variables exterrieures à celle-ci : pour cela on v modifier les variables globales :
/!\ il est déconseillé de trop travailler avec les globales.

principe : on déclare dans le corps de notre programme une variable.Dans notre fonction on declare que la modif de variable touche à une globale (hors de la fonction donc).
Python pour l'affectation de la variable va examiner les différents espaces ( en partant de l'espace local puis en remontant ) jusqu'a ce qu'il trouve la variable à modifier : et donner la possibilité à la fonction de modifier celle-ci.
on doit pour permettre ce mecanisme utiliser dans le corps de notre fonction le  keyword "global" qu'on place générallement sous la def de fonction, sous le docstring.


>>> nb = 2
>>> def fonct(nb):
...     """function in order to test the modification of a var set outside the function , using global spec"""
...     nb += 1
...     print("ok for now our var value is {}".format(nb))
... 
>>> fonct(3)
ok for now our var value is 4
>>> 


== Tp "hangman" =

Un jeu du pendu
Le premier point de la mission est de réaliser un jeu du pendu. Je rappelle brièvement
les règles, au cas où : l’ordinateur choisit un mot au hasard dans une liste, un mot
de huit lettres maximum. Le joueur tente de trouver les lettres composant le mot. À
chaque coup, il saisit une lettre. Si la lettre figure dans le mot, l’ordinateur affiche le
mot avec les lettres déjà trouvées. Celles qui ne le sont pas encore sont remplacées par
des étoiles (*). Le joueur a 8 chances. Au delà, il a perdu.
On va compliquer un peu les règles en demandant au joueur de donner son nom, au
début de la partie. Cela permettra au programme d’enregistrer son score.
Le score du joueur sera simple à calculer : on prend le score courant (0 si le joueur
n’a aucun score déjà enregistré) et, à chaque partie, on lui ajoute le nombre de coups
restants comme points de partie. Si, par exemple, il me reste trois coups au moment
où je trouve le mot, je gagne trois points.
Par la suite, vous pourrez vous amuser à faire un décompte plus poussé du score, pour l’instant cela suffira bien. 




