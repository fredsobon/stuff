=== notes automate_the_boring_stuff_with_python ===


1/ bases :type de données : 
- caracteres à entourer avec "ou ' ou """ pour la gestion multiligne.
>> print("hello world!")
hello world!
>>> 2 + 2
4
>>> 2.4 * 4
9.6
Concatenation : 
>>> "alice" + "bob"
'alicebob'
attention toujours associer les même type de données pour des calculs ..ex sur les chaines de caractères :
>>> "alice" + 3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Can't convert 'int' object to str implicitly
>>> "alice" * 2
'alicealice'
- enregistrement de variable :
elles sont comme une boite que l'on met dans la mémoire de l'ordinateur.On va procéder à l'assignation d'une variable avec :
un nom et le signe "=" :
>>> spam = 42
>>> spam + 3
45
>>> egg = 2
>>> spam + egg 
44
>>> spam + spam + egg
86
Quand une nouvelle valeur est saisie pour une variable : l'ancienne est effacée.
elles peuvent comporter des lettres maj, min , des chiffres, des "_" mais ne peuvent pas commencer par un chiffre et doivent ne former qu'un mot.
On peut se référrer à pep8 qui declare les bonnes pratiques de nommage des variables python.
Premier programme :

# This program says hello and asks for my name.
print('Hello world!')
print('What is your name?')
# ask for their name
myName = input()
print('It is good to meet you, ' + myName)
print('The length of your name is:')
print(len(myName)
print('What is your age?')
# ask for their age
myAge = input()
print('You will be ' + str(int(myAge) + 1) + ' in a year.')

après avoir rendu executable le fichier on le lance et on obtient donc :
boogie=/home/boogie/Documents/lab/python/boring==> ./00001.py 
Hello world!
What is your name?
bob
It is good to meet you, bob
The length of your name is:
3
What is your age?
40
You will be 41 in a year.


on peut afficher des notes en tant que commentaire il suffit de commencer les lignes avec un # 
pour afficher une ligne vide on peut facilement écrire :
print()
print va nous permettre d'afficher du texte (on encadre ce texte de caractères de type " ' ou """ 

input cette fonction va nous permettre de récupérer les données saisies par le user.
on assigne le tout dans une variable qui se nomme myName 
len est une fonction qui va retourner le nombre de caractères saisis dans le fonction ou le nombre de caracteres referant la valeur d'une variable.
on peut utiliser les fonctions str() , float() et str() pour convertir des types de données en d'autres car il est obligatoire de toujours utiliser des variables de mêmes type pour faire des opérations entre elles.

round() : la fonction round nous permet d'arrondir les nombres passés en paramètres :
>>> round(3.43)
3
>>> round(3.78)
4
>>> round(3.50)
4
>>> round(3.5)
4
>>> round(3.49)
3
par défaut la fonction arrondi au supérieur.

2/ flow control :
on va pouvoir prendre des décisions , ceci va pouvoir se faire en partie grâce à un nouveau type de données les Booléens : True et False (casse à respecter scrupuleusement)
>>> a= True
>>> a
True
>>> a == False
False
>>> a != False
True
On va biensur utiliser les opérateurs de comparaison :

== Equal to
!= Not equal to
< Less than
> Greater than
<= Less than or equal to
>= Greater than or equal to
on va également utiliser les tables de vérité :

"ET" 
The and Operator’s Truth Table
Expression Evaluates to...
True and True True
True and False False
False and True False
False and False False

"OU"
Table 2-3: The or Operator’s Truth Table
Expression Evaluates to...
True or True True
True or False True
False or True True
False or False False

"NON" 
The not Operator
Unlike and and or , the not operator operates on only one Boolean value (or
expression). The not operator simply evaluates to the opposite Boolean value.
>>> not True
False
>>> not not not not True
True
The not Operator’s Truth Table
Expression Evaluates to...
not True False
not False True

On peut biensur mixer test booleen et comparaisons :

>>> (4 < 5) and (5 < 6)
True
>>> (4 < 5) and (9 < 6)
False
>>> (1 == 2) or (2 == 2)
True


Test conditionnel : 
les tests conditionnels vont toujours utiliser les booleens : True et False.
on va utiliser l'indentation et la création de blocks de code :

On indente de quatre espaces le bloc de code puis on place un ":" à la fin de notre condition. On imbrique les blocks sans soucis : il faut forcement juste respecter l'indentation nécéssaire lors du déroulement de notre script: 
exemples : 
if name == 'Mary':
    print('Hello Mary')
    if password == 'swordfish':
        print('Access granted.')
    else:
        print('Wrong password.')

if name == 'Alice':
    print('Hi, Alice.')
elif age < 12:
    print('You are not Alice, kiddo.')


if name == 'Alice':
    print('Hi, Alice.')
elif age < 12:
    print('You are not Alice, kiddo.')
elif age > 2000:
    print('Unlike you, Alice is not an undead, immortal vampire.')
elif age > 100:
    print('You are not Alice, grannie.')


if name == 'Alice':
    print('Hi, Alice.')
elif age < 12:
    print('You are not Alice, kiddo.')
elif age > 100:
    print('You are not Alice, grannie.')
elif age > 2000:
    print('Unlike you, Alice is not an undead, immortal vampire.')
on utilise fréquemment la clause else à la fin d'un test egalement :

if name == 'Alice':
    print('Hi, Alice.')
elif age < 12:
    print('You are not Alice, kiddo.')
else:
    print('You are neither Alice nor a little kid.')

-while :
on peut voir le while comme un if sauf qu'à la fin du test on recommence l'action tant que le test effectué est True / vrai :
on va donc toujours mettre un compteur : un point de départ et une fin ( une action qui va modifier le corps de la boucle) pour evidemment ne pas tomber dans une boucle infinie :

avec un if on a ce type de tests :

spam = 0
if spam < 5:
    print('Hello, world.')
    spam = spam + 1
ce qui nous donne à l'execution :

python3 test.py 
Hello, world.
..le pattern n'est affiché qu'une seule fois.

avec while on a : 

#!/usr/bin/env python3

spam = 0
while spam < 3:
    print("hello world !")
    spam = spam + 1

notre pattern est donc affiché tant que notre test est vrai ( ici spam inferrieur à 3)
boogie=/home/boogie/Documents/lab/python/boring==> ./00002.py 
hello world !
hello world !
hello world !

On peut faire une boucle anonyme : ex demander à un user de saisir son prenom et tant que celui ci n'ecrit pas ce qu'on veut ..recommencer à lui poser la question :

name = ''
    while name != 'your name':
    print('Please type your name.')
    name = input()
print('Thank you!')

ce qui nous donne : 

python3 00003.py 
Please type your name.
bob
Please type your name.
your name
Thank you!

- break : l'utilisation de cette clause va nous permettre de sortir d'une boucle par exemple :
Dès que l'execution du code rencontre le keyword break : on sort de la boucle :

while True:
    print('Please type your name.')
    name = input()
    if name == 'your name':
    break
print('Thank you!')

ce qui a première  vue ne change pas grand chose : 

boogie=/home/boogie/Documents/lab/python/boring==> python3 00004.py 
Please type your name.
bob
Please type your name.
your name
Thank you!

