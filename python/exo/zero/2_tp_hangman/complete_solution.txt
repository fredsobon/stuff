Correction proposée
Voici la correction que je vous propose. J’espère que vous êtes arrivés à un résultat
satisfaisant, même si vous n’avez pas forcément réussi à tout faire. Si votre jeu marche,
c’est parfait !
Télécharger les fichiers
B
Code web : 934163

Voici le code des trois fichiers.

- donnees.py
""" Ce fichier d é finit quelques donn é es , sous la forme de
variables ,utiles au programme pendu """

# Nombre de coups par partie
nb_coups = 8
# Nom du fichier stockant les scores
nom_fichier_scores = " scores "

# Liste des mots du pendu
liste_mots = [
" armoire " ,
" boucle " ,
" buisson " ,
" bureau " ,
" chaise " ,
" carton " ,
" couteau " ,
" fichier " ,
" garage " ,
" glace " ,
" journal " ,
" kiwi " ,
" lampe " ,
" liste " ,
" montagne " ,
" remise " ,
" sandale " ,
" taxi " ,
" vampire " ,
" volant " ,
]

- fonctions.py
""" Ce fichier d é finit des fonctions utiles pour le programme
pendu . On utilise les donn é es du programme contenues dans donnees . py """

import os
import pickle
from random import choice
from donnees import *

# Gestion des scores

def recup_scores () :
""" Cette fonction r é cup è re les scores enregistr é s si le
fichier existe. Dans tous les cas , on renvoie un dictionnaire , soit l 'objet dépicklé, soit un dictionnaire vide. On s'appuie sur nom_fichier_scores d é fini dans donnees . py """

if os . path . exists ( nom_fichier_scores ) : # Le fichier existe 
# On le récupère
    fichier_scores = open( nom_fichier_scores , " rb " )
    mon_depickler = pickle.Unpickler( fichier_scores )
    scores = mon_depickler.load ()
    fichier_scores.close ()
else : # Le fichier n 'existe pas
    scores = { }
return scores

def enregistrer_scores ( scores ) :
""" Cette fonction se charge d ' enregistrer les scores dans le fichier nom_fichier_scores . Elle reçoit en paramètre le dictionnaire des scores à enregistrer """

fichier_scores = open ( nom_fichier_scores , " wb " ) # On écrase les anciens scores
mon_pickler = pickle . Pickler ( fichier_scores )
mon_pickler . dump ( scores )
fichier_scores . close ()

# Fonctions gérant les éléments saisis par l ' utilisateur

def recup _ nom _utilisateur() :
""" Fonction charg ée de ré cupérer le nom de l 'utilisateur. Le nom de l 'utilisateur doit être composé de 4 caractères minimum , chiffres et lettres exclusivement . Si ce nom n ' est pas valide , on appelle r écursivement la fonction pour en obtenir un nouveau """

nom_utilisateur = input ( " Tapez votre nom : " )
# On met la première lettre en majuscule et les autres en minuscules
nom_utilisateur = nom_utilisateur . capitalize ()
if not nom_utilisateur . isalnum () or len ( nom_utilisateur ) <4 :
    print ( " Ce nom est invalide . " )
# On appelle de nouveau la fonction pour avoir un autre nom
   return recu p_nom_ utilis ateur ()
else :
    return nom_utilisateur

def recup_lettre () :
""" Cette fonction r é cup è re une lettre saisie par l ' utilisateur . Si la chaine recupérée n 'est pas une lettre , on appelle r é cursivement la fonction jusqu 'à obtenir une lettre """

lettre = input ( " Tapez une lettre : " )
lettre = lettre . lower ()
if len ( lettre ) >1 or not lettre . isalpha () :
    print ( " Vous n ' avez pas saisi une lettre valide . " )
    return recup_lettre ()
else :
    return lettre

# Fonctions du jeu de pendu
def choisir_mot () :
""" Cette fonction renvoie le mot choisi dans la liste des mots liste_mots . On utilise la fonction choice du module random ( voir l ' aide ) . """
    return choice ( liste_mots )

def recup_mot_masque ( mot_complet , lettres_trouvees ) :
""" Cette fonction renvoie un mot masqu é tout ou en partie ,
en fonction :
- du mot d 'origine (type str)
- des lettres d éjà trouvées (type list)
On renvoie le mot d 'origine avec des * remplaçant les lettres que l 'on n 'a pas encore trouvées. """

mot_masque = " "
for lettre in mot_complet :
    if lettre in lettres_trouvees :
        mot_masque += lettre
    else :
        mot_masque += " * "
        return mot_masque

- pendu.py

""" Ce fichier contient le jeu du pendu .
Il s ' appuie sur les fichiers :
- donnees . py
- fonctions . py """

from donnees import *
from fonctions import *

# On récupère les scores de la partie
scores = recup_scores ()

# On récupère un nom d ' utilisateur
utilisateur = recup_nom _utilisateur ()

# Si l ' utilisateur n 'a pas encore de score , on l ' ajoute
if utilisateur not in scores.keys () :
    scores [ utilisateur ] = 0 # 0 point pour commencer
# Notre variable pour savoir quand arrêter la partie
continuer_partie = 'o '

while continuer_partie != 'n ':
    print ( " Joueur{0} : {1} point(s)".format(utilisateur, scores[utilisateur]) )
    mot_a_trouver = choisir_mot ()
    lettres_trouvees = []
    mot_trouve = recup_mot_masque ( mot_a_trouver ,
    lettres_trouvees )
    nb_chances = nb_coups

    while mot_a_trouver != mot_trouve and nb_chances > 0 :
        print ( " Mot à trouver { 0 } (encore { 1 } chances)".format mot_trouve , nb_chances) )
        lettre = recup_lettre ()
        if lettre in lettres_trouvees : # La lettre a déjà été choisie
            print ( " Vous avez d é j à choisi cette lettre . " )
        elif lettre in mot_a_trouver : # La lettre est dans le mot à trouver
            lettres_trouvees .append(lettre)
            print ("Bien joué.")
        else :
            nb_chances -= 1
            print ( " ... non , cette lettre ne se trouve pas dans le mot ... " )
            mot_trouve = recup_mot_masque ( mot_a_trouver ,lettres_trouvees )
    
    # A-t-on trouvé le mot ou nos chances sont - elles épuisées ?
    if mot_a_trouver == mot_trouve :
        print ( " F é licitations ! Vous avez trouv é le mot { 0 }.".format(mot_a_trouver))
    else :
        print ( " PENDU !!! Vous avez perdu . " )
    
    # On met à jour le score de l ' utilisateur
    scores [ utilisateur ] += nb_chances
    continuer_partie = input ( " Souhaitez - vous continuer la partie(O/N)?")
    continuer_partie = continuer_partie . lower ()

# La partie est finie , on enregistre les scores
enregistrer_scores (scores)
# On affiche les scores de l ' utilisateur
print ("Vous finissez la partie avec { 0 } points . ".format(scores[ utilisateur ]) )

