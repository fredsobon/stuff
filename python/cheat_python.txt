==== raw cheat python ====
==  types :
- type fonction :
connaitre un type de donnée : type(donnée)
>>> type("lapin")
<class 'str'>
>>> type(True)
<class 'bool'>
>>> type("2")
<class 'str'>
>>> a = "lapin"
>>> type(a)
<class 'str'>

caracteres : des fonctions dediées à la classe str aident beaucoup.
pour saisir du texte le mettre entre '' , "" ou """ """ (ici on peut saisir du texte en multiligne.). On protege par un \ les ' " que l'ont considere comme caracteres dans notre texte

les operations arthmetiques sont possible sur les types de même classe :
>>> "Lapin" + "1"
'Lapin1'
>>> "lapin" * 2
'lapinlapin'
>>> a = "lapin"
>>> b = 3
>>> a * b
'lapinlapinlapin'

-fonction len : va nous servir a compter le nombre d'élements

>>> a = "blablabla"
>>> len(a)
9

- Le type Node est utilisé pour définir "rien" :
>>> None
>>> a = None
>>> a
>>> type(a)
<class 'NoneType'>
Ce qui nous permet d'initialiser un objet / variable qui sera traitée apres 
- concatenation :
>>> "Lapin" + "1"
'Lapin1'

- conversion de type :
>>> a = int("3")
>>> type(a)
<class 'int'>
>>> a = float("3.2")
>>> type(a)
<class 'float'>
>>> a = str(3)
>>> type(a)
<class 'str'>

= input : interraction avec le user :
Attention s'utilise toujours avec une variable :
>>> ans = input("how are you ? ")
how are you ? cool
>>> ans
'cool'
>>> type(ans)
<class 'str'>

= operateurs logiques : vont nous servir a tester : le resultat est un booleen : True ou False
>>> number = 44
>>> number > 43
True
>>> number < 32
False
>>> number >= 44
True
>>> number <= 44
True
>>> number == 44
True
>>> number == 43
False

-> condition "ou" : un des deux membres doit être a vrai 
>>>True or False
True
>>> True or True
True
>>> False or True
True
>>> False or False
False

-> condition "et" tout doit être vrai
>>> True and True
True
>>> True and False
False
>>> False and True
False
>>> False and False

= tests conditionels :
il est imperatif d'indenter de 4 espaces chaques portion de bloc de code : cf doc python pep8
if / else : 

>>> prix = 30
>>> money = int(input("how many dollards have you got ? ")) #
ici on demande au user de saisir un nombre : celui ci est vu par python comme une chaine de caractere : on convertie immediatement le nombre pour pouvoir comparer avec le nombre de prix
how many dollards have you got ? 15
>>> if money > prix:
...     print("hey you can buy this stuff")
... else:
...     print("no way u got to work harder!")
...
no way u got to work harder!

if /elif /else :
>>> sister = 14 
>>> brother = 12
>>> if sister >  brother:
...     print("girl is older")
... elif sister == brother:
...     print("same age!")
... else:
...     print("boy is older")
... 
girl is older


= boucle while :
= while : est comme un if : une condition va être testée et u
ne action réalisée ou non . La difference est qu'en fonction
du resultat de l'evaluation on retourne dans la boucle while.
Il faut donc que des elements modifient les param de la condi
tions sinon on est dans une boucle infinie :

>>> sister = 5
>>> brother = 2
>>> while sister > brother:
...     print("girl is older!")
...     brother = brother + 1 # ou plus simple brother += 1
...
girl is older!
girl is older!
girl is older!

= commentaire en python :
le commentaire est le "#" 

== liste /tuple ==

= liste : collection d'element ordonnée :

>>> fruit = []
>>> type(fruit)
<class 'list'>
- append : ajoute un element a une liste :
>>> fruit.append("banane")
>>> fruit
['banane']
>>> fruit.append("ananas")
>>> fruit
['banane', 'ananas']
pour acceder a un element on  utilise l'index. on commence à compter à partir de 0
>>> fruit[0]
'banane'
>>> fruit[2]
'citron'
on peut modifier l'element d'une liste :
>>> fruit[2] = "pomme"
>>> fruit[2]
'pomme'
- pop : va nous servir a supprimer le dernier element d'une liste :
>>> fruit.pop()
'pomme'
>>> fruit
['banane', 'ananas']

- insert : va nous permettre de rajouter un element parmi ceu
x existant dans notre list :
>>> couleur.insert(1, 'jaune')
>>> couleur
['vert', 'jaune', 'rouge']

- slice 
>>> couleur
['vert', 'jaune', 'rouge', 'purple']
>>> len(couleur)
4
slice intervale : premier element d'index inclu, dernier exclu
>>> couleur[1:3]
['jaune', 'rouge']

on peut utiliser des bornes :
>>> couleur[:3]
['vert', 'jaune', 'rouge']
>>> couleur[1:]
['jaune', 'rouge', 'purple']
>>> couleur
['vert', 'jaune', 'rouge', 'purple']
>>> couleur[1:-1]
['jaune', 'rouge']

n peut setter un "pas" pour extraire les elements.
ex  tous les deux elements dans l'intervalle 1 à 6 :
>>> couleur
['vert', 'jaune', 'rouge', 'purple', 'pink', 'grey']
>>> couleur[1:6:2]
['jaune', 'purple', 'grey']

n peut donc inverser notre liste :
>>> couleur
['vert', 'jaune', 'rouge', 'purple', 'pink', 'grey']
>>> couleur[::-1]
['grey', 'pink', 'purple', 'rouge', 'jaune', 'vert']
ceci est valable pour les chaine de caracteres ( slicables mais non mutables) :
>>> "hello world!"[::-1]
'!dlrow olleh'
- tuple : ressemble aux listes (slicable etc ..) : il n'est p
as mutable.
ce qui est utile quand on veut s'assurer qu'aucune modif ne s
era faite sur nos entrées. le tuple est un peu plus rapide eg
alement.
>>> fix = ("lapin", "coincoin")
>>> type(fix)
<class 'tuple'>
>>> fix[1]
'coincoin'
>>> fix[1] = "loup"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment

== boucle for : ==

caracteres, list et tuples sont iterables
>>> lang = "python"
>>> for lettre in lang:
...     print(lettre)
...
p
y
t
h
o
n
>>> couleur
['vert', 'jaune', 'rouge', 'purple', 'pink', 'grey']
>>> fix
('lapin', 'coincoin')
liste et tuple sont iterables :
>>> for c in couleur:
...     print(c)
...
vert
jaune
rouge
purple
pink
grey
>>> for animal in fix:
...     print(animal)
...
lapin
coincoin

