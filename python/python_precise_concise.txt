Table des matières

Chapitre 1 – Python précis et concis . . . . . . . . . . . . . . . . . . . . . . . . . . .

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Conventions typographiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Utilisation de la ligne de commande Python . . . . . . . . . . . . . . . . . . . . .
Options de la commande Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Spécifications du programme à exécuter en ligne de commande . . . . . . .
Options de la commande Python 2.X . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Variables d’environnement de Python . . . . . . . . . . . . . . . . . . . . . . . . . . .
Variables opérationnelles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Variables de la commande Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Utilisation du lanceur Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Directives de fichiers du lanceur . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Lignes de commandes du lanceur . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Variables d’environnement du lanceur . . . . . . . . . . . . . . . . . . . . . . . . . . .
Types intégrés et opérateurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Priorité des opérateurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Notes sur l’utilisation des opérateurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Opérations par catégorie . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Notes sur les opérations sur les types séquence . . . . . . . . . . . . . . . . . . . .
Types intégrés spécifiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Nombres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Chaînes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Chaînes Unicode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Listes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Dictionnaires . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Fichiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Ensembles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Autres types et conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instructions et syntaxe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Règles syntaxiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Règles de nommage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instructions spécifiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instructions d’assignation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction print . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction if . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction while . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction for . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction pass . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction break . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction continue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction del . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction def . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction return . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction yield . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction global . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction nonlocal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction import . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction from . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction try . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction raise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction assert . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instruction with . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instructions Python 2.X . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Espace de noms et règles de portée . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Noms qualifiés : espaces de noms d’objets . . . . . . . . . . . . . . . . . . . . . . . .
Noms non qualifiées : portées lexicales . . . . . . . . . . . . . . . . . . . . . . . . . . .
Portées imbriquées et closures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Programmation orientée objet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Classes et instances . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Attributs pseudoprivés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Nouvelles classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Règles d’héritage formelles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Méthodes de surchargement d’opérateur . . . . . . . . . . . . . . . . . . . . . . . . .
Méthodes pour tous les types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Méthodes pour les collections (séquences, mappings) . . . . . . . . . . . . . . .
Méthodes pour les nombres (opérateurs binaires) . . . . . . . . . . . . . . . . . .
Méthodes pour les nombres (autres opérations) . . . . . . . . . . . . . . . . . . . .
Méthodes pour les descripteurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Méthodes pour gestionnaires de contextes . . . . . . . . . . . . . . . . . . . . . . . . .
Méthodes de surchargement d’opérateur Python 2.X . . . . . . . . . . . . . . .
Fonctions intégrées . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Fonctions intégrées Python 2.X . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Exceptions intégrées . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Superclasses : catégories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Exceptions spécifiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Exceptions spécifiques OSError . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Exceptions de catégories d’avertissements . . . . . . . . . . . . . . . . . . . . . . . . .
Avertissements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Exceptions intégrées Python 3.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Exceptions intégrées Python 2.X . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Attributs intégrés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Modules de la librairie standard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Module sys . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Module string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Fonctions et classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Constantes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Module système os . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Outils d’administration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Constantes de portabilité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Commandes du shell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Utilitaires d’environnement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Outils de descripteurs de fichiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Utilitaires de noms de chemins de fichiers . . . . . . . . . . . . . . . . . . . . . . . . .
Contrôle des processus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Module os.path . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Module de recherche de motifs par expressions régulières . . . . . . . . .
Fonctions du module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Objets pattern . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Objets match . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Syntaxe des motifs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Modules de persistance des objets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Modules shelve et dbm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Module pickle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Module et outils graphiques tkinter . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Exemple tkinter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Principaux widgets tkinter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Fonctions courantes de boîtes de dialogue . . . . . . . . . . . . . . . . . . . . . . . . .
Outils et classes supplémentaires tkinter . . . . . . . . . . . . . . . . . . . . . . . . . .
Comparaisons entre Tk et tkinter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Outils et modules Internet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Autres modules de la librairie standard . . . . . . . . . . . . . . . . . . . . . . . . . .
Module math . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Module time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Module timeit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Module datetime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Module random . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Module json . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Module subprocess . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Module enum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Module struct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Modules de gestion du threading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
API de base de données SQL Python . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Exemple d’utilisation de l’API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Interface du module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Objets connexion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Objets curseur . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Objets types et constructeurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Conseils supplémentaires . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Conseils de base concernant le langage . . . . . . . . . . . . . . . . . . . . . . . . . . .
Conseils concernant l’environnement . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Conseils d’utilisation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Conseils divers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .


=== INTRODUCTION   ===

Python est un langage de programmation générique, open source, prenant en charge plusieurs modèles de programmation (procédural, fonctionnel et orienté objet). On l’utilise aussi bien pour créer des programmes autonomes que des scripts dans une grande variété de domaines, et on estime que c’est l’un des langages de programmation les plus utilisés au monde.

La lisibilité du code, la fonctionnalité de ses librairies1, une conception qui optimise la productivité du développeur, la qualité logicielle, la portabilité des programmes, et l’intégration des composants sont les principales caractéristiques de Python. Python peut tourner sur la plupart des systèmes d’exploitation actuels tels que Unix, Linux, Windows, Macintosh, Java, .NET, Android ou iOS, pour ne citer que ceux-là.

Le présent ouvrage présente de façon synthétique les types et les instructions Python, les noms des méthodes spéciales, les fonctions intégrées et les exceptions, ainsi que les modules de librairies standards couramment utilisés et d’autres outils Python dignes d’intérêt.

Les développeurs en feront leur manuel de référence qui viendra compléter d’autres publications contenant des tutoriels, des exemples de code et d’autres ressources d’apprentissage.

Cette cinquième édition traite de Python 3.X et 2.X. S’il est vrai qu’elle est centrée sur la version 3.X, elle couvre néanmoins les différences de la version 2.X. Cette édition a été mise à jour pour être en phase avec les versions 3.3 et 2.7, mais aussi avec les améliorations de la version 3.4. Toutefois, l’essentiel reste applicable à l’ensemble des versions 2.X et 3.X, qu’elles soient antérieures ou ultérieures.

Cette édition s’applique également à toutes les grandes implémentations de Python, notamment CPython, PyPy, Jython, IronPython, et Stackless. Elle a également été mise à jour et complétée pour suivre les évolutions du langage, des librairies et des pratiques. Parmi ces nouveautés on trouvera : MRO et les algorithmes formels d’héritage de super(), les imports, les gestionnaires de contextes, l’indentation des blocs, ainsi que des modules de librairies tels que json, timeit,random, subprocess, enum, et le nouveau lanceur Windows.


http://docs.python.org/3/whatsnew/index.html


Chapitre 1. Python précis et concis

UTILISATION DE LA LIGNE DE COMMANDE PYTHON

Les lignes de commande pour exécuter les programmes Python à partir du shell ont le format suivant :

python [option*]

[fichier de script| -c commande | -m module | - ] [arg*]

Dans cette syntaxe, python désigne l’interpréteur exécutable Python, avec son chemin complet, ou bien avec le mot python résolu
par le shell (par exemple, via le paramètre PATH). Les options pour Python lui-même apparaissent avant le nom du programme à exécuter

(option). Les arguments destinés au code à exécuter n’apparaissent qu’après le nom du programme (arg).

Options de la commande Python

Voici en Python 3.X (voir plus bas la section intitulée Options de la

commande Python 2.X pour les différences) les éléments option de la

commande Python qui sont utilisés par Python lui-même :

-b

Émet un avertissement en cas d’appel de str() avec un objet bytes ou bytearray sans argument d’encodage, et en cas de comparaison d’un objet bytes ou bytearray avec un objet str.

L’option -bb provoque à la place des erreurs.

-B

N’écrit pas les fichiers de code intermédiaire (bytecode) .pyc ou .pyo lors de l’import des modules source.

-d

Active la sortie de l’analyseur de débogage (pour les développeurs du noyau de Python).

-E

Ignore les variables d’environnement Python (comme PYTHONPATH qui sont décrites plus bas).

-h

Affiche le message d’aide et termine le programme.

-i

Passe en mode interactif après l’exécution d’un script. Conseil : cette option est utile pour le débogage après une exception ; voir aussi pdb.pm(), qui est décrit dans la documentation de la
librairie Python.

-O

Optimise le code intermédiaire généré (crée et utilise des fichiers bytecode .pyo). N’apporte, à cette heure, qu’une amélioration mineure des performances.

-OO

Fonctionne comme l’option précédente -O, mais supprime éga- lement la documentation (docstrings) du code intermédiaire.

-q

N’affiche pas le numéro de version ni le message de copyright lors du démarrage en mode interactif (à partir de Python 3.2).

-s

N’ajoute pas le répertoire du site de l’utilisateur au chemin de recherche du module sys.path.

-S

Ne réalise pas d’import du module site à l’initialisation.

-u

Force stdout et stderr à passer en mode binaire et sans tampon (unbuffered).

-v

Affiche un message chaque fois qu’un module est initialisé, en indiquant l’emplacement à partir duquel il a été chargé ; en répétant le paramètre (-vv), on obtient davantage d’informa-
tion.

-V

Affiche le numéro de version de Python et quitte le programme (identique à --version).

-W arg

Contrôle les avertissements :
arg prend la forme action:message:catégorie:module:numéro_de_ligne.
Voir aussi les sections Avertissements et Exceptions de catégories d’avertissements, ainsi que la documentation du module des avertissements dans le manuel de référence de la librairie
Python (http://www.python.org/doc/).

-x

Saute la première ligne du code source, ce qui permet l’utilisation de formes #!cmd non compatibles avec Unix.


-X option

Définit une option spécifique à une implémentation de Python (à partir de Python 3.2) ; voir la documentation spécifique de l’implémentation pour les valeurs de l’option.
Spécifications du programme à exécuter en ligne de commande

Le code à exécuter et les arguments de la ligne de commande qui sont passés en paramètre sont spécifiés de la manière suivante dans la ligne de commande Python :

Fichier_de_script

Spécifie le nom du script Python à exécuter qui représente le fichier principal du programme (par exemple, python main.py exécute le code de main.py). Le nom du script, qui peut être
un chemin absolu ou relatif (désigné par « . »), est accessible dans sys.argv[0]. Avec certaines plateformes, les lignes de commandes peuvent aussi omettre l’élément python si elles
commencent par un nom de script et si elles ne contiennent pas d’options pour Python.

-c commande

Spécifie quel code Python (sous la forme d’une chaîne de caractères) doit être exécuté (par exemple : python -c "print(’spam’ * 8)" demande à Python d’effectuer une
opération d’affichage). sys.argv[0] renvoie la valeur ’-c’.

-m module

Lance un module en tant que script : recherche un module dans sys.path et l’exécute en tant que fichier racine (par
exemple : python -m pdb s.py exécute le module de débogage pdb situé dans un répertoire de librairies standard, avec l’argument s.py). Le module peut également désigner un package
(par exemple :idlelib.idle). sys.argv[0] renvoie le chemin complet du module.

Lit les commandes Python en provenance du flux d’entrée standard, stdin (par défaut) ; passe en mode interactif si stdin est un « tty » (terminal interactif). sys.argv[0] renvoie ’’.


arg*

Signale que tout autre élément de la ligne de commande est passé au fichier de script ou à la commande, et apparaît dans la liste des chaînes sys.argv[1:].

Si aucun fichier_de_script, commande ni module n’est spécifié, Python entre en mode interactif et lit les commandes depuis stdin (en utilisant readline pour l’entrée s’il est installé), sys.argv[0] renvoyant une chaîne vide (’’), sauf si l’option – a été employée.
Parallèlement aux lignes de commandes traditionnelles exécutées dans un shell, il est en général possible de lancer des programmes

Python en cliquant sur leur nom de fichier depuis un explorateur de fichiers dans une interface graphique, en appelant des fonctions de la librairie standard Python (par exemple : os.popen()), et en utilisant des options de menus de lancement des programmes dans des IDE tels que IDLE, Komodo, Eclipse et NetBeans.

Options de la commande Python 2.X

Python 2.X accepte le même format de ligne de commande, mais ne prend en charge ni l’option –b, qui est liée aux changements de typesde chaînes de Python 3.X, ni –q, ni non plus –X, qui sont des ajouts récents de la version 3.X. En revanche, il accepte d’autres options des versions 2.6 et 2.7 (certaines sont même présentes dans des versions antérieures) :

-t et –tt

Émet des avertissements en cas de mélanges incohérents de tabulations et d’espaces dans les indentations. Si l’on emploie l’option -tt, les erreurs sont en revanche déclenchées. Python
3.X traite toujours ces incohérences comme des erreurs de syntaxe (voir la section intitulée Règles syntaxiques).

-Q

Les options en rapport avec la division sont les suivantes :
-Qold (par défaut), -Qwarn, -Qwarnall et –Qnew. Toutes sont supplantées par le nouveau comportement de la véritable division de Python 3.X (voir la section Notes sur l’utilisation des opérateurs).

-3

Émet des avertissements pour toute incompatibilité Python

3.X dans le code que l’utilitaire 2to3, chargé de l’installatio standard de Python, ne peut pas réparer facilement.

-R

Pour lutter contre les attaques par déni de service, les valeurs de hachage des différents types sont modifiées par un nombre pseudo-aléatoire, si bien qu’il est impossible de les deviner
entre les invocations successives de l’interpréteur. Cette option est nouvelle à partir de Python 2.6.8. Ce commutateur est également présent dans la version 3.X à partir de la version
3.2.3 par souci de compatibilité, mais cette création aléatoire des valeurs de hachage est activée par défaut depuis la version

== VARIABLES D’ENVIRONNEMENT DE PYTHON ==

Les variables d’environnement (l’environnement est également appelé shell) sont des paramètres au niveau du système qui s’étendent à tous les programmes et qui sont utilisés pour la configuration globale.

Variables opérationnelles

Voici les principales variables d’environnement configurables par l’utilisateur et permettant la modification du comportement des :w
scripts :

PYTHONPATH
Ajoute au chemin de recherche par défaut celui des fichiers de modules importés. Le format de la valeur de cette variable est identique au paramètre PATH du shell : chemins de répertoires séparés par le caractère deux points (point-virgule sous Windows). Si la variable est définie, les imports de modules lancent une recherche des fichiers importés dans chaque répertoire listé dans PYTHONPATH, de la gauche vers la droite. Ils sont ajoutés à sys.path (le chemin complet de recherche des modules pour les composants les plus à gauche des imports absolus) après le répertoire du script, et avant les répertoires des librairies standards. Voir sys.path dans les sections Module sys et Instruction import.

PYTHONSTARTUP
Si l’on assigne un nom de fichier lisible à cette variable, les commandes Python de ce fichier sont exécutées avant que la première invite ne soit affichée en mode interactif (ce qui est
pratique pour les outils d’usage fréquent).

PYTHONHOME
Si la variable est définie, sa valeur est utilisée comme répertoire alternatif pour les modules des librairies (ou sys.prefix, sys.exec_prefix). Le chemin par défaut de recherche des modules est : sys.prefix/lib.

PYTHONCASEOK
Si la variable est définie, Python ne fait pas la différence entre les minuscules et les majuscules dans les noms des fichiers des instructions d’imports (cela ne fonctionne actuellement que
pour Windows et OS X).

PYTHONIOENCODING
La valeur de la variable est assignée à la chaîne encodingname[:errorhandler] pour remplacer l’encodage Unicode par défaut (et le gestionnaire d’erreurs optionnel) utilisé pour les
transferts de texte vers les flux stdin, stdout et stderr. Ce paramètre peut être nécessaire pour les textes non ASCII dans certains shells (par exemple : si l’affichage est défaillant, essaye utf8 ou un autre encodage).

PYTHONHASHSEED
Si la variable a la valeur « random », une valeur aléatoire sera utilisée pour le hachage des objets str, bytes et datetime ; il est également possible d’attribuer à la variable un entier dans
la plage allant de 0 à 4 294 967 295 pour obtenir des valeurs de hachage prévisibles (à partir de Python 3.2.3 et 2.6.8).

PYTHONFAULTHANDLER
Si la variable est définie, Python enregistre les gestionnaires dès le démarrage pour générer un objet traceback en cas d’erreurs fatales (à partir de Python 3.3, équivalent à -X faulthandler)Les variables d’environnement suivantes sont équivalentes à certaines options de la commande Python (voir la section Options de la commande Python) :

PYTHONDEBUG
Si elle n’est pas vide, équivaut à l’option -d.

PYTHONDONTWRITEBYTECODE
Si elle n’est pas vide, équivaut à l’option -B.

PYTHONINSPECT
Si elle n’est pas vide, équivaut à l’option -i.

PYTHONNOUSERSITE
Si elle n’est pas vide, équivaut à l’option -s.

PYTHONOPTIMIZE
Si elle n’est pas vide, équivaut à l’option -O.

PYTHONUNBUFFERED
Si elle n’est pas vide, équivaut à l’option -u.

PYTHONVERBOSE
Si elle n’est pas vide, équivaut à l’option -v.

PYTHONWARNINGS
Si elle n’est pas vide, équivaut à l’option -W, avec la même valeur. La variable accepte aussi une chaîne séparée par des virgules comme un équivalent des options multiples de -W (Àpartir de Python 3.2 et 2.7.).

UTILISATION DU LANCEUR WINDOWS
Uniquement sous Windows, Python 3.3 (et les versions ultérieures) installe un lanceur de scripts, qui est aussi disponible séparément pour les versions précédentes. Ce lanceur se compose des exécutables py.exe (console) et pyw.exe (interface graphique), qui peuvent être invoqués sans le paramètre PATH ; ces exécutables sont configurés de telle sorte qu’ils peuvent exécuter des fichiers Python en se basant sur leur extension. Cela permet aux versions de Python d’être sélectionnées de trois manières différentes : avec les directives de type Unix « #! » au sommet des scripts, avec les arguments de la ligne de commande, et grâce à des valeurs par défaut configurables.

Directives de fichiers du lanceur
Le lanceur reconnaît les lignes « #! » en en-tête des fichiers de scripts qui indiquent les versions de Python sous l’une des formes suivantes
et dans lesquelles le caractère * est égal à : vide pour utiliser la version par défaut (actuellement, il s’agit de la version 2, si elle est installée, et cela revient à l’omission d’une ligne « #! ») ; un numéro de version majeure (par exemple, 3) pour lancer la dernière version de cette ligne de produit installée ; ou bien une spécification complète majeure.mineure, éventuellement suffixée par 32 pour privilégier une installation 32 bits (par exemple, 3.1–32) :

#!/usr/bin/env python*
#!/usr/bin/python*
#!/usr/local/bin/python*
#!python*

Tous les arguments de la commande Python (python.exe) peuvent être indiqués à la fin de la ligne, et Python 3.4 (et les versions suivantes) peuvent interroger la variable PATH pour rechercher les lignes « #! » qui mentionnent juste python sans numéro explicite de version.

Lignes de commandes du lanceur

Le lanceur peut également être invoqué à partir du shell avec des lignes de commandes sous la forme suivante :

py [pyarg] [pythonarg*] script.py [scriptarg*]

Plus généralement, tout ce qui peut apparaître dans une commande python après son composant python peut aussi apparaître après l’élément optionnel pyarg d’une commande py, puis est passé au
Python généré tel quel. Cela inclut les paramètres de spécification du programme -m, -c et - ; voir la section Utilisation de la ligne de commande Python.

Le lanceur accepte les formes d’arguments suivantes pour le paramètre optionnel pyarg, qui est identique à la partie * qui mentionne un fichier à la fin d’une ligne « #! » :
Lance la dernière version 2.X installée
Lance la dernière version 3.X installée
-X.Y
Lance la version spécifiée (X est égal à 2 ou 3)

-X.Y32
Lance la version 32 bits spécifiée

Si les deux arguments sont présents, les arguments de la ligne de commande ont la priorité sur les valeurs fournies dans les lignes « #! ».
Quand elles sont installées, les lignes « #! » peuvent être appliquées dans plus de contextes (par exemple, des clics sur des icônes). 

Variables d’environnement du lanceur

Le lanceur reconnaît aussi les paramètres optionnels des variables d’environnement, qui peuvent être utilisés pour personnaliser le choix de la version par défaut ou quand l’information passée est partielle (par exemple, quand le numéro de version est manquant ou que seul

le numéro majeur de version est précisé, ou avec l’argument de la
commande py) :

PY_PYTHON

Version à utiliser par défaut(sinon 2)

PY_PYTHON3

Version à utiliser pour une version 3 partielle (par exemple, 3.2)

PY_PYTHON2

Version à utiliser pour une version 2 partielle (par exemple, 2.6)

Ces paramètres ne sont employés que par les exécutables du lanceur, et non pas quand python est invoqué directement.

TYPES INTÉGRÉS ET OPÉRATEURS

Priorité des opérateurs

Le tableau 1 Priorités des opérateurs en Python 3.X liste les opérateurs

Python. Les opérateurs dans les cellules du bas du tableau ont une

priorité plus élevée quand ils sont utilisés dans des expressions

regroupant plusieurs opérateurs sans parenthèses.

Termes atomiques et typage dynamique

Dans le tableau 1 Priorités des opérateurs en Python 3.X, les éléments

remplaçables X, Y, Z, i, j, et k peuvent prendre dans les expressions

les valeurs suivantes :

• Nom de variable, remplacé par la dernière valeur assignée



Types intégrés et opérateurs

13

• Expression littérale, définie dans la section Types intégrés spéci-

fiques

• Expression imbriquée, provenant d’une ligne quelconque de ce

tableau, éventuellement entre parenthèses

Les variables Python suivent un modèle de typage dynamique (elles

ne sont pas déclarées, mais sont créées au moment de leur assigna-

tion) ; leurs valeurs sont des références d’objets, qui peuvent être de

n’importe quel type. Elles doivent être assignées avant d’apparaître

dans une expression, car elles n’ont pas de valeur par défaut. Dans les

noms de variables, on fait toujours la différence entre les minuscules

et les majuscules (voir la section Règles de nommage). Les objets

référencés par des variables sont créés automatiquement, et quand

ils ne sont plus utilisés, ils sont supprimés automatiquement par le

garbage collector de Python, qui emploie des compteurs de références

dans Cpython .

Également dans le tableau 1, l’élément modifiable attr doit être

le nom littéral (sans guillemets) d’un attribut ; args1 est une liste

d’arguments formels (voir la la définition dans la section Instruction

def) ; args2 est une liste d’arguments d’entrée (voir la définition dans

la section Instruction expression) ; et le littéral ... est une expression

atomique seulement valide en 3.X.

La syntaxe des compréhensions et des littéraux de structures de

données (tuple, liste, dictionnaire et ensemble) indiquée de manière

abstraite dans les trois dernières lignes du tableau 1 est définie dans

la section Types intégrés spécifiques.

Notes sur l’utilisation des opérateurs

• En Python 2.X seulement, l’opérateur d’inégalité peut s’écrire

X != Y ou X <> Y. En Python 3.X, la dernière formulation a

été supprimée car elle est redondante.

• En Python 2.X seulement, une expression entre apostrophes

d’ouverture ‘X‘ est équivalente à repr(X), et convertit les

objets à afficher en tant que chaînes de caractères. En Python

3.X, il est préférable d’utiliser les fonctions intégrées str() et

repr() qui sont plus lisibles.

• En Python 3.X et 2.X, la division entière X // Y tronque

toujours la partie décimale et retourne le résultat sous la forme

d’un entier pour les entiers.





14

Chapitre 1. Python précis et concis

Tableau 1 — Priorités des opérateurs en Python 3.X

Opérateur

Description

yield X

Résultat de fonction génératrice (renvoie la valeur de send())

lambda args1: X

Générateur de fonction anonyme (renvoie X lors de l’appel)

X if Y else Z

Sélection ternaire (X est évalué seulement si Y est vrai)

X or Y

OU logique : Y est évalué seulement si X est faux

X and Y

ET logique : Y est évalué seulement si X est vrai

not X

NON logique

X in Y, X not in Y

Appartenance : itérables, ensembles

X is Y, X is not Y

Test d’identité d’objet

X < Y, X <= Y, X > Y, Comparaison

de grandeurs, sous-ensembles et sur-

X >= Y

ensembles

X == Y, X != Y

Opérateurs d’égalité

X | Y

OU logique avec une comparaison bit à bit, union

ensembliste

X ˆ Y

OU logique exclusif avec une comparaison bit à bit, différence

symétrique ensembliste

X & Y

ET logique avec une comparaison bit à bit, intersection

ensembliste

X << Y, X >> Y

Décalage de X à gauche, à droite de Y bits

X + Y, X

Y

Addition/concaténation, soustraction/différence ensembliste

X * Y, X % Y,

Multiplication/répétition, modulo/format, division, division

X / Y, X // Y

entière

-X, +X

Négation unaire, identité

X

Complément du NON logique avec une comparaison bit à

~

bit (inversion)

X ** Y

Puissance (élévation à la puissance)

X[i]

Indiçage (séquence, mapping, autres)

X[i:j:k]

Extraction (les trois bornes sont optionnel es)

X(args2)

Appel (fonction, méthode, classe, autre élément appelable)



Types intégrés et opérateurs

15

Tableau 1 — (suite)

X.attr

Référence d’attribut

(....)

Tuple, expression, expression de générateur

[....]

Liste, compréhension de listes

{....}

Dictionnaire, ensemble, compréhension de dictionnaires et

d’ensembles

• L’expression X / Y accomplit une véritable division en 3.X (le

reste est toujours conservé dans un résultat à virgule flottante),

et une division classique en 2.X (le reste est tronqué pour les

entiers) à moins que la véritable division de la version 3.X ne

soit activée en 2.X avec from __future__ import division ou

l’option Python -Qnew.

• La syntaxe [....] est utilisée à la fois pour les littéraux de listes

et les compréhensions de listes. Les compréhensions de listes

accomplissent une boucle implicite et collectent les résultats

des expressions dans une nouvelle liste.

• La syntaxe (....) est utilisée pour les tuples et les expressions,

ainsi que pour les expressions génératrices (une forme de

compréhension de liste qui produit des résultats à la demande,

au lieu de créer une liste de résultats). Dans ces trois cas de

figures, il est parfois possible d’omettre les parenthèses. Quand

les parenthèses d’un tuple sont omises, la virgule qui sépare les

éléments agit comme un opérateur de priorité inférieure s’il n’y

a rien d’autre de significatif.

• La syntaxe {....} est utilisée pour les littéraux de dictionnaires.

En Python 3.X et 2.7, elle est aussi utilisée pour définir les

littéraux, et à la fois les compréhensions de dictionnaires et

d’ensembles ; utilisez set() et les instructions de boucle en 2.6

et dans les versions antérieures.

• Les expressions yield et if/else sont disponibles en Python

2.5 et dans les versions ultérieures. La première renvoie les

arguments send() dans des générateurs, la deuxième étant un

raccourci pour une instruction if sur plusieurs lignes. yield

nécessite des parenthèses s’il n’est pas tout seul du côté droit

d’une instruction d’assignation.



16

Chapitre 1. Python précis et concis

• Les opérateurs de comparaison peuvent être chaînés : X < Y <

Z produit le même résultat que X < Y and Y < Z, mais Y n’est

évalué qu’une seule fois dans la forme chaînée.

• L’expression X[i:j:k] est équivalente à l’indiçage avec un objet

slice : X[slice(i, j, k)].

• En Python 2.X, les comparaisons de grandeurs entre des types

différents sont autorisées (en convertissant des nombres en un

type commun, et en ordonnant les autres types différents en

fonction du nom de leur type). En Python 3.X, les comparai-

sons de grandeurs entre des types mixtes non numériques sont

interdites et génèrent des exceptions ; cela inclut aussi les tris.

• Les comparaisons de grandeurs pour les dictionnaires ne sont

plus prises en charge en Python 3.X (bien que les tests d’égalité

le soient) ; la comparaison sorted(adict.items()) est une

alternative possible en 3.X.

• Les expressions d’appel autorisent les arguments positionnels

et les arguments par mot-clé, et de façon arbitraire un mélange

des deux ; voir les sections Instruction expression et Instruction

def pour la syntaxe d’appel.

• Python 3.X autorise l’utilisation des ellipses (littéralement

avec ... et avec les objets Ellipsis) sous la forme d’une

expression atomique n’importe où dans le code source. On

peut les employer dans certains cas comme une alternative à

pass ou None (par exemple, dans le corps d’une fonction stub

out, ou pour l’initialisation d’une variable indépendamment de

son type).

Opérations par catégorie

Dans cette section, par souci de concision, nous avons omis les

parenthèses des noms des méthodes __X__. En général, tous les

types intégrés prennent en charge les opérations de comparaison

et les opérations booléennes listées dans le tableau 2 Opérations de

comparaison et opérations booléennes (bien que Python 3.X ne prenne

pas en charge les comparaisons de grandeurs pour les dictionnaires et

les types mixtes non numériques).

Le booléen true indique tout nombre différent de zéro ou toute

collection non vide (liste, dictionnaire, etc.), tous les objets ayant une

valeur booléenne. Les noms réservés True et False sont préassignés

aux valeurs « vrai » et « faux » et se comportent comme les entiers 1



Types intégrés et opérateurs

17

Tableau 2 — Opérations de comparaison et opérations booléennes

Opérateur

Description

X < Y

Strictement inférieur àa

X <= Y

Inférieur ou égal à

X > Y

Strictement supérieur à

X >= Y

Supérieur ou égal à

X == Y

Égal à (valeur identique)

X != Y

Différent de (équivalent à X <> Y en Python 2.X seulement)b

X is Y

Objet identique

X is not Y

Objet différent

X < Y < Z

Comparaisons chaînées

not X

Si X est faux, alors on renvoie True ; sinon, False

X or Y

Si X est faux, alors on renvoie Y ; sinon, X

X and Y

Si X est faux, alors on renvoie X ; sinon, Y

a. Pour implémenter les expressions de comparaison, reportez-vous à la fois aux

méthodes de classe proposant une comparaison riche (par exemple, __lt__ pour <) en

3.X et 2.X, et à la méthode générale __cmp__ en 2.X, qui sont décrites dans la section

« Méthodes de surchargement d’opérateur ».

b. != et <> signifient tous les deux « différent de » en 2.X, mais != est la syntaxe

préférée en 2.X et la seule qui soit prise en charge en 3.X. is accomplit un test

d’identité ; ==, qui accomplit une comparaison de valeur, est par conséquent bien plus

utile.

et 0 avec des formats d’affichage personnalisés. L’objet spécial None a

la valeur « faux » et apparaît dans différents contextes Python.

Les comparaisons renvoient True ou False et sont automatique-

ment appliquées de manière récursive dans les objets composites

quand cela est nécessaire pour déterminer un résultat.

L’évaluation des opérateurs booléens and et or est arrêtée (court-

circuit) dès qu’un résultat est connu et l’un des deux opérandes (la

valeur à gauche ou à droite de l’opérateur) est renvoyé, sa valeur

booléenne indiquant le résultat.



18

Chapitre 1. Python précis et concis

Les tableaux 3 à 6 définissent les opérations communes aux types

des trois grandes catégories — séquence (ordonnée selon la position),

mapping (accès par clé), et nombre (tous les types numériques) —

ainsi que les opérations disponibles pour les types mutables (modi-

fiables) en Python. La plupart des types exportent également d’autres

opérations spécifiques à un type (par exemple, des méthodes), comme

cela est décrit dans la section Types intégrés spécifiques.

Tableau 3 — Opérations sur les types séquence (chaînes, listes, tuples,

octets, tableaux d’octets)

Opération

Description

Méthode de classe

X in S

Tests d’appartenance

__contains__,

X not in S

__iter__,

__getitem__a

S1 + S2

Concaténation

__add__

S * N, N * S

Répétition

__mul__

S[i]

Indice par décalage

__getitem__

S[i :j ], S [i :j :k ]

Slicing : éléments dans S à partir de __getitem__b

l’offset i jusqu’à j1 par pas optionnel

de k

len(S )

Longueur

__len__

min(S ), max(S )

Élément minimum, maximum

__iter__,

__getitem__

iter(S )

Protocole d’itération

__iter__

for X in S :,

Itération (tous les contextes)

__iter__,

[expr for X in S ],

__getitem__

map(func , S ), etc.

a. Reportez-vous aussi à la section « Protocole d’itération » pour de plus amples informations sur ces méthodes et leur fonctionnement. S’il est défini, __contains__ est préféré à

__iter__, qui est lui-même préféré à __getitem__.

b. En Python 2.X, on peut aussi définir __getslice__, __setslice__, et __delslice__

pour gérer les opérations de slicing. En 3.X, ces méthodes ont été remplacées au profit du

passage des objets slice à leurs équivalents basés sur les indices des éléments. Les objets

slice peuvent être utilisés de façon explicite dans les expressions d’indiçage à la place des

limites i:j:k.



Types intégrés et opérateurs

19

Tableau 4 — Opérations sur les séquences mutables (listes, tableaux

d’octets)

Opération

Description

Méthode de classe

S[ i] = X

Assignation d’indice : change l’élément __setitem__

existant à l’offset i pour référencer X

S[ i: j] = I,

Assignation du slice : S à partir de i __setitem__

S[ i: j: k] = I

jusqu’à j1 avec un pas optionnel k

(éventuel ement vide) est remplacé par

tous les éléments de l’itérable I

del S[ i]

Suppression de l’indice

__delitem__

del S[ i: j],

Suppression du slice

__delitem__

del S[ i: j: k]

Tableau 5 — Opérations de mapping (dictionnaires)

Opération

Description

Méthode de classe

D[ k]

Indice par clé

__getitem__

D[ k] = X

Assignation de la clé : change ou crée __setitem__

l’entrée pour la clé k pour référencer X

del D[ k]

Suppression de l’élément par sa clé

__delitem__

len( D)

Longueur (nombre de clés)

__len__

k in D

Test d’appartenance de la cléa

Identique

au

tableau 3

k not in D

Contraire de k in D

Identique

au

tableau 3

iter( D)

Objet itérateur pour les clés de D

Identique

au

tableau 3

for k in D:, etc.

Parcourt toutes les clés de D (tous les Identique

au

contextes d’itération)

tableau 3

a. En Python 2.X, l’appartenance à la clé peut aussi être codée comme D.has_key(k).

Cette méthode est supprimée en Python 3.X au profit de l’expression in, qui est également

préférée en 2.X. Voir la section « Dictionnaires ».





20

Chapitre 1. Python précis et concis

Tableau 6 — Opérations numériques (pour tous les types numériques)

Opération

Description

Méthode de classe

X + Y, X Y

Addition, soustraction

__add__, __sub__

X * Y, X / Y,

Multiplication, division, division entière, __mul__,

X // Y, X % Y

modulo

__truediv__a,

__floordiv__,

__mod__

X, + X

Négatif, positif

__neg__, __pos__

X | Y, X & Y,

OR avec une comparaison bit à bit, AND, __or__,

__and__,

X ^ Y

OR exclusif (entiers)

__xor__

X

N, X

N

Décalage à gauche avec une comparai- __lshift__, __rshift__

son bit à bit, décalage à droite (entiers)

X

Inversion avec une comparaison bit à __invert__

~

bit (entiers)

X ** Y

X puissance Y

__pow__

abs(X )

Valeur absolue

__abs__

int(X )

Conversion en entierb

__int__

float(X )

Conversion en virgule flottante

__float__

complex(X ),

Création d’une valeur complexe

__complex__

complex(re ,im )

divmod(X , Y )

Tuple : (X / Y , X % Y )

__divmod__

pow(X , Y [,Z ])

Élévation à la puissance

__pow__

a. L’opérateur / invoque __truediv__ en Python 3.X, mais __div__ en Python 2.X, à moins

que la division véritable soit activée. Voir la section « Notes sur l’utilisation des opérateurs »

pour la sémantique de la division.

b. En Python 2.X, la fonction intégrée long() invoque la méthode de classe __long__. En

Python 3.X, le type int incorpore le type long, qui a été supprimé.

Notes sur les opérations sur les types séquence

Vous trouverez ci-dessous des remarques et des exemples sur quelques

opérations listées dans les tableaux 3 et 4.



Types intégrés et opérateurs

21

Indiçage : S[i]

• Récupère les composants à la position des offsets (le premier

élément est à l’offset 0).

• Les indices négatifs comptent à reculons à partir de la fin (le

dernier élément est à l’offset 1).

• S[0] récupère le premier élément ; S[1] récupère le deuxième

élément.

• S[2] récupère l’avant dernier élément (identique à S[len(S)

2]).

Slicing : S[i:j]

• Extrait des sections contiguës d’une séquence, de i jusqu’à j1.

• Les limites de l’objet slice i et j ont respectivement pour valeur

par défaut 0 et la longueur de la séquence len(S).

• S[1:3] extrait les données de l’offset 1 jusqu’à 3, mais sans

l’inclure.

• S[1:] extrait les données de l’offset 1 jusqu’à la fin (len(S)-1).

• S[:1] extrait les données de l’offset 0 jusqu’au dernier élément,

mais sans l’inclure.

• S[:] crée une copie en mode shallow de l’objet S.

Slicing étendu : S[i:j:k]

• Le troisième élément, k, est le pas (sa valeur par défaut est 1),

qui est ajouté à l’offset de chaque élément extrait.

• S[::2] extrait un élément sur deux de la séquence S.

• S[::1] correspond à la séquence S inversée.

• S[4:1:1] récupère en ordre inverse de l’offset 4 jusqu’à l’offset

1, mais sans l’inclure.

Assignation de slicing : S[i:j:k] = I

• L’assignation de slicing est similaire à une suppression, puis à

une insertion à l’endroit de la suppression.

• Les itérables assignés à un slicing de base S[i:j] n’ont pas

besoin que leur taille corresponde.

• Les itérables assignés à un slicing étendu S[i:j:k] doivent

avoir la même taille.





22

Chapitre 1. Python précis et concis

Autre

• La concaténation, la répétition, et le slicing renvoient de

nouveaux objets (ce n’est pas toujours vrai pour les tuples).

TYPES INTÉGRÉS SPÉCIFIQUES

Cette section traite des nombres, des chaînes, des listes, des diction-

naires, des tuples, des fichiers, des ensembles et des autres types de

base. Les sous-sections fournissent des détails qui sont communs à

Python 3.X et 2.X. En général, tous les types de données composites

traités ici (par exemple, les listes, les dictionnaires et les tuples)

peuvent s’imbriquer les uns dans les autres autant de fois que néces-

saire. Les ensembles peuvent aussi s’imbriquer, mais ils ne peuvent

contenir que des objets immutables.

Nombres

Les nombres sont des valeurs immutables (non modifiables), qui

prennent en charge des opérations numériques. Cette section traite

des types numériques de base (entier, virgule flottante), ainsi que des

types plus avancés (complexe, décimal, et fraction).

Littéraux et création

Les nombres sont écrits sous différentes formes littérales et créés par

certaines opérations intégrées :

1234, 24, +42, 0

Entiers (précision illimitée).1

1.23, 3.14e-10, 4E210, 4.0e+210, 1., .1

Virgule flottante (normalement implémenté comme le type

double du C en CPython).

1. En Python 2.X, il y a un type distinct, nommé long, pour les entiers

avec une précision illimitée ; int est pour les entiers normaux avec une

précision généralement limitée à 32 bits. Les objets de type long peuvent être

codés avec un suffixe « L » (par exemple, 99999L), bien que les entiers soient

automatiquement convertis en types long s’ils nécessitent une précision sup-

plémentaire. En 3.X, le type int fournit une précision illimitée et comprend

donc les types 2.X int et long ; le préfixe littéral « L » est supprimé en 3.X.





Types intégrés spécifiques

23

0o177, 0x9ff, 0b1111

Littéraux octaux, hexadécimaux et binaires pour les entiers.1

3+4j, 3.0+4.0j, 3J

Nombres complexes.

decimal.Decimal(’1.33’), fractions.Fraction(4, 3)

Types basés sur des modules : décimal, fraction.

int(9.1), int(’-9’), int(’1111’, 2), int(’0b1111’, 0),,

float(9), float(’1e2’), float(’-.1’), complex(3, 4.0)

Permet de créer des nombres à partir d’autres objets, ou à partir

de chaînes avec la possibilité de convertir la base. À l’inverse,

hex(N), oct(N), et bin(N) créent des chaînes de chiffres pour

des entiers, et la mise en forme des chaînes crée des chaînes

génériques pour les nombres. Voir aussi les sections Mise en

forme des chaînes, Conversions de types, et Fonctions intégrées.

Opérations

Les types numériques prennent en charge toutes les opérations numé-

riques (voir le tableau 6). Dans les expressions comportant des types

mixtes, Python convertit les opérandes vers le type « le plus élevé »,

où le type entier est inférieur au type virgule flottante qui est lui-même

inférieur au type complexe. À partir de Python 3.0 et 2.6, les objets de

type entier et virgule flottante ont aussi quelques méthodes spécifiques

à leur type et d’autres attributs ; reportez-vous au manuel de la librairie

de référence de Python pour plus de détails :

>>> (2.5).as_integer_ratio()

# attribut float

(5, 2)

>>> (2.5).is_integer()

False

>>> (2).numerator, (2).denominator # attribut int

(2, 1)

>>> (255).bit_length(), bin(255)

# méthode 3.1+

(8, ’0b11111111’)

1. En Python 2.X, les littéraux octaux peuvent aussi être écrits avec un zéro

en en-tête, 0777 et 0o777 étant équivalents. En 3.X, seule la dernière forme

est prise en charge pour les valeurs octales.



24

Chapitre 1. Python précis et concis

Décimal et fraction

Python fournit deux types numériques supplémentaires dans les

modules de la librairie standard : décimal est un nombre à virgule

flottante avec une précision fixe, et fraction est un type rationnel

qui conserve le numérateur et le dénominateur de façon explicite.

Ces deux types peuvent être utilisés pour régler le problème de

l’imprécision des calculs avec des nombres à virgule flottante :

>>> 0.1 - 0.3

-0.19999999999999998

>>> from decimal import Decimal

>>> Decimal(’0.1’) - Decimal(’0.3’)

Decimal(’-0.2’)

>>> from fractions import Fraction

>>> Fraction(1, 10) - Fraction(3, 10)

Fraction(-1, 5)

>>> Fraction(1, 3) + Fraction(7, 6)

Fraction(3, 2)

Les fractions simplifient automatiquement les résultats. En réglant

les problèmes de précision et en prenant en charge différents proto-

coles de troncature et d’arrondi, les décimaux sont utiles pour les

applications monétaires. Reportez-vous au manuel de la librairie de

référence de Python pour les détails.

Autres types numériques

Python comprend aussi un type set (décrit dans la section Ensembles).

Des types numériques supplémentaires, comme des vecteurs optimisés

et des matrices sont disponibles sous la forme d’extensions open

source (par exemple, le package NumPy à http://www.numpy.org).

D’autres librairies tierces proposent des fonctionnalités de visualisa-

tion, des outils statistiques, l’amélioration de la précision pour les

calculs en virgule flottante, et bien d’autres choses encore que vous

trouverez sur le Web.



Types intégrés spécifiques

25

Chaînes

L’objet string (chaîne) normal str est une séquence immutable (non

modifiable) de caractères auxquels on accède par leur offset (position).

Ses caractères sont représentés par le rang qu’ils occupent dans

l’ensemble des caractères, et chaque caractère individuel est un objet

string de longueur 1.

Le modèle complet de l’objet string varie selon les versions de

Python.

Python 3.X a trois types string avec des interfaces similaires :

str

Une séquence immutable de caractères, utilisée pour tous les

textes (ASCII et Unicode).

bytes

Une séquence immutable d’entiers courts, utilisée pour repré-

senter les octets de données binaires.

bytearray

Une variante mutable du type byte.

Python 2.X en revanche a deux types string avec des interfaces

similaires :

str

Une séquence immutable de caractères, utilisée à la fois pour le

texte représenté par des octets (8 bits) et les données binaires.

unicode

Une séquence immutable de caractères, utilisée pour le texte

codé en Unicode.

Python 2.X (à partir de 2.6) a aussi le type Python 3.X bytearray

pour assurer la compatibilité avec 3.X, mais il n’impose pas une

distinction claire entre le texte et les données binaires (il peut être

mélangé librement avec des chaînes de caractères en 2.X).

Pour la prise en charge d’Unicode à la fois en 3.X et en 2.X,

reportez-vous à la section Chaînes Unicode. La majeure partie du reste

de cette section concerne tous les types string, mais consultez les

sections Méthodes de chaînes, Chaînes Unicode et Fonctions intégrées

pour en savoir plus sur les types bytes et bytearray.



26

Chapitre 1. Python précis et concis

Littéraux et création

Les littéraux de type string sont écrits sous la forme d’une série de

caractères entre guillemets, et sont éventuellement précédés d’un

caractère indiquant leur type de données ; une chaîne vide est codée

sous la forme de guillemets qui se suivent. Différentes opérations

intégrées renvoient également une nouvelle chaîne :

’Python"s’, "Python’s"

Les guillemets simples et doubles fonctionnent de la même

manière, et chaque caractère peut incorporer des guillemets de

l’autre type sans séquence d’échappement.

"""Ceci est un bloc multiligne"""

Les blocs encadrés par une suite de trois guillemets rassemblent

plusieurs lignes de texte en une seule chaîne avec des mar-

queurs de fin de ligne (\n) insérés entre les lignes originales

entre guillemets.

’Python\’s\n’

Les séquences de code d’échappement commençant par un

antislash (voir le tableau 7, Constantes chaînes des codes d’échap-

pement) sont remplacées par le code du caractère qu’elles repré-

sentent (par exemple, ’\n’ correspond au caractère ASCII qui

a pour valeur décimale 10).

"Ceci" "est" "concaténé"

Les constantes de chaînes adjacentes sont concaténées. Si

l’on met des parenthèses, cette forme peut tenir sur plusieurs

lignes).

r’chaîne\brute’, R’une\autre’

Chaînes brutes : les antislashs sont interprétés de manière

littérale (sauf s’ils sont à la fin d’une chaîne). Cela est utile

pour les expressions régulières et les chemins de répertoires

sous Windows : par exemple, r’c:\dir1\file’.

hex(), oct(), bin()

Crée des chaînes hexadécimales, octales et binaires à partir

de nombres entiers. Reportez-vous aux sections Nombres et

Fonctions intégrées.

Les formes littérales suivantes produisent des chaînes spécialisées

qui sont décrites dans la section Chaînes Unicode.



Types intégrés spécifiques

27

b’...’

Littéraux de chaînes bytes en Python 3.X : il s’agit d’une

séquence de valeurs de 8 bits représentant des données binaires

brutes. Pour des raisons de compatibilité avec 3.X, cette forme

est aussi disponible en Python 2.6 et 2.7, où elle crée sim-

plement une chaîne normale str. Reportez-vous aux sections

Méthodes de chaînes, Chaînes Unicode et Fonctions intégrées.

bytearray(...)

Construction de chaînes bytearray : il s’agit d’une variante

mutable de bytes qui est disponible en Python 3.X, et en

Python 2.X à partir de 2.6. Reportez-vous aux sections

Méthodes de chaînes, Chaînes Unicode et Fonctions intégrées.

u’...’

Littéraux de chaînes Unicode en Python 2.X : il s’agit d’une

séquence de codes Unicode. Par souci de compatibilité avec

2.X, cette forme est aussi disponible en Python 3.X à partir

de 3.3, où elle crée simplement une chaîne normale str (mais

les littéraux normaux et les chaînes str prennent en charge

le texte Unicode en Python 3.X). Reportez-vous à la section

Chaînes Unicode.

str(), bytes(), bytearray() (et unicode() seulement en 2.X)

Création de chaînes à partir d’objets, avec une possibilité d’en-

codage et de codage Unicode en Python 3.X. Reportez-vous à

la section Fonctions intégrées.

Les littéraux de chaînes peuvent contenir des séquences d’échap-

pement issues du tableau 7, Constantes chaînes des codes d’échappement

pour représenter des caractères spéciaux.

Opérations

Tous les types string prennent en charge toutes les opérations sur

les séquences (voir le tableau 3), ainsi que les méthodes spécifiques

aux chaînes (décrites dans la section intitulée Méthodes de chaînes).

De plus, le type str supporte les expressions % de mise en forme de

chaînes et la substitution de modèles (traitée plus loin), et le type

bytearray prend en charge les opérations sur les séquences mutables

(voir le tableau 4, ainsi que quelques méthodes supplémentaires qui

s’apparentent aux traitements des listes). Reportez-vous également

au module de gestion des expressions régulières pour les chaînes

dans la section intitulée Module de recherche de motifs par expressions



28

Chapitre 1. Python précis et concis

Tableau 7 — Constantes chaînes des codes d’échappement

Échappement

Signification

Échappement

Signification

\nouvel e_ligne

L’antislash est ignoré et \t

Tabulation horizontale

la nouvel e ligne se pour-

suit sur la ligne précé-

dente (continuation de

ligne)

\\

Antislash (\)

\v

Tabulation verticale

\’

Guil emet simple (’)

\N{ id}

Caractère dont le nom

dans la base de don-

nées Unicode est pré-

cisé entre accolades

\"

Guil emet double (")

\uhh

Caractère Unicode dont

le code est fourni en

hexadécimal sur 16 bits

\a

Bip

\Uhhhhhhhh

Caractère Unicode dont

le code est fourni en

hexadécimal sur 32 bits

[a]

\b

Retour arrière

\xhh

Caractère dont le code

est fourni en hexa-

décimal sur 2 chiffres

maximum

\f

Saut de page

\ooo

Caractère dont le code

est fourni en octal sur

3 chiffres maximum

\n

Nouvel e ligne

\0

Caractère Nul

(mais

n’est pas une fin de

chaîne)

\r

Retour (de chariot)

\autre

Ceci

n’est

pas

une

séquence

d’échappement

[a] \Uhhhhhhhh a une longueur exacte de 8 chiffres en hexadécimal (h) ; \u et \U ne

peuvent être utilisés que pour des littéraux de chaînes Unicode.



Types intégrés spécifiques

29

régulières, et les fonctions de gestion de chaînes dans la section

intitulée Fonctions intégrées.

Mise en forme de chaînes

En Python 3.X et 2.X (à partir de 3.0 et 2.6), les chaînes normales str

prennent en charge deux sortes de formatage qui mettent en forme

les objets avec des chaînes de description de format :

• Au moyen d’une expression (toutes versions de Python), codée

avec l’opérateur % : fmt % (valeurs)

• Au moyen d’une méthode (syntaxe plus récente, utilisable

en 3.0, 2.6 et ultérieures), codée avec la syntaxe suivante :

fmt.format(valeurs)

Ces deux syntaxes produisent de nouvelles chaînes basées sur des

codes de substitution qui sont spécifiques à leur type. Leur résultat

peut être affiché ou assigné à des variables pour un usage ultérieur :

>>> ’%s, %s, %.2f’ % (42, ’spam’, 1 / 3.0)

’42, spam, 0.33’

>>> ’{0}, {1}, {2:.2f}’.format(42, ’spam’, 1 / 3.0)

’42, spam, 0.33’

Bien que le formatage par l’appel d’une méthode semble s’être

développé plus rapidement ces dernières années, l’emploi d’expres-

sions reste très fréquent dans les anciens programmes et les deux

syntaxes sont entièrement supportées. De plus, si certains considèrent

l’usage de la méthode comme un peu plus facile à mémoriser et cohé-

rente, l’expression est souvent plus simple et plus concise. Puisque

ces deux formes ne sont que de légères variations autour d’un même

thème, de fonctionnalité et de complexité équivalentes, il n’y a pas

lieu aujourd’hui d’en recommander l’une plus que l’autre.

Expressions de mise en forme de chaînes

Les expressions de formatage de chaînes remplacent les cibles % dans

la chaîne sur la gauche de l’opérateur %, avec les valeurs sur la droite

(comme dans la fonction sprintf en C). Si on doit remplacer plus

d’une seule valeur, elles doivent être codées comme un tuple à droite

de l’opérateur %. Si on ne doit remplacer qu’un seul élément, il peut



30

Chapitre 1. Python précis et concis

être codé comme une valeur unique ou un tuple à un seul élément

sur la droite (imbriquez des tuples pour mettre en forme un nouveau

tuple). Si des noms de clés sont utilisés sur la gauche, un dictionnaire

doit être fourni sur la droite, et le caractère * permet aux paramètres

largeur et précision d’être passés de manière dynamique :

>>> ’The knights who say %s!’ % ’Ni’

’The knights who say Ni!’

>>> ’%d %s, %d you’ % (1, ’spam’, 4.0)

’1 spam, 4 you’

>>> ’%(n)d named %(x)s’ % {’n’: 1, ’x’: "spam"}

’1 named spam’

>>> ’%(n).0E => [%(x)-6s]’ % dict(n=100, x=’spam’)

’1E+02 => [spam ]’

>>> ’%f, %.2f, %+.*f’ % (1/3.0, 1/3.0, 4, 1/3.0)

’0.333333, 0.33, +0.3333’

Syntaxe de l’expression de mise en forme

Sur la gauche de l’opérateur % dans la chaîne de formatage, les

cibles de substitution ont le format général suivant, dont tous les

composants sont optionnels sauf le dernier (le texte, en dehors de ces

cibles de substitutions, est conservé tel quel) :

%[(keyname)][flags][width][.prec]typecode

Voici la syntaxe des cibles de substitution :

keyname

Référence entre parenthèses, grâce à son nom de clé, un

élément dans le dictionnaire attendu.

flags

Un caractère qui peut prendre les valeurs suivantes : (justifie à

gauche), + (signe numérique), espace (utilise un espace avant

les nombres positifs et un signe – pour les nombres négatifs), 0

(remplissage de zéros).

width

La largeur totale minimum du champ (utiliser * pour l’obtenir

à partir des valeurs).

prec

Donne le nombre de chiffres décimaux (c’est-à-dire la préci-

sion) après la virgule (utiliser * pour l’obtenir des valeurs).



Types intégrés spécifiques

31

typecode

Un caractère issu du tableau 8.

width et prec peuvent être codés avec le caractère * pour que

leur valeur soit obtenue à partir de l’élément suivant dans les valeurs

à droite de l’opérateur % lorsque les tailles ne sont connues qu’au

moment de l’exécution du programme. Astuce : %s convertit généra-

lement n’importe quel type d’objet en sa représentation sous forme

de chaîne.

Tableau 8 — Codes des types de formatage de chaînes pour %

Code

Signification

Code

Signification

s

Convertit en chaîne tout objet en utili- X

Identique à x, mais en

sant str()

majuscules

r

Identique à s, mais utilise repr() au lieu e

Format exponentiel en vir-

de str()

gule flottante

c

Caractère unique (int ou str)

E

Identique à e, mais en

majuscules

d

Décimal (entier en base 10)

f

Format décimal en virgule

flottante

i

Entier

F

Identique à f, mais en

majuscules

u

Identique à d (obsolète)

g

Format en virgule flottante

(identique à e ou f)

o

Octal (entier en base 8)

G

Identique à g, mais en

majuscules

x

Hexadécimal (entier en base 16)

%

Littéral ‘%’ (codé %%)

Méthode de mise en forme de chaînes

L’appel d’une méthode pour le formatage des chaînes fonctionne de

manière similaire à ce qui a été présenté dans la section précédente

avec les expressions, mais cette technique utilise la syntaxe classique

qui identifie les cibles de substitutions avec les caractères {} au lieu

de %.

Les cibles de substitutions dans les chaînes de formatage peuvent

désigner les arguments des méthodes par leur position ou par leur nom.



32

Chapitre 1. Python précis et concis

Elles peuvent également faire référence à des attributs d’arguments,

des clés et des offsets ; elles peuvent accepter un formatage par défaut

ou fournir des codes de types explicites, et imbriquer la syntaxe des

cibles pour extraire des valeurs à partir d’une liste d’arguments :

>>> ’The knights who say {0}!’.format(’Ni’)

’The knights who say Ni!’

>>> ’{0} {1}, {2:.0f} you’.format(1, ’spam’, 4.0)

’1 spam, 4 you’

>>> ’{n} named {x:s}’.format(n=1, x="spam")

’1 named spam’

>>> ’{n:.0E} => [{x:<6s}]’.format(

**dict(n=100, x=’spam’))

’1E+02 => [spam ]’

>>> ’{:f}, {:.2f}, {:+.{}f}’.format(

1/3.0, 1/3.0, 1/3.0, 4)

’0.333333, 0.33, +0.3333’

La plupart des applications de la méthode format ont des équiva-

lents dans les modèles d’expression %, comme cela a été vu dans la

section précédente (par exemple, clé de dictionnaire et références de

valeurs avec *), néanmoins l’emploi de la méthode permet de coder

certaines opérations à l’intérieur même de la chaîne de formatage :

>>> import sys

# Méthode vs expression : attr, clé, index

>>> fmt = ’{0.platform} {1[x]} {2[0]}’

>>> fmt.format(sys, dict(x=’ham’), ’AB’)

’win32 ham A’

>>> fmt = ’%s %s %s’

>>> fmt % (sys.platform, dict(x=’ham’)[’x’], ’AB’[0])

’win32 ham A’

À partir de Python 3.1 et 2.7, une virgule précédant la désignation

d’un entier ou d’un nombre à virgule flottante dans typecode (voir

plus loin la section Syntaxe de la méthode de mise en forme, insère les

virgules séparatrices de milliers, et un typecode avec % formate le

pourcentage (technique qui n’est pas présente dans l’expression de

formatage elle-même, mais qui est simple à coder sous la forme de

fonctions réutilisables) :

>>> ’{0:,d}’.format(1000000)

’1,000,000’

>>> ’{0:13,.2f}’.format(1000000)



Types intégrés spécifiques

33

’ 1,000,000.00’

>>> ’{0:%} {1:,.2%}’.format(1.23, 1234)

’123.000000% 123,400.00%’

À partir de Python 3.1 et 2.7, les numéros de champs sont

automatiquement numérotés séquentiellement s’ils ont été omis dans

le paramètre fieldname (voir plus loin la section la section Syntaxe

de la méthode de mise en forme). Les trois formulations suivantes

produisent un effet identique, même si la numérotation automatique

des champs est peut-être moins lisible s’il y a un grand nombre de

champs :

>>> ’{0}/{1}/{2}’.format(’usr’, ’home’, ’bob’)

’usr/home/bob’

>>> ’{}/{}/{}’.format(’usr’, ’home’, ’bob’)

# Auto

’usr/home/bob’

>>> ’%s/%s/%s’ % (’usr’, ’home’, ’bob’)

# Expr

’usr/home/bob’

Un objet unique peut également être mis en forme via la fonction

intégrée format(object, formatspec) (voir la section Fonctions inté-

grées), qui est utilisée par la méthode format, et dont le comportement

peut être mis en œuvre dans les classes avec la méthode de surcharge

d’opérateur __format__ (voir la section Méthodes de surchargement

d’opérateur).

Syntaxe de la méthode de mise en forme

Dans les chaînes pour l’appel de méthode de formatage, les cibles de

substitution prennent la forme suivante, avec quatre éléments, tous

optionnels, qui doivent apparaître sans espaces intermédiaires (nous

avons ici utilisé des espaces pour des raisons de lisibilité) :

{fieldname component !conversionflag :formatspec}

Voici la syntaxe des cibles de substitution :

fieldname

Un numéro optionnel ou une clé identifiant un argument ;

on peut l’omettre pour utiliser la numérotation relative des

arguments en 2.7, 3.1, et ultérieur.

component

Une chaîne de zéros ou de plusieurs références .name ou

[index] utilisée pour récupérer des attributs ou des valeurs



34

Chapitre 1. Python précis et concis

indicées de l’argument. On peut l’omettre et employer la valeur

entière de l’argument.

conversionflag

Introduit par un ! si présent, qui est suivi d’un r, s, ou a pour

appeler respectivement les fonctions intégrées repr(), str(),

ou ascii() avec la valeur comme argument.

formatspec

Commence avec le caractère : si présent, et se compose de

texte spécifiant la manière dont la valeur doit être présentée,

avec des détails tels que la largeur du champ, l’alignement, le

remplissage, la précision décimale, etc. Se termine avec un

code de type de données optionnel.

Après les deux-points, le composant imbriqué formatspec a

sa propre syntaxe, décrite ci-dessous (les crochets ne doivent pas

être saisis, mais ils signifient ici simplement que les éléments sont

optionnels) :

[[fill]align][sign][#][0][width][,][.prec][typecode]

Voici la syntaxe du paramètre formatspec imbriqué :

fill

Peut être n’importe quel caractère de remplissage autre que {

ou }.

align

Peut être <, >, =, ou ˆ, pour respectivement un alignement à

gauche, un alignement à droite, un remplissage après un signe

plus ou moins, ou un centrage.

sign

Un caractère qui peut être +, , ou un espace.

, (virgule)

Place une virgule pour la séparation des milliers à partir de

Python 3.1 et 2.7.

width et prec

Comme avec l’expression %, formatspec peut aussi contenir

des chaînes de formatage {} imbriquées ne contenant qu’un

fieldname, pour récupérer dynamiquement les valeurs de la

liste d’arguments (de manière très semblable à * dans les

expressions de formatage). Un 0 précédant width active un

remplissage par des zéros en fonction du signe (comme avec



Types intégrés spécifiques

35

fill), et un caractère # active une conversion alternative (si

elle est disponible).

typecode

Très semblable à ce qui se passe dans les expressions % listées

dans le tableau 8, mais la méthode de formatage a un code

de type b supplémentaire pour afficher les entiers au format

binaire (comme quand on utilise bin) ; à partir de Python 3.1

et 2.7, % est un code de type supplémentaire pour mettre en

forme les pourcentages. N’utilisez que d pour les entiers en base

10 (i ou u ne sont pas employés).

Vous noterez qu’à la différence du %s générique utilisé dans

l’expression, le code de type s de la méthode exige un objet string

comme argument ; avec la méthode, il est possible d’omettre le code

de type pour accepter tout type de manière générique.

Modèles de substitutions de chaînes

À partir de Python 2.4, il y a une autre forme de substitution de chaîne

qui diffère de l’expression et de la méthode décrites dans les sections

précédentes. Pour une mise en forme complète, la substitution est

réalisée avec l’opérateur % ou la méthode str.format() (les quatre

exemples suivants renvoient ’2: PR5E’) :

’%(page)i: %(book)s’ % {’page’: 2, ’book’: ’PR5E’}

’%(page)i: %(book)s’ % dict(page=2, book=’PR5E’)

’{page}: {book}’.format(**dict(page=2, book=’PR5E’))

’{page}: {book}’.format(page=2, book=’PR5E’)

Pour les tâches de substitutions plus simples, une classe Template

dans string utilise $ pour indiquer la substitution :

>>> import string

>>> t = string.Template(’$page: $book’)

>>> t.substitute({’page’: 2, ’book’: ’PR5E’})

’2: PR5E’

Les valeurs de substitutions peuvent être fournies sous la forme de

mots-clés ou de clés de dictionnaires :



36

Chapitre 1. Python précis et concis

>>> s = string.Template(’$who likes $what’)

>>> s.substitute(who=’bob’, what=3.14)

’bob likes 3.14’

>>> s.substitute(dict(who=’bob’, what=’pie’))

’bob likes pie’

La méthode safe_substitute ignore les clés manquantes plutôt

que de déclencher une exception :

>>> t = string.Template(’$page: $book’)

>>> t.safe_substitute({’page’: 3})

’3: $book’

Méthodes de chaînes

Outre la méthode format() décrite plus haut, les méthodes de chaînes

de caractères fournissent des outils de gestion de texte de haut niveau

qui vont au-delà des expressions de chaînes. Le tableau 9 énumère les

méthodes de chaînes disponibles ; dans ce tableau, S représente n’im-

porte quel objet string (techniquement, un str 3.X). Les méthodes

de chaînes qui modifient du texte renvoient toujours une nouvelle

chaîne et ne modifient jamais l’objet lui-même (les chaînes sont des

immutables, c’est-à-dire qu’elles ne sont pas modifiables).

On trouvera plus de détails sur ces méthodes dans les sections

décrivant les fonctions à la suite du tableau ; vous pouvez aussi

exécuter dans la console un help(str.nom_de_méthode). Astuce :

cette liste peut varier en fonction de la version de Python que vous

utilisez ; pour voir la vôtre, saisissez :

sorted(x for x in dir(str) if not x.startswith(’__’))

Reportez-vous également au module d’expressions régulières dans

la section Module de recherche de motifs par expressions régulières pour

des équivalents à certaines méthodes de types string s’appuyant sur

des motifs.

Méthodes bytes et bytearray

Les types de chaînes bytes et bytearray en Python 3.X ont des

ensembles de méthodes similaires au type str normal présenté dans la

section précédente, cependant leur rôles étant différents, elles ne sont

pas exactement interchangeables (str est du texte Unicode, bytes



Types intégrés spécifiques

37

Tableau 9 — Méthodes de chaînes en Python 3.X

S.capitalize()

S.casefold() (à partir de Python 3.3)

S.center( width, [, fil ])

S.count( sub [, start [, end]])

S.encode([ encoding [, errors]])

S.endswith( suffix [, start [, end]])

S.expandtabs([ tabsize])

S.find( sub [, start [, end]])

S.format(* args, ** kwargs)

S.format_map(mapping) (à partir de Python 3.2)

S.index( sub [, start [, end]])

S.isalnum()

S.isalpha()

S.isdecimal()

S.isdigit()

S.isidentifier()

S.islower()

S.isnumeric()

S.isprintable()

S.isspace()

S.istitle()

S.isupper()

S.join(iterable)

S.ljust( width [, fil ])

S.lower()



38

Chapitre 1. Python précis et concis

Tableau 9 — (suite)

S.lstrip([ chars])

S.maketrans( x [, y [, z]])

S.partition( sep)

S.replace( old, new [, count])

S.rfind( sub [, start [, end]])

S.rindex( sub [, start [, end]])

S.rjust( width [, fil ])

S.rpartition( sep)

S.rsplit([ sep [, maxsplit]])

S.rstrip([ chars])

S.split([ sep [, maxsplit]])

S.splitlines([ keepends])

S.startswith( prefix [, start [, end]])

S.strip([ chars])

S.swapcase()

S.title()

S.translate( map)

S.upper()

S.zfil ( width)

des données brutes binaires, et bytearray est un mutable, c’est-à-dire

qu’il est modifiable). Dans les exemples suivants exécutés en Python

3.3, set(dir(X)) – set(dir(Y)) calcule les attributs uniques de X :

>>> set(dir(str)) - set(dir(bytes))

{’__rmod__’, ’encode’, ’isnumeric’, ’format’,

’isidentifier’, ’isprintable’, ’isdecimal’,

’format_map’, ’__mod__’, ’casefold’}



Types intégrés spécifiques

39

>>> set(dir(bytes)) - set(dir(str))

{’decode’, ’fromhex’}

>>> set(dir(bytearray)) - set(dir(bytes))

{’extend’, ’remove’, ’insert’, ’append’, ’pop’,

’__iadd__’, ’reverse’, ’clear’, ’__imul__’,

’copy’, ’__setitem__’, ’__alloc__’, ’__delitem__’}

À noter :

• str ne prend pas en charge le décodage Unicode (le texte est

déjà décodé), mais il peut être encodé en bytes.

• bytes et bytearray ne prennent pas en charge le décodage

Unicode (ce sont des octets bruts, comprenant du texte déjà

encodé), mais on peut les décoder en str.

• bytes et bytearray ne prennent pas en charge le formatage de

chaîne (implémenté par str.format et les __mod__ et __rmod__

de l’opérateur %).

• bytearray a des méthodes de modification en place supplémen-

taires et des opérateurs semblables à list (exemple : append,

+=).

Reportez-vous à la section Chaînes byte et bytearray pour plus

d’informations sur les opérations de chaînes d’octets. Voir également

la section Chaînes Unicode pour plus d’informations sur les modèles

de types string, et la section Fonctions intégrées pour les appels de

fonctions.

Note

L’ensemble des méthodes disponibles en Python 2.X varie légère-

ment (par exemple, il existe une méthode decode pour le modèle

de type Unicode spécifique à 2.X). Le type de chaîne unicode

de Python 2.X a une interface quasi identique aux objets str

de 2.X. Pour plus de détails, référez-vous à l’ouvrage Python 2.X

Library Reference, ou exécutez dans une console dir(str) ou

help(str.method).

Les sections suivantes détaillent quelques méthodes listées dans le

tableau 9 qui ont été regroupées par domaine fonctionnel. Pour tous

les appels documentés qui renvoient un résultat sous forme de chaîne,



40

Chapitre 1. Python précis et concis

le résultat est une nouvelle chaîne (les chaînes étant des immutables,

elles ne sont jamais modifiées). On désigne par « espace blanc » les

espaces, les tabulations et les caractères de fin de ligne (tout ce qui se

trouve dans string.whitespace).

Méthodes de recherche

S.find(sub [, start [, end]])

Renvoie l’offset de la première occurrence de la chaîne sub

dans S, entre les offsets start et end (qui sont par défaut

égaux à 0 et len(S), la chaîne entière). Renvoie -1 si aucune

occurrence n’est trouvée. Astuce : voir également l’opérateur

d’appartenance in (dans le tableau 3, Opérations sur les types

séquence (chaînes, listes, tuples, octets, tableaux d’octets)), qui

peut être employé pour tester la présence d’une sous-chaîne

dans une chaîne.

S.rfind(sub [, start [, end]])

Comme find, mais recherche en partant de la fin (de droite à

gauche).

S.index(sub [, start [, end]])

Comme find, mais déclenche une exception ValueError si

aucune occurrence n’est trouvée, au lieu de -1.

S.rindex(sub [, start [, end]])

Comme rfind, mais déclenche une exception ValueError si

aucune occurrence n’est trouvée, au lieu de -1.

S.count(sub [, start [, end]])

Compte le nombre d’occurrences non superposées de sub dans

S, depuis l’offset start jusqu’à end (qui ont pour valeur par

défaut 0 et len(S)).

S.startswith(sub [, start [, end]])

True si la chaîne S commence par la sous-chaîne sub. start

et end sont des options pour définir le départ et la fin de la

recherche de sub.

S.endswith(sub [, start [, end]])

True si la chaîne S se termine par la sous-chaîne sub. start

et end sont des options pour définir le départ et la fin de la

recherche de sub.



Types intégrés spécifiques

41

Méthodes de découpage et de concaténation

S.split([sep [, maxsplit]])

Renvoie une liste des mots de la chaîne S, en utilisant sep

comme délimiteur. Si maxsplit est donné, maxsplit définit

le nombre maximal de découpages effectués. Si sep n’est pas

spécifié ou est égal à None, n’importe quel espace blanc est

considéré comme un séparateur. ’a*b’.split(’*’) retourne

[’a’,’b’]. Astuce : utilisez list(S) pour convertir une chaîne

en une liste de caractères (par exemple : [’a’,’*’,’b’]).

S.join(iterable)

Concatène un itérable de chaînes (par exemple, une liste ou

un tuple) en une chaîne unique, S étant ajouté entre chaque

élément. S peut être ’’ (une chaîne vide) pour convertir un

itérable de caractères en une chaîne (’*’.join([’a’,’b’])

retourne ’a*b’).

S.replace(old, new [, count])

Renvoie une copie de la chaîne S dont toutes les occur-

rences des sous-chaînes old ont été remplacées par new. Si

count est renseigné, seules les count premières occurrences

seront remplacées. Cela revient à utiliser une combinaison de

x=S.split(old) et new.join(x).

S.splitlines([keepends])

Découpe la chaîne S selon les fins de lignes, et renvoie des

listes de lignes. Le résultat ne conserve pas les sauts de lignes

sauf si keepends est égal à True.

Méthodes de mise en forme

S.format(*args, **kwargs), S.format_map(mapping)

Reportez-vous à la section Mise en forme des chaînes. En

Python 3.2 et ultérieur, S.format_map(M) est identique à

S.format(**M), sauf que M n’est pas copié.

S.capitalize()

Met en majuscule le premier caractère de la chaîne S, et en

minuscules le reste des caractères.

S.expandtabs([tabsize])

Remplace les tabulations contenues dans la chaîne S par un

nombre d’espaces égal à tabsize (la valeur par défaut est 8).



42

Chapitre 1. Python précis et concis

S.strip([chars])

Supprime les espaces blancs en tête et fin de la chaîne S (ou

les caractères dans chars si le paramètre est passé).

S.lstrip([chars])

Supprime les espaces blancs au début de la chaîne S (ou les

caractères dans chars si le paramètre est passé).

S.rstrip([chars])

Supprime les espaces blancs en fin de la chaîne S (ou les

caractères dans chars si le paramètre est passé).

S.swapcase()

Convertit toutes les majuscules en minuscules et inversement.

S.upper()

Convertit toutes les lettres en majuscules.

S.lower()

Convertit toutes les lettres en minuscules.

S.casefold()

En Python 3.3 et ultérieur, renvoie une version de S exploi-

table pour des comparaisons sans faire de différence entre

minuscules et majuscules ; comparable à S.lower(), mais cer-

tains caractères Unicode sont convertis en minuscules de façon

intelligente (par exemple, ’ß’ est converti en "ss").

S.ljust(width [, fill])

Justifie à gauche la chaîne S d’une largeur de width caractères

et remplit à droite l’espace restant avec des caractères fill

(par défaut, un espace). L’expression et la méthode de mise en

forme de chaînes produisent des effets similaires.

S.rjust(width [, fill])

Justifie à droite la chaîne S d’une largeur de width caractères

et remplit à gauche l’espace restant avec des caractères fill

(par défaut, un espace). L’expression et la méthode de mise en

forme de chaînes produisent des effets similaires.

S.center(width [, fill])

Centre la chaîne S d’une largeur de width caractères et remplit

à gauche et à droite l’espace restant avec des caractères fill

(par défaut, un espace). L’expression et la méthode de mise en

forme de chaînes produisent des effets similaires.

S.zfill(width)

Remplit de zéros à gauche une chaîne S pour produire une

chaîne de largeur width (on peut arriver à ce résultat via la

mise en forme de chaînes).



Types intégrés spécifiques

43

S.translate(table [, deletechars])

Supprime tous les caractères deletechars contenus dans la

chaîne S (s’ils sont présents), puis traduit les caractères en utili-

sant le tableau table, constitué d’une chaîne de 256 caractères

donnant la valeur correspondante de chaque caractère, indicée

selon son numéro ordinal.

S.title()

Renvoie une version de la chaîne au format de titre anglo-

saxon : chaque mot commence par une majuscule et tous les

autres caractères sont en minuscules.

Méthodes de test de contenu

S.is*()

Les tests booléens is*() fonctionnent avec des chaînes de

toutes tailles. Ils testent le contenu de chaînes de différentes

catégories (isalnum, isalpha, isdigit, etc.) et renvoient tou-

jours False si la chaîne à tester est vide.

Module originel de gestion des chaînes

À partir de Python 2.0, la majorité des fonctions de traitement de

chaînes contenues dans le module standard string, sont devenues

disponibles sous la forme de méthodes d’objets chaînes. Si X référence

un objet chaîne, un appel de fonction du module string tel que :

import string

res = string.replace(X, ’span’, ’spam’)

est en général équivalent en Python 2.0 et ultérieur à un appel de

méthode string tel que :

res = X.replace(’span’, ’spam’)

Néanmoins l’appel via la méthode est préférable et il est plus

rapide ; en outre, il n’implique pas d’import de module. Vous noterez

que l’opération string.join(iterable, delim) a été remplacée par

une méthode delim.join(iterable). Toutes ces fonctions ont été

retirées du module string en Python 3.X : à la place, on utilisera

les méthodes d’objets string. Reportez-vous à la section Module string

pour plus informations sur ce module.



44

Chapitre 1. Python précis et concis

Chaînes Unicode

Tout texte est considéré comme du texte Unicode, même s’il est

encodé avec un caractère par octet (8 bits) selon le schéma ASCII.

Python prend en charge des jeux de caractères et des encodages plus

élaborés grâce à Unicode (notamment des chaînes qui peuvent utiliser

plusieurs octets pour représenter des caractères en mémoire, et des

fichiers texte gérant différents types d’encodages). Cette prise en

charge diffère selon les versions de Python. La version 3.X traite

tout texte comme étant de l’Unicode, et les données binaires sont

représentées séparément, alors que Python 2.X distingue le texte codé

sur 8 bits (et les données) du texte Unicode :

En Python 3.X

Le type normal str et le littéral ’ccc’ représentent tous les

textes, à la fois le texte encodé en 8 bits et le texte Unicode

qui est plus riche. str est une séquence immutable de carac-

tères —des codes (identifiants ordinaux) Unicode décodés en

mémoire.

Le type bytes et le littéral b’ccc’ représentent des valeurs

de données binaires, sous la forme d’octets, notamment des

médias et du texte encodé en Unicode. bytes est une séquence

immutable de petits entiers (un octet formé de 8 bits), qui

prend en charge la majorité des opérations str, et affiche les

contenus, quand cela est possible, sous la forme de caractères

ASCII. Il existe un type supplémentaire : bytearray. C’est

une variante mutable de bytes, comprenant des méthodes

supplémentaires semblables à celles de gestion des listes pour

réaliser des modifications directement.

En 3.X, on notera aussi que les fichiers normaux créés avec

open() impliquent des objets str pour les contenus textuels

et des objets bytes pour les contenus binaires. En mode texte,

les fichiers encodent automatiquement en sortie et décodent

automatiquement en entrée.

À partir de Python 3.3, la forme Unicode littérale u’ccc’

provenant de 2.X est également disponible pour permettre la

compatibilité descendante (elle crée une chaîne str 3.X).

En Python 2.X

Le type normal str et le littéral ’ccc’ représentent les valeurs

du texte en 8 bits et des données binaires. Par ailleurs le type

unicode et le littéral u’ccc’ représentent les codes du texte



Types intégrés spécifiques

45

Unicode, qui est potentiellement plus riche. Les deux types

string sont des séquences d’immutables, et prennent en charge

des opérations quasi identiques.

En 2.X, les fichiers normaux créés avec open() sont orientés

octets, et une fonction codecs.open() prend en charge la

lecture et l’écriture des fichiers contenant du texte Unicode

avec l’encodage et le décodage lors des transferts.

À partir de Python 2.6, le littéral bytes b’ccc’ en provenance

de 3.X est également disponible, permettant la compatibilité

ascendante avec le code 3.X (il crée un str 2.X), et le mutable

bytearray de 3.X est également présent, même s’il correspond

moins à ce type.

Prise en charge d’Unicode en Python 3.X

Python 3.X permet aux caractères non ASCII d’être codés en chaînes

d’hexadécimaux (\x) et d’utiliser les échappements 16 et 32 bits

Unicode (\u, \U). De plus, chr() prend en charge les codes de

caractères Unicode :

>>> ’A\xE4B’

’AäB’

>>> ’A\u00E4B’

’AäB’

>>> ’A\U000000E4B’

’AäB’

>>> chr(0xe4)

’ä’

Les chaînes normales peuvent être encodées en octets bruts et

les octets bruts peuvent être décodés en chaînes normales, en faisant

appel à des encodages soit par défaut soit explicites (ainsi qu’à des

règles optionnelles de gestion d’erreurs : voir str() dans la section

Fonctions intégrées) :

>>> ’A\xE4B’.encode(’latin-1’)

b’A\xe4B’

>>> ’A\xE4B’.encode()

b’A\xc3\xa4B’

>>> ’A\xE4B’.encode(’utf-8’)

b’A\xc3\xa4B’

>>> b’A\xC3\xA4B’.decode(’utf-8’)

’AäB’



46

Chapitre 1. Python précis et concis

Les objets fichiers encodent aussi automatiquement en sortie et

décodent en entrée quand ils sont en mode texte (mais pas en mode

binaire) ; ils acceptent un nom d’encodage pour remplacer l’encodage

par défaut. (voir open() dans la section Fonctions intégrées) :

>>> S = ’A\xE4B’

>>> open(’uni.txt’, ’w’, encoding=’utf-8’).write(S)

3

>>> open(’uni.txt’, ’rb’).read()

b’A\xc3\xa4B’

>>>

>>> open(’uni.txt’, ’r’, encoding=’utf-8’).read()

’AäB’

À partir de la version 3.3, Python 3.X prend également en

charge le littéral Unicode u’ccc’ de 2.X pour assurer la compatibilité

descendante, mais il est équivalent à ’ccc’, et crée une chaîne str

3.X normale.

À la fois en 3.X et 2.X, il est possible d’incorporer directement du

contenu Unicode dans des fichiers de code source : utilisez une ligne

semblable à la ligne suivante comme première ou deuxième ligne de

votre fichier pour, si nécessaire, pour remplacer l’encodage UTF-8 par

défaut de Python :

# -*- coding: latin-1 -*-

Chaînes bytes et bytearray

Les objets chaînes bytes et bytearray de Python 3.X représentent

des données binaires 8 bits (y compris du texte Unicode encodé) ;

quand cela est possible, ils sont affichés au format texte ASCII et

ils prennent en charge la plupart des opérations de chaînes str, y

compris les méthodes et les opérations sur les séquences (mais pas la

mise en forme de chaînes) :

>>> B = b’spam’

>>> B

b’spam’

>>> B[0]

# Opération de séquence

115

>>> B + b’abc’

b’spamabc’

>>> B.split(b’a’)

# Méthodes



Types intégrés spécifiques

47

[b’sp’, b’m’]

>>> list(B)

# Séquence d’entiers

[115, 112, 97, 109]

De plus, bytearray prend en charge des opérations de modifica-

tion semblables à celles des listes :

>>> BA = bytearray(b’spam’)

>>> BA

bytearray(b’spam’)

>>> BA[0]

115

>>> BA + b’abc’

bytearray(b’spamabc’)

>>> BA[0] = 116

# Possibilité de modifier

>>> BA.append(115)

# Méthodes de liste

>>> BA

bytearray(b’tpams’)

Les deux types bytes et bytearray prennent en charge les opé-

rations sur les séquences (voir le tableau 3 Opérations sur les types

séquence (chaînes, listes, tuples, octets, tableaux d’octets)), ainsi que les

méthodes propres à certains types décrites plus haut dans la section

Méthodes bytes et bytearray. De plus, bytearray prend en charge les

opérations sur les séquences mutables (voir le tableau 4 Opérations

sur les séquences mutables (listes, tableaux d’octets)). Voir également les

appels de constructeurs de types dans la section Fonctions intégrées.

Python 2.6 et 2.7 possèdent le type bytearray mais pas le type

bytes (b’ccc’ est pris en charge pour assurer la compatibilité ascen-

dante avec 3.X, mais c’est un équivalent de ’ccc’ qui crée une chaîne

str 2.X normale).

Prise en charge d’Unicode en Python 2.X

En Python 2.X, les chaînes Unicode sont écrites sous la forme

de u’ccc’, qui crée un type d’objet unicode (en Python 3.X, le

type normal string et les littéraux sont utilisés pour Unicode). Des

caractères Unicode quelconques peuvent être écrits en utilisant une

séquence d’échappement particulière \uHHHH, où HHHH est un nombre

hexadécimal à quatre chiffres allant de 0000 à FFFF. La séquence

d’échappement habituelle \xHH peut également être utilisée, et des

séquences d’échappement en octal peuvent aussi être utilisées pour

les caractères jusqu’à +01FF, qui est codé en octal par \777.



48

Chapitre 1. Python précis et concis

Le type unicode prend en charge les méthodes de chaînes et

les opérations sur les séquences (voir le tableau 3, Opérations sur les

types séquence (chaînes, listes, tuples, octets, tableaux d’octets)). En

Python 2.X, les chaînes normales peuvent être mélangées avec les

chaînes Unicode. La combinaison de chaînes codées sur 8 bits et de

chaînes Unicode force systématiquement la conversion en Unicode,

en utilisant l’encodage ASCII par défaut (par exemple : ’a’ + u’bc’

donne u’abc’). Les opérations comprenant plusieurs types postulent

que la chaîne codée en 8 bits contient des données codées en ASCII

US sur 7 bits (et provoque une erreur s’il y a un caractère qui

n’est pas en ASCII). Les fonctions intégrées str() et unicode()

peuvent être utilisées pour la conversion entre chaîne normale et

chaîne Unicode, les méthodes encode() et decode() appliquent ou

suppriment l’encodage Unicode.

Les fonctions intégrées ainsi que certains modules incluent

codecs.open(), qui réalise des conversions d’encodage Unicode lors

des transferts de données, de manière très similaire à la fonction

intégrée open() en 3.X.

Listes

Les listes sont des séquences mutables (modifiables) de références

d’objets auxquelles on accède à partir de leur offset (position).

Littéraux et création

Les littéraux de listes sont écrits sous la forme de séries de valeurs

séparées par des virgules et encadrées par une paire de crochets. Ils

peuvent être construits de manière dynamique par un certain nombre

d’opérations :

[]

Une liste vide.

[0, 1, 2, 3]

Une liste à quatre éléments dont les indices vont de 0 à 3.

L = [’spam’, [42, 3.1415], 1.23, {}]

Une sous-liste imbriquée : L[1][0] renvoie 42.

L = list(’spam’)

Crée une liste de tous les éléments d’un itérable quelconque

en appelant la fonction constructeur.



Types intégrés spécifiques

49

L = [x ** 2 for x in range(9)]

Crée une liste en rassemblant les résultats d’expressions au

cours de l’itération (compréhension de listes).

Opérations

Les opérations incluent toutes les opérations sur les séquences (voir le

tableau 3, Opérations sur les types séquence (chaînes, listes, tuples, octets,

tableaux d’octets)), toutes les opérations sur les séquences modifiables

(voir le tableau 4, Opérations sur les séquences mutables (listes, tableaux

d’octets)), ainsi que les méthodes suivantes qui sont spécifiques aux

listes, où L désigne un objet liste quelconque :

L.append(X)

Insère un objet unique X à la fin de L, et effectue la modification

de la liste.

L.extend(I)

Insère chaque élément de tout itérable I à la fin de L (comme

avec un +). Cela est identique à L[len(L):] = I. Astuce :

utilisez L[:0] = I pour ajouter tous les éléments au début de I.

L.sort(key=None, reverse=False)

Trie L en ordre croissant par défaut ; si le paramètre key est

présent, il spécifie une fonction à un argument permettant

d’extraire ou de calculer la valeur de comparaison à partir

de chaque élément de la liste. Si le paramètre reverse est

présent et qu’il est égal à true, les éléments de la liste sont triés

comme si chaque comparaison était inversée. Par exemple :

L.sort(key=str.lower, reverse=True). Voir également la

fonction sorted() dans la section Fonctions intégrées.

L.reverse()

Inverse les éléments de L. Voir également la fonction rever-

sed() dans la section Fonctions intégrées.

L.index(X [, i [, j]])

Retourne l’indice de la première occurrence de l’objet X dans

L ; provoque une exception s’il n’est pas trouvé. Il s’agit d’une

méthode de recherche. Si i et éventuellement j sont passés, le

plus petit k est retourné, comme dans l’exemple L[k] == X et

i <= k < j, où j est égal par défaut à len(L).

L.insert(i, X)

Insère un objet X dans L à la position i (comme L[i:i] =

[X], pour i positif ou négatif). Astuce : utilisez L[i:i] = I



50

Chapitre 1. Python précis et concis

pour insérer tous les éléments d’un itérable quelconque I à la

position i.

L.count(X)

Renvoie le nombre d’occurrences de X dans L.

L.remove(X)

Supprime la première occurrence de l’objet X dans L; lève une

exception si introuvable. Identique à : del L[L.index(X)].

L.pop([i])

Supprime le dernier élément de L (ou celui à la position i).

S’utilise en association avec append() pour mettre en œuvre

des piles. Identique à x=L[i]; del L[i]; return x, où i est

égal par défaut à 1, c’est-à-dire le dernier élément.

L.clear()

Supprime tous les éléments de L. Disponible seulement en 3.X,

à partir de 3.3.

L.copy()

Crée une copie shallow de L. Disponible seulement en 3.X, à

partir de 3.3.

Note

En Python 2.X, la syntaxe de la méthode de liste sort est :

L.sort(cmp=None, key=None, reverse=False)

où cmp est une fonction de comparaison à deux arguments, qui

renvoie une valeur inférieure, égale, ou supérieure à zéro pour

indiquer un résultat inférieur, égal, ou supérieur. Cette fonction

de comparaison n’existe plus en 3.X parce qu’elle était le plus

souvent utilisée pour faire correspondre des valeurs de tri et un

ordre de tri inversé (c’est dans ce cas-là que les deux derniers

arguments étaient employés).

Expressions de compréhensions de listes

Un littéral de liste entre crochets ([...]) peut être une simple liste

d’expressions ou une expression de compréhension de liste au format

suivant :

[expr for target1 in iterable1 [if condition1]

for target2 in iterable2 [if condition2] ...

for targetN in iterableN [if conditionN] ]



Types intégrés spécifiques

51

Les compréhensions de listes produisent des listes de résultats :

elles collectent toutes les valeurs de l’expression expr, pour chaque

itération de toutes les boucles for imbriquées, où chaque condition

optionnelle est vraie. Les boucles for, à partir de la deuxième jusqu’à

la énième, ainsi que toutes les parties if sont optionnelles, et expr

et chaque condition peuvent utiliser des variables assignées par des

boucles for imbriquées. En 2.X, les noms assignés dans une compré-

hension de liste sont créés dans la portée qui encadre l’expression de

compréhension, mais en 3.X, ils sont restreints à la compréhension.

Les compréhensions peuvent être imbriquées librement.

Les compréhensions sont semblables à la fonction intégrée map().

En 3.X seulement, map() requiert list() pour forcer la génération

des résultats à afficher, parce que la fonction effectue une itération

tout en étant elle-même itérable ; en 2.X, map() renvoie une liste :

>>> [ord(x) for x in ’spam’]

[115, 112, 97, 109]

>>> list(map(ord, ’spam’))

# Utilise list() en 3.X

[115, 112, 97, 109]

Néanmoins, les compréhensions permettent souvent d’éviter

d’avoir à créer une fonction utilitaire temporaire :

>>> [x ** 2 for x in range(5)]

[0, 1, 4, 9, 16]

>>> list(map((lambda x: x ** 2), range(5)))

[0, 1, 4, 9, 16]

Les compréhensions avec des conditions sont similaires à filter()

(également itérable en 3.X seulement) :

>>> [x for x in range(5) if x % 2 == 0]

[0, 2, 4]

>>> list(filter((lambda x: x % 2 == 0), range(5)))

[0, 2, 4]

Les compréhensions avec des boucles imbriquées for sont sem-

blables aux instructions for normales :

>>> [x + y for x in range(3) for y in [10, 20, 30]]

[10, 20, 30, 11, 21, 31, 12, 22, 32]

>>> res = []

>>> for x in range(3):



52

Chapitre 1. Python précis et concis

...

for y in [10, 20, 30]:

...

res.append(x + y)

...

>>> res

[10, 20, 30, 11, 21, 31, 12, 22, 32]

Protocole d’itération

Le protocole d’itération définit un ensemble d’objets et de méthodes

utilisés dans tous les contextes d’itérations (notamment les compré-

hensions, les instructions des boucles for, et les fonctions intégrées

comme map() ou filter()) pour parcourir automatiquement les

éléments d’une collection ou les résultats produits à la demande.

L’itération fonctionne de la manière suivante :

• Les contextes d’itérations agissent sur un itérable (un objet

comprenant une méthode __iter__()).

• À son invocation, la méthode __iter__ () de l’itérable ren-

voie un itérateur (un objet avec une méthode __next__ () ; il

s’agit éventuellement du même objet).

• À l’appel de la méthode __next__() de l’itérateur, la méthode

retourne l’élément suivant de l’itération, ou bien provoque une

exception StopIteration pour mettre fin à l’itération.

De plus, la fonction intégrée iter(X) invoque une méthode

X.__iter__() d’un itérable, et la fonction intégrée next(I) appelle

une méthode I.__next__() d’un itérateur, ce qui simplifie les boucles

des itérations manuelles et la couche de portabilité. Certains outils,

comme la fonction intégrée map() et l’expression générateur ( generator

expression), sont à la fois des contextes d’itérations (pour leur sujet) et

des objets itérables (pour leurs résultats) ; reportez-vous aux sections

précédentes et suivantes.

Les classes peuvent fournir une méthode __iter__() pour inter-

cepter l’opération intégrée iter(X) ; si elle est définie, son résultat

comprend une méthode __next__() permettant de parcourir les

résultats dans les contextes d’itérations. Si __iter__() n’est pas

définie, la méthode d’indiçage __getitem__() est utilisée comme

méthode de repli pour réaliser une itération jusqu’à IndexError.

En Python 2.X, la méthode de l’objet itérateur I.__next__()

s’appelle I.next(), mais l’itération fonctionne de la même manière.

La fonction intégrée next(I) invoque la méthode I.next() en 2.6 et



Types intégrés spécifiques

53

2.7 au lieu de I.__next__(), ce qui facilite à la fois la compatibilité

3.X en 2.X, et la compatibilité 2.X en 3.X.

Expressions générateurs

À partir de Python 2.4, les expressions générateurs produisent des

effets similaires aux compréhensions de listes, sans nécessiter la

génération physique d’une liste contenant tous les résultats. Les

expressions générateurs définissent un ensemble de résultats, mais

ne matérialisent pas la totalité de la liste, afin d’économiser de la

mémoire. À la place, elles créent un objet générateur qui va renvoyer

les éléments un par un, dans des contextes d’itérations, en prenant

automatiquement en charge le protocole d’ itération mentionné dans la

section précédente. Par exemple :

ords = (ord(x) for x in aString if x not in skipStr)

for o in ords:

...

Les expressions générateurs sont des compréhensions codées entre

parenthèses plutôt qu’entre crochets, mais ceci mis à part, elles

prennent en charge l’ensemble de la syntaxe des compréhensions de

listes. Les parenthèses utilisées pour la fonction avec un seul argument

suffisent pour créer un itérable qui doit être passé à une fonction :

sum(ord(x) for x in aString)

Les variables de boucles d’expressions générateurs (par exemple : x,

dans la ligne précédente) sont inaccessibles en dehors de l’expression

générateur, que ce soit en Python 2.X ou 3.X. En 2.X, les compré-

hensions de listes conservent la variable de la boucle assignée à sa

dernière valeur, mais toutes les autres compréhensions restreignent la

variable à l’expression ; en Python 3.X, les variables de boucles sont

restreintes à l’expression dans toutes les formes de compréhensions.

Pour parcourir les résultats, les contextes d’itérations externes,

comme les boucles for, utilisent la méthode I.__next__() du pro-

tocole d’itération en 3.X, la méthode I.next() en Python 2.X, ou

encore la fonction intégrée next(I) en Python 2.X ou 3.X, qui appelle

la méthode appropriée en fonction de la portabilité. Lorsque cela est

nécessaire, appelez list() pour produire tous les résultats (restants)

en une fois (les générateurs étant leur propres itérateurs, invoquer

__iter__() est sans danger mais inutile) :



54

Chapitre 1. Python précis et concis

>>> squares = (x ** 2 for x in range(5))

>>> squares

<generator object <genexpr> at 0x027C1AF8>

>>> iter(squares) is squares # __iter__() optionnelle

True

>>> squares.__next__()

# Méthode (.next en 2.X)

0

>>> next(squares)

# Intégrée (3.X, 2.6+)

1

>>> list(squares)

# Jusqu’à StopIteration

[4, 9, 16]

Reportez-vous aux sections Protocole d’itération pour plus d’infor-

mations sur les expressions générateurs, et Instruction yield pour les

fonctions de générateur qui produisent aussi un objet générateur.

Autres expressions de compréhensions

Reportez-vous également aux informations sur les dictionnaires et

les compréhensions d’ensembles dans cet ouvrage (dans les sections

Dictionnaires et Ensembles). Ce sont des expressions similaires qui

produisent des dictionnaires et des ensembles en une fois ; elles

acceptent une syntaxe identique à celle des compréhensions de

listes et des expressions générateurs, mais elles sont codées entre des

accolades, et les compréhensions de dictionnaires commencent par

une paire d’expressions clé/valeur :

>>> [x * x for x in range(10)] # compréhension de liste

[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

>>> (x * x for x in range(10)) # expression générateur

<generator object <genexpr> at 0x009E7328>

>>> {x * x for x in range(10)} # Ensemble : 3.X, 2.7

{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}

>>> {x: x * x for x in range(10)} # Dictionnaire : 3.X, 2.7

{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49,

8: 64, 9: 81}



Types intégrés spécifiques

55

Dictionnaires

Les dictionnaires sont des mappings mutables (modifiables) de réfé-

rences d’objets auxquels on accède par une clé (et non pas une

position). Ce sont des tableaux non ordonnés qui associent des clés

avec des valeurs et qui sont gérés en interne comme des tables de

hachage à taille dynamique. En Python 3.X, les dictionnaires sont

très différents :

• En Python 2.X, les méthodes keys()/values()/items()

renvoient des listes. Il existe une méthode de recherche

has_key() ; il y a des méthodes itérables distinctes

iterkeys()/itervalues()/iteritems() et il est possible

de comparer les dictionnaires directement. À partir de

Python 2.7, les compréhensions de dictionnaires 3.X

sont disponibles pour assurer la portabilité, et les vues

de style 3.X sont prises en charge avec les méthodes

viewkeys()/viewvalues()/viewitems().

• En Python 3.X, les méthodes keys()/values()/items() ren-

voient des objets « vue » ( view) itérables à la place des listes ;

has_key() a été remplacée par les expressions in ; les méthodes

itérables de Python 2.X ont été remplacées par l’itération

d’objet vue ; les dictionnaires ne peuvent pas être comparés

directement, mais le résultat de sorted(D.items()) peut l’être,

et il y a maintenant une nouvelle expression de compréhension

de dictionnaire.

• Les objets vue de Python 3.X, qui offrent des résultats à la

demande, conservent l’ordre original du dictionnaire, reflètent

les changements futurs du dictionnaire, et peuvent prendre en

charge les opérations sur les ensembles. Les vues de clés sont

toujours comparables à des ensembles, ce qui n’est pas le cas des

vues de valeurs. Les vues d’éléments peuvent l’être si tous leurs

éléments sont uniques et hachables (inmutables). Reportez-

vous à la section Ensembles pour les expressions d’ensembles

qui peuvent s’appliquer à certaines vues. Passez en paramètre

les vues à la fonction list() pour forcer la génération de tous

les résultats en une seule fois (par exemple, pour l’affichage, ou

pour appliquer L.sort() à la liste).



56

Chapitre 1. Python précis et concis

Littéraux et création

Les littéraux de dictionnaires s’écrivent sous la forme de séries de

paires clé/valeur séparées par des virgules et encadrées par des acco-

lades ; la fonction intégrée dict() prend en charge d’autres modèles

de création, et les compréhensions de dictionnaires emploient l’itéra-

tion en Python 3.X et 2.7. L’assignation de nouvelles clés génère de

nouvelles entrées.

Tout objet immutable peut servir de clé de dictionnaire (par

exemple : une chaîne, un nombre, un tuple), et les instances de classes

peuvent être des clés si elles héritent des méthodes de protocole

de hachage (voir __hash__ dans la section Méthodes de surcharge-

ment d’opérateur). Les clés de tuples prennent en charge les valeurs

composites (par exemple : adict[(M,D,Y)], les parenthèses étant

optionnelles) :

{}

Un dictionnaire vide (pas un ensemble).

{’spam’: 2, ’eggs’: 3}

Un dictionnaire à deux éléments : les clés sont ’spam’ et

’eggs’, les valeurs 2 et 3.

D = {’info’: {42: 1, type(’’): 2}, ’spam’: []}

Dictionnaires imbriqués : D[’info’][42] retourne 1.

D = dict(name=’Bob’, age=45, job=(’mgr’, ’dev’))

Crée un dictionnaire en passant les arguments sous la forme de

mots-clés au constructeur.

D = dict(zip(’abc’, [1, 2, 3]))

Crée un dictionnaire en passant des paires clé/valeur au

constructeur.

D = dict([[’a’, 1], [’b’, 2], [’c’, 3]])

On obtient le même résultat que dans l’exemple précédent :

tout itérable composé d’une clé et d’une valeur est accepté.

D = {c.upper(): ord(c) for c in ’spam’}

Expression de compréhension de dictionnaire (en Python 3.X

et 2.7). Reportez-vous à la section Expressions de compréhensions

de listes pour la syntaxe complète.

Opérations

Les opérations comprennent toutes les opérations de mapping (voir

le tableau 5, Opérations de mapping (dictionnaires)), ainsi que les



Types intégrés spécifiques

57

méthodes suivantes propres aux dictionnaires, dans lesquelles D

représente systématiquement un objet dictionnaire :

D.keys()

Toutes les clés de D. En Python 2.X, une liste est renvoyée.

En Python 3.X, retourne un objet vue itérable, comme cela a

été décrit plus haut. for K in D prend aussi implicitement en

charge l’itération des clés.

D.values()

Toutes les valeurs stockées dans D. En Python 2.X, une liste

est renvoyée. En Python 3.X, retourne un objet vue itérable,

comme cela a été décrit plus haut.

D.items()

Paires de tuples (clé, valeur), une pour chaque entrée de D.

En Python 2.X, une liste est renvoyée. En Python 3.X, retourne

un objet vue itérable, comme cela a été décrit plus haut.

D.clear()

Supprime tous les éléments de D.

D.copy()

Renvoie une copie shallow de D.

D.update(D2)

Fusionne toutes les entrées de D2 avec D, ce qui équivaut à

for (k, v) in D2.items(): D[k] = v. En Python 2.4 et ulté-

rieur, accepte également un itérable de paires clé/valeur, ainsi

que des arguments sous la forme de mots-clés (par exemple :

D.update(k1=v1, k2=v2)).

D.get(K [, default])

Semblable à D[K] pour la clé K, mais renvoie default (ou None

si la valeur par défaut n’est pas précisée) au lieu de provoquer

une exception quand K n’est pas trouvé dans D.

D.setdefault(K, [, default])

Identique à D.get(K, default), mais assigne aussi la clé K à

default s’il ne se trouve pas dans D.

D.popitem()

Supprime et renvoie une paire (clé, valeur) choisie de

manière arbitraire.

D.pop(K [, default])

Si la clé K est trouvée dans D, renvoie D[K] et supprime K ;

sinon, renvoie default si la valeur par défaut est définie, sinon

provoque une erreur KeyError.



58

Chapitre 1. Python précis et concis

dict.fromkeys(I [, value])

Crée un nouveau dictionnaire avec des clés provenant de

l’itérable I et des valeurs définies par le paramètre value (la

valeur par défaut est None). Peut être appelé sur une instance

de D ou un type dict.

Les méthodes suivantes ne sont disponibles qu’en Python 2.X :

D.has_key(K)

Renvoie True si D a une clé K, ou False dans le cas contraire.

En Python 2.X uniquement, cette méthode est équivalente à K

in D, mais en règle générale, on ne la recommande pas car elle

a été supprimée en Python 3.X.

D.iteritems(), D.iterkeys(), D.itervalues()

Renvoient des itérables en fonction de paires clé/valeur, de

clés seules ou de valeurs seules. En Python 3.X, elles ont été

supprimées car items(), keys() et values() renvoient des vues

itérables.

D.viewitems(), D.viewkeys(), D.viewvalues()

Disponibles à partir de Python 2.7, celles-ci retournent des

vues itérables en fonction de paires clé/valeur, de clés seules,

ou de valeurs seules, le but étant d’émuler les vues retournées

par les fonctions 3.X items(), keys() et values().

Les opérations suivantes sont décrites dans le tableau 5, Opérations

de mapping (dictionnaires), mais renvoient aux méthodes qui viennent

d’être étudiées :

K in D

Renvoie True si D a la clé K, ou False dans le cas contraire.

Remplace has_key() en Python 3.X.

for K in D

Réalise une itération des clés K de D (dans tous les contextes

d’itérations). Le dictionnaire prend en charge l’itération

directe : for K in D est similaire à for K in D.keys().

Le premier s’appuie sur l’itérateur de clés du dictionnaire.

En Python 2.X, keys() retourne une nouvelle liste, ce qui

provoque une très légère surcharge du système. En Python 3.X,

keys() renvoie une vue itérable au lieu d’une liste enregistrée

sur le disque, ce qui rend les deux formes équivalentes.



Types intégrés spécifiques

59

Tuples

Les tuples sont des séquences immutables (non modifiables) de réfé-

rences d’objets accessibles via leur offset (position).

Littéraux et création

Les littéraux de tuples s’écrivent sous la forme d’une série de valeurs

séparées par des virgules et encadrées par des parenthèses. Les paren-

thèses sont parfois facultatives (par exemple, dans les en-têtes des

boucles for et pour les assignations =) :

()

Un tuple vide.

(0,)

Un tuple à un élément (pas une expression simple).

(0, 1, 2, 3)

Un tuple à quatre éléments.

0, 1, 2, 3

Un autre tuple à quatre éléments (comme dans l’exemple précé-

dent) ; mais invalide quand les virgules et les parenthèses sont

significatives (exemples : argument de fonctions, affichages

2.X).

T = (’spam’, (42, ’eggs’))

Tuples imbriqués : T[1][1] renvoie ’eggs’.

T = tuple(’spam’)

Crée un tuple à partir de tous les éléments d’un itérable, en

appelant la fonction constructeur.

Opérations

Les tuples acceptent toutes les opérations sur les séquences (voir le

tableau 3, Opérations sur les types séquence (chaînes, listes, tuples, octets,

tableaux d’octets)), ainsi que les deux méthodes suivantes, propres aux

tuples, en Python 2.6, 3.0, et les versions ultérieures :

T.index(X [, i [, j]])

Renvoie l’indice de la première occurrence de l’objet X dans le

tuple T ; provoque une exception si aucune occurrence n’est

trouvée. Il s’agit d’une méthode de recherche. Si on passe i et

éventuellement j, la méthode renvoie le plus petit k tel que



60

Chapitre 1. Python précis et concis

T[k] == X et i <= k < j, où j prend len(T) comme valeur

par défaut.

T.count(X)

Renvoie le nombre d’occurrences de X dans un tuple T.

Fichiers

La fonction intégrée open() crée un objet fichier, qui est l’interface la

plus commune vers les fichiers externes. Dans les sections suivantes,

sont décrits les objets fichiers qui exportent les méthodes de transfert

de données, où les contenus de fichiers sont représentés sous la forme

de chaînes Python. Cette liste n’étant pas exhaustive, il faudra vous

reporter aux manuels Python pour les appels et les attributs moins

fréquemment utilisés.

En Python 2.X seulement, le nom file() peut être utilisé comme

synonyme de open() au moment de la création de l’objet fichier, mais

open() est généralement la formulation recommandée. En Python

3.X, file() n’est plus disponible (pour la personnalisation des fichiers,

on utilise les classes du module io).

Reportez-vous à la fonction open() dans la section Fonctions

intégrées pour plus de détails sur la création de fichiers. Reportez-vous

également à la section Chaînes Unicode pour la distinction entre

fichiers textes et fichiers binaires, et les différences qui en découlent

pour leurs types de chaînes en Python 3.X.

Pour d’autres outils en rapport avec la gestion des fichiers dans

ce livre, consultez les modules dbm, shelve, et pickle dans la section

Modules de persistance des objets, les fonctions de fichiers basées sur

des descripteurs de fichier du module os, les outils pour chemins de

répertoires os.path dans la section Module système os, le stockage

des fichiers JSON dans la section Module json et l’emploi de bases de

données SQL dans la section API de base de données SQL Python.

Vous pouvez aussi vous reporter aux manuels Python concer-

nant socketobj.makefile() pour convertir un socket en un objet

apparenté à un fichier, et io.StringIO(str) et io.BytesIO(bytes)

(StringIO.StringIO(str) en Python 2.X) pour convertir une chaîne

en un objet apparenté à un fichier, compatible avec des API qui

attendent une interface d’objet fichier.



Types intégrés spécifiques

61

Méthodes pour les fichiers d’entrée

infile = open(filename, ’r’)

Crée un objet fichier d’entrée, connecté au fichier externe

nommé. filename est normalement une chaîne (par exemple,

’data.txt’) qui renvoie au répertoire de travail en cours, à

moins qu’elle ne comprenne un préfixe de chemin de répertoire

(par exemple, ’c:\dir\data.txt’). Le deuxième argument

donne le mode du fichier : ’r’ effectue la lecture en mode texte,

’rb’ lit en mode binaire, sans interpréter les sauts de lignes. Le

mode est optionnel et sa valeur par défaut est ’r’. En Python

3.X, open() accepte également un nom d’encodage Unicode

optionnel en mode texte ; des outils similaires existent en 2.X

avec codecs.open().

infile.read()

Lit tout le fichier, et renvoie son contenu sous la forme d’une

chaîne unique. En mode texte (’r’), les fins de lignes sont

converties par défaut en ’\n’. En mode binaire (’rb’), la

chaîne produite peut contenir des caractères non imprimables

(par exemple, ’\0’). En Python 3.X, le mode texte décode le

texte Unicode en chaînes str et le mode binaire renvoie un

contenu inchangé sous la forme d’une chaîne bytes.

infile.read(N)

Lit au maximum N octets supplémentaires (1 ou plus) ; vide à

la fin du fichier.

infile.readline()

Lit la ligne suivante (via le marqueur de fin de ligne) ; vide à

la fin du fichier.

infile.readlines()

Lit le fichier en entier sous la forme d’une liste de lignes. L’ité-

rateur de ligne de l’objet fichier présenté ci-dessous constitue

une alternative.

for line in infile

Utilise l’itérateur de ligne de l’objet fichier infile pour parcourir

automatiquement les lignes du fichier. Disponible dans tous les

contextes d’itération, y compris les boucles for, map(), et les

compréhensions (par exemple : [line.rstrip() for line in

open(’filename’)]). L’itération for line in infile produit

un résultat similaire à for line in infile.readlines(), à

ceci près que l’utilisation de l’itérateur de ligne renvoie des



62

Chapitre 1. Python précis et concis

lignes à la demande au lieu de charger tout le fichier en

mémoire, et gère donc plus efficacement l’espace.

Méthodes pour les fichiers de sortie

outfile = open(filename, ’w’)

Crée un objet fichier de sortie, connecté à un fichier externe

dont le nom est filename (défini dans la section précédente).

Le mode ’w’ écrit du texte, et le mode ’wb’ des données

binaires sans interprétation des marqueurs de fin de ligne. En

Python 3.X, open() accepte aussi un nom d’encodage Unicode

optionnel en mode texte ; en 2.X, codecs.open() a des outils

similaires.

outfile.write(S)

Écrit tout le contenu de la chaîne S dans un fichier, sans

appliquer de mise en forme. En mode texte ’\n’ est converti

par défaut dans le marqueur de fin de ligne qui est spécifique

à la plateforme. En mode binaire, la chaîne peut contenir des

octets non imprimables (par exemple, on utilise ’a\0b\0c’

pour écrire une chaîne de cinq octets, dont deux sont des zéros

binaires). En Python 3.X, le mode texte requiert des chaînes

Unicode str qu’il encode à l’écriture, et le mode binaire attend

et écrit des chaînes bytes non modifiées.

outfile.writelines(I)

Écrit toutes les chaînes de l’itérable I dans un fichier, sans ajout

automatique de caractères de fin de ligne.

Méthodes pour tous les fichiers

file.close()

Fermeture manuelle pour libérer les ressources (bien que

CPython ferme automatiquement les fichiers s’ils sont encore

ouverts après avoir été traités par le garbage collector).

Reportez-vous également au gestionnaire de contextes de

l’objet fichier dans la section Gestionnaires de contextes de

fichiers.

file.tell()

Retourne la position en cours du fichier.

file.seek(offset [, whence])

Définit la position en cours du fichier à offset (décalage) pour

un accès direct. whence peut prendre les valeurs 0 (décalage



Types intégrés spécifiques

63

à partir du début), 1 (décalage +/– à partir de la position

actuelle), ou 2 (décalage à partir de la fin). Par défaut, la valeur

de whence est 0.

file.isatty()

Retourne True si le fichier est connecté à un périphérique tty

(interactif), sinon False (peut retourner 1 ou 0 dans certaines

versions moins récentes de Python).

file.flush()

Vide le tampon stdio du fichier. Utile pour les pipes en

mémoire tampon, si le fichier est lu par un autre processus

(ou un humain). C’est aussi utile pour les fichiers créés et lus

dans le même processus.

file.truncate([size])

Tronque le fichier pour qu’il atteigne, au maximum, size octets

(ou sa position en cours si aucune taille n’est passée). Non

disponible sur toutes les plateformes.

file.fileno()

Obtient le numéro du fichier (un entier qui est le descripteur

du fichier). Il s’agit grosso modo de la conversion d’un objet

fichier en un descripteur de fichier qui peut être passé aux outils

du module os. Astuce : utilisez os.fdopen() ou open() en 3.X

pour convertir un descripteur de fichier en un objet fichier.

Autres attributs de fichiers (certains en lecture seule)

file.closed

True si le fichier a été fermé.

file.mode

Chaîne du mode (par exemple, ’r’) passé à la fonction open().

file.name

Nom de la chaîne du fichier externe correspondant.

Gestionnaires de contextes de fichiers

En Python standard (CPython), les objets fichiers se ferment d’eux-

mêmes s’ils sont encore ouverts après avoir été traités par le gar-

bage collector. De ce fait, les fichiers temporaires (par exemple :

open(’name’).read()) sont suffisants et n’ont pas besoin d’être expli-

citement fermés, puisque l’objet fichier est immédiatement récupéré

et fermé. Cependant, il se peut que certaines implémentations de



64

Chapitre 1. Python précis et concis

Python (par exemple, Jython), ne récupèrent pas et ne ferment pas

les fichiers de façon aussi automatique.

Afin de garantir la fermeture après la sortie d’un bloc de code, qu’il

provoque une exception ou non, utilisez l’instruction try/finally et

une fermeture manuelle :

myfile = open(r’C:\misc\script’, ’w’)

try:

...use myfile...

finally:

myfile.close()

Vous pouvez aussi utiliser l’instruction with/as disponible en

Python 3.X et 2.X (à partir de 2.6 et 3.0) :

with open(r’C:\misc\script’, ’w’) as myfile:

...use myfile...

Le premier insère un appel de fermeture lors de la conclusion de

l’action. Le second fait appel à des gestionnaires de contextes de fichiers

qui garantissent la fermeture automatique d’un fichier à la sortie du

bloc de code. Pour plus de détails, reportez-vous aux instructions try

et with dans la section Instructions et syntaxe.

Notes sur l’utilisation des fichiers

• Certains modes d’ouverture de fichiers (par exemple, ’r+’)

permettent d’avoir à la fois un fichier d’entrée et un fichier

de sortie ; d’autres modes (par exemple, ’rb’) spécifient un

mode de transfert binaire pour supprimer les conversions de

marqueurs de fin de ligne (et l’encodage Unicode en Python

3.X). Reportez-vous à open() dans la section Fonctions intégrées.

• Les opérations de transfert de fichiers se produisent à la position

en cours du fichier, mais un appel de la méthode seek()

repositionne le fichier pour un accès direct.

• Les transferts de fichiers peuvent être faits sans tampon (voir

les arguments de la fonction open() dans la section Fonctions

intégrées, et le paramètre de ligne de commande -u dans la

section Options de la commande Python.

• Python 2.X comprend également la méthode xreadlines()

qui fonctionne comme un itérateur de ligne automatique de



Types intégrés spécifiques

65

fichier ; cette méthode a été retirée de Python 3.X car elle était

redondante.

Ensembles

Les ensembles sont des collections mutables (modifiables) non ordon-

nées d’objets uniques et immutables (non modifiables). Les ensembles

prennent en charge les opérations mathématiques qui leur sont

propres telles que l’union et l’intersection. Ce ne sont pas des

séquences (ils ne sont pas ordonnés), ni des mappings (ils n’associent

pas des valeurs à des clés), mais ils prennent en charge l’itération, et ils

fonctionnent de manière similaire à des dictionnaires qui n’auraient

que des clés.

Littéraux et création

En Python 2.X et 3.X, les ensembles peuvent être créés avec la

fonction intégrée set(), en lui passant un itérable dont les éléments

deviennent membres de l’ensemble ainsi produit. En Python 3.X et

2.7, il est également possible de créer des ensembles via le littéral

{...} et l’expression de compréhensions d’ensembles, bien que set()

soit encore utilisée pour créer un ensemble vide ({} est le dictionnaire

vide), et construire des ensembles à partir d’objets existants.

Les ensembles sont mutables (modifiables), mais les éléments d’un

ensemble doivent être immutables ; la fonction intégrée frozenset()

crée un ensemble immutable qui peut être imbriqué dans un autre

ensemble :

set()

Un ensemble vide ({} est un dictionnaire vide).

S = set(’spam’)

Un ensemble de quatre éléments : valeurs ’s’, ’p’, ’a’, ’m’

(tout itérable est accepté).

S = {’s’, ’p’, ’a’, ’m’}

Un ensemble de quatre éléments, identique à l’exemple précé-

dent (en Python 3.X et 2.7).

S = {ord(c) for c in ’spam’}

Expression de compréhension d’ensemble (en Python 3.X et

2.7) ; pour la syntaxe complète, reportez-vous à la section

Expressions de compréhensions de listes.



66

Chapitre 1. Python précis et concis

S = frozenset(range(5, 5))

Un ensemble figé (immutable) de 10 entiers, de 5 à 4.

Opérations

Ce qui suit détaille les principales opérations sur les ensembles, où S,

S1, et S2 sont des ensembles quelconques. La majorité des opérateurs

d’expressions nécessitent deux ensembles, mais leurs équivalents

employant une méthode acceptent n’importe quel itérable, (que nous

appelons autre dans les exemples de cette section). Cette liste est

représentative mais incomplète. Pour obtenir une liste exhaustive des

expressions et méthodes en rapport avec les ensembles, consultez le

manuel intitulé Python’s Library Reference :

x in S

Appartenance : renvoie True si l’ensemble S contient x.

S1 – S2, S1.difference(autre)

Différence : nouvel ensemble comprenant les éléments de S1

qui ne sont pas dans S2 (ou dans autre).

S1 | S2, S1.union(autre)

Union : nouvel ensemble comprenant les éléments de S1 et de

S2 (ou dans autre) sans doublon.

S1 & S2, S1.intersection(autre)

Intersection : nouvel ensemble comprenant les éléments qui

sont à la fois dans S1 et dans S2 (ou dans autre).

S1 <= S2, S1.issubset(autre)

Sous-ensemble : vérifie que chaque élément appartenant à S1

appartienne aussi à S2 (ou à autre).

S1 >= S2, S1.issuperset(autre)

Sur-ensemble : vérifie que chaque élément appartenant à S2

(ou à autre) appartienne aussi à S1.

S1 < S2, S1 > S2

Véritables sous-ensembles et sur-ensembles : vérifie que S1 et

S2 ne sont pas identiques.

S1 ˆ S2, S1.symmetric_difference(autre)

Différence symétrique : nouvel ensemble comprenant des élé-

ments soit de S1, soit de S2 (soit de autre) mais n’appartenant

pas aux deux ensembles.

S1 |= S2, S1.update(autre)

Mise à jour (ne fonctionne pas avec les ensembles figés) : ajoute

des éléments de S2 (ou provenant de autre) à S1.



Types intégrés spécifiques

67

S.add(x), S.remove(x), S.discard(x), S.pop(), S.clear()

Mises à jour (ne fonctionne pas avec les ensembles figés) :

ajoute un élément, supprime un élément en fonction de sa

valeur, supprime un élément s’il est présent, supprime et ren-

voie un élément de façon arbitraire, supprime tous les éléments.

len(S)

Longueur : dénombre les éléments d’un ensemble.

for x in S

Itération : tous les contextes d’itération.

S.copy()

Fait une copie shallow de S ; identique à set(S).

Autres types et conversions

Parmi les types primitifs de base de Python, on compte également les

booléens (qui sont décrits plus bas), None (un faux objet substituable),

NotImplemented (utilisé par les méthodes de surchargement d’opéra-

teur), Ellipsis (créé par le littéral ... en 3.X), les types (auxquels

on accède avec la fonction intégrée type() et qui sont toujours des

classes en Python 3.X), ainsi que les fonctions, les modules et les

classes.

Booléen

Le type booléen, nommé bool, fournit deux constantes prédéfinies qui

sont ajoutées à la portée intégrée, nommées True et False (disponibles

depuis la version 2.3). Dans la plupart des cas, ces constantes peuvent

être traitées comme si on leur avait respectivement assigné les entiers

1 et 0 (par exemple, True + 3 donne 4). Cependant, le type bool

est une sous-classe du type int, qui est personnalisé pour afficher les

instances différemment (True affiche « True », et non pas « 1 », et

il peut être utilisé comme une mnémonique intégrée dans les tests

logiques).

Conversions de types

Les tableaux 10 et 11 listent les outils pour convertir un type en un

autre type. Tous ces outils créent de nouveaux objets (il ne s’agit pas

de convertisseurs qui modifient les objets). Python 2.X prend aussi en

charge des convertisseurs long(S) vers long et ‘X‘ vers string, qui ont

été supprimés en Python 3.X. Reportez-vous aux sections Nombres



68

Chapitre 1. Python précis et concis

et Mise en forme des chaînes pour certains des outils listés dans ces

tableaux.

Tableau 10 — Convertisseurs de séquences

Convertisseur

Convertit de

En

list( X ),

String, tuple, et tout itérable

Liste

[ n for n in X ][a]

tuple( X )

String, liste, et tout itérable

Tuple

’ .join( X )

Itérable de chaînes

String

[a] La forme de compréhension de liste peut (éventuel ement) être plus lente que

list(), et peut ne pas se révéler optimale dans ce contexte spécifique de conversion. En

Python 2.X seulement, map(None, X) a le même résultat que list(X) dans ce contexte,

bien que cette forme de map() ait été supprimée en Python 3.X.

Tableau 11 — Convertisseurs de chaînes et d’objets

Convertisseur

Convertit de

En

eval( S)

String

Tout objet ayant une syntaxe

d’expression

int( S [, base]),[a]

String ou nombre

Entier, virgule flottante

float( S)

repr( X ),

Tout objet Python

String (repr est d’un usage moins

str( X )

facile que str)

F % X, F.format( X ), format( X, Objets

avec des String

[ F ])

codes de format

hex( X ), oct( X ), bin( X ), str( X )

Types entiers

Chaînes de chiffres en hexadéci-

mal, octal, binaire, décimal

ord( C), chr( I)

Caractère,

code Code entier, caractère

entier

[a] Dans la version 2.2 et ultérieure, les fonctions de conversion (par exemple, int(),

float(), str()) servent aussi de constructeurs de classes et el es peuvent être sous-

classées. En Python 3.X, tous les types sont des classes, et toutes les classes sont des

instances de la classe type.





Instructions et syntaxe

69

INSTRUCTIONS ET SYNTAXE

Cette section décrit les règles de la syntaxe et du nommage des

variables.

Règles syntaxiques

Vous trouverez ci-dessous les règles générales d’écriture des pro-

grammes Python :

Contrôle du flux

Les instructions s’exécutent les unes à la suite des autres, à

moins que des instructions de contrôle ne soient utilisées pour

effectuer un branchement ailleurs dans le code (par exemple,

if, while, for, raise, calls, etc.).

Blocs

Un bloc imbriqué est délimité par l’indentation de toutes ses

instructions qui doivent avoir le même niveau d’indentation

(que l’on utilise des espaces ou des tabulations). Un bloc imbri-

qué peut aussi apparaître sur la même ligne que son en-tête

d’instruction (en suivant le caractère d’en-tête « : »), s’il est

constitué uniquement d’instructions simples non composées.

En règle générale, un bloc donné doit utiliser toutes les tabu-

lations ou tous les espaces pour l’indentation. La combinaison

des deux est analysée selon deux règles formelles : ( 1) une tabu-

lation compte pour suffisamment d’espaces pour le numéro de

colonne jusqu’au multiple de 8 suivant, et ( 2) une incohérence

supplémentaire est détectée en comptant chaque tabulation

comme un espace.

En Python 2.X, les combinaisons d’espaces et de tabulations

sont autorisées, si la première règle est satisfaite ; cependant,

le mélange des tabulations et des espaces est déconseillé, car

cela peut provoquer des erreurs et cela nuit à la clarté. De plus,

les options –t ou –tt peuvent être utilisées pour définir des

combinaisons qui ne sont pas conformes à la deuxième règle

(voir la section intitulée Utilisation de la ligne de commande

Python). En Python 3.X, les combinaisons d’espaces et de

tabulations sont toujours autorisées si elles sont valides et

conformes à la fois aux règles 1 et 2, mais elles engendrent

des erreurs dans le cas contraire (même comportement qu’avec

l’option –tt en 2.X).



70

Chapitre 1. Python précis et concis

Par exemple, à la fois en 3.X et en 2.X, un bloc extérieur

indenté avec 2 espaces, 1 tabulation, et 2 espaces (règle 1 : 10,

règle 2 : 5) permet qu’un bloc intérieur soit indenté avec 1

tabulation et 5 espaces (règle 1 : 13, règle 2 : 6). Un bloc

intérieur avec 2 tabulations et 1 espace (règle 1 : 17, règle 2 : 3)

fonctionne en 2.X par défaut (règle 1) mais pas en 3.X (règle 2).

Un code facile à maintenir ne devrait pas employer ces règles

subtiles et devrait utiliser soit des espaces, soit des tabulations.

Instructions

Une instruction se termine à la fin d’une ligne, mais peut se

poursuivre sur plusieurs lignes si une ligne physique se termine

par un antislash (\), une paire de (), [], ou {} non fermés, ou

bien une chaîne entre guillemets triples non fermés. Plusieurs

instructions simples peuvent apparaître sur une seule ligne, si

elles sont séparées par un point-virgule (;).

Commentaires

Les commentaires débutent par un dièse (#) placé sur n’importe

quelle colonne (mais pas à l’intérieur d’une constante chaîne)

et s’étendent jusqu’à la fin de la ligne ; les commentaires sont

ignorés par l’interpréteur Python.

Documentation

Si une fonction, un fichier de module, ou une classe com-

mence par un littéral chaîne (éventuellement après des com-

mentaires), le littéral est stocké dans l’attribut __doc__ de

l’objet. Reportez-vous à la fonction help() dans la section

intitulée Fonctions intégrées, ainsi qu’au module et au script

pydoc dans la Python Library Reference, pour en savoir plus

sur l’extraction automatisée et les outils d’affichage. Conseil :

à partir de Python 3.2, python -m pydoc -b lance l’interface

de consultation de PyDoc (utilisez –g au lieu de –b dans les

versions antérieures pour le mode graphique).

Espaces blancs

En général, ils n’ont une signification qu’à la gauche du code,

là où l’indentation est employée pour délimiter les blocs. Dans

le cas contraire, les lignes vides et les espaces sont ignorés, à

l’exception des séparateurs dans les constantes de type chaîne).





Instructions et syntaxe

71

Règles de nommage

Cette section contient les règles des noms définis par l’utilisateur

(c’est-à-dire les variables) dans les programmes.

Format des noms

Structure

Les noms définis par l’utilisateur commencent par une lettre

ou un underscore (_), et sont suivis par un nombre quelconque

de lettres, chiffres ou underscores.

Mots réservés

Les noms définis par l’utilisateur ne peuvent pas être des mots

réservés Python qui sont listés dans le tableau 12, Mots réservés

en Python 3.X 1.

Différences entre majuscules et minuscules

Les noms définis par l’utilisateur et les mots réservés font

toujours la différence entre les minuscules et les majuscules :

SPAM, spam et Spam sont tous des noms différents.

Caractères inutilisés

Python n’emploie pas les caractères $ et ? dans sa syntaxe,

bien qu’ils puissent apparaître dans les constantes chaîne et

les commentaires. À l’intérieur des chaînes, $ a une fonction

spéciale dans les modèles de substitution (voir la section

intitulée Modèles de substitutions de chaînes), et $ et ? ont une

fonction spéciale dans la recherche des motifs (voir la section

intitulée Module de recherche de motifs par expressions régulières).

Création

Les noms définis par l’utilisateur sont créés par une assignation,

mais ils doivent exister quand on y fait référence (par exemple,

les compteurs doivent être explicitement initialisés à zéro).

Reportez-vous aux sections intitulées Termes atomiques et typage

dynamique et Espace de noms et règles de portée.

1. Cette règle peut ne pas s’appliquer en dehors de l’implémentation CPy-

thon. Par exemple, le système basé sur Java, Jython, peut autoriser l’emploi

de mots réservés comme variables dans certains contextes.



72

Chapitre 1. Python précis et concis

Tableau 12 — Mots réservés en Python 3.X

False

class

final y

is

return

None

continue

for

lambda

try

True

def

from

nonlocal

while

and

del

global

not

with

as

elif

if

or

yield

assert

else

import

pass

break

except

in

raise

Note

En Python 2.X, print et exec sont des mots réservés, mais

ils prennent la forme d’instructions, et non pas de fonctions

intégrées. Vous noterez également qu’en Python 2.X, nonlocal,

True et False ne sont pas des mots réservés ; nonlocal n’existe

pas et True et False sont des noms intégrés. with et as sont des

mots réservés à partir de 2.6 et 3.0, mais pas dans les versions

antérieures à 2.X à moins que les gestionnaires de contextes ne

soient explicitement activés. yield est un mot réservé à partir de

la version 2.3 ; dans les versions suivantes, yield n’est plus une

instruction, mais est devenue une expression, tout en restant un

mot réservé.

Conventions de nommage

• Les noms qui commencent et se terminent par deux unders-

cores (par exemple, __init__) ont une signification spéciale

pour l’interpréteur, mais ne sont pas des mots réservés.

• Les noms qui commencent par un underscore (par exemple, _X)

et qui sont assignés au niveau le plus élevé d’un module ne sont

pas copiés par les imports from...* (voir aussi la liste des noms

des modules exportés __all__ dans les sections Instruction from

et Attributs pseudoprivés). Dans les autres contextes, il s’agit

d’une convention informelle pour les noms internes.





Instructions spécifiques

73

• Les noms qui commencent mais ne se terminent pas par deux

underscores (par exemple, __X) à l’intérieur d’une instruction

class sont préfixés par le nom de cette classe (voir la section

Attributs pseudoprivés).

• Le nom qui n’est composé que d’un underscore (_) est uni-

quement utilisé dans l’interpréteur interactif pour stocker le

résultat de la dernière évaluation.

• Les noms des fonctions intégrées et des exceptions (par

exemple, open, SyntaxError) ne sont pas des mots réservés. Ils

existent dans la portée précédente et peuvent être réassignés

pour masquer la signification de la portée actuelle (par

exemple, open = myfunction).

• Les noms des classes commencent en général par une majuscule

(par exemple, MyClass), et les modules par une minuscule (par

exemple, mymodule).

• Le premier argument (le plus à gauche) d’une fonction de

méthode de classe se nomme en général self (c’est une

convention très suivie).

• Les noms des modules sont résolus selon une analyse des che-

mins des répertoires ; les noms situés avant le chemin peuvent

masquer d’autres chemins ayant le même nom, que cela soit

intentionnel ou non (voir la section Instruction import).

INSTRUCTIONS SPÉCIFIQUES

Les sections suivantes décrivent toutes les instructions Python.

Chaque section liste la syntaxe des instructions et les détails de leur

utilisation. Pour les instructions composées, la mention suite dans une

instruction représente une ou plusieurs instructions, éventuellement

indentées sous la forme d’un bloc sous une ligne d’en-tête. Une

suite doit être indentée sous un en-tête si elle contient une autre

instruction composée (if, while, etc.) ; dans le cas contraire, elle

peut apparaître sur la même ligne que l’en-tête d’instruction. Les

deux constructions suivantes sont toutes les deux valides :



74

Chapitre 1. Python précis et concis

if x < 42:

print(x)

while x: x = x 1

if x < 42: print(x)

Les sous-sections suivantes détaillent les instuctions qui sont

communes à Python 3.X et 2.X ; reportez-vous également à la section

Instructions Python 2.X à la fin de cette section pour des informations

spécifiques à Python 2.X.

Instructions d’assignation

cible = expression

cible1 = cible2 = expression

cible1, cible2 = expression1, expression2

cible1 += expression

cible1, cible2,

... = itérable-même-longueur

(cible1, cible2, ...) = itérable-même-longueur

[cible1, cible2, ...] = itérable-même-longueur

cible1, *cible2, ... = itérable-longueur-correspondante

Toutes les assignations stockent des références à des objets dans

des cibles. Les instructions d’assignation demandent une assignation

avec les syntaxes explicites précédentes dans lesquelles :

• Les expressions produisent des objets.

• Les cibles peuvent être de simples noms (X), des attributs

qualifiés (X.attr), ou des indices et des extractions (X[i],

X[i:j:k]).

• Les variables des cibles ne sont pas déclarées à l’avance, mais

doivent avoir été assignées avant d’être utilisées dans une

expression (voir la section Termes atomiques et typage dyna-

mique).

La première forme listée ci-dessus est une assignation basique. La

deuxième forme (assignation multicible), assigne le même objet résul-

tant d’une expression à chaque cible. La troisième forme (assignation

d’un tuple), apparie les cibles aux expressions, de la gauche vers la

droite. La quatrième forme (assignation augmentée), est un raccourci

pour une opération couplée à une assignation (voir la prochaine

section).





Instructions spécifiques

75

Les quatre dernières formes sont des assignations de séquences, qui

affectent des composants de n’importe quelle séquence ou de tout

autre itérable aux cibles correspondantes, de la gauche vers la droite.

La séquence ou l’itérable à droite peut être de n’importe quel type,

mais doit être de même longueur à moins qu’un nom commençant

par une étoile (*X) n’apparaisse dans les cibles à gauche, comme

dans la dernière forme. Cette dernière forme (appelée assignation de

séquence étendue et disponible uniquement en Python 3.X) autorise

le nom commençant par une étoile à collecter de manière arbitraire

des éléments (voir la section Assignation de séquence étendue (3.X))1.

L’assignation se produit aussi de manière implicite dans d’autres

contextes en Python (par exemple, les variables des boucles for

et le passage des arguments à une fonction), et certaines formes

d’instructions d’assignation s’appliquent ailleurs (par exemple, les

séquences dans les boucles for).

Assignation augmentée

Le tableau 13 liste une série d’instructions supplémentaires d’assi-

gnation. Connue sous le nom d’ assignation augmentée, cette forme

implique une expression binaire plus une assignation. Par exemple,

les deux formes suivantes sont pratiquement équivalentes :

X = X + Y

X += Y

Cependant, la référence à la cible X de la deuxième forme a

besoin d’être évaluée seulement une fois, et les opérations en place

( in-place) peuvent être appliquées pour des mutables en cas d’opti-

misation (par exemple, list1 += list2 appelle automatiquement

list1.extend(list2), au lieu de l’opération de concaténation plus

lente qu’implique +). Les classes peuvent surcharger les assignations

en place avec des noms de méthodes qui commencent par un i (par

exemple, __iadd__() pour +=, __add__() pour +). La forme X //= Y

(division entière) a été ajoutée à partir de la version 2.2.

1. L’assignation de séquence parmet aussi à une collection imbri-

quée de valeurs d’être assignée à une séquence imbriquée de cibles :

((a,b),c)=([1,2],3). En Python 2.X seulement, ce modèle peut aussi être

utilisé pour les arguments d’en-tête de fonction.



76

Chapitre 1. Python précis et concis

Tableau 13 — Instructions d’assignation augmentée

X += Y

X &= Y

X = Y

X |= Y

X *= Y

X ˆ= Y

X /= Y

X »= Y

X %= Y

X «= Y

X **= Y

X //= Y

Assignation de séquence normale

En Python 2.X et 3.X, toute séquence ou n’importe quel itérable de

valeurs peut être assigné à n’importe quelle séquence de noms, tant

que les longueurs sont identiques. Cette forme basique d’assignation

de séquence fonctionne dans la plupart des contextes d’assignation :

>>> a, b, c, d = [1, 2, 3, 4]

>>> a, d

(1, 4)

>>> for (a, b, c) in [[1, 2, 3], [4, 5, 6]]:

...

print(a, b, c)

...

1 2 3

4 5 6

Assignation de séquence étendue (3.X)

En Python 3.X (seulement), l’assignation de séquence est étendue

pour autoriser la collection d’un nombre arbitraire d’éléments, en

préfixant une variable dans la cible de l’assignation par une étoile ;

dans ce cas, les longueurs des séquences n’ont pas besoin de corres-

pondre, et le nom avec une étoile collecte tous les éléments sans

correspondance dans une nouvelle liste :

>>> a, *b = [1, 2, 3, 4]

>>> a, b

(1, [2, 3, 4])

>>> a, *b, c = (1, 2, 3, 4)

>>> a, b, c

(1, [2, 3], 4)

>>> *a, b = ’spam’

>>> a, b

([’s’, ’p’, ’a’], ’m’)



Instructions spécifiques

77

>>> for (a, *b) in [[1, 2, 3], [4, 5, 6]]:

...

print(a, b)

...

1 [2, 3]

4 [5, 6]

Note

En Python 3.3 et dans les versions précédentes, les syntaxes

spéciales *X et **X peuvent apparaître dans trois contextes : dans

les instructions d’assignation où *X collecte les éléments sans corres-

pondance dans les assignations de séquences, dans les en-têtes de

fonctions où les deux formes collectent les arguments positionnels

et les arguments nommés sans correspondance, et dans les appels

de fonctions où les deux formes réalisent un unpacking d’itérables

et de dictionnaires dans des éléments individuels (arguments).

En Python 3.4, les développeurs ont envisagé de généraliser

cette syntaxe avec une étoile pour qu’elle soit utilisable dans

des littéraux de structure de données (pour réaliser un unpacking

de collections en éléments individuels, comme dans son premier

usage dans les appels de fonction). En Python 3.5, la syntaxe

d’unpacking avec une étoile a été étendue aux tuples, listes,

ensembles, dictionnaires et compréhensions. Par exemple :

[x, * iter]

# unpacking d’éléments : liste

(x, * iter), {x, * iter} # idem pour un tuple, ensemble

{’x’: 1, **dict}

# unpacking d’éléments : dictionnaire

[* iter for iter in x] # unpacking d’éléments : compréhension

Ceci est un ajout de la version 3.5 par rapport à la version 3.3 qui

ne prend en compte que les instructions d’assignation, les appels

et les en-têtes de fonctions.

Instruction expression

expression

function([value, name=value, *name, **name...])

object.method([value, name=value, *name, **name...])

Toute expression peut apparaître sous la forme d’une instruction

(par exemple, sur une ligne toute seule). À l’inverse, les instructions



78

Chapitre 1. Python précis et concis

ne peuvent pas apparaître dans un autre contexte d’expression (par

exemple, les instructions d’assignation n’ont pas de résultat et ne

peuvent pas être imbriquées).

Les instructions expressions sont généralement utilisées pour les

appels de fonctions et de méthodes n’ayant aucune valeur de retour

utile, et pour l’affichage en mode interactif. Les instructions expres-

sions sont également le codage le plus courant pour les expressions

yield et les appels à la fonction intégrée Python 3.X print(), bien

que nous les classions dans cet ouvrage sous la forme d’instructions

spécifiques.

Syntaxe d’appel

Dans les appels de fonctions et de méthodes, les arguments sont

séparés par des virgules et correspondent normalement à la position

des arguments des en-têtes def de la fonction. Les appels peuvent

éventuellement lister des noms d’arguments spécifiques dans les fonc-

tions afin de recevoir des valeurs passées en utilisant la syntaxe par

mot-clé nom=valeur. C’est alors le nom de l’argument qui correspond

et non plus sa position.

Syntaxe d’appel des arguments arbitraires

La syntaxe spéciale avec une étoile peut aussi être utilisée dans

les listes d’arguments lors des appels de fonctions et de méthodes

pour réaliser un unpacking de collections en un nombre arbitraire

d’arguments individuels. Si pargs et kargs sont respectivement un

itérable et un dictionnaire :

f(*pargs, **kargs)

Alors cette forme appelle la fonction f avec des arguments

positionnels à partir de l’itérable pargs, et les arguments par mot-clé

(argument nommé) à partir du dictionnaire kargs. Par exemple :

>>> def f(a, b, c, d): print(a, b, c, d)

...

>>> f(*[1, 2], **dict(c=3, d=4))

1 2 3 4

Cette syntaxe est conçue pour être symétrique avec la syntaxe des

arguments arbitraires des en-têtes de fonctions comme def f(*pargs,



Instructions spécifiques

79

**kargs), qui collecte les arguments sans correspondance. Dans les

appels, les éléments avec une étoile réalisent un unpacking dans des

arguments individuels, et ils peuvent être combinés avec d’autres

arguments positionnels et par mot-clé selon des règles d’ordre (par

exemple, g(1, 2, foo=3, bar=4, *pargs, **kargs)).

En Python 2.X, la fonction intégrée apply() produit un effet

similaire, mais elle a été supprimée en Python 3.X :

apply(f, pargs, kargs)

Reportez-vous à la section Instruction def, qui comprend le

tableau 15, Format des arguments dans les appels, pour des détails sur la

syntaxe des appels.

Instruction print

En Python 3.X, l’affichage de texte sur le flux de la sortie standard

prend la forme d’un appel à une fonction intégrée, qui est en général

codée sous la forme d’une instruction expression (par exemple, sur

une ligne toute seule). Voici sa syntaxe d’appel :

print([valeur [, valeur]*]

[, sep=str] [, end=str]

[, file=object] [, flush=bool])

Chaque valeur est une expression qui produit un objet, dont la

chaîne str() doit être affichée. Cet appel comporte quatre arguments

nommés optionnels (les valeurs défaut s’appliquent si on les oublie

ou si l’on passe None) :

Sep

Une chaîne à placer entre les valeurs (la valeur par défaut est

l’espace : ’ ’).

End

Une chaîne à placer entre à la fin du texte affiché (la valeur

par défaut est une nouvelle ligne : ’\n’).

File

Un objet semblable à un fichier dans lequel le texte est écrit

(la valeur par défaut est la sortie standard : sys.stdout).



80

Chapitre 1. Python précis et concis

Flush

Accepte la valeur true ou false, pour activer ou désactiver le

vidage sur disque du flux de sortie (à partir de Python 3.3; la

valeur par défaut est False).

Passez une chaîne vide ou personnalisée à sep et end pour sup-

primer ou modifier l’espace séparateur et le saut de ligne. Passez un

fichier ou un objet similaire à un fichier à file pour rediriger la sortie

dans votre script (reportez-vous à la section intitulée Fichiers) :

>>> print(2 ** 32, ’spam’)

4294967296 spam

>>> print(2 ** 32, ’spam’, sep=’’)

4294967296spam

>>> print(2 ** 32, ’spam’, end=’ ’); print(1, 2, 3)

4294967296 spam 1 2 3

>>> print(2 ** 32, ’spam’, sep=’’,

...

file=open(’out’, ’w’))

>>> open(’out’).read()

’4294967296spam\n’

Comme par défaut les opérations print appellent simplement la

méthode write() de l’objet référencé actuellement par sys.stdout,

le code suivant est équivalent à print(X) :

import sys

sys.stdout.write(str(X) + ’\n’)

Pour rediriger le text de print dans un fichier ou un objet d’une

classe, passez n’importe quel objet avec une méthode write() à

l’argument nommé file comme dans l’exemple précédent, ou bien

réassignez sys.stdout à n’importe quel objet (voir la section Fichiers) :

sys.stdout = open(’log’, ’a’) # Objet avec write()

print(’Warning-bad spam!’)

# Méthode write() de l’objet

Comme sys.stdout peut être réassigné, l’argument nommé file

n’est pas strictement nécessaire ; cependant, il évite souvent à la fois

les appels explicites à la méthode write() et la sauvegarde ainsi que

la restauration de la valeur originale sys.stdout lors d’une opération

print quand le flux original est encore nécessaire. Pour de plus amples



Instructions spécifiques

81

informations sur la version 3.X de print(), reportez-vous à la section

Fonctions intégrées.

Instruction print Python 2.X

En Python 2.X, print est une instruction spécifique, et non pas une

fonction intégrée, qui a la forme suivante :

print [valeur [, valeur]* [,]]

print >> file [, valeur [, valeur]* [,]]

L’instruction Python 2.X print affiche la représentation affichable

de chaque valeur sur le flux de sortie standard (définie par la valeur

de sys.stdout) et ajoute des espaces entre les valeurs. Une virgule

en fin d’instruction supprime le saut de ligne qui est normalement

ajouté à la fin de la liste ; il s’agit de l’équivalent de l’emploi de end=’

’ dans la fonction print en Python 3.X :

>>> print 2 ** 32, ’spam’

4294967296 spam

>>> print 2 ** 32, ’spam’,; print 1, 2, 3

4294967296 spam 1 2 3

L’instruction Python 2.X print peut également désigner un objet

de type fichier comme sortie afin qu’il soit la cible du texte affiché, à

la place de sys.stdout :

fileobj = open(’log’, ’a’)

print >> fileobj, "Warning-bad spam!"

Si l’objet fichier est égal à None, alors sys.stdout est utilisé. Cette

syntaxe Python 2.X >> est équivalente à l’argument nommé file=F

en Python 3.X. Il n’y a pas d’équivalent à sep=S en Python 2.X, bien

que les lignes puissent être préformatées et affichées sous la forme

d’un seul élément.

Les parenthèses fonctionnent dans la commande print 2.X, mais

cela crée des tuples pour plusieurs éléments. Pour utiliser la fonction

print Python 3.X en Python 2.X, exécutez le code suivant dans une

session interactive ou bien au sommet d’un script ; cela peut être

utilisé en 2.X (pour une compatibilité ascendante 3.X), et en 3.X

(pour une compatibilité descendante 2.X) :



82

Chapitre 1. Python précis et concis

from __future__ import print_function

Instruction if

if test:

suite

[elif test:

suite]*

[else:

suite]

L’instruction if effectue un choix parmi une ou plusieurs actions

(blocs d’instructions). Elle exécute la suite associée au premier test

if ou elif qui est vrai, ou bien la suite else si tous les tests sont faux.

Les parties elif et else sont optionnelles.

Instruction while

while test:

suite

[else:

suite]

La boucle while est une boucle généraliste qui exécute la première

suite tant que le test au sommet de la boucle est vrai. Elle exécute la

suite optionnelle else une fois à la sortie de la boucle si la boucle se

termine sans exécuter d’instruction break dans la première suite.

Instruction for

for cible in itérable:

suite

[else:

suite]

La boucle for est une itération d’une séquence (ou tout autre

itérable) qui assigne les éléments de itérable à cible et exécute

la première suite pour chaque élément. L’instruction for exécute la

suite else optionnelle une fois à la sortie si la boucle se termine

sans exécuter d’instruction break dans la première suite. cible peut

représenter n’importe quel élément susceptible d’apparaître du côté



Instructions spécifiques

83

gauche d’une instruction d’assignation = (par exemple, for (x, y)

in tuplelist).

Depuis Python 2.2, cela marche de la manière suivante : Python

essaye d’abord d’obtenir un objet itérateur I avec iter(iterable) puis

appelle la méthode I.__next__() de cet objet de manière répétée

jusqu’à ce que l’exception StopIteration soit levée (I.__next__()

est appelée I.next() en Python 2.X). Si l’on ne peut obtenir aucun

objet itérateur (par exemple, aucune méthode __iter__ n’est définie),

alors cela marche en indiçant de manière répétée iterable avec des

indices de plus en plus élevés jusqu’à ce que l’exception IndexError

soit levée.

L’itération se produit dans plusieurs contextes en Python, notam-

ment les instructions boucles for, les compréhensions, et map().

Reportez-vous à la section Protocole d’itération dans l’étude des listes

pour de plus amples informations sur le mécanisme utilisé par la

boucle for et tous les autres contextes d’itération.

Instruction pass

pass

Il s’agit d’une instruction qui ne réalise rien, et qui est utilisée

quand la syntaxe l’exige (par exemple, pour les corps des fonctions

bouchonnées ( stubbed-out)). En Python 3.X seulement, les points de

suspension (...) peuvent jouer le même rôle.

Instruction break

break

Cette instruction sort immédiatement de l’instruction de boucle

while ou for la plus proche (la plus interne), en sautant le else qui

lui est associé (s’il y en a un). Conseil : les instructions raise et try

peuvent être utilisées pour sortir de plusieurs niveaux de boucles.



84

Chapitre 1. Python précis et concis

Instruction continue

continue

Cette instruction va immédiatement au sommet de l’instruction

de boucle while ou for la plus proche ; elle reprend l’exécution dans

la ligne d’en-tête de la boucle.

Instruction del

del name

del name[i]

del name[i:j:k]

del name.attribute

L’instruction del supprime des variables, des éléments, des clés,

des extractions et des attributs. Dans sa première forme, name est un

nom de variable pris littéralement. Dans les trois dernières formes,

name peut être n’importe quelle expression qui évalue le contenu

traité par l’instruction (avec des parenthèses si cela est nécessaire

pour la priorité des opérateurs). Par exemple : del a.b()[1].c.d.

Cette instruction est principalement utilisée pour les structures de

données, et non pas pour gérer la mémoire. Elle supprime également la

référence aux objets précédemment référencés, ce qui peut provoquer

leur traitement par le garbage collector (c’est-à-dire leur recyclage)

s’ils ne sont pas référencés ailleurs. Vous noterez cependant que le

recyclage par le garbage collector est automatique et n’a pas besoin

normalement d’être invoqué explicitement par l’instruction del.

Instruction def

[decoration]

def nom([arg,... arg=valeur,... *arg, **arg]):

suite

L’instruction def crée de nouvelles fonctions, qui peuvent aussi

servir de méthodes dans des classes. Elle crée un objet fonction et

l’assigne à un nom de variable. Chaque appel à un objet fonction

génère une nouvelle portée locale où les noms assignés sont par défaut

locaux à l’appel de la fonction (à moins qu’ils ne soient déclarés en



Instructions spécifiques

85

tant que global ou nonlocal en 3.X). Pour des détails sur la notion

de portée, consultez la section Espace de noms et règles de portée.

Les arguments sont passés par assignation ; dans un en-tête def,

ils peuvent être définis dans l’un des quatre formats listés dans

le tableau 14 Format des arguments dans les définitions. Ces formats

d’arguments peuvent aussi être utilisés dans un appel de fonction où

ils sont interprétés selon la forme décrite dans le tableau 15 Format des

arguments dans les appels (voir la section intitulée Instruction expression

pour des détails sur la syntaxe d’appel des fonctions).

Tableau 14 — Format des arguments dans les définitions

Format de l’argument

Interprétation

Nom

Correspondance par nom ou position

nom=valeur

Valeur par défaut si nom n’est pas passé

*nom

Col ecte les arguments positionnels supplémentaires sous la

forme d’un nouveau tuple nom

**nom

Col ecte les arguments nommés supplémentaires sous la

forme d’un nouveau dictionnaire nom

*autre, nom[=valeur]

Arguments uniquement nommés en Python 3.X après *

*, nom[=valeur]

Identique à la ligne précédente (s’il n’y a pas *)

Tableau 15 — Format des arguments dans les appels

Format de

l’argument

Interprétation

valeur

Argument positionnel

nom=valeur

Argument nommé (correspondance sur le nom)

*itérable

Réalise l’unpacking d’une séquence ou d’un autre itérable

d’arguments positionnels

**dictionnaire

Réalise l’unpacking d’un dictionnaire d’arguments nommés



86

Chapitre 1. Python précis et concis

Arguments uniquement nommés en Python 3.X

Seul Python 3.X généralise la définition des fonctions afin d’autoriser

les arguments uniquement nommés, qui ne peuvent donc pas être

passés selon leur position et qui sont obligatoires s’ils ne sont pas

codés avec des valeurs par défaut. Les arguments uniquement nommés

sont codés après le symbole *, qui peut apparaître sans nom s’il y a

des arguments uniquement nommés et aucun argument positionnel :

>>> def f(a, *b, c): print(a, b, c) # Argument nommé c

obligatoire

...

>>> f(1, 2, c=3)

1 (2,) 3

>>> def f(a, *, c=None): print(a, c) # Argument nommé c

optionnel

...

>>> f(1)

1 None

>>> f(1, c=’spam’)

1 spam

Annotations des fonctions Python 3.X

Python 3.X (seulement) généralise aussi la définition des fonctions

afin d’autoriser l’annotation des arguments et des valeurs de retour

avec des valeurs d’objets pour un usage dans les extensions. Les

annotations sont codées sous la forme :valeur après le nom de

l’argument et avant la valeur par défaut, et sous la forme ->valeur

après la liste des arguments. Elles sont collectées dans un attribut

__annotations__ de la fonction, mais ne sont pas traitées sous une

forme spéciale par Python :

>>> def f(a:99, b:’spam’=None) -> float:

...

print(a, b)

...

>>> f(88)

88 None

>>> f.__annotations__

{’a’: 99, ’b’: ’spam’, ’return’: <class ’float’>}



Instructions spécifiques

87

Expressions lambda

Les fonctions peuvent aussi être créées sous la forme d’une expression

lambda, qui crée un nouvel objet fonction et le retourne pour qu’il

soit appelé ultérieurement, au lieu de l’assigner à un nom :

lambda arg, arg,...: expression

Dans une expression lambda, chaque arg est de la même forme

qu’une définition (voir le tableau 14, Format des arguments dans les

définitions), et l’expression est la valeur de retour implicite des appels

ultérieurs ; le code de l’expression est différé dans l’attente des

appels :

>>> L = lambda a, b=2, *c, **d: [a, b, c, d]

>>> L(1, 2, 3, 4, x=1, y=2)

[1, 2, (3, 4), {’y’: 2, ’x’: 1}]

Comme lambda est une expression, et non pas une instruction, elle

peut être utilisée dans les endroits où une définition est impossible

(par exemple, dans une expression littérale de dictionnaire ou une

liste d’arguments d’un appel de fonction). Comme lambda calcule une

expression unique au lieu d’exécuter des instructions, cela n’est pas

conçu pour des fonctions complexes (dans ce cas, il faut utiliser def).

Valeurs par défaut et attributs de fonctions

Les valeurs des arguments par défaut des mutables sont évaluées une

fois au moment de l’instruction def, et non pas à chaque appel, ce

qui permet de conserver l’état entre les appels. Certains considèrent

cependant que ce comportement constitue un problème si bien que

les classes et les références à des portées englobantes ( closing scope)

sont de meilleurs outils pour conserver l’état ; utilisez la valeur par

défaut None pour les mutables et les tests explicites afin d’éviter des

modifications involontaires, comme dans les exemples ci-dessous :

>>> def grow(a, b=[]):

# def grow(a, b=None):

...

b.append(a)

#

if b == None: b = []

...

print(b)

#

...

...

>>> grow(1); grow(2)

[1]

[1, 2]



88

Chapitre 1. Python précis et concis

Python 2.X et 3.X prennent également en charge les attributs

arbitraires dans les fonctions, ce qui constitue une autre forme de

conservation de l’état (bien que les attributs ne supportent que l’état

par objet fonction, qui n’est que par appel si chaque appel génère un

nouvel objet fonction) :

>>> grow.food = ’spam’

>>> grow.food

’spam’

Décorateurs de fonctions et de méthodes

À partir de Python 2.4, les définitions de fonctions peuvent être

précédées par une syntaxe de déclaration qui décrit la fonction qui

suit. Connues sous le nom de décorateurs et codées avec un caractère @,

ces déclarations fournissent une syntaxe explicite pour les techniques

fonctionnelles. Voici la syntaxe d’un décorateur de fonction:

@décorateur

def F():

...

qui est équivalente à cette liaison manuelle de nom :

def F():

...

F = décorateur(F)

Cela a pour effet de lier à nouveau le nom de la fonction au

résultat du passage de la fonction via le décorateur appelable. Les

décorateurs de fonctions peuvent être utilisés pour gérer les fonctions,

ou les appels ultérieurs à ces fonctions (en utilisant des objets proxy).

Les décorateurs peuvent être appliqués à n’importe quelle définition

de fonction, notamment les méthodes au sein d’une classe :

class C:

@décorateur

def M():

# Identique à M = décorateur(M)

...

Plus généralement, les décorateurs suivants imbriqués :



Instructions spécifiques

89

@A

@B

@C

def f(): ...

sont équivalents au code suivant qui n’emploie pas de décora-

teurs :

def f(): ...

f = A(B(C(f)))

Les décorateurs peuvent aussi accepter des listes d’arguments :

@spam(1, 2, 3)

def f(): ...

Dans ce cas, spam doit être une fonction qui retourne une fonction,

ce que l’on appelle une fonction factory ; son résultat est utilisé comme

le véritable décorateur, et peut conserver l’état de l’argument si

nécessaire. Les décorateurs doivent apparaître sur la ligne précédant la

définition de la fonction, et non pas sur la même ligne (par exemple,

@A def f(): ... sur une seule ligne est interdit).

Comme ils acceptent et retournent des objets appelables ( cal-

lables), certaines fonctions intégrées, notamment property(), static-

method() et classmethod() peuvent être utilisées comme décorateurs

de fonctions (voir la section Fonctions intégrées). La syntaxe des

décorateurs est également prise en charge par les classes en Python

2.6 et 3.0, et ultérieurement dans les versions 2 et 3 (voir la section

Instruction class).

Instruction return

return [expression]

L’instruction return quitte la fonction et retourne une valeur

d’expression comme résultat de l’appel à la fonction. Si l’expression

est absente, sa valeur par défaut est égale à None, qui est aussi la

valeur de retour par défaut des fonctions qui se terminent sans

return. Conseil : retournez un tuple pour un résultat de fonction

comprenant plusieurs valeurs. Voir aussi la section Instruction yield

pour la sémantique spéciale de return utilisée dans une fonction

génératrice.



90

Chapitre 1. Python précis et concis

Instruction yield

yield expression

# Toutes versions de Python

yield from itérable

# 3.3 et versions ultérieures

L’expression yield en 2.X et 3.X définit une fonction génératrice,

qui produit des résultats à la demande. Les fonctions contenant

une expression yield sont compilées spécialement ; quand elles sont

appelées, elles créent et retournent un objet générateur (un itérable qui

prend automatiquement en charge le protocole d’itération pour fournir

des résultats dans des contextes d’itération.

Généralement codée sous la forme d’une instruction expression

(par exemple, sur une ligne indépendante), yield suspend l’état de

la fonction et retourne une valeur d’expression. Lors de l’itération

suivante, l’emplacement précédent de la fonction et l’état de la

variable sont restaurés, et le contrôle reprend immédiatement après

l’instruction yield.

Utilisez une instruction return à la fin de l’itération ou abandon-

nez simplement la fin de la fonction. Une instruction return d’une

fonction génératrice ne doit pas donner de valeur de retour avant la

version 3.3, mais peut en fournir une à partir de la version 3.3 qui

soit conservée sous la forme d’un attribut d’objet d’exception (voir la

section Modifications de la fonction génératrice en Python 3.3) :

def generateSquares(N):

for i in range(N):

yield i ** 2

>>> G = generateSquares(5) # Possède __init__, __next__

>>> list(G)

# Génère des résultats à

présent

[0, 1, 4, 9, 16]

Quand elle est utilisée sous la forme d’une expression (par

exemple, A = yield X), yield retourne à l’appelant l’objet passé à

la méthode send() du générateur, et doit être encadrée par des

parenthèses, à moins qu’elle ne soit le seul élément à la droite du

signe = (par exemple, A = (yield X) + 42). Dans ce mode, les

valeurs sont envoyées à un générateur en appelant send(value) ; le

générateur est redémarré et l’expression yield retourne une valeur.



Instructions spécifiques

91

Si la méthode normale __next__() ou la fonction intégrée next() est

appelée, yield retourne None.

Les fonctions génératrices ont aussi une méthode throw(type)

pour lever une exception à l’intérieur du générateur lors de la dernière

instruction yield, et une méthode close() qui lève une nouvelle

exception GeneratorExit à l’intérieur du générateur pour mettre fin à

l’itération. yield est standard à partir de la version 2.3 et les versions

suivantes ; les méthodes send(), throw() et close() du générateur

sont disponibles à partir de Python 2.5.

La méthode __iter__() d’une classe contenant une instruction

yield retourne un générateur avec une fonction __next__() créée

automatiquement. Voir la section Protocole d’itération dans l’étude des

listes pour le mécanisme utilisé par les fonctions génératrices, et la

section Expressions de générateur pour un outil qui crée également un

objet générateur.

Modifications de la fonction génératrice en Python 3.3

À partir de 3.3, Python 3.X (seulement) prend en charge une clause

from dans cette instruction, qui dans son usage normal est similaire

à un yield dans une boucle for qui parcourt les éléments d’un

itérable ; dans des rôles plus avancés, cette extension permet à des

sous-générateurs de recevoir des valeurs directement à partir d’une

portée appelante plus élevée :

for i in range(N): yield i

# Toutes versions de Python

yield from range(N)

# Option en 3.3 et

ultérieurement

À partir de 3.3, si une fonction génératrice arrête l’itération et

sort avec une instruction return explicite, toute valeur donnée à

l’instruction return devient accessible sous la forme d’un attribut

value d’une exception StopIteration implicitement créée et levée.

Cette valeur est ignorée par les itérations automatiques, mais peut

être demandée par des itérations manuelles ou un autre code qui

accède à l’exception (voir la section Exceptions intégrées). En Python

2.X, et en 3.X avant 3.3, un return avec une valeur dans une fonction

génératrice est traité comme une erreur de syntaxe.



92

Chapitre 1. Python précis et concis

Instruction global

global nom [, nom]*

L’instruction global est une déclaration d’espace de noms : quand

elle est utilisée à l’intérieur d’une instruction de définition de classe

ou de fonction, alors toutes les apparitions du nom dans ce contexte

sont traitées comme des références à une variable globale (de niveau

module) de ce nom (que la variable nom soit assignée ou non et que

la variable nom existe déjà ou non).

Cette instruction permet la création et la modification des

variables globales dans une fonction ou une classe. En raison des

règles de portée de Python, vous devez déclarer seulement les

noms globaux qui sont assignés ; les noms qui ne sont pas déclarés

deviennent locaux si on les assigne, mais des références globales sont

automatiquement disponibles à l’intérieur du module. Voir aussi la

section Espace de noms et règles de portée.

Instruction nonlocal

nonlocal nom [, nom]*

Disponible uniquement en Python 3.X.

L’instruction nonlocal est une déclaration d’espace de noms :

quand elle est utilisée à l’intérieur d’une fonction imbriquée, alors

toutes les apparitions du nom dans ce contexte sont traitées comme

des références à une variable locale de ce nom dans la portée de la

fonction (que le nom soit assigné ou non).

Le nom doit exister dans la fonction ; cette instruction permet de le

remplacer par une fonction imbriquée. En raison des règles de portée

de Python, vous devez déclarer seulement les noms non locaux qui

sont assignés ; les noms qui ne sont pas déclarés deviennent locaux si

on les assigne, mais les références non locales sont automatiquement

disponibles dans les fonctions. Voir aussi la section Espace de noms et

règles de portée.



Instructions spécifiques

93

Instruction import

import [package.]* module [as nom]

[, [package.]* module [as nom]]*

L’instruction import fournit un accès aux modules : elle importe

la totalité d’un module. Les modules à leur tour contiennent des

noms récupérés par qualification : module.attribut. Les assignations

au niveau le plus élevé d’un fichier Python créent des attributs objets

de module. La clause optionnelle as assigne une variable nom à l’objet

module importé et supprime le nom original du module (ce qui est

utile pour obtenir des synonymes plus courts des noms de modules

longs ou des chemins de packages), et les préfixes optionnels package

indiquent les chemins des répertoires des packages (qui sont décrits

dans la prochaine section).

module désigne le module cible qui est généralement un fichier de

code source Python ou de bytecode compilé. Le module est fourni sans

son extension (par exemple, .py), et doit en principe être situé dans

un répertoire du chemin de recherche des modules, à moins qu’il ne

soit imbriqué dans un chemin de package.

Pour les composants les plus à gauche de module ou de package

de chemins d’import absolus, le chemin de recherche des modules est

sys.path (une liste de noms de répertoires initialisée à partir du

répertoire le plus élevé du programme, du paramètre PYTHONPATH, du

contenu du fichier de chemins .pth, et des valeurs par défaut de

Python. Les modules peuvent aussi être situés dans un répertoire

unique de packages pour les composants des packages imbriqués (voir

la section Imports de packages) et les imports relatifs des instructions

from (voir la section Syntaxe des imports relatifs des packages), et les

chemins de recherche peuvent s’étendre de manière arbitraire jusqu’à

certains répertoires pour les packages d’espaces de noms à partir de

Python 3.3 (voir la section Packages d’espaces de noms Python 3.3).

La première fois où un module est importé par un programme, son

code source est compilé en bytecode si nécessaire (et enregistré dans

un fichier .pyc si possible), puis il est exécuté du haut vers le bas

afin de générer les attributs de l’objet module par une assignation. En

Python 2.X et 3.1 (et les versions antérieures), les fichiers de bytecode

sont enregistrés le répertoire des fichiers de code source du même nom

(par exemple, module.pyc). En Python 3.2 et les versions ultérieures,



94

Chapitre 1. Python précis et concis

le bytecode est enregistré dans un sous-répertoire __pycache__ du

répertoire des fichiers de code source, avec un nom qui identifie la

version (par exemple, module.cpython-33.pyc).

Les imports ultérieurs utilisent le module déjà importé, mais

imp.reload() (reload() en 2.X) force les réimports des modules déjà

chargés. Pour importer en utilisant un nom de chaîne, reportez-vous à

la fonction __import__() utilisée par import dans la section Fonctions

intégrées et importlib.import_module(nom_de_module) de la biblio-

thèque standard.

En CPython standard, les imports peuvent aussi charger des

extensions C et C++ compilées, avec des attributs correspondant aux

noms du langage externe. Dans d’autres implémentations, les imports

peuvent aussi désigner des librairies de classes d’autres langages (par

exemple, Jython peut générer un wrapper de module Python qui

s’interface avec une librairie Java).

Imports de packages

S’ils sont utilisés, les noms des préfixes des packages désignent les

noms des répertoires, les chemins de modules comportant des points

reflètent les hiérarchies des répertoires. Un import de la forme import

dir1.dir2.mod charge généralement le fichier du module à partir du

chemin dir1/dir2/mod.py, où dir1 doit se trouver dans un répertoire

listé dans le chemin de recherche des modules (sys.path pour les

imports absolus) et dir2 est situé dans dir1 (et pas dans sys.path).

Dans les packages normaux, chaque répertoire listé dans une

instruction import doit avoir un fichier (éventuellement vide)

__init__.py qui sert d’espace de noms du module au niveau du

répertoire. Ce fichier est exécuté lors du premier import via le

répertoire, et tous les noms assignés dans les fichiers __init__.py

deviennent des attributs de l’objet module du répertoire. Les

packages des répertoires peuvent résoudre les conflits de noms

identiques provoqués par la nature linéaire de PYTHONPATH.

Reportez-vous aussi à la section Syntaxe des imports relatifs des

packages pour de plus amples informations sur les références à l’in-

térieur des packages des instructions from, et à la section Packages

d’espaces de noms Python 3.3 pour un type de package alternatif qui

ne nécessite pas de fichier __init__.py.



Instructions spécifiques

95

Packages d’espaces de noms Python 3.3

À partir de Python 3.3, l’opération d’import est étendue pour recon-

naître les packages d’espaces de noms (les packages de modules qui sont

la concaténation virtuelle d’un ou plusieurs répertoires imbriqués

dans les entrées du chemin de recherche des modules.

Les packages d’espaces de noms ne contiennent pas (car c’est

impossible) de fichier __init__.py. Ils servent d’option de repli et

d’extension aux modules et packages normaux, qui ne sont reconnus

que si un nom n’est pas retrouvé, mais correspond à un ou plusieurs

répertoires trouvés au cours de l’analyse du chemin de recherche.

Cette fonctionnalité est activée pour les instructions import et from.

Algorithme d’import

Avec l’ajout des packages d’espaces de noms, les imports suivent

les étapes initiales habituelles comme par le passé (par exemple,

vérification des modules déjà importés et des fichiers bytecode), mais

la recherche d’un module est étendue de la manière suivante.

Au cours des imports, Python parcourt chaque répertoire du che-

min de recherche des modules (défini par sys.path pour les composants

les plus à gauche des imports absolus, et par un emplacement de

packages pour les imports relatifs et les composants imbriqués des

chemins de packages. À partir de 3.3, si, par exemple, on recherche un

module importé ou un package nommé spam, pour chaque répertoire

du chemin de recherche des modules, Python teste les critères de

correspondance dans cet ordre :

1. Si répertoire\spam\__init__.py est trouvé, un package nor-

mal est importé et retourné.

2. Si répertoire\spam.{py, pyc, ou toute autre extension

de module} est trouvé, un module simple est importé et

retourné.

3. Si répertoire\spam est trouvé et qu’il s’agit d’un répertoire, il

est enregistré et l’analyse se poursuit avec le répertoire suivant

du chemin de recherche.

4. Si aucun des éléments ci-dessus n’est trouvé, alors l’analyse se

poursuit avec le répertoire suivant du chemin de recherche.

Si l’analyse du chemin de recherche se termine sans retourner

un module ou un package lors des étapes 1 ou 2, et qu’au moins un



96

Chapitre 1. Python précis et concis

répertoire a été enregistré à l’étape 3, alors un package d’espace de

noms est créé immédiatement. Le nouveau package d’espace de noms

a un attribut __path__ défini par un itérable de chaînes de chemins

de répertoires qui ont été trouvés et enregistrés au cours de l’étape 3

de l’analyse, mais il n’a pas de __file__.

L’attribut __path__ est utilisé dans les accès ultérieurs pour recher-

cher tous les composants des packages quand des éléments imbriqués

sont demandés, à la manière du répertoire unique d’un package

normal. Il joue le même rôle pour les composants de niveau inférieur

que sys.path pour les composants du niveau le plus élevé qui sont

le plus à gauche des chemins absolus d’imports, et qui deviennent le

chemin parent pour accéder aux éléments inférieurs utilisant le même

algorithme en quatre étapes.

Instruction from

from [package.]* module import

[(] nom [as autre_nom]

[, nom [as autre_nom]]* [)]

from [package.]* module import *

L’instruction from importe un module tout comme l’instruction

import (voir la section précédente), mais copie aussi les noms des

variables à partir du module à utiliser sans avoir à utiliser d’attribut

de qualification. La deuxième forme (from ... import *) copie tous

les noms assignés au niveau le plus élevé du module, à l’exception de

ceux avec un seul underscore en en-tête ou bien de ceux qui ne sont

pas listés dans la liste __all__ du module (si elle est définie).

Si elle est utilisée, la clause as crée un synonyme du nom comme

dans l’instruction import, et fonctionne pour n’importe quel com-

posant du nom. S’ils sont employés, les chemins d’import package

fonctionnent aussi comme dans l’instruction import (par exemple,

from dir1.dir2.mod import X) pour les packages d’espaces de noms

normaux et 3.3, bien que le chemin du package ait besoin d’être listé

au moins une fois dans from (mais pas à chaque référence d’attribut).

À partir de Python 2.4, les noms importés à partir d’un module

peuvent être encadrés par des parenthèses pour s’étendre sur plusieurs

lignes sans antislashs (il s’agit d’une syntaxe spéciale qui ne vaut que

pour from).



Instructions spécifiques

97

En Python 3.X, la forme from ... import * n’est pas valide dans

une fonction ou une classe, car elle empêche de classifier les portées

des noms au moment de la définition. En raison des règles de portée,

la forme * génère aussi des avertissements en 2.X à partir de la version

2.2 si elle apparaît imbriquée dans une fonction ou une classe.

L’instruction from est aussi utilisée pour autoriser de futurs (mais

toujours en discussion) ajouts au langage, avec from __future__

import nom_fonctionnalité. Cette forme ne doit apparaître qu’au

sommet d’un fichier module (précédé uniquement par une chaîne de

documentation ou des commentaires), ou bien n’importe quand au

cours d’une session interactive.

Syntaxe des imports relatifs des packages

En Python 3.X et 2.X, l’instruction from (mais pas import) peut

utiliser des points en en-tête dans les noms de modules pour spécifier

des références de modules à l’intérieur du package (ces imports sont

relatifs au répertoire du package dans lequel le module qui importe

réside). Les imports relatifs restreignent le chemin de recherche du

module initial au répertoire du package. Les autres imports sont

absolus, et les modules se situent dans sys.path. Voici quelques

modèles généraux des différentes syntaxes :

from source import nom [, nom]*

# Absolu : sys.path

from . import module [, module]*

# Relatif : uniquement

package

from .source import nom [, nom]*

# Relatif : uniquement

package

from .. import module [, module]*

# Parent dans package

from ..source import nom [, nom]*

# Parent dans package

Dans cette forme de from, source peut être un simple identifica-

teur ou un chemin de packages séparés par des points, nom et module

sont de simples identificateurs, et les points en en-tête identifient

l’import comme étant relatif au package. L’extension as qui sert à

renommer (elle n’est pas présente dans cet exemple) fonctionne aussi

sous cette forme comme pour une instruction normale from à la fois

pour le nom et le module.

La syntaxe des points en en-tête fonctionne à la fois en Python

3.X et 2.X afin de rendre les imports explicitement relatifs aux



98

Chapitre 1. Python précis et concis

packages. Cependant, pour les imports sans points en en-tête, c’est le

répertoire du package qui est d’abord recherché en Python 2.X, mais

pas en Python 3.X. Pour activer la sémantique complète d’import des

packages de Python 3.X en Python 2.6 et dans les versions suivantes,

il faut employer :

from __future__ import

absolute_import

Comme ils peuvent prendre en charge un éventail plus large

d’usages, les chemins absolus d’imports des packages, relatifs à un

répertoire de sys.path, sont souvent privilégiés par rapport aux

imports relatifs implicites de packages en Python 2.X, et la syntaxe

d’import relatif des packages de Python 2.X et 3.X.

Instruction class

[décoration]

class nom [ ( super [, super]* [, metaclass=M] ) ]:

suite

L’instruction class crée de nouveaux objets classe, qui sont des

usines fabriquant des objets instance. Le nouvel objet classe hérite de

chaque classe super listée selon l’ordre donné, puis est assigné à la

variable nom. L’instruction class introduit une nouvelle portée locale

des noms, et tous les noms assignés dans l’instruction class génèrent

des attributs d’objets de la classe partagés par toutes les instances de

la classe.

Vous trouverez ci-dessous une liste de choses importantes à savoir

sur les classes (pour des détails sur la programmation orientée objet,

reportez-vous aux sections Programmation orientée objet et Méthodes de

surchargement d’opérateur) :

• Les superclasses (appelées aussi classes de base), à partir

desquelles une nouvelle classe hérite des attributs, sont

listées entre parenthèses dans l’en-tête (par exemple, class

Sub(Super1, Super2)).

• Les assignations dans la suite d’instructions génèrent des attri-

buts de classes dont héritent les instances : les instructions

def imbriquées créent des méthodes, alors que les instructions

d’assignation créent de simples membres de classes.



Instructions spécifiques

99

• L’appel de la classe génère des objets instance. Chaque objet

instance peut avoir ses propres attributs, et hérite des attributs

de la classe et de toutes ses superclasses.

• Les fonctions de méthodes reçoivent un premier argument spécial,

appelé self selon une convention bien ancrée, qui est l’objet

instance qui est le sujet implicite de l’appel de la méthode, et

qui donne accès aux attributs d’états de l’instance.

• Les fonctions intégrées staticmethod() et classmethod()

prennent en charge les autres types de méthodes, et les

méthodes Python 3.X peuvent être traitées comme de simples

fonctions quand elles sont appelées via une classe.

• Les méthodes spéciales de surchargement d’opérateur dont le

nom commence par __X__ interceptent les opérations inté-

grées.

• Quand cela est justifié, les classes fournissent le maintien de

l’état et la structure du programme, ainsi que la prise en charge

de la réutilisation du code via la personnalisation des nouvelles

classes.

Décorateurs de classes en Python 3.X, 2.6 et 2.7

En Python 2.6, 3.0, et dans les versions ultérieures, la syntaxe du

décorateur peut être appliquée aux instructions class, en plus des

définitions de fonctions. Voici la syntaxe des décorateurs de classes :

@decorator

class C:

def meth():

...

qui est équivalente à cette liaison manuelle du nom :

class C:

def meth():

...

C = decorator(C)

Cela a pour effet de lier à nouveau le nom de la classe au résultat

du passage de la classe via le décorateur qui est appelable. Comme

les décorateurs de fonctions, les décorateurs de classes peuvent être

imbriqués et prennent en charge les arguments de décorateurs. Les

décorateurs de classes peuvent être utilisés pour gérer les classes,



100

Chapitre 1. Python précis et concis

ou bien les appels ultérieurs de création d’instances qu’ils reçoivent

(grâce à des objets proxy).

Métaclasses

Les métaclasses sont des classes qui généralement dérivent de la classe

type afin de personnaliser la création des objets classe eux-mêmes.

Par exemple :

class Meta(type):

def __new__(meta, cname, supers, cdict):

# Ceci et __init__ sont exécutés par l’appel de

type

c = type.__new__(meta, cname, supers, cdict)

return c

En Python 3.X, les classes définissent leurs propres métaclasses en

utilisant des arguments nommés dans les en-têtes class :

class C(metaclass=Meta): ...

En Python 2.X, on utilise à la place les attributs de classe :

class C(object):

__metaclass__ = Meta

...

Le code la métaclasse est exécuté à la conclusion d’une instruction

class (comme avec les décorateurs de classes). Reportez-vous à la

fonction type() dans la section Fonctions intégrées pour faire la liaison

entre les instructions class et les méthodes des métaclasses.

Instruction try

try:

suite

except [type [as valeur]]:

# ou [, valeur] en 2.X

suite

[except [type [as valeur]]:

suite]*

[else:

suite]

[finally:

suite]



Instructions spécifiques

101

try:

suite

finally:

suite

L’instruction try, qui intercepte les exceptions, peut spécifier des

clauses except contenant des suites qui servent de gestionnaires pour

les exceptions levées au cours d’une suite try, des clauses else qui

s’exécutent si aucune exception ne se produit au cours de la suite try,

et des clauses finally qui s’exécutent qu’une exception ait lieu ou

non. Les clauses except interceptent les exceptions et permettent de

les traiter, alors que les clauses finally exécutent des actions de fin

du bloc.

Des exceptions peuvent être levées automatiquement par Python,

ou bien de manière explicite par programmation avec des instructions

raise (voir la section Instruction raise). Dans les clauses except, le

type est une expression fournissant la classe d’exception à intercepter,

et un nom de variable supplémentaire valeur peut être utilisé pour

intercepter l’instance de la classe d’exception qui a été levée. Le

tableau 16 ( Formats des clauses de l’instruction try) liste toute les clauses

susceptibles d’apparaître dans une instruction try.

Tableau 16 — Formats des clauses de l’instruction try

Format de la clause

Interprétation

except:

Intercepte toutes les exceptions

except type:

Intercepte seulement une exception spécifique

except type as valeur:

Intercepte une exception et ses instances

except ( type1, type2):

Intercepte une des exceptions

except ( type1, type2) as valeur:

Intercepte une des exceptions et ses instances

else:

S’exécute si aucune exception n’est levée

final y:

Exécute toujours ce bloc en quittant l’instruc-

tion try

L’instruction try doit avoir au moins une clause except

ou finally, voire les deux. L’ordre des clauses est le suivant :



102

Chapitre 1. Python précis et concis

try→except→else→finally, les clauses else et finally étant

optionnelles ; il peut y avoir plusieurs clauses except (ou aucune),

mais il doit au moins y avoir une clause except s’il y a une clause

else. finally communique correctement avec return, break et

continue : si l’une de ces clauses passe le contrôle en dehors du bloc

try, la clause finally est exécutée à la sortie du bloc.

Il existe quelques variantes courantes, notamment :

except nom_de_classe as X:

Intercepte une classe d’exception, et assigne X à l’instance

levée. X donne accès aux attributs d’information d’état, aux

chaînes d’impression, ou aux méthodes appelables de l’instance

levée. Pour les anciennes exceptions de chaîns, X est assignée

aux données supplémentaires passées avec la chaîne (les excep-

tions de chaînes ont été supprimées en Python 3.X et 2.X, à

partir des versions 3.0 et 2.6).

except ( type1, type2, type3) as X:

Intercepte les exceptions nommées dans un tuple, et assigne X

aux données supplémentaires.

En Python 3.X, le nom X de la clause as est localisé dans le bloc

except, et supprimé quand il sort du bloc ; en 2.X, ce nom n’est pas

local à ce bloc. Consultez également l’appel sys.exc_info() de la

section Module sys pour l’accès générique à la classe et à l’instance

d’exception (c’est-à-dire à type et valeur) après le déclenchement

d’une exception.

Formats de l’instruction try en Python 2.X

En Python 2.X, l’instruction try fonctionne comme nous l’avons

décrit, mais la clause as utilisée dans les gestionnaires except pour

accéder à l’instance levée est codée avec une virgule (as et la virgule

fonctionnent à la fois en 2.6 et 2.7 pour la compatibilité 3.X), mais

as n’est pas présent dans les versions antérieures 2.X :

except nom_de_classe, X:

Intercepte une classe d’exception, et assigne X à l’instance

levée (utilisez as après la version 2.5).

except ( nom1, nom2, nom2), X:

Intercepte les exceptions, et assigne X aux données supplémen-

taires (utilisez as après la version 2.5).



Instructions spécifiques

103

Instruction raise

En Python 3.X, l’instruction raise prend les formes suivantes :

raise instance [from (autre_exception | None)]

raise classe

[from (autre_exception | None)]

raise

La première forme lève une instance de classe créée manuellement

(par exemple, raise Error(args)). La deuxième forme crée et lève

une nouvelle instance de classe (équivalent à raise classe()). La

troisième forme lève à nouveau l’exception la plus récente. Consultez

la section suivante ( Exceptions chaînées Python 3.X) pour la clause

optionnelle from.

L’instruction raise déclenche des exceptions. Elle peut être

utilisée pour lever explicitement des exceptions intégrées ou des

exceptions définies par l’utilisateur. Consultez la section Exceptions

intégrées pour les exceptions prédéfinies par Python.

Lors de l’exécution de raise, le contrôle du programme passe à la

clause except correspondant à l’instruction try la plus récente dont

la clause correspond, ou, s’il n’y a pas de correspondance, au niveau

supérieur du processus qui met fin au programme et affiche un message

d’erreur standard. Les clauses finally sont excutées dans le même

temps. Une clause except est considérée comme correspondante si

elle désigne la classe de l’instance levée ou l’une de ses superclasses

(voir la section Classes d’exceptions). L’instance levée est assignée à la

variable as de la clause except correspondante (si elle est présente).

Exceptions chaînées Python 3.X

En Python 3.X (seulement), la clause optionnelle from permet le

chaînage des exceptions : autre_exception est une autre classe ou

instance d’exception, qui est attachée à l’attribue __cause__ de

l’exception levée. Si l’exception levée n’est pas interceptée, Python

affiche les deux exceptions dans le message d’erreur standard :

try:

...

except Exception as E:

raise TypeError(’Bad’) from E



104

Chapitre 1. Python précis et concis

À partir de Python 3.3, la forme raise from peut également

spécifier None, afin d’annuler les exceptions chaînées accumulées au

point d’exécution de l’instruction :

raise TypeError(’Bad’) from None

Classes d’exceptions

À partir de Python 3.0 et 2.6, toutes les exceptions sont identifiées par

des classes, qui doivent être dérivées de la classe intégrée Exception

(en 2.X, cette dérivation n’est nécessaire que pour les classes créées

dans le nouveau style). La superclasse Exception fournit des valeurs

par défaut pour l’affichage des chaînes, ainsi que la conservation de

l’argument constructeur de l’attribut args des tuples.

Les classes d’exceptions prennent en charge les catégories d’excep-

tions qui peuvent être facilement étendues. Comme les instructions

try interceptent toutes les sous-classes quand elles désignent une

superclasse, les catégories d’exceptions peuvent être modifiées en

changeant l’ensemble des sous-classes sans interrompre les instruc-

tions try existantes. L’instance levée fournit aussi le stockage des

informations supplémentaires sur l’exception :

class General(Exception):

def __init__(self, x):

self.data = x

class Specific1(General): pass

class Specific2(General): pass

try:

raise Specific1(’spam’)

except General as X:

print(X.data)

# Affiche ’spam’

Formats de l’instruction raise Python 2.X

Avant Python 2.6, Python 2.X autorise l’identificatin des exceptions

avec des chaînes et des classes. En raison de cela, ses instructions

raise peuvent prendre les formes suivantes, dont beaucoup existent

par souci de rétro-compatibilité :



Instructions spécifiques

105

raise string

# Correspond au même objet string

raise string, data

# Assigne des données à la

variable exc

raise classe, instance

# Correspond à la classe ou la

superclasse

raise instance

# = inst.__class__, inst

raise classe

# = class()

raise classe, arg

# = class(arg), noninst

raise classe, (arg [, arg]*) # = class(arg, arg,...)

raise

# Lève à nouveau l’exception en

cours

Les exceptions de chaînes ont été abandonnées (ainsi que les

avertissements) à partir de Python 2.5. Python 2.X autorise également

un troisième élément dans les instructions raise, qui doit être un

objet traceback utilisé à la la place de l’emplacement courant et qui

désigne l’endroit où l’exception a eu lieu.

Instruction assert

assert expression [, message]

L’instruction assert accomplit des contrôles de débogage. Si

l’expression est fausse, elle lève une exception AssertionError, en

lui passant le message sous la forme d’un argument de constructeur,

s’il est fourni. Le paramètre de commande en ligne -O supprime les

instructions assert (leurs tests ne sont ni inclus ni exécutés).

Instruction with

with expression [as variable]:

# 3.0/2.6, +

suite

with expression [as variable]

[, expression [as variable]]*:

# 3.1/2.7, +

suite

L’instruction with englobe un bloc imbriqué dans un gestionnaire

de contextes (décrit plus bas), qui peut exécuter des actions d’entrée

de bloc, et garantir que des actions de sortie de bloc sont exécutées,

que des exceptions soient levées ou non. with peut constituer une



106

Chapitre 1. Python précis et concis

alternative à try/finally pour les actions de sortie, mais seulement

pour les objets ayant des gestionnaires de contextes.

L’expression est censée retourner un objet qui prend en charge le

protocole de gestion du contexte. Cet objet peut aussi retourner une

valeur qui sera assignée à la variable si la clause optionnelle as est

présente. Les classes peuvent définir des gestionnaires de contextes

personnalisés, et certains types intégrés, comme les fichiers et les

threads, fournissent des gestionnaires de contextes avec des actions

de sortie qui ferment les fichiers, libèrent les verrous de thread, etc. :

with open(r’C:\misc\script’, ’w’) as myfile:

...process myfile, auto-closed on suite exit...

Consultez la section Fichiers pour des informations détaillées

sur l’utilisation des gestionnaires de contextes, et la documentation

Python pour les autres types intégrées qui prennent en charge ce

protocole et cette instruction.

Cette instruction, qui est disponible à partir de Python 2.6 et 3.0,

peut être activée en 2.5 avec la syntaxe suivante :

from __future__ import with_statement

Gestionnaires de contextes multiples en Python 3.1 and 2.7

À partir de Python 3.1 et 2.7, l’instruction with peut également

spécifier plusieurs gestionnaires de contextes, c’est-à-dire que des

gestionnaires peuvent être imbriqués. Les éléments multiples des

gestionnaires de contextes sont séparés par des virgules et ils fonc-

tionnent de la même manière que des instructions with imbriquées.

En général, le code suivant 3.1, 2.7 (et dans les versions ultérieures) :

with A() as a, B() as b:

...statements...

est équivalent à ce code qui fonctionne aussi en 3.0 et 2.6 :

with A() as a:

with B() as b:

...statements...

Par exemple, dans le code suivant, les actions de sortie des deux

fichiers sont exécutées automatiquement quand le bloc d’instruction

se termine, quel que soit le résultat de l’exception :



Instructions spécifiques

107

with open(’data’) as fin, open(’res’, ’w’) as fout:

for line in fin:

fout.write(transform(line))

Protocole de gestionnaire de contextes

Les objets s’intègrent avec l’instruction with selon le modèle méthode-

appel décrit ci-dessous (voir aussi la section Méthodes pour gestionnaires

de contextes) :

1. L’expression est évaluée, et on obtient un objet que l’on

appelle gestionnaire de contextes qui doit définir des méthodes

nommées __enter__ et __exit__.

2. La méthode __enter__() du gestionnaire de contextes est

appelée. La valeur qu’elle retourne est assignée à la variable

si elle est présente, et elle est ignorée dans le cas contraire.

3. Le code de la suite imbriquée est exécuté.

4. Si la suite lève une exception, la méthode __exit__(type,

value, traceback) est appelée avec les détails de l’exception.

Si la méthode retourne une valeur fausse, l’exception est à

nouveau levée ; dans le cas contraire, il est mis fin à l’excep-

tion.

5. Si la suite ne lève pas d’exception, la méthode __exit__ est

quand même appelée, mais ses trois arguments sont tous passés

avec la valeur None.

Instructions Python 2.X

Python 2.X prend en charge l’instruction print décrite plus haut,

mais pas nonlocal, ni with intégralement avant la version 2.6. En

outre, raise, try, et def ont des syntaxes légèrement différentes en

Python 2.X comme nous l’avons noté précédemment, et les variantes

sémantiques qui sont spécifiques à la version 3.X et que nous avons

listées dans la section précédente ne s’appliquent pas en général à la

version 2.X (par exemple, les packages d’espaces de noms).

L’instruction suivante n’est disponible qu’en Python 2.X :

exec codestring [in globaldict [, localdict]]

L’instruction exec exécute du code de façon dynamique. codes-

tring peut être n’importe quelle instruction Python (voire plusieurs





108

Chapitre 1. Python précis et concis

instructions séparées par une ligne) sous la forme d’une chaîne, qui est

compilée puis exécutée dans l’espace de noms contenant l’instruction

exec, ou dans les dictionnaires d’espaces de noms global/local s’ils sont

spécifiés (par défaut, localdict est égal à globaldict). codestring

peut aussi être un code compilé. Consultez aussi les entrées des

fonctions compile(), eval() et de la fonction Python 2.X execfile()

dans la section Fonctions intégrées.

En Python 3.X, cette instruction devient la fonction exec() (voir

la section Fonctions intégrées). La syntaxe assurant la compatibilité

exec(a, b, c) est aussi acceptée en Python 2.X. Conseil : n’utilisez

pas ceci pour évaluer des chaînes de code qui ne sont pas dignes de

confiance car elles s’exécutent sous la forme de lignes de code.

ESPACE DE NOMS ET RÈGLES DE PORTÉE

Cette section traite des règles de liaison et de recherche des noms

(voir aussi les sections Format des noms, Conventions de nommage ainsi

que Termes atomiques et typage dynamique). Dans tous les cas, les noms

sont créés lors de leur première assignation, mais ils doivent déjà

exister quand on y fait référence. Les noms qualifiés et ceux qui ne

sont pas qualifiés sont résolus de manière différente.

Noms qualifiés : espaces de noms d’objets

Les noms qualifiés (X, dans object.X) s’appellent des attributs et

résident dans les espaces de noms d’objets. Les assignations dans

certaines portées lexicales1 servent à initialiser des espaces de noms

d’objets (par exemple, les attributs de module et de classe) :

Assignation : objet.X = valeur

crée ou modifie le nom de l’attribut X dans l’espace de noms

de l’objet. Il s’agit ici du cas normal ; reportez-vous à la sec-

tion Règles d’héritage formelles plus loin pour des informations

détaillées.

1. Les portées lexicales font référence à des structures de code physiquement

(syntaxiquement) imbriquées dans le code source d’un programme.



Espace de noms et règles de portée

109

Référence : objet.X

recherche le nom de l’attribut X dans l’objet, puis dans toutes

les classes accessibles au-dessus les instances et les classes. Il

s’agit de la définition de l’ héritage ; consultez les Règles d’héritage

formelles pour des informations détaillées.

Noms non qualifiées : portées lexicales

Les noms qui ne sont pas qualifiés (X, au début d’une expression)

impliquent des règles de portée lexicale. Les assignations lient de tels

noms à une portée locale, à moins qu’ils ne soient déclarés en tant

que global, ou nonlocal en 3.X.

Assignation : X = valeur

rend le nom X local par défaut : crée ou modifie le nom X

dans la portée locale en cours. Si X est déclaré en tant que

global, cela crée ou modifie le nom X dans la portée du

module qui le contient. En Python 3.X seulement, si X est

déclaré en tant que nonlocal, cela modifie le nom X dans la

portée de la fonction qui le contient. Les variables locales sont

normalement stockées dans la pile d’appels pendant le runtime

pour un accès rapide, et ne sont directement visibles que par

le code dans la même portée.

Référence : X

recherche au maximum le nom X dans quatre catégorie de

portées, selon l’ordre suivant :

– La portée locale en cours (la fonction qui contient le nom)

– Les portées locales de toutes les fonctions qui le contiennent

lexicalement (les autres couches de fonctions, de l’intérieur

vers l’extérieur)

– La portée globale en cours (le module qui le contient)

– La portée intégrée (qui correspond au module builtins en

Python 3.X, et au module __builtin__ en Python 2.X)

Les contextes de portée locale et globale sont définis dans

le tableau 17, Portées des noms non qualifiés. Les déclarations

global font commencer la recherche dans la portée globale, et

les déclarations nonlocal en 3.X restreignent la recherche aux

fonctions qui contiennent le nom.



110

Chapitre 1. Python précis et concis

Cas spéciaux : compréhensions, exceptions

Python 3.X localise les variables de boucles dans toutes les

compréhensions (Python 2.X fait la même chose à l’exception

des compréhensions de listes). Python 3.X localise et supprime

la variable d’exception de la clause except des instructions

try (2.X ne localise pas ce nom). Consultez aussi les sections

Expressions de compréhensions de listes et Instruction try

Tableau 17 — Portées des noms non qualifiés

Contexte du code

Portée globale

Portée locale

Module

Identique à la portée locale

Le module lui-même

Fonction, méthode

Enclosing module

Définition/appel de fonction

Classe

Module qui le contient

Instruction class

Script, mode interactif

Identique à la portée locale

Module __main__

exec(), eval()

Portée globale de l’appelant Portée locale de l’appelant

(ou passée)

(ou passée)

Portées imbriquées et closures

La recherche dans les fonctions qui contiennent un nom référencé

(voir la catégorie n° 2 de la précédente section) s’appelle portée

imbriquée statiquement, et fait partie du standard à partir de la version

2.2. Par exemple, la fonction suivante marche parce que la référence

à x dans f2 a accès à la portée f1 qui le contient :

def f1():

x = 42

def f2():

print(x)

# Garde x dans la portée de f1

return f2

# Pour être appelé plus tard :

f1()()=>42

Les fonctions imbriquées qui gardent les références à une portée

englobante (par exemple, f2 dans le code précédent) s’appellent des

closures ; il s’agit d’un outil de conservation de l’état qui constitue

parfois une alternative ou un complément aux classes, et qui a été

amélioré en 3.X avec nonlocal (voir la section Instruction nonlocal).



Espace de noms et règles de portée

111

Les portées s’imbriquent de manière arbitraire, mais seules les fonc-

tions englobantes (pas les classes) sont recherchées :

def f1():

x = 42

def f2():

def f3():

print(x)

# Trouve x dans la portée de f1

f3()

# f1() affiche 42

f2()

Portées englobantes et valeurs par défaut

Dans les versions de Python inférieures à 2.2, les fonctions de la

section précédentes provoquent des erreurs car le nom x n’est pas

local (dans la portée de la fonction imbriquée), global (dans le

module englobant f1) ou intégré. Pour que de tels cas puissent

fonctionner avec des versions antérieures à 2.2 ou quand cela est

nécessaire, les arguments par défaut conservent les valeurs de la portée

immédiatement englobante, car les valeurs des paramètres par défaut

sont évalués avant d’entrer dans def :

def f1():

x = 42

def f2(x=x):

print(x)

# f1()() affiche 42

return f2

Cette technique, qui fonctionne toujours dans les versions plus

récentes de Python, s’applique aussi aux expressions lambda, qui

impliquent une portée imbriquée, tout comme def, et sont plus

couramment imbriquées en pratique :

def func(x):

action = (lambda n: x ** n)

# Utilisé à partir de

2.2

return action

# func(2)(4)=16

def func(x):

action = (lambda n, x=x: x ** n) # Alternative par

défaut

return action

# func(2)(4)=16

Bien que ceci soit largement dépassé dans la plupart des cas, les

valeurs par défaut sont encore parfois nécessaires pour faire référence





112

Chapitre 1. Python précis et concis

à des variables de boucles quand on crée des fonctions à l’intérieur de

boucles ; dans le cas contraire, de telles variables reflètent seulement

leur valeur finale de boucle :

for I in range(N):

actions.append(lambda I=I: F(I)) # Valeur en cours de

I

PROGRAMMATION ORIENTÉE OBJET

Les classes sont le principal outil POO (programmation orientée

objet) de Python. Elles prennent en charge les instances multiples,

l’héritage des attributs et la surcharge des opérateurs. Python prend

également en charge les techniques de programmation fonctionnelle

(grâce à des outils comme les générateurs, les lambdas, les compré-

hensions, les maps, les closures, les décorateurs et les fonctions de

première classe) qui peuvent servir d’alternatives à la POO dans

certaines circonstances.

Classes et instances

Les objets classes fournissent un comportement par défaut

• L’instruction class crée un objet classe et l’assigne à un nom.

• Les assignations dans les instructions class créent des attributs

de classe, qui héritent du comportement et de l’état de l’objet.

• Les méthodes de classe sont des instructions def imbriquées,

avec des arguments particuliers pour recevoir l’instance du sujet

implicite.

Les objets instances sont générés à partir des classes

• L’appel d’un objet classe, comme une fonction, crée un nouvel

objet instance.

• Chaque objet instance hérite des attributs de la classe et

obtient son propre espace de noms.

• Les assignations des attributs du premier argument (par

exemple, self.X = V) des méthodes créent des attributs pour

chaque instance.



Programmation orientée objet

113

Règles d’héritage

• L’héritage se produit au moment de la qualification des attri-

buts, c’est-à-dire dans objet.attribut, si objet est une classe

ou une instance.

• Les classes héritent des attributs de toutes les classes listées dans

la ligne d’en-tête de l’instruction class (superclasses). Quand

plusieurs classes sont listées, cela signifie qu’il y a un héritage

multiple.

• Les instances héritent des attributs de la classe à partir de

laquelle elles sont générées, plus de tous ceux des superclasses

de cette classe.

• L’héritage recherche dans l’instance, puis dans sa classe, et

ensuite dans toutes les superclasses accessibles, pour utiliser la

première version du nom d’attribut qu’il trouve. Les recherches

dans les superclasses s’effectuent normalement en profondeur,

puis de la gauche vers la droite, mais les nouvelles classes

procèdent selon un modèle de graphe en diamant.

Consultez la section Règles d’héritage formelles pour des informa-

tions détaillées sur l’héritage.

Attributs pseudoprivés

Par défaut, tous les noms des attributs des modules et des classes sont

visibles partout. Des conventions spéciales permettent de masquer

des données limitées, mais elles sont en grande partie conçues pour

empêcher les collisions de noms (voir aussi la section Conventions de

nommage).

Attributs privés des modules

Les noms dans les modules commençant par un seul underscore

(par exemple, _X), et ceux qui ne figurent pas dans la liste __all__

du module, ne sont pas copiés quand un client utilise from module

import *. Il ne s’agit pas cependant d’une isolation stricte, car on peut

toujours accéder à ces noms grâce aux autres formes d’instructions

d’import.



114

Chapitre 1. Python précis et concis

Atributs privés des classes

Les noms figurant n’importe où au sein d’une instruction class com-

mençant par deux underscores (par exemple, __X) sont transformés

pendant la compilation pour inclure le nom de la classe qui les

contient sous la forme de préfixe (par exemple, _Classe__X). Le

préfixe ajouté du nom de la classe permet de situer de tels noms dans

la classe qui les contient et les distingue ainsi à la fois dans l’objet

instance self et la hiérarchie des classes.

Cela évite les collisions qui peuvent se produire entre les

méthodes ayant le même nom, et les attributs dans un unique objet

instance situé en bas de la chaîne d’héritage (pour un attribut

donné, toutes les assignations à self.attribut modifient l’espace de

noms de l’instance unique). Il ne s’agit cependant pas d’une isolation

strice, car on peut toujours accéder à de tels attributs via le nom

transformé.

Un contrôle d’accès assurant une certaine isolation peut aussi être

implémenté avec des classes proxy qui valident l’accès aux attributs

grâce aux méthodes __getattr__() et __setattr__() (voir la section

Méthodes de surchargement d’opérateur).

Nouvelles classes

En Python 3.X, il y a un modèle de classes unique : toutes les

classes sont considérées comme bénéficiant du nouveau style qu’elles

dérivent ou non de object. En Python 2.X, il y a deux modèles de

classes : le modèle classique (qui est le modèle par défaut dans toutes

les versions 2.X) et le nouveau modèle, qui est une option à partir de

2.2, codé par la dérivation d’un type prédéfini ou d’une classe objet

prédéfinie (par exemple, class A(objet)).

Les nouvelles classes (qui engloblent toutes les classes en Python

3.X) ont les différences suivantes par rapport aux classes ordinaires :

• Les modèles de graphe en diamant d’héritages multiples ont un

ordre de recherche légèrement différent (pour faire simple, la

recherche s’effectue plus en largeur qu’en profondeur grâce

au nouveau style __mro__ ; voir la section Règles d’héritage

formelles).

• Les classes sont désormais des types, et les types sont à présent

des classes : type(I) retourne la classe à partir de laquelle



Programmation orientée objet

115

une instance est créée, au lieu d’un type d’instance générique,

qui est normalement identique à I.__class__. La classe type

peut être sous-classée pour personnaliser la création des classes,

et toutes les classes héritent de object, qui fournit un petit

ensemble de méthodes par défaut.

• Les méthodes __getattr__() et __getattribute__() ne sont

plus exécutées pour les attributs implicitement récupérés par

les opérations intégrées. Elles ne sont pas appelées pour les

noms des méthodes de surchargement d’opérateur __X__ ; la

recherche de tels noms commence au niveau des classes, pas

des instances. Pour intercepter et déléguer l’accès à de tels

noms de méthodes, ils doivent en général être redéfinis dans

des classes wrapper/proxy.

• Les nouvelles classes ont une série de nouveaux outils spéci-

fiquement conçus pour leur gestion, notamment les slots, les

propriétés, les descripteurs et la méthode __getattribute__().

Reportez-vous à la section Méthodes de surchargement d’opéra-

teur pour __slots__, __getattribute__(), et les méthodes de

descripteurs __get__(), __set__(), et __delete__() ; consultez

aussi la section Fonctions intégrées pour property().

Règles d’héritage formelles

L’héritage se produit sur la référence du nom des attributs (la

recherche objet.nom qui est au cœur du code orienté objet) quand

l’objet est dérivé à partir d’une classe. Il diffère selon le type de

classe (classique ou nouvelle), bien que le code ordinaire s’exécute

souvent de manière identique quel que soit le modèle.

Classes classiques : DFLR

Dans les classes classiques (comportement par défaut en 2.X), la

recherche de l’héritage des références de noms s’effectue dans l’ordre

suivant :

1. L’instance

2. Puis sa classe

3. Puis toutes les superclasses de sa classe, d’abord en en profon-

deur, puis de gauche à droite



116

Chapitre 1. Python précis et concis

La première occurrence trouvée est alors utilisée. On appelle cet

ordre DFLR, qui correspond à l’acronyme anglais Depth-First Left Right

(d’abord en profondeur, puis de gauche à droite).

Cette recherche de référence peut être lancée à partir d’une

instancee ou d’une classe ; normalement, les assignations d’attributs

sont stockées dans l’objet cible sans recherche et il existe des cas

spéciaux pour __getattr__() (exécution si la recherche ne réussit

pas à trouve un nom ) et __setattr__() (exécution pour toutes les

assignations d’attributs).

Nouvelles classes : MRO

L’héritage dans les nouvelles classes (qui sont la norme en 3.X

et une option en 2.X) emploie la technologie MRO (acronyme

anglais de Method Resolution Order, c’est-à-dire ordre de résolution

des méthodes). Il s’agit d’un chemin linéarisé à travers l’arborescence

d’une classe, et d’un composant imbriqué de l’héritage, qui est

accessible dans l’attribut __mro__ d’une classe. Pour simplifier les

choses le modèle MRO est calculé de la manière suivante :

1. On liste toutes les classes dont une instance hérite en utilisant

le modèle de recherche DFLR des classes classiques, et on

inclut une classe plusieurs fois si elle est visitée plus d’une fois.

2. On analyse la liste obtenue en recherchant les classes en

double, en supprimant tous les doublons de la liste sauf la

dernière occurrence (qui est la plus à droite).

La séquence MRO obtenue pour une classe donnée comprend la

classe, ses superclasses, et touts les superclasses de niveau supérieur

jusqu’à la classe racine implicite ou explicite de l’objet au sommet de

l’arborescence. La séquence est ordonnée de telle sorte que chaque

classe apparaît avant ses parents, et les parents multiples conservent

l’ordre dans lequel ils apparaissent dans le tuple de la superclasse

__bases__.

Comme les parents communs dans les graphes en diamant n’appa-

raissent qu’à la position de leur dernière visite dans le MRO, les classes

de niveau inférieur sont recherchées en priorité quand la liste MRO

est utilisée ultérieurement par l’héritage des attributs (ce qui fait que

les recherches selon des graphes en diamant sont plus en largeur qu’en

prodonfeur), et chaque classe est incluse et ainsi visitée juste une fois,

quel que soit le nombre de classes qui y conduise.



Programmation orientée objet

117

Le modèle MRO est utilisé à la fois par l’héritage et par l’appel

super(), qui est une fonction intégrée invoquant toujours une classe

suivante sur le MRO (en fonction du point d’appel), qui n’est pas

forcément une superclasse, mais peut être utilisée pour diffuser les

appels de méthodes à travers une arborescence de classes en visitant

chaque classe une seule fois.

Exemple : sans graphe en diamant

class D:

attr = 3

#

D:3

E:2

class B(D):

pass

#

|

|

class E:

attr = 2

#

B

C:1

class C(E):

attr = 1

#

\

/

class A(B, C): pass

#

A

X = A()

#

|

print(X.attr)

#

X

# DFLR = [X, A, B, D, C, E]

# MRO = [X, A, B, D, C, E, objet]

# Affiche "3" à la fois en 3.X et 2.X (toujours)

Exemple : avec graphe en diamant

class D:

attr = 3

#

D:3

D:3

class B(D):

pass

#

|

|

class C(D):

attr = 1

#

B

C:1

class A(B, C): pass

#

\

/

X = A()

#

A

print(X.attr)

#

|

#

X

# DFLR = [X, A, B, D, C, D]

# MRO = [X, A, B, C, D, objet] (ne conservque que le

dernière D)

# Affiche "1" en 3.X, "3" en 2.X ("1" si D(objet))

Nouvel algorithme d’héritage

En fonction du code de la classe, le nouvel héritage peut impliquer des

descripteurs, des métaclasses et des MRO (les sources des noms dans

cette procédure sont testées dans l’ordre, qu’elles soient numérotées

ou bien dans l’ordre de la gauche vers la droite dans des conjonctions

de « ou »).



118

Chapitre 1. Python précis et concis

Pour rechercher un nom d’attribut :

1. À partir d’une instance I, la recherche s’effectue dans l’ins-

tance, sa classe, et ses superclasses, de la manière suivante :

– Recherche du __dict__ de toutes les classes en se basant

sur le __mro__ trouvé dans la __class__.de I.

– Si un descripteur de données est trouvé dans l’étape a, son

__get__() est appelé.

– Sinon, une valeur dans le __dict__ de l’instance I est

retournée.

– Sinon, on appelle un descripteur nondata ou une valeur

trouvée dans l’étape a est retournée.

2. À partir d’une classe C, la recherche s’effectue dans la classe, ses

superclasses, et l’arborescence de ses métaclasses de la manière

suivante :

– Recherche du __dict__ de toutes les métaclasses en se

bansant sur le __mro__ trouvé dans la __class__.de C.

– Si un descripteur de données est trouvé dans l’étape a, son

__get__() est appelé.

– Sinon, on appelle un descripteur ou on retourne une valeur

dans le __dict__ d’une classe class en fonction du propre

__mro__.de C.

– Sinon, on appelle un descripteur nondata ou une valeur

trouvée dans l’étape a est retournée.

3. Dans les règles 1 et 2, les opérations intégrées (par exemple,

les expressions) n’utilisent essentiellement que les sources de

l’étape a pour la recherche implicite des noms des méthodes,

et la recherche de super() est personnalisée.

En outre, la méthode __getattr__() peut être exécutée si elle

est définie quand un attribut n’est pas trouvé ; la méthode __getat-

tribute__() peut être exécutée pour chaque attribut récupéré ; et

la superclasse de l’objet en question fournit certaines valeurs par

défaut au sommet de l’arborescence de chaque classe et métaclasse

(c’est-à-dire à la fin de chaque MRO).

Comme dans les cas spéciaux, les opérations intégrées sautent les

sources des noms, comme cela est décrit dans la troisième règle, et la

fonction intégrée super() empêche l’héritage normal. Pour les objets



Programmation orientée objet

119

retournés par super(), les attributs sont résolus grâce à une analyse

spéciale prenant en compte le contexte d’une partie limitée d’un

MRO d’une classe, en choisissant le premier descripteur ou la valeur

trouvée au cours de la recherche, au lieu d’appliquer un héritage

complet (qui est utilisé sur l’objet super seulement si cette analyse

échoue) ; voir super() dans la section Fonctions intégrées.

Pour assigner un nom d’attribut :

Un sous-ensemble de la procédure de recherche est exécuté pour

l’assignation des attributs :

• Quand elle s’applique à une instance, une telle assignation suit

essentiellement les étapes a à c de la règle 1, en recherchant

dans l’arborescence de l’instance, bien que l’étape b appelle

__set__() au lieu de __get__(), et que l’étape c soit la dernière

étape et stocke dans l’instance au lieu de tenter une récupéra-

tion.

• Quand elle s’applique à une class, une telle assignation exécute

la même procédure sur l’arborescence de la métaclasse de la

classe : il s’agit approximativement de la règle 2, mais l’étape c

est la dernière étape et stocke dans la classe.

La méthode __setattr__() intercepte toujours toutes les assigna-

tions d’attributs comme auparavant, bien qu’il devienne moins utile

pour cette méthode d’employer le __dict__ de l’instance pour assigner

les noms, car les nouvelles extensions comme les slots, les propriétés

et les descripteurs implémentent les attributs au niveau de la classe (il

s’agit d’une sorte de mécanisme « virtuel » des données de l’instance).

Certaines instances peuvent n’avoir aucun __dict__ quand les slots

sont utilisés (optimisation).

Contexte et nouvel ordre de priorité

Les procédures du nouvel héritage imposent effectivement des règles

de priorité sur l’opération fondamentale de résolution des noms, qui

peut être pensée de la manière suivante (avec les étapes correspon-

dantes de l’algorithme d’héritage entre parenthèses) :

Pour les instances, essayez :

1. Descripteurs de données de l’aborescence de la classe ( 1b)

2. Valeurs de l’objet instance ( 1c)





120

Chapitre 1. Python précis et concis

3. Descripteurs nondata de l’aborescence de la classe ( 1d)

4. Valeurs de l’aborescence de la classe ( 1d)

Pour les classes, essayez :

1. Descripteurs de données de l’aborescence de la métaclasse ( 2b)

2. Descripteurs de l’aborescence de la classe ( 2c)

3. Valeurs de l’aborescence de la classe ( 2c)

4. Descripteurs nondata de l’aborescence de la métaclasse ( 2d)

5. Valeurs de l’aborescence de la métaclasse ( 2d)

Python exécute au maximum une (pour la règle 1) ou deux (pour

la règle 2) recherches dans l’arborescence par recherche de nom,

malgré la présence de quatre ou cinq sources de noms. Reportez-vous

également à la description de la section précédente de la procédure

de recherche des cas spéciaux exécutée pour les objets retournés par

la nouvelle fonction intégrée super().

Consultez aussi la section Méthodes pour les descripteurs et la

section Métaclasses pour leurs sujets, la section Méthodes de surchar-

gement d’opérateur pour les détails sur l’emploi de __setattr__(),

__getattr__(), et __getattribute__(), et les fichiers de code Python

object.c et typeobject.c, qui hébergent respectivement les implé-

mentations des instances et des classes (dans le code source de la

distribution Python).

MÉTHODES DE SURCHARGEMENT D’OPÉRATEUR

Les classes peuvent intercepter et implémenter des opérations inté-

grées en fournissant des fonctions qui sont préfixées et suffixées par

deux caractères underscore (__). Ces noms ne sont pas réservés et

peuvent être hérités des superclasses comme d’habitude. Python en

localise au maximum un par opération et l’appelle automatiquement.

Python appelle une méthode de surchargement d’une classe quand

des instances apparaissent des des expressions et d’autres contextes.

Par exemple, si une classe définit une méthode nommée __getitem__,

et que X est une instance de cette classe, l’expression X[i] est

un équivalent de l’appel de méthode X.__getitem__(i) (bien que,

actuellement, l’utilisation directe de cette forme d’appel de méthode

n’offre en général aucun gain de vitesse et peut même être pénalisant).



Méthodes de surchargement d’opérateur

121

Le surchargement des noms des méthodes est quelque peu arbi-

traite : la méthode __add__ d’une classe n’accomplit pas forcément

une addition ou une concaténation (bien qu’elle doive normalement

jouer un rôle similaire). De plus, les classes peuvent en général

mélanger les méthodes gérant des nombres et des collections et les

opérations sur des mutables et des immutables. La plupart des noms de

surchargement d’opérateurs n’ont pas de valeur par défaut (à l’excep-

tion de ceux dans object pour les nouvelles classes), et l’exécution

d’une opération lève une exception si sa méthode correspondante

n’est pas définie (par exemple, + sans __add__).

Les sous-sections suivantes énumèrent les méthodes disponibles

pour les opérations. Dans cette section, les parenthèses à la fin sont

en principe omises pour les noms des méthodes __X__ afin d’alléger

le texte, car leur contexte est implicite. Cette section se concentre

sur Python 3.X, mais elle fournit les détails de surchargement des

opérateurs qui sont communs à la plupart des versions de Python.

Consultez la section Méthodes de surchargement d’opérateur Python 2.X

à la fin de cette section pour les éléments uniques à certaines versions

de Python.

Méthodes pour tous les types

__new__( cls [, arg]*)

Appelée pour créer et retourner une nouvelle instance de la

classe cls. Reçoit les arguments du constructeur arg passés à

la classe cls. Si une instance de la classe cls est retournée, la

méthode __init__ de l’instance est invoquée avec le self de la

nouvelle instance, plus les mêmes arguments du constructeur ;

sinon, __init__ n’est pas exécutée. En général codée pour

appeler la méthode __new__ d’une superclasse via un nom

d’une superclasse explicite ou super() (voir la section Fonctions

intégrées), et gérer puis retourner l’instance qui en résulte. Il

s’agit d’une méthode qui est automatiquement statique.

Elle n’est pas utilisée dans les classes normales ; elle est prévue

pour permettre aux sous-classes de types immutables de person-

naliser la création d’instances, et pour autoriser les métaclasses

personnalisées à adapter la création des classes. Reportez-vous

à type() dans la section Fonctions intégrées pour le dernier cas

qui invoque cette méthode avec des arguments de création de

classe.



122

Chapitre 1. Python précis et concis

__init__( self [, arg]*)

Invoquée lors de la création de la classe class(args...). Il

s’agit de la méthode du constructeur qui initialise la nouvelle

instance, self. Quand elle est exécutée pour les appels avec

un nom de classe, self est fournie automatiquement ; arg

represéente les arguments passés au nom de la classe, et il peut

s’agir de n’importe quelle forme d’argument de définition de

fonction (voir les sections Instruction expression et Instruction

def, y compris le tableau 14, Format des arguments dans les

définitions).

Bien qu’elle soit techniquement appelée après __new__,

__init__ est le moyen préféré pour configurer les nouveaux

objets dans toutes les classes au niveau de l’application. Elle

ne doit pas retourner de valeur, et si nécessaire, elle doit

appeler manuellement la méthode __init__ des superclasses

en passant en même temps l’instance à self, via un nom de

superclasse explicite ou super() (voir la section Fonctions

intégrées). Python appelle une seule méthode __init__

automatiquement.

__del__( self)

Invoquée lors du traitement de l’instance par le garbage collec-

tor. Il s’agit de la méthode du destructeur qui fait le ménage

quand une instance self est libérée (recyclée). Les objets

imbriqués sont automatiquement libérés quand leur conteneur

est supprimé (à moins qu’ils ne soient référencés ailleurs).

Pendant l’exécution de cette méthode, les exceptions sont

ignorées et seuls des messages sont envoyés à sys.stderr.

Conseil : l’instuction try/finally permet de programmer plus

finement les actions de sortie d’un bloc de code ; l’instruction

with offre des possibilités similaires pour les types d’objets qui

sont pris en charge.

__repr__( self)

Invoquée par repr(self), elle permet un affichage interactif

et imbriqué (comme ‘self‘ en Python 2.X). Elle est aussi

invoquée par str(self) et print(self) s’il n’y a pas de

méthode __str__. Cette méthode retourne généralement une

représentation de self de bas niveau sous la forme d’une

chaîne de caractères.



Méthodes de surchargement d’opérateur

123

__str__( self)

Invoquée par str(self) et print(self) (ou utilise __repr__

comme solution de repli si elle est définie). Cette méthode

retourne en général une présentation de haut niveau sous forme

de chaîne de caractères de self.

__format__( self, formatspec)

Appelée par la fonction intégrée format() (et par extension,

par la méthode str.format() de str) pour produire une repré-

sentation de chaîne mise en forme de l’objet self, grâce à la

chaîne formatspec dont la syntaxe pour les types intégrés est

fournie par le composant du même nom dans str.format().

Voir les sections Syntaxe de la méthode de mise en forme, Méthode

de mise en forme de chaînes et Fonctions intégrées. Cette méthode

est nouvelle à partir de Python 2.6 et 3.0.

__bytes__( self)

Appelée par bytes() pour retourner une représentation chaîne

d’un type bytes de self, uniquement en Python 3.X.

__hash__( self)

Invoquée par dictionary[self] et hash(self), et les autres

opérations de collection hachées, notamment celles du type

set. Cette méthode retourne une clé de hachage sous la forme

d’un entier unique et non modifiable, et interagit discrète-

menta avec __eq__, ces deux méthodes ayant des valeurs par

défaut qui garantissent que tous les objets ne se considèrent

égaux qu’avec eux-mêmes ; consultez la documentation de

Python pour des informations détaillées.

__bool__( self)

Appelée pour les tests de valeur vraie et la fonction intégrée

bool() ; retourne False ou True. Quand __bool__ n’est pas

définie, __len__() est appelée si elle est définie et désigne une

valeur vraie avec valeur différente de zéro. Si une classe ne

définit ni __len__ ni __bool__, toutes ses instances sont consi-

dérées comme vraies. Cette méthode est nouvelle en Python

3.X ; en Python 2.X, cette méthode s’appelle __nonzero__ au

lieu de __bool__, mais elle fonctionne de manière identique.

__call__( self [, arg]*)

Invoquée par self(args...), quand une instance est appelée

comme un fonction. arg peut prendre n’importe quelle forme

d’argument de définition de fonction. Par exemple, les deux

définitions suivantes :



124

Chapitre 1. Python précis et concis

def __call__(self, a, b, c, d=5):

def __call__(self, *pargs, **kargs):

correspondent toutes les deux aux deux appels suivants :

self(1, 2, 3, 4)

self(1, *(2,), c=3, **dict(d=4))

Voir la section Instruction def, notamment le tableau 14, Format

des arguments dans les définitions, pour des détails sur les options

arg.

__getattr__( self, name)

Invoquée par self.nom, lorsque nom est un accès à un attribut

indéfini (cette méthode n’est pas appelée si nom existe ou s’il est

hérité par self). nom est une chaîne. Cette méthode retourne

un objet ou lève une exception AttributeError.

Elle est disponible à la fois pour les classes normales et les

nouvelles classes. En Python 3.X et dans les nouvelles en 2.X,

elle n’est pas exécutée pour les attributs __X__ implicitement

récupérés par les opérations intégrées (par exemple, les expres-

sions) ; vous devez redéfinir de tels noms dans des classes ou

superclasses wrapper/proxy. Consultez également __dir__ dans

cette liste.

__setattr__( self, nom, valeur)

Invoquée par self.nom=valeur (toutes les assignations d’at-

tributs). Conseil : assignez via une clé __dict__ ou une super-

classe (par exemple, objet) afin d’éviter les boucles récursives ;

une instruction self.attr=x dans la méthode __setattr__

appelle à nouveau __setattr__, mais ce n’est pas le cas de

self.__dict__[’attr’]=x.

La récursivité peut aussi être évitée en appelant de manière

explicite la version superclasse object d’une nouvelle classe :

object.__setattr__(self, attr, valeur). Cela peut être

préférable ou obligatoire dans les arborescences de classes qui

implémentent des attributs virtules d’instance au niveau de la

classe, comme les slots, propriétés, ou descripteurs (par exemple,

les slots peuvent exclure une instance __dict__).

__delattr__( self, nom)

Invoquée par del self.nom (toutes les suppressions d’attributs).

Conseil : afin d’éviter les boucles récursives, supprimez les



Méthodes de surchargement d’opérateur

125

attributs via __dict__ ou une superclasse, de la même manière

qu’avec __setattr__.

__getattribute__( self, nom)

Appelée de manière inconditionnelle pour implémenter des

accès aux attributs des instances de la classe. Si la classe définit

aussi __getattr__, elle ne sera jamais appelée (à moins d’être

appelée explicitement). Cette méthode doit retourner la valeur

de l’attribut (calculée) ou lever une exception AttributeError.

Afin d’éviter la récursivité infinie de cette méthode, son implé-

mentation doit toujours appeler la méthode de la superclasse

avec le même nom pour accéder à tous les attributs dont elle a

besoin (par exemple, objet.__getattribute__(self, nom).

Elle est disponible à la fois pour les classes normales et les

nouvelles classes. En Python 3.X et dans les nouvelles en 2.X,

elle n’est pas exécutée pour les attributs __X__ implicitement

récupérés par les opérations intégrées (par exemple, les expres-

sions) ; vous devez redéfinir de tels noms dans des classes ou

superclasses wrapper/proxy. Consultez également __dir__ dans

cette liste.

__lt__( self, autre)

__le__( self, autre)

__eq__( self, autre)

__ne__( self, autre)

__gt__( self, autre)

__ge__( self, autre)

Respectivement, ces méthodes sont utilisées par self < autre,

self <= autre, self == autre, self != autre, self > autre,

et self >= autre. Ajoutées à la version 2.1, on les appelle les

méthodes de comparaison riche et sont invoquées pour toutes

les expressions de comparaison en Python 3.X. Par exemple,

X < Y appelle X.__lt__(Y) si elle est définie. En Python

2.X uniquement, on préfère appeler ces méthodes plutôt que

__cmp__, et __ne__ est également exécutée pour self <> autre

en 2.X.

Ces méthodes peuvent retourner n’importe quelle valeur, mais

si l’opérateur de comparaison est utilisé dans un contexte de

Boolean, la valeur de retour est interprétée comme un résultat

Boolean de l’opérateur. Ces méthodes peuvent aussi retour-

ner (sans lever d’exception) l’objet spécial NotImplemented si

l’opération n’est pas prise en charge par les opérandes (ce qui



126

Chapitre 1. Python précis et concis

fonctionne même si la méthode n’a pas été définie, et force

Python 2.X à revenir à la méthode générale __cmp__ si elle a

été définie).

Il n’y a pas de relations implicites entre les opérateurs de

comparaison. Par exemple, si X == Y est vrai, cela n’implique

pas que X != Y soit faux : __ne__ doit être définie en même

temps que __eq__ si les opérateurs sont censés se comporter

de manière symétrique. Il n’y a pas non plus de version du

côté droit (arguments permutés) de ces méthodes que l’on

puisse utiliser quand l’argument gauche ne prend pas en charge

l’opération, alors que c’est le cas de l’argument de droite.

__lt__ et __gt__ sont le symétrique l’une de l’autre, tout

comme __le__ et __ge__, __eq__ et __ne__ étant leur propre

reflet. Utilisez __lt__ pour les tris en Python 3.X, et consultez

la documentation de __hash__ dans le manuel Python afin

d’étudier le rôle de __eq__ dans le hachage.

__slots__

Cet attribut de classe peut être assigné à une chaîne, une

séquence, ou à un autre itérable de chaînes donnant les noms

des attributs d’instances de la classe. Si elle est définie dans

une nouvelle classe (ce qui inclut toutes les classes en Python

3.X), __slots__ génère un descripteur de gestion au niveau de

la classe (voir la section Méthodes pour les descripteurs), réserve

de l’espace pour les attributs déclarés dans les instances, et

empêche la création automatique de __dict__ pour chaque ins-

tance (à moins que des chaînes ’__dict__’ ne soient incluses

dans __slots__, auquel cas les instances ont aussi une méthode

__dict__ et les attributs non nommés dans __slots__ peuvent

être ajoutés dynamiquement).

Comme ils peuvent supprimer une méthode __dict__ par

instance, les slots peuvent optimiser l’utilisation de l’espace.

Cependant, ils sont en général déconseillés (sauf cas excep-

tionnels où l’on doit prendre des précautions) car ils peuvent

endommager certains types de code, et ont des contraines

d’utilisation complexes (voir la documentation Python pour

des informations détaillées).

Pour prendre en charge des classes avec __slots__, les outils

qui listent de manière générique les attributs ou y accèdent

par leur nom doivent en général employer fonctions qui

sont neutres du point de vue du stockage, comme getattr(),



Méthodes de surchargement d’opérateur

127

setattr(), et dir(), qui s’appliquent à la fois au stockage

d’attributs de __dict__ et __slots__.

__instancecheck__( self, instance)

Retourne vrai pour isinstance() si instance est considérée

comme une instance directe ou indirecte de la classe. Cette

méthode est nouvelle en Python 3.X et 2.6 ; consultez la

documentation de Python pour son utilisation.

__subclasscheck__( self, subclass)

Retourne vrai pour issubclass() si subclass doit être consi-

dérée comme une sous-classe directe ou indirecte de la classe.

Cette méthode est nouvelle en Python 3.X et 2.6 ; consultez

la documentation de Python pour son utilisation.

__dir__( self)

Appelée par dir(self) (voir la section Fonctions intégrées).

Retourne une séquence de noms d’attributs. Permet à certaines

classes de faire connaître leurs attributs à l’aide de dir(), quand

ces attributs sont calculés dynamiquement avec des outils

comme __getattr__ mais sont connus de la classe elle-même.

Certains cas d’utilisation dynamique peuvent ne pas qualifier

directement, mais certains proxys généraux sont capables de

déléguer cet appel à des objets mandatés afin de prendre en

charge les outils d’attributs. Cette méthode, qui est nouvelle

en Python 3.X, a été portée aussi en Python 2.6 et 2.7.

Méthodes pour les collections (séquences, mappings)

__len__( self)

Invoquée par len(self) et éventuellement pour les tests

de valeur de vérité. Cette méthode retourne la taille d’une

collection. Pour les tests booléens, Python recherche d’abord

__bool__, puis __len__, et il considère ensuite l’objet comme

vrai (__bool__ s’appelle __nonzero__ en Python 2.X). Une

longueur égale à zéro signifie que la valeur est fausse.

__contains__( self, item)

Invoquée par item in self pour les tests d’appartenance person-

nalisés (dans le cas contraire, l’appartenance utilise __iter__,

si elle est définie, sinon __getitem__). Cette méthode retourne

un résultat vrai ou faux.



128

Chapitre 1. Python précis et concis

__iter__( self)

Invoquée par iter(self). Ajoutée à la version 2.2, cette

méthode fait partie du protocole d’itération. Elle retourne un

objet avec une méthode __next__ (éventuellement self).

Le résultat de la méthode __next__() de l’objet est ensuite

appelé de manière répétée dans tous les contextes d’itération

(par exemple, les boucles for), et doit retourner le résultat

siuvant ou lever une exception StopIteration pour terminer

la progression des résultats.

S’il n’y a pas de méthode __iter__ définie, l’itération a recours

à __getitem__. La méthode __iter__ d’une classe peut aussi

être codée avec un yield imbriqué pour retourner un généra-

teur avec une méthode __next__ créée automatiquement. En

Python 2.X, __next__ se nomme simplement next. Voir aussi

les sections Instruction for et Protocole d’itération.

__next__( self)

Invoquée par la fonction intégrée next(self), et par tous les

contextes d’itération pour avancer dans les résultats. Cette

méthode fait partie du protocole d’itération ; voir la méthode

__iter__ dans cette liste pour les détails de son utilisation. Elle

est nouvelle en Python 3.X ; en Python 2.X, elle s’appelle next,

mais fonctionne de la même manière.

__getitem__( self, clé)

Invoquée par self[clé], self[i:j:k], x in self, et éven-

tuellement dans tous les contextes d’itération. Cette méthode

implémente toutes les opérations relatives à l’indiçage, notam-

ment celles pour les séquences et les mappings. Les contextes

d’itération (par exemple, in et for) indicent de manière répé-

tée à partir de 0 jusqu’à IndexError, à moins que la méthode

préférable __iter__ ne soit définie. __getitem__ et __len__

constituent le protocole de séquence.

En Python 3.X, cette méthode et les deux suivantes sont

également appelées pour les opérations d’extraction ( slicing),

et dans ce cas, clé est un objet slice. Les objets slice, qui

peuvent être propagés par une autre expression slice, ont les

attributs start, stop, et step, qui peuvent tous prendre la

valeur None (pour signaler l’absence). Consultez aussi slice()

dans la section Fonctions intégrées.



Méthodes de surchargement d’opérateur

129

__setitem__( self, key, value)

Invoquée par self[clé]=valeur, self[i:j:k]=valeur. Cette

méthode est appelée pour l’assignation à une clé ou un indice

de collection, ou bien à un objet slice d’une séquence.

__delitem__( self, clé)

Invoquée par del self[clé], del self[i:j:k]. Cette méthode

est appelée pour la suppression d’un indice/clé et d’un objet

slice d’une séquence.

__reversed__( self)

Elle est appellée si elle est définie par la fonction intégrée

reversed() pour implémenter une itération à l’envers person-

nalisée. Elle retourne un nouvel objet itérable qui parcourt

tous les objets du conteneur en ordre inverse. S’il n’y a pas de

méthode __reversed__ définie, reversed() utilise le protocole

de séquence (méthodes __len__ et __getitem__).

Méthodes pour les nombres (opérateurs binaires)

Les méthodes numériques (et de comparaison) qui ne prennent pas

en charge leur opération pour les arguments fournis doivent retourner

(sans lever d’exception) l’objet spécial intégré NotImplemented, qui

fonctionne même si la méthode n’a pas du tout été définie. Les

opérations non prises en charge pour tous les types d’opérandes

doivent rester non définies.

Consultez le tableau 1 Priorités des opérateurs en Python 3.X pour

des exemples de rôles d’opérateurs dans les types intégrés, bien que la

signification de l’opérateur soit définie par surchargement des classes.

Par exemple, __add__ est invoquée par le signe + pour l’addition

de nombres et la concaténation de séquences, mais peut avoir une

sémantique arbitraire dans de nouvelles classes.

Méthodes binaires de base

__add__( self, autre)

Invoquée par self + autre.

__sub__( self, autre)

Invoquée par self autre.

__mul__( self, autre)

Invoquée par self * autre.

__truediv__( self, autre)



130

Chapitre 1. Python précis et concis

Invoquée par self / autre en Python 3.X. En Python 2.X, /

invoque à la place __div__ à moins que la division véritable ne

soit activée (voir la section Notes sur l’utilisation des opérateurs).

__floordiv__( self, autre)

Invoquée par self // autre.

__mod__( self, autre)

Invoquée par self % autre.

__divmod__( self, autre)

Invoquée par divmod( self, autre).

__pow__( self, autre [, modulo])

Invoquée par pow( self, autre [, modulo]) et self ** autre.

__lshift__( self, autre)

Invoquée par self << autre.

__rshift__( self, autre)

Invoquée par self >> autre.

__and__( self, autre)

Invoquée par self & autre.

__xor__( self, autre)

Invoquée par self âutre.

__or__( self, autre)

Invoquée par self | autre.

Méthodes binaires du côté droit

__radd__( self, autre)

__rsub__( self, autre)

__rmul__( self, autre)

__rtruediv__( self, autre)

__rfloordiv__( self, autre)

__rmod__( self, autre)

__rdivmod__( self, autre)

__rpow__( self, autre)

__rlshift__( self, autre)

__rrshift__( self, autre)

__rand__( self, autre)

__rxor__( self, autre)

__ror__( self, autre)

Il s’agit des équivalents pour le côté droit des opérateurs

binaires de la section précédente. Les méthodes d’opérateurs

binaires ont une variante du côté droit qui commencent par



Méthodes de surchargement d’opérateur

131

le préfixe r (« r » est l’initiale de right qui signifie droit en

anglais ; par exemple, __add__ et __radd__). Ces variantes

du côté droit ont les mêmes listes d’arguments, mais self se

situe du côté droit de l’opérateur. Par exemple, self + autre

appelle self.__add__(autre), alors que autre + self invoque

self.__radd__(autre).

La méthode du côté droit r n’est appelée que lorsque l’instance

est à droite et que l’opérande gauche n’est pas une instance

d’une classe qui implémente l’opération :

– instance + non instance exécute __add__

– instance + instance exécute __add__

– non instance + instance exécute __radd__

Si deux instances de classes différentes qui surchargent l’opé-

ration sont en présence, la classe de gauche est privilégiée.

__radd__ effectue souvent une conversion ou permutte l’ordre

et ajoute à nouveau pour déclencher __add__.

Méthodes binaires augmentées

__iadd__( self, autre)

__isub__( self, autre)

__imul__( self, autre)

__itruediv__( self, autre)

__ifloordiv__( self, autre)

__imod__( self, autre)

__ipow__( self, autre[, modulo])

__ilshift__( self, autre)

__irshift__( self, autre)

__iand__( self, autre)

__ixor__( self, autre)

__ior__( self, autre)

Il s’agit des méthodes d’assignation aumentée. Respectivement,

elles sont appelées pour les formats d’instructions d’assigna-

tion suivants : +=, -=, *=, /=, //=, %=, **=, <<=, >>=, &=, ˆ=,

et |=. Ces méthodes doivent tenter d’effectuer l’opération

in-place (en modifiant self) et de retourner le résultat (qui

peut être self). Si une méthode n’est pas définie, l’opération

augmentée a recours aux méthodes normales. Pour évaluer

X += Y, où X est une instance d’une classe qui a une méthode



132

Chapitre 1. Python précis et concis

__iadd__, X.__iadd__(Y) est appelée. Sinon, on utilise __add__

et __radd__.

Méthodes pour les nombres (autres opérations)

__neg__( self)

Invoquée par self.

__pos__( self)

Invoquée par +self.

__abs__( self)

Invoquée par abs(self).

__invert__( self)

Invoquée par self.

~

__complex__( self)

Invoquée par complex(self).

__int__( self)

Invoquée par int(self).

__float__( self)

Invoquée par float(self).

__round__( self [, n])

Invoquée par round(self [, n]). Nouveau en Python 3.X.

__index__( self)

Appelée pour implémenter operator.index(). Elle est aussi

invoquée dans d’autres contextes où Python nécessite un entier.

Cela inclut les instances qui se présentent sous forme d’indices,

de limites de slicing, et d’arguments des fonctions intégrées

bin(), hex(), et oct(). La méthode doit retourner un entier.

Elle est similaire en Python 3.X et 2.X, mais elle n’est pas

appelée pour hex() et oct() en 2.X (il faut utiliser les méthodes

__hex__ et __oct__ en 2.X). En Python 3.X, __index__ incor-

pore et remplace les méthodes __oct__ et __hex__ de Python

2.X, et l’entier retourné est mis en forme automatiquement.

Méthodes pour les descripteurs

Les méthodes suivantes ne s’appliquent que lorsqu’une instance

d’une classe les définissant (une classe descripteur) est assignée à un

attribut de classe d’une autre classe (appelée la classe propriétaire). Ces

méthodes du descripteur sont ensuite automatiquement invoquées

pour l’accès à l’attribut de la classe propriétaire et à ses instances :



Méthodes de surchargement d’opérateur

133

__get__(self, instance, propriétaire)

Cette méthode est appelée pour récupérer l’attribut de la classe

propriétaire d’une instance de cette classe. propriétaire est

toujours la classe propriétaire ; instance est l’instance par

laquelle on accède à l’attribut, ou None quand on accède

à l’attribut directement via la classe propriétaire ; self est

l’instance de la classe descripteur. La méthode retourne la

valeur de l’attribue ou lève une exception AttributeError.

self et instance peuvent avoir des informations d’état.

__set__(self, instance, valeur)

Cette méthode est appelée pour assigner à l’attribut d’une

instance de la classe propriétaire une nouvelle valeur.

__delete__( self, instance)

Cette méthode sert à supprimer l’attribut d’une instance de la

classe propriétaire.

Les descripteurs et leurs méthodes sont disponibles dans les

nouvelles classes, qui comprennent toutes les classes en 3.X. Ils ne

sont pleinement opérationnels en 2.X que si le descripteur et les

classes propriétaires sont des nouvelles classes. Un descripteur avec

une méthode __set__ s’appelle un descripteur de données, et il a la

priorité sur les autres noms dans l’héritage (voir la section Règles

d’héritage formelles).

Note

Les « descripteurs » de classes ne doivent pas être confondus avec

les « descripteurs de fichiers » (voir les sections Fichiers et Outils

de descripteurs de fichiers pour des informations sur les descripteurs

de fichiers).

Méthodes pour gestionnaires de contextes

Les méthodes suivantes implémentent le protocole de gestionnaire de

contextes, qui est utilisé par l’instruction with (voir aussi la section

Instruction with pour le mécanisme qui emploie ces méthodes) :

__enter__( self)

Entre dans le contexte de runtime lié à cet objet. L’instruction

with assigne la valeur de retour de cette méthode à la cible

spécifiée dans la clause as de l’instruction (si elle existe).



134

Chapitre 1. Python précis et concis

__exit__(self, type, valeur, traceback)

Sort du contexte de runtime lié à cet objet. Les paramètres

après self décrivent l’exception qui a provoqué la sortie du

contexte. Si la sortie du contexte s’est produite sans lever

d’exception, tous les trois arguments sont à None. Dans le

cas contraire, les arguments sont identiques aux résultats de

sys.exc_info() (voir la section Module sys). Retourne une

valeur vraie pour empêcher qu’une exception levée soit propa-

gée par la méthode qui a appelé.

Méthodes de surchargement d’opérateur Python 2.X

La section précédente fait état de différences sémantiques entre les

méthodes de surchargemetn d’opérateur qui sont disponibles à la fois

en Python 3.X et 2.X. Cette section détaille les différences de contenu

entre les deux versions.

Certaines des méthodes décrites dans la section précédente ne

fonctionnent en 2.X qu’avec les nouvelles classes, qui sont une exten-

sion optionnelle en 2.X. Cela inclut __getattribute__, __slots__,

et les méthodes de descripteur. Les autres méthodes peuvent se com-

porter différemment en 2.X pour les nouvelles classes (par exemple,

__getattr__), et certaines méthodes ne sont disponibles que dans

les dernières releases 2.X (par exemple, __dir__, __instancecheck__,

__subclasscheck__). Vous trouverez ci-dessous la liste des méthodes

qui sont spécifiques à chaque version.

Méthodes uniques en Python 3.X

Les méthodes suivantes existent en Python 3.X, mais pas en Python

2.X :

• __round__

• __bytes__

• __bool__ (utilisez __nonzero__ en Python 2.X, ou __len__)

• __next__ (utilisez next en Python 2.X)

• __truediv__ (disponible en Python 2.X uniquement si la véri-

table division est activée : voir la section Notes sur l’utilisation

des opérateurs)

• __index__ pour l’emploi de oct(), hex() (utilisez __oct__,

__hex__ en Python 2.X)



Méthodes de surchargement d’opérateur

135

Méthodes uniques en Python 2.X

Les méthodes suivantes existent en Python 2.X, mais pas en Python

3.X :

__cmp__( self, autre) (et __rcmp__)

Invoquée par self > autre, autre == self, cmp(self, autre),

etc. Cette méthode est appelée pour toutes les comparai-

sons pour lesquelles aucune méthode plus spécifique (comme

__lt__) n’est définie ou héritée. Elle retourne 1, 0, ou 1 pour

self inférieur à, égal à, ou supérieur à autre. Si aucune

méthode de comparaison riche ou aucune méthode __cmp__

n’est définie, les instances de classe sont comparées selon

leur identité (adresse en mémoire). La méthode de côté droit

__rcmp__ n’est plus prise en charge à partir de la version 2.1.

En Python 3.X, utilisez les méthodes de comparaison plus

spécifiques décrites précédemment : __lt__, __ge__, __eq__,

etc. Utilisez __lt__ pour le tri en Python 3.X.

__nonzero__( self)

Invoquée par la valeur de vérité (sinon, __len__ est utilisée si

elle est définie).

En Python 3.X, cette méthode est renommée __bool__.

__getslice__( self, low, high)

Invoquée par self[low:high] pour le slicing des séquences. Si

aucune méthode __getslice__ n’est trouvée, et pour les slices

étendus à trois éléments, un objet slice est créé et passé à la

place à la méthode __getitem__.

En Python 2.X, cette méthode et les deux suivantes sont

considérées comme obsolètes, mais sont toujours prises en

charge (elles sont appelées pour les expressions slice si elles

sont définies, et sont préférées à leurs équivalents basés sur

les éléments). En Python 3.X, ces trois méthodes sont tota-

lement supprimées, les slices invoquant toujours à la place

__getitem__, __setitem__, ou __delitem__, avec un objet

slice comme argument. Voir slice() dans la section Fonctions

intégrées.

__setslice__( self, low, high, valeur)

Invoquée par self[low:high]=valeur pour l’assignation des

slices des séquences. Voir aussi la note précédente sur l’obsoles-

cence de __getitem__.



136

Chapitre 1. Python précis et concis

__delslice__( self, low, high)

Invoquée par del self[low:high] pour la suppression des slices

des séquences. Voir aussi la note précédente sur l’obsolescence

de __getitem__.

__div__( self, autre) (plus __rdiv__, __idiv__)

Invoquée par self / autre, à moins que la véritable division

ne soit activée (auquel cas __truediv__ est exécutée à la

place). En Python 3.X, elles sont toujours remplacées par

__truediv__, __rtruediv__, et __itruediv__ parce que / est

toujours une vraie division. Voir aussi la section Notes sur

l’utilisation des opérateurs. Conseil : assignez __truediv__ =

__div__ pour prendre en charge les deux modèles dans une

seule méthode.

__long__( self)

Invoquée par long(self). En Python 3.X, le type int rem-

place totalement le type long, si bien que cette méthode est

supprimée.

__oct__( self)

Invoquée par oct(self). Cette méthode retourne une repré-

sentation d’une chaîne octale. En Python 3.X, elle retourne à

la place un entier pour __index__().

__hex__( self)

Invoquée par hex(self). Cette méthode retourne une repré-

sentation d’une chaîne hexadécimale. En Python 3.X, elle

retourne à la place un entier pour __index__().

__coerce__( self, autre)

Invoquée par l’expression arithmétique en mode mixte,

coerce(). Cette méthode retourne un tuple de (self, autre)

converti en un type commun. Si __coerce__ est définie, elle

est généralement appelée avant que les méthodes d’opérateurs

réels ne soient tentés (par exemple, avant __add__). Elle doit

retourner un tuple contenant des opérandes convertis en un

type commun (ou None si elle ne peut pas convertir). Voir le

manuel de référence Python pour en savoir plus sur les règles

de contrainte.

__unicode__( self)

Appelée en 2.X par unicode(self) pour retourner une chaîne

Unicode pour self (voir la section Fonctions intégrées Python

2.X). Il s’agit de l’équivalent Unicode de __str__.





Fonctions intégrées

137

__metaclass__

Attribut de classe assigné à la métaclasse de la classe. En

Python 3.X, utilisez à la place la syntaxe de l’argument nommé

metaclasse=M dans la ligne d’en-tête de la classe (voir la section

Métaclasses).

FONCTIONS INTÉGRÉES

Tous les noms intégrés (fonctions, exceptions, et ainsi de suite)

existent dans la portée implicite intégrée externe, qui correspond

au module builtins (nommé __builtin__ en Python 2.X). Comme

la recherche des noms s’effectue toujours en dernier sur cette portée,

ces fonctions sont toujours disponibles dans les programmes sans avoir

besoin d’être importées. Cependant, leurs noms ne sont pas des mots

réservés et ils peuvent être masqués par des assignations du même nom

dans les portées globale ou locale. Exécutez help(nom_de_fonction)

pour des informations supplémentaires sur l’usage des fonctions.

Cette section se concentre sur Python 3.X, mais elle fournit le

détail des fonctions intégrées qui sont communes à la plupart des

versions de Python. Consultez la section Fonctions intégrées Python

2.X à la fin de cette section pour les fonctions qui ne concernent que

certaines versions de Python :

abs( N)

Retourne la valeur absolue d’un nombre N.

all(itérable)

Retourne True seulement si tous les éléments de l’itérable

sont vrais.

any(itérable)

Retourne True si un élément de l’itérable est vrai. Conseil :

filter(bool, I) et [x for x in I if x] collectent toutes les

valeurs vraies d’un itérable I.

ascii( objet)

Comme repr(), retourne une chaîne contenant une représen-

tation affichable d’un objet, mais les caractères non-ASCII

du résultat de repr() sont transcodés à l’aide des caractères

d’échappement \x, \u, ou \U. Ce résultat est similaires à celui

qui est retourné par repr() en Python 2.X.



138

Chapitre 1. Python précis et concis

bin( N)

Convertit un entier en une chaîne de chiffres binaires (base

2). Le résultat est une expression Python valide. Si l’argu-

ment N n’est pas un objet Python int, il doit définir une

méthode __index__() qui retourne un entier. Conseil : pensez

aussi à int(string, 2) pour convertir des nombres binaires,

des littéraux binaires 0bNNN dans du code, et le type b dans

str.format().

bool([ X])

Retourne la valeur booléenne d’un objet X, en utilisant la

procédure standard de test de vérité. Si X est faux ou omis,

False est retourné ; dans le cas contraire, True est retourné.

bool est aussi une classe, qui est une sous-classe de int. La

classe bool ne peut pas être sous-classée davantage. Ses seules

instances sont False et True.

bytearray([ arg [, encodage [, erreurs]]])

Retourne un nouveau tableau d’octets. Le type bytearray est

une séquence de mutables qui sont des nombres entiers compris

dans la plage 0...255, s’affichant sous la forme de texte ASCII

quand cela est possible. Il s’agit essentiellement d’une variante

mutable de bytes, qui prend en charge la plupart des opérations

sur les séquences de mutables, ainsi que la plupart des méthodes

du type chaîne str. arg peut être une chaîne str avec un nom

d’encodage (et éventuellement des erreurs) comme avec str()

(décrite plus loin dans cette liste), un entier pour intialiser un

tableau de valeurs NULL (valeur zéro), un itérable de petits

entiers utilisés pour initialiser le tableau (chaîne de bytes

ou un autre bytearray), un objet se conformant à l’interface

de visualisation de la mémoire (appelée auparavant buffer)

utilisé pour intialiser le tableau, voire être absent, pour créer

un tableau vide. Voir également la section Chaînes byte et

bytearray.

bytes([ arg [, encodage [, erreurs]]])

Retourne un nouvel objet bytes, qui est une séquence immu-

table d’entiers dans la plage 0...255. bytes est une version

immutable de bytearray. La fonction a les mêmes méthodes

de chaînes non mutables et les mêmes opérations de séquences.

Elle est généralement utilisée pour représenter une chaîne

d’octets sur 8 bits de données binaires (par exemple, des médias,

du texte encodé en Unicode). Les arguments du constructeur



Fonctions intégrées

139

sont interprétés de la même manière que pour bytearray().

Les objets bytes peuvent aussi être créés avec le littéral b’ccc’

en Python 3.X (en 2.X, cela crée un str normal). Voir aussi la

section Chaînes byte et bytearray.

callable( objet)

Retourne True si l’objet est un appelable ( callable) ; dans le

cas contraire, retourne False. Cet appel est présent en 2.X. En

3.X, il a été supprimé en Python 3.0 et 3.1, mais réintroduit à

partir de 3.2 ; dans les versions précédentes de 3.X, utilisez à la

place hasattr(objet, ’__call__’).

chr( I)

Retourne une chaîne d’un caractère dont le code Unicode est

l’entier I. Il s’agit de la fonction inverse de ord() (par exemple,

chr(97) renvoie ’a’ et ord(’a’) renvoie 97).

classmethod( fonction)

Retourne une méthode de classe de fonction. Une méthode

de classe reçoit la classe la plus spécifique (la plus basse) de

l’instance sujette comme premier argument implicite, tout

comme une méthode d’instance reçoit l’instance. Ceci est utile

pour la gestion des données par classe. Utilisez la forme du

décorateur de fonction @classmethod en version 2.4 et dans les

versions suivantes (voir la section Instruction def).

compile(string, nom_fichier, sorte [, flags[, dont_inherit]])

Compile un string en un objet code. string est une chaîne

Python contenant du code Python. nom_fichier est une chaîne

utilisée dans les messages d’erreurs (en général, il s’agit du nom

du fichier à partir duquel on lit le code, ou bien de ’<string>’

si le nom est saisi de façon interactive). sorte peut avoir la

valeur ’exec’ si string contient des instruction, ’eval’ si

string est une expression, ou ’single’, qui affiche la sortie

d’une instruction d’expression qui est évaluée à une valeur

différente de None. L’objet de code qui en résulte peut être

exécuté à l’aide d’un appel des fonctions intégrées exec() ou

eval(). Les deux derniers arguments optionnels contrôlent les

instructions futures affectant la compilation de la chaîne ; si

ces arguments sont absents, la chaîne est compilée avec les

futures instructions effectives à la place d’un appel à compile()

(voir la documentation de Python pour les détails).



140

Chapitre 1. Python précis et concis

complex([ réel [, imag]])

Crée un objet nombre complexe (cela peut aussi être codé en

utilisant le suffixe J ou j : réel+imagJ). imag vaut 0 par défaut.

Si les deux arguments sont omis, la fonction retourne 0j.

delattr( objet, nom)

Supprime l’attribut nommé nom (une chaîne) de l’objet. Simi-

laire à del objet.nom, mais nom est une chaîne, et non pas une

variable prise littéralement (par exemple, delattr(a, ’b’) est

équivalent à del a.b).

dict([mapping | itérable | arguments nommés])

Retourne un nouveau dictionnaire intialisé à partir d’un map-

ping, d’une séquence ou tout autre itérable de paires clé/valeur,

ou bien d’un ensemble d’arguments nommés. Si aucun argu-

ment n’est fourni, la fonction retourne un dictionnaire vide. Il

s’agit d’un nom de classe d’un type qui peut être sous-classé.

dir([ objet])

Si aucun argument n’est passé, la fonction retourne la liste des

noms de la portée locale en cours (espace de noms). Quand

un objet avec des attributs est passé comme argument, elle

retourne la liste des noms d’attributs associés à cet objet.

Elle fonctionne sur les modules, les classes, et les instances

de classes, ainsi que sur les objets intégrés avec des attributs

(listes, dictionnaires, etc.). Le résultat, qui inclut les attributs

hérités, est trié ; utilisez les attributs de __dict__ pour les listes

d’attributs d’un seul objet. Cet appel exécute objet.__dir__()

si elle existe, ce qui peut fournir les noms des attributs calculés

dans les classes proxys ou dynamiques.

divmod( X, Y)

Retourne un tuple de (X / Y, X % Y).

enumerate( itérable, début=0)

Retourne un objet enumerate itérable. itérable doit être

une séquence ou un autre objet itérable qui prend en charge

le protocole d’itération. La méthode __next__() de l’itéra-

teur retourné par enumerate() retourne un tuple contenant

un compteur (démarrant à début, ou zéro par défaut) et la

valeur correspondante obtenue du parcour de l’itérable. Cela

est utile pour obtenir une série indicée des positions et des

éléments, dans des itérations comme des boucles for (par

exemple, (0, x[0]), (1, x[1]), (2, x[2]), ...). La fonction

est disponible dans la version 2.3 et les suivantes. Voir aussi



Fonctions intégrées

141

la section Module enum pour les enumerations fixes en Python

3.4.

eval(expr [, global [, local]])

Évalue l’expression expr, qui est censée être une chaîne conte-

nant une expression Python ou un objet de code compilé. expr

est évaluée dans les portées des espaces de noms de l’appel eval

lui-même, à moins que les arguments de dictionnaire d’espaces

de noms global et/ou local ne soient passés. local a pour

valeur pas défaut global seulement si global est passé. Cet

appel retourne le résultat de l’expression expr. Consultez aussi

la fonction compile() étudiée plus haut dans cette section

pour précompiler, la fonction exec() documentée plus bas

dans cette section, pour exécuter des chaînes d’instructions.

Conseil : n’utilisez pas ceci pour évaluer des chaînes de code

qui ne sont pas dignes de confiance car le code est exécuté.

exec(instructions [, global [, local]])

Évalue des instructions, qui sont censées être une chaîne

contenant des instructions Python ou un objet de code compilé.

Si instructions est une chaîne, la chaîne est analysée comme

une suite d’instructions Python, qui sont ensuite exécutées, à

moins qu’il y ait une erreur de syntaxe. S’il s’agit d’un objet de

code, il est simplement exécuté. global et local fonctionne

de la même manière que pour eval(), et compile() peut être

utilisé pour précompiler les objets de code. Cette fonction est

disponible sous la forme d’une instruction en Python 2.X (voir

la section Instructions Python 2.X), et son statut a oscillé entre

fonction et instruction plus d’une fois dans l’histoire de Python.

Conseil : n’utilisez pas ceci pour évaluer des chaînes de code

qui ne sont pas dignes de confiance car le code est exécuté.

filter(fonction, itérable)

Retourne les éléments de l’itérable pour lesquels la fonction

retourne une valeur vraie. La fonction accepte un paramètre.

Si la fonction est None, cela retourne tous les éléments vrais de

l’itérable (ce qui est équivalent à passer bool à la fonction).

En Python 2.X, cet appel retourne une liste. En Python 3.X,

cela retourne un objet itérable qui génère des valeurs à la

demande et peut être traversé une seule fois (appelez list()

pour forcer la génération des résultats si nécessaire).



142

Chapitre 1. Python précis et concis

float([ X])

Convertit un nombre ou une chaîne X en un nombre à virgule

flottante (ou 0.0 si aucun argument n’est passé). Voir aussi la

section Nombres pour des exemples d’utilisation. Il s’agit d’un

nom de classe d’un type qui peut être sous-classé.

format(valeur [, formatspec])

Convertit une valeur d’objet en une représentation mise

en forme, selon un format contrôlé par la chaîne formats-

pec. L’interprétation de formatspec dépend du type de l’ar-

gument valeur ; la plupart des types intégrés utilisent une

syntaxe standard de mise en forme qui a été décrite plus

haut (voir formatspec dans la section Syntaxe de la méthode

de mise en forme). format(valeur, formatspec), qui appelle

valeur.__format__(formatspec), est une opération de base

de la méthode str.format() (par exemple, format(1.3333,

’.2f’) est équivalent à ’{0:.2f}’.format(1.3333)).

frozenset([ itérable])

Retourne un objet d’ensemble figé dont les éléments sont

extraits d’un itérable. Les ensembles figés sont des ensembles

d’immutables qui n’ont pas de méthodes de mise à jour et qui

peuvent être imbriqués dans d’autres ensembles.

getattr(objet, nom [, valeur_par_défaut])

Retourne la valeur d’un nom d’attribut (une chaîne) à partir

d’un objet. Similaire à objet.nom, mais le nom est évalué sous

la forme d’une chaîne, et ce n’est pas un nom de variable pris

littéralement (par exemple, getattr(a, ’b’) est équivalent à

a.b). Si l’attribut nommé n’existe pas, la valeur_par_défaut

est retounée si elle est fournie, sinon une exception Attribu-

teError est levée.

globals()

Retourne un dictionnaire contenant les variables globales

de l’appelant (par exemple, les noms du module qui les

contiennent).

hasattr( objet, nom)

Retourne True si l’objet a un attribut appelé nom (une chaîne),

et False dans le cas contraire.

hash( objet)

Retourne la valeur de hachage de l’objet (s’il en a une). Les

valeurs de hachage sont des entiers utilisés pour comparer



Fonctions intégrées

143

rapidement les clés des dictionnaires au cours d’une recherche

dans un dictionnaire. Invoque objet.__hash__().

help([ objet])

Invoque le système d’aide intégré. Cette fonction est conçue

pour une utilisation interactive. Si aucun argument n’est

fourni, une session d’aide interactive démarre dans la console

de l’interpréteur. Si l’argument est une chaîne, le sytème

recherche le nom d’un module, d’une fonction, d’une classe,

d’une méthode, d’un mot-clé ou d’une rubrique de la documen-

tation, et le texte d’aide est affiché. Si l’argument est n’importe

quel autre forme d’objet, l’aide de cet objet est générée (par

exemple, help(list.pop))

hex( N)

Convertit un nombre entier N en une chaîne de chiffres hexa-

décimaux (base 16). Si l’argument N n’est pas un objet Python

int, en Python 3.X il doit définir une méthode __index__() qui

retourne un entier (en 2.X, __hex__() est appelée à la place).

id(objet)

Retourne un entier qui est l’identifiant de l’objet, qui est

unique dans le processus d’appel parmi tous les objets existants

(il s’agit de son adresse en mémoire).

__import__( nom, [... autres args...])

, fonctionImporte et retourne un module, qui dépend du

nom passé sous la forme d’une chaîne pendant le runtime

(par exemple, mod = __import__(’mymod’)). Cet appel est en

général plus rapide que la construction et l’exécution avec

exec() d’une chaîne d’une instruction import. Cette fonction

est appelée en interne par les instructions import et from

et peut être contournée pour personnaliser les opérations

d’import. Tous les arguments, sauf le premier, ont un rôle

important (reportez-vous au manuel Python). Consultez éga-

lement l’appel du module imp module de la librairie standard

et importlib.import_module(), ainsi que la section Instruction

import.

input([ prompt])

Affiche une chaîne prompt si elle est fournie, puis lit une ligne à

partir du flux d’entrée stdin (sys.stdin) et la retourne sous la

forme d’une chaîne. Elle supprime le caractère \n à la fin de la

ligne et lève une exception EOFError à la fin du flux stdin. Sur



144

Chapitre 1. Python précis et concis

les platefomes où GNU readline est pris en charge, input()

l’utilise. En Python 2.X, cette fonction se nomme raw_input().

int([nombre | string [, base]])

Convertit un nombre ou une chaîne en un entier. La conver-

sion des nombres à virgule flottante en entiers supprime la

partie décimale. base ne peut être passée que si le premier

argument est une chaîne, et sa valeur par défaut est 10. Si

l’argument base a une valeur 0, la base est déterminée par le

contenu de la chaîne (comme un littéral de code), sinon la

valeur de la base passée est utilisée pour la base de la conversion

de la chaîne. base peut être égale à 0, et couvrir la plage 2...36.

La chaîne peut être précédée par un signe et encadrée par

des espaces qui seront ignorés. S’il n’y a pas d’arguments, la

fonction retourne 0. Voir aussi la section Nombres pour des

exemples d’utilisation. Il s’agit d’un nom de classe d’un type

qui peut être sous-classé.

isinstance(objet, classinfo)

Retourne True si l’objet est une instance de classinfo, ou une

instance de n’importe quelle sous-classe. classinfo peut aussi

être un tuple de classes et/ou de types. En Python 3.X, les types

sont des classes, si bien qu’il n’y a pas de cas spécial pour les

types. En Python 2.X, le second argument peut aussi être un

objet type, ce qui rend cette fonction très utile dans les deux

versions de Python comme alternative à l’outil de test de type

(isinstance(X, Type) par rapport à type(X) is Type).

issubclass( classe1, classe2)

Retourne True si classe1 est dérivée de classe2. classe2 peut

aussi être un tuple de classes.

iter(objet [, sentinelle])

Retourne un objet itérateur qui peut être utilisé pour par

parcourir les éléments d’un objet itérable. Les objets itéra-

teurs retournés ont une méthode __next__() qui retourne

l’élément suivant ou lève une exception StopIteration pour

terminer la progression. Tous les contextes d’itération en

Python utilisent ce protocole pour leur parcours, s’il est pris

en charge par l’objet. La fonction intégrée next(I) appelle

aussi I.__next__() automatiquement. S’il n’y a qu’un argu-

ment, objet est censé fournir son propre itérateur ou être une

séquence ; s’il y a deux arguments, objet est un appelable qui



Fonctions intégrées

145

est appelé jusqu’à ce qu’il retourne une sentinelle. L’appel à

iter() peut être surchargé dans les classes avec __iter__().

En Python 2.X, les objets itérateur ont une méthode nommée

next() et non pas __next__(). Par souci de compatibilité, la

fonction intégrée next() est aussi disponible en 2.X (à partir

de 2.6) et appelle I.next() au lieu de I.__next__(). Avant

la version 2.6, I.next() peut être appelée explicitement à la

place. Voir aussi next() dans cette liste, et la section Protocole

d’itération.

len(objet)

Retourne le nombre d’éléments (longueur) d’un object collec-

tion, qui peut être une séquence, un mapping, un ensemble,

ou une autre forme de collection (par exemple, une collection

définie par l’utilisateur).

list([ itérable])

Retourne une nouvelle liste contenant tous les éléments de

n’importe quel objet itérable. Si l’itérable est déjà une

liste, la fonction retourne une copie shallow. S’il n’y a pas

d’arguments, elle retourne une nouvelle liste vide. Il s’agit d’un

nom de classe d’un type qui peut être sous-classé.

locals()

Retourne un dictionnaire contenant les variables locales de

l’appelant (avec une entrée clé:valeur par local).

map(fonction, itérable [, itérable]*)

Applique la fonction à chaque élément d’une séquence ou

d’un autre objet itérable, et retourne les résultats individuels.

Par exemple, map(abs, (1, 2)) retourne 1 et 2. Si des argu-

ments d’itérables supplémentaires sont passés, la fonction doit

prendre tous ces arguments, puis est passée à un élément de

chaque itérable pour tous les appels ; dans ce mode, l’itération

s’arrête à la fin de l’itérable le plus court.

En Python 2.X, cela retourne une liste des résultats des appels

individuels. En Python 3.X, cela retourne à la place un objet

itérable qui génère les résultats à la demande et ne peut être

parcouru qu’une seule fois (appelez list() pour forcer la

génération des résultats si nécessaire).

En Python 2.X (mais pas en Python 3.X), si la fonction est

None, map() collecte tous les éléments itérable dans une liste

de résultats ; s’il y plusieurs itérables, le résultat combine leurs

éléments dans des tuples, et tous les itérables sont comblés avec



146

Chapitre 1. Python précis et concis

des valeurs None pour parvenir à la longueur du plus long. Un

outil similaire est disponible en Python 3.X dans le module de

librairie standard : itertools.

max( itérable [, arg]* [, key= fonction])

Avec un seul argument itérable, la fonction retourne l’élé-

ment ayant la valeur la plus élevée d’un itérable non vide

(par exemple, une chaîne, un tuple, une liste, un ensemble).

Avec plusieurs arguments, la fonctionne retourne la valeur la

plus élevée de tous les arguments. L’argument optionnel key

spécifie une fonction de transformation comme celle qui est

utilisée pour list.sort() et sorted() (voir les sections Listes

et Fonctions intégrées).

memoryview( objet)

Retourne un objet memoryview créé par l’argument objet.

Les vues mémoire permettent au code Python d’accéder aux

données internes d’un objet qui prend en charge le proto-

cole sans copier l’objet. La mémoire peut être interprétée

comme de simples octets ou bien des structures de données

plus complexes. Parmi les objets intégrés qui prennent en

charge le protocole de vue mémoire, il y a bytes et bytearray.

Reportez-vous à la documentation Python ; les vues mémoire

sont une bonne alternative au protocole buffer() en Python

2.X et à la fonction intégrée, bien que memoryview() ait été

portée en Python 2.7 pour une compatibilité avec 3.X.

min( itérable [, arg]* [, key= fonction])

Avec un seul argument itérable, la fonction retourne l’élé-

ment ayant la valeur la moins élevée d’un itérable non vide

(par exemple, une chaîne, un tuple, une liste, un ensemble).

Avec plusieurs arguments, la fonctionne retourne la valeur

la moins élevée de tous les arguments. L’argument key est

similaire à celui de la fonction max() (étudiée plus haut dans

cette liste).

next(itérateur [, valeur_par_défaut])

Récupère l’élément suivant de l’objet itérateur en appelant

sa méthode __next__() (en 3.X). Si on arrive au bout de

l’itérateur, la valeur_par_défaut est retournée si elle est

fournie, sinon une exception StopIteration est levée. Cette

fonction est aussi disponible en Python 2.6 et 2.7, où elle

appelle itérateur.next() au lieu de itérateur.__next__().

Cela facilite la compatibilité entre les versions 2.X et 3.X de



Fonctions intégrées

147

Python. En Python 2.X, avant la version 2.6, cette fonction

n’existe pas ; utilisez manuellement itérateur.next() à la

place pour des itérations manuelles. Voir aussi iter() dans

cette liste, et la section Protocole d’itération.

object()

Retourne un nouvel objet sans fonctionnalités. object (son

nom littéral) est une superclasse de toutes les nouvelles classes

(nouveau style), qui comprend toutes les classes en Python 3.X,

et les classes explicitement dérivées du type object en Python

2.X. Elle possède un petit ensemble de méthodes par défaut

(voir dir(object)).

oct( N)

Convertit un nombre N en une chaîne de chiffres en octal (base

8). Si l’argument N n’est pas un objet Python int, en Python

3.X il doit définir une méthode __index__() qui retourne un

entier (en 2.X, __oct__() est appelée à la place).

open(...)

open( fichier

[, mode=’r’

[, buffering=-1

[, encoding=None # Mode texte uniquement

[, errors=None # Mode texte uniquement

[, newline=None # Mode texte uniquement

[, closefd=True, # Descripteurs uniquement

[, opener=None ]]]]]]]) # Opener personnalisé 3.3+

Retourne un nouvel objet fichier connecté au fichier externe

nommé par fichier, ou bien lève une exception IOError (ou

une sous-classe OSError à partir de 3.3) si l’ouverture du fichier

échoue. Cette section décrit la fonction open() de Python 3.X ;

pour l’utilisation en Python 2.X, reportez-vous à la section

Fonctions intégrées Python 2.X.

fichier est en général un objet texte ou une chaîne d’octets

qui fournit le nom (avec son chemin si le fichier ne se trouve

pas dans le répertoire de travail) du fichier à ouvrir. fichier

peut aussi être un descripteur de fichier du fichier à ouvrir. Si

un descripteur de fichier est fourni, il est fermé quand l’objet

retourné est fermé, à moins que closefd ne soit défini à False.

Toutes les options suivantes peuvent être passées sous la forme

d’arguments nommés.



148

Chapitre 1. Python précis et concis

mode est une chaîne optionnelle qui spécifie le mode dans

lequel le fichier est ouvert. Par défaut, mode vaut ’r’, ce qui

signifie que le fichier est ouvert en lecture en mode texte. Parmi

les autres valeurs courantes, on peut citer ’w’ pour l’écriture

(le fichier est écrasé s’il existe déjà), et ’a’ pour l’ajout. En

mode texte, si encodage n’est pas spécifié, l’encodage utilisé

dépend de la plateforme, et les nouvelles lignes comprennent

pas défaut le caractère ’\n’. Pour la lecture et l’écriture d’octets

bruts, utilisez les modes binaires ’rb’, ’wb’, ou ’ab’, et ne

spécifiez pas le paramètre encodage.

Certains modes peuvent être combinés : ’r’ (option par défaut

qui ouvre en lecture), ’w’ (écriture avec écrasement), ’a’ (écri-

ture avec ajout à la fin du fichier s’il existe déjà), ’b’ (mode

binaire), ’t’ (option par défaut qui ouvre en mode textge), ’+’

(pour ouvrir en lecture et en écriture un fichier disque à mettre

à jour), ’U’ (uniquement pour assurer la rétrocompatibilité des

caractères de nouvelle ligne). Le paramètre par défaut du mode

’r’ est identique à ’rt’ (ouverture en lecture en mode texte).

Pour un accès aléatoire en mode binaire, le mode ’w+b’ ouvre

et écrase le fichier avec des octets ayant la valeur zéro, alors

que ’r+b’ ouvre le fichier sans l’écraser.

Python fait une différence entre des fichiers ouverts en mode

texte et en mode binaire, même quand le système d’exploita-

tion n’en fait pas :

• En entrée, les fichiers ouverts en mode binaire (en ajoutant ’b’ à

mode) retournent un contenu sous la forme d’objets bytes sans

décodage Unicode ni de transformation des caractères de fin de

ligne. En mode texte (valeur par défaut, ou quand le paramètre

’t’ est ajouté à mode), le contenu du fichier est retourné sous

la forme de chaînes str après que les octets sont décodés avec

un nom d’encodage Unicode explicitement passé ou bien un

encodage par défaut dépendant de la plateforme, et les fins de

ligne sont transformées avec la valeur du paramètre newline.

• En sortie, le mode binaire attend des types bytes ou un bytearray

et écrit les caractères sans les modifier. Le mode texte attend

des types str, et les encode selon un encodage Unicode puis

applique une transformation des caractères de fin de ligne en

prenant la valeur du paramètre newline.



Fonctions intégrées

149

buffering est une option utilisée pour définir la stratégie de

tampon. Par défaut (quand le paramètre n’est pas passé ou qu’il

a une valeur 1), un tampon total est activé. Pour désactiver le

tampon, il faut passer la valeur 0 (cela n’est autorisé qu’en mode

binaire) ; la valeur 1 indique un tampon par ligne (uniquement

en mode texte) et une valeur > 1 indique un tampon total

et précise la taille du tampon. Le transfert des données mises

en tampon peut ne pas être immédiatement accompli (utilisez

file.flush() pour forcer le vidage des buffers).

encoding est le nom de l’encodage utilisé pour décoder ou enco-

der le contenu d’un fichier texte. Ce paramètre ne doit être uti-

lisé qu’en mode texte. L’encodage par défaut dépend de la plate-

forme (qui est récupérée par locale.getpreferredencoding()),

mais n’importe quel encodage pris en charge par Python peut

être passé. Consultez le module codecs dans la librairie stan-

dard Python pour obtenir la liste des encodages disponibles.

errors est une chaîne optionnelle qui spécifie la manière

de gérer les erreurs d’encodage. Ce paramètre ne doit être

utilisé qu’en mode texte. Les valeurs suivantes peuvent

être passées : ’strict’ (valeur par défaut pour None) pour

lever une exception ValueError en cas d’erreurs d’encodage,

’ignore’ pour ignorer les erreurs (attention, le fait d’ignorer

les erreurs d’encodage peut engendrer des pertes de données),

’replace’ pour employer un marqueur de remplacement pour

les données invalides. Consultez la documentation Python et

codecs.register_error() dans la librairie standard Python

pour la liste complète des valeurs autorisées pour ce paramètre,

ainsi que str() dans cette liste.

newline contrôle le fonctionnement des caractères universels

de nouvelle ligne, et ne s’applique qu’en mode texte. Ce

paramètre peut prendre les valeurs suivantes None (valeur par

défaut), ’’, ’\n’, ’\r’, et ’\r\n’ :

En entrée, si newline est égal à None, le mode universel est

activé : les lignes peuvent se terminer par ’\n’, ’\r’, ou

’\r\n’, et tous ces caractères sont transformés en ’\n’ avant

d’être retournés à l’appelant. Si newline est égal à ’’, le mode

universel est activé, mais les fins de ligne sont retournées à

l’appelant sans être transformées. Si la ligne comporte d’autres

valeurs légales, les fins de ligne sont terminées par la chaîne

fournie et sont retournées à l’appelant.



150

Chapitre 1. Python précis et concis

En sortie, si newline est égal à None, tous les caractères ’\n’

écrits sont transformés et prenent la valeur du séparateur de

ligne par défaut du système d’exploitation, os.linesep. Si

newline est égal à ’’, il n’y a pas de transformation. Si la ligne

comporte d’autres valeurs légales, tous les caractères ’\n’ écrits

sont transformés avec la chaîne fournie.

Si closefd est égal à False, le descripteur de fichier sera main-

tenu ouvert quand le fichier sera fermé. Cela ne fonctionne

pas quand un nom de fichier est fourni sous la forme d’une

chaîne et closefd doit être égal à True (valeur par défaut)

dans ce cas. Si opener passe un appelable en Python 3.3 et

dans les versions ultérieures, opener(file, flags) obtient un

descripteur de fichier, avec des arguments comme quand on

utilise os.open() (voir la section Module système os).

Consultez aussi la section Fichiers pour l’interface des

objets retournés par open(). Conseil : tout objet prenant

en charge l’interface objet des fichiers peut en général

être utilisé dans des contextes attendant un fichier

(par exemple, socketobj.makefile(), en Python 3.X

io.StringIO(str) et io.BytesIO(bytes), et en Python 2.X

StringIO.stringIO(str), toutes ces fonctions figurant dans la

librairie Python standard).

Note

Comme le mode de fichier implique à la fois des options de

configuration et des types de données string en 3.X, il est utile

de se représenter la fonction open() comme ayant deux modes

bien distincts : le mode texte et le mode binaire.Les développeurs

Python choisissent de surcharger une seule fonction pour prendre

en charge les deux types de fichiers, avec des arguments spécifiant

le mode et des types de contenu différents, au lieu de fournir deux

fonctions open() séparées. La librairie de la classe io (dont open()

est le frontend en 3.X) gère des types de fichiers spécialisés pour

les modes. Consultez la documentation Python pour les détails

concernant le module io. io est aussi disponible en 2.X à partir

de 2.6 comme une alternative au type intégré file, mais il s’agit

de l’interface normale de fichier pour la fonction open() en 3.X.



Fonctions intégrées

151

ord( C)

Retourne un entier correspondant à la valeur du code de la

chaîne C composée d’un caractère. Pour les caractères ASCII,

il s’agit du code ASCII sur 7 bits ; en général, c’est le code

Unicode de la chaîne Unicode C. Consultez également dans

cette liste la fonction inverse chr().

pow( X, Y [, Z])

Retourne X à la puissance Y [modulo Z]. Similaire à l’opérateur

d’expression **.

print(...)

print([ objet [, objet]*]

[, sep=’ ’] [, end=’\n’]

[, file=sys.stdout] [, flush=False])

J’ai présenté cette fonction comme open() car elle a à présent

trop de paramètres pour tenir sur une seule ligne.

Imprime des objet(s) optionnels sur le flux file, séparés

par des sep, suivis par des end, avec un paramètre optionnel

de traitement de post-impression flush. Les quatre derniers

arguments, s’ils sont présents, doivent être fournis sous la forme

d’arguments nommés, et ont des valeurs par défaut indiquées

dans la syntaxe ; flush est disponible à partir de Python 3.3.

Tous les arguments qui ne sont pas des arguments nommés sont

convertis en chaînes en utilisant l’équivalent de str(), et écrits

sur le flux. sep et end doivent être des chaînes ou être égaux à

None (ce qui signifie qu’ils utilisent leur valeur par défaut). Si

aucun objet n’est fourni, end est écrit. file doit être un objet

avec une méthode write(string), mais n’a pas besoin d’être

un véritable fichier ; s’il n’est pas passé ou bien est égal à None,

sys.stdout sera utilisé.

La fonctionnalité de print est disponible sous la forme d’une

instruction en Python 2.X. Voir aussi la section Instruction

print.

property([ fget[, fset[, fdel[, doc]]]])

Retourne un attribut propriété pour les nouvelles classes

(classes qui dérivent de object, notamment toutes les classes

en 3.X). fget est un fonction pour récupérer la valeur d’un

attribut, fset est une fonction pour la définir, et fdel une

fonction pour la supprimer. Cette fonction peut être utilisée

comme décorateur de fonction (@property), et retourne un

objet avec les méthodes getter, setter, et deleter, qui



152

Chapitre 1. Python précis et concis

peuvent aussi être utilisées comme décorateurs dans ce

rôle (voir la section Instruction def). Cette fonction est

implémentée avec des descripteurs (voir la section Méthodes

pour les descripteurs).

range([ début,] fin [, pas])

Retourne des entiers successifs compris entre début et fin.

Avec un seul argument, la fonction retourne des entiers à partir

de 0 jusqu’à fin1. Avec deux arguments, elle retourne des

entiers compris entre début et fin1. Avec trois arguments, elle

retourne des entiers compris entre début et fin1, en ajoutant

la valeur de pas à chaque élément de la suite. Début et pas ont

respectivement une valeur par défaut de 0 et 1.

pas peut être supérieur à 1 pour sauter des éléments (range(0,

20, 2) représente une liste d’entiers pairs compris entre 0

et 18), ou négatif pour compter à rebours à partir de début

(range(5, 5, 1) va de 5 à 4). Cette fonction est souvent

utilisée pour générer des listes d’offsets ou pour répéter des

compteurs dans les boucles for et les autres itérations.

En Python 2.X, cette fonction retourne une liste. En Python

3.X, elle retourne un objet itérable qui génère des valeurs à la

demande et peut être parcouru plusieurs fois (appelez list()

pour forcer la génération des résultats si nécessaire).

repr( objet)

Retourne la représentation d’une chaîne affichable sous la

forme de code d’un objet. La chaîne prend généralement une

forme potentiellement analysable par eval(), ou fournit plus

de détails que str() (dont la description figure dans cette

liste). En Python 2.X seulement, c’est l’équivalent de ‘objet‘

(cette expression avec des guillemets inversés a été supprimée

en Python 3.X). Voir __repr__() dans la section Méthodes de

surchargement d’opérateur.

reversed( seq)

Retourne un itérable inversé. seq doit être un objet qui a une

méthode __reversed__() ou prend en charge le protocole de

séquence (la méthode __len__(), et la méthode __getitem__()

appelée avec des arguments entiers démarrant à partir de 0).

round( X [, N])

Retourne la valeur en virgule flottante de X arrondie à N chiffres

après la virgule. N vaut zéro par défaut, et peut être négatif pour

indiquer le rang des chiffres à gauche de la virgule. La valeur



Fonctions intégrées

153

de retour est un entier si la fonction est appelée avec un seul

argument ; dans le cas contraire, elle est du même type que X.

En Python 2.X uniquement, le résultat est toujours une valeur

en virgule flottante. En Python 3.X uniquement, la fonction

appelle X.__round__().

set([itérable])

Retourne un ensemble dont les éléments sont extraits d’un

itérable. Les éléments doivent être des immutables. Pour

représenter des ensembles d’ensembles, les ensembles imbri-

qués doivent être des objets frozenset. Si l’itérable n’est

pas spécifié, la fonction retourne un nouvel ensemble vide.

La fonction est disponible depuis la version 2.4. Voir aussi la

section Ensembles, et le littérel d’ensemble {...} en Python

3.X et 2.7.

setattr(objet, nom, valeur)

Assigne valeur au nom de l’attribut (une châine) de l’objet.

Similaire à objet.nom = valeur, mais nom est évalué comme

une châine et n’est pas un nom de variable pris littéralement

(par exemple, setattr(a, ’b’, c) est équivalent à a.b = c).

slice([ début ,] fin [, pas])

Retourne un objet slice qui représente une plage, avec des

attributs en lecture seule début, fin, and pas, qui peuvent

prendre la valeur None. Les arguments sont interprétés de

la même manière que pour la fonction range(). Les objets

slice peuvent être utilisés à la place de la notation i:j:k (par

exemple, X[i:j] est équivalent à X[slice(i, j)]).

sorted( itérable, key=None, reverse=False)

Retourne une nouvelle liste triée à partir des éléments d’un

itérable. Les arguments nommés optionnels key et reverse

ont la même signification que ceux de la méthode list.sort()

qui est décrite dans la section Listes ; key est une fonction de

transformation de valeur à un seul argument. Cela fonctionne

sur n’importe quel itérable et retourne un nouvel objet au

lieu de modifier une liste ; c’est utile pour les boucles for

afin d’éviter de décomposer les appels à la fonction de tri

pour séparer les instructions en raison des valeurs de retour

None. Cette fonction est disponible en 2.4 et dans les versions

ultérieures.

En Python 2.X, la signature d’appel est sorted(itérable,

cmp=None, key=None, reverse=False), où les arguments



154

Chapitre 1. Python précis et concis

optionnels cmp, key, et reverse ont la même signification que

dans la méthode Python 2.X list.sort() décrite plus haut

dans la section Listes.

staticmethod( fonction)

Retourne une méthode staique pour fonction. Une méthode

statique ne reçoit pas une instance en tant que premier argu-

ment implicite, et se révèle donc utile pour traiter les attributs

des classes qui couvrent les instances. Utilisez le décorateur de

fonction @staticmethod en 2.4 et dans les versions ultérieures

(voir la section Instruction def). En Python 3.X uniqument,

cette fonction n’est pas nécessaire pour les fonctions simples

des classes appelées uniquement via des objets de classes (et

jamais via des objets d’instances).

str([objet [, encodage [, erreurs]]])

Cette fonction (qui est aussi un nom d’un type pouvant être

sous-classé) opère selon deux modes en Python 3.X qui sont

déterminés par la syntaxe d’appel :

Chaîne d’impression : quand seul le paramètre objet est fourni,

la représentation de haut niveau de la chaîne imprimable de

l’objet est retournée. Pour les chaînes, il s’agit de la chaîne elle-

même. À la différence de repr(X), str(X) ne tente pas toujours

de retourner une chaîne qui soit acceptable par eval() ; son

but est de retourner une chaîne lisible et imprimable. Sans

argument, la fonction retourne une chaîne vide. Voir aussi

__str__() dans la section Méthodes de surchargement d’opérateur,

qui est invoquée par ce mode.

Décodage Unicode : si encodage et/ou erreurs sont passés, la

fonction décode l’objet qui peut être une chaîne d’octets ou

un tampon de caractères, en utilisant le codec du paramètre

encodage. Le paramètre encodage est une chaîne fournissant

le nom de l’encodage Unicode ; si l’encodage est inconnu,

l’exception LookupError est levée. La gestion d’erreurs est

réalisée selon la valeur du paramètre erreurs, qui peut être

égal à ’strict’ (valeur par défaut), pour lever l’exception

ValueError lors d’erreurs d’encodage, à ’ignore’ pour ignorer

en silence les erreurs (ceci peut engendrer une perte de don-

nées) ou à ’replace’ pour remplacer les caractères d’entrée

qui ne peuvent pas être décodés avec le caractère de remplace-

ment officiel Unicode, U+FFFD. Reportez-vous aussi au module

codecs de la librairie standard, ainsi qu’à la méthode similaire



Fonctions intégrées

155

bytes.decode() (par exemple, b’a\xe4’.decode(’latin-1’)

est équivalent à str(b’a\xe4’, ’latin-1’)).

En Python 2.X, cette fonction a une signature plus simple

str([objet]), et retourne une chaîne contenant une représen-

tation imprimable de haut niveau de l’objet (équivalente au

premier mode d’utilisation Python 3.X étudié dans la première

énumération de la liste précédente). Le décodage Unicode

est implémenté en 2.X par des méthodes de chaînes ou la

fonction 2.X unicode(), qui est fondamentalement la même

que la fonction 3.X str() étudiée ici (voir la section suivante).

sum(itérable [, début])

Effectue la somme en partant du début et de tous les éléments

d’un itérable, et retourne le total. La valeur par défaut de

début est 0. Les éléments de l’itérable sont normalement des

nombres et les chaînes ne sont pas autorisées. Conseil : pour

concaténer un itérable de chaînes, utilisez ’’.join(itérable).

super([ type [, objet]])

Retourne la superclasse de type. Si le second argument est

omis, l’objet super retourné n’est pas lié. Si le second argument

est un objet, isinstance(objet, type) doit être vrai. Si le

second argument est un type, issubclass(objet, type) doit

être vrai. Cette fonction marche pour toutes les classes en 3.X,

mais uniquement pour les nouvelles classes en Python 2.X, où

type n’est pas optionnel.

En 3.X seulement, l’appel de super() sans arguments dans

une méthode de classe est implicitement équivalent à

super(class_contenante, argument_méthode_self). Qu’elle

soit implicite ou explicite, cette forme d’appel crée un

objet proxy lié qui apparie l’instance self avec l’accès à

l’emplacement de la classe appelante sur le MRO de la classe

de self. Cet objet proxy est utilisable pour les références

ultérieures des attributs de la superclasse et les appels de

méthodes. Voir aussi la section Nouvelles classes : MRO pour

des informations supplémentaires sur l’ordre MRO.

Comme super() sélectionne toujours une classe suivante sur

le MRO (la première classe suivant la classe appelante ayant

un attribut recherché, qu’elle soit ou non une véritable super-

classe), elle peut être utilisée pour le routage de l’appel de

méthodes. Dans une arborescence de classes à hériage unique,

cet appel peut être utilisé pour faire référence aux superclasses



156

Chapitre 1. Python précis et concis

parentes de manière générique sans les nommer explicitement.

Dans les arborescences à héritage multiple, cet appel peut être

utilisé pour implémenter une répartition coopérative des appels

de méthodes qui proprage les appels dans l’arborescence.

Le dernier mode d’utilisation, la répartition coopérative d’ap-

pels de méthodes, peut être utile dans les graphes en dia-

mant, car une chaîne d’appel de méthodes ne visite chaque

superclasse qu’une seule fois. Cependant, super() peut aussi

produire un comportement implicite qui dans le cas de certains

programmes n’invoque par les superclasses comme il se doit

ou comme on s’y attend. La technique de répartition de la

méthode super() impose en général trois obligations :

• Ancres : la méthode appelée par super() doit exister, ce qui

nécessite du code supplémentaire si aucune ancre de chaîne

d’appel n’est présente.

• Arguments : la méthode appelée par super() doit avoir la même

signature d’arguments dans la totalité de l’arborescence de la

classe, ce qui peut nuite à la flexibilité, particulièrement pour

les méthodes comme les constructeurs.

• Déploiement : chaque apparition de la méthode appelée par

super(), sauf la dernière, doit utiliser super() elle-même, ce qui

peut rendre difficile l’emploi de code existant, le changement

d’ordre des appels, le surchargement des méthodes et le codage

des classes autonomes.

En raison de ces contraines, l’appel de méthodes de super-

classes par le nom explicite d’une superclasse au lieu d’utiliser

super() peut dans certains cas se révéler plus simple, plus

prévisible, voire obligatoire. Pour une superclasse S, la forme

traditionnelle et explicite S.méthode(self) est équivalente

à l’implicite super().méthode(). Voir aussi la section Nouvel

algorithme d’héritage pour en apprendre plus sur le cas spécial

de la recherche d’attribut de super() ; au lieu d’exécuter un

héritage complet, ses objets qui en résultent analysent une

partie dépendante du contexte d’un MRO d’arborescence de

classe, en sélectionnant le premier descripteur ou la première

valeur qui correspond.

tuple([ itérable])

Retourne un nouveau tuple ayant les mêmes éléments que

l’itérable passé en paramètre. Si l’itérable est déjà un tuple,



Fonctions intégrées

157

il est retourné directement (il ne s’agit pas d’une copie) ; cela

est suffisant car les tuples sont des immutables. S’il n’y a pas

d’argument, la fonction retourne un nouveau tuple vide. C’est

aussi un nom de classe d’un type qui peut être sous-classé.

type(objet | (nom, bases, dict))

Cette fonction (qui est aussi un nom de type pouvant être

sous-classé) est utilisée selon deux modes différents qui sont

déterminés par la syntaxe d’appel :

– Avec un seul argument, la fonction retourne un objet

type représentant le type de l’ objet. Ceci est utile pour

tester un type dans les instructions if (par exemple,

type( X)==type([])). Voir aussi le module types dans la

librairie standard pour les objets des types prédéfinis qui ne

sont pas des noms intégrés, et isinstance() plus haut dans

cette section. Dans les nouvelles classes, type( objet) est

généralement identique à objet.__class__. En Python

2.X seulement, le module types inclut également des

synonymes pour la plupart des noms des types intégrés.

– Avec trois arguments, la fonction sert de constructeur, en

retournant un objet d’un nouveau type. Il s’agit d’une forme

dynamique de l’instruction class. La chaîne nom est le

nom de la classe et devient l’attribut __name__ ; le tuple

bases tuple détaille les classes de la base (super) et devient

l’attribut __bases__ ; le dictionnaire dict est l’espace de

noms contenant les définitions des attributs du corps de

la classe et devient l’attribut __dict__. Par exemple, les

deux lignes de code suivantes sont équivalentes :

class X(object): a = 1

X = type(’X’, (object,), dict(a=1))

Ce mapping est employé pour la construction des métaclasses,

dans lesquelles de tels appels de type() sont exécutés automa-

tiquement, et invoquent en général les méthodes __new__()

et/ou __init__() d’une métaclasse avec des arguments de

création de classe des sous-classes de type.

Voir aussi les sections Métaclasses, Décorateurs de classes en

Python 3.X, 2.6 et 2.7, et __new__() dans la section Méthodes

de surchargement d’opérateur.



158

Chapitre 1. Python précis et concis

vars([ objet])

Sans arguments, la fonction retourne un dictionnaire conte-

nant les noms de la portée locale en cours. Avec pour argument

un objet module, classe, ou instance de classe, elle retourne un

dictionnaire correspondant à l’espace de noms des attributs de

l’objet (c’est-à-dire sa méthode __dict__). Le résultat ne doit

pas être modifié. Conseil : cette fonction est utile pour faire

référence à des variables dans la mise en forme de chaînes.

zip([itérable [, itérable]*])

Retourne une série de tuples, où chaque énième tuple contient

le énième élément de chacun des itérables de l’argument. Par

exemple, zip(’ab’, ’cd’) retourne (’a’, ’c’) et (’b’, ’d’).

Au moins un itérable est nécessaire, sinon le résultat est vide.

La série qui en résulte est tronquée à la longueur du plus

petit itérable de l’argument. Avec un argument ne comportant

qu’un seul itérable, la fonction retourne une série de tuples ne

contenant qu’un seul élément. Elle peut aussi être utilisée pour

dézipper des tuples zippés : X, Y = zip(*zip(T1, T2)).

En Python 2.X, la fonction retourne une liste. En Python

3.X, elle retourne un objet itérable qui génère des valeurs à la

demande et qui ne peut être parcouru qu’une seule fois (appelez

list() pour forcer la génération des résultats si nécessaire). En

Python 2.X (mais pas en Python 3.X), quand il y a plusieurs

itérables de la même longueur comme arguments, zip() est

similaire à map() avec un premier argument égal à None.

Fonctions intégrées Python 2.X

La section précédente signale les différences de sémantique entre les

fonctions intégrées qui sont disponibles à la fois en Python 3.X et

2.X. Cette section indique les différences de contenu entre les deux

versions de Python.

Fonctions Python 3.X absentes en Python 2.X

Python 2.X n’a pas en général les fonctions Python 3.X suivantes :

ascii()

Elle est équivalente à la fonction Python 2.X repr().



Fonctions intégrées

159

exec()

Elle est présente en Python 2.X avec une sémantique similaire

sous la forme d’une instruction.

memoryview()

La fonction est disponible en Python 2.7 par souci de compati-

bilité avec 3.X.

print()

Présente dans le module Python 2.X __builtin__, mais la

fonction n’est pas utilisable directement avec la même syntaxe

sans import __future__, car elle est disponible sous la forme

d’une instruction et il s’agit d’un mot réservé en Python 2.X

(voir la section Instruction print).

Fonctions Python 2.X absentes en Python 3.X

Python 2.X comporte les fonctions supplémentaires suivantes, dont

certains sont disponibles sous différentes formes en Python 3.X :

apply( fonction, pargs [, kargs])

Appelle tout objet appelable fonction (fonction, méthode,

classe, etc.), passant les arguments positionneles dans le tuple

pargs, et les arguments nommés dans le dictionnaire kargs.

Elle retourne le résultat de l’appel de la fonction.

En Python 3.X, la fonction a été supprimée. Utilisez à la

place la syntaxe d’appel d’unpacking des arguments : fonc-

tion(*pargs, **kargs). Cette forme étroilée est également

préférée en Python 2.X, parce qu’elle est plus générique et

parce qu’elle est symétrique avec les termes étoilés des défini-

tions des fonctions (voir la section Instruction expression).

basestring()

C’est la classe de base (super) pour les chaînes normales et

Unicode (utile pour les tests isinstance()).

En Python 3.X, le type unique str représente tous les textes

(sur 8 bits et en Unicode).

buffer( objet [, offset [, taille]])

Retourne un nouvel objet buffer pour un objet conforme (voir

le manuel de la librairie Python 2.X).

Cette fonction a été supprimée en Python 3.X. La nouvelle

fonction memoryview(), qui fournit les mêmes services en 3.X,

est aussi disponible en Python 2.7 par souci de compatibilité.



160

Chapitre 1. Python précis et concis

cmp( X, Y)

Retourne un entier négatif, zéro ou un entier positif pour

désigner X < Y, X == Y, ou X > Y, respectivement.

En Python 3.X, la fonction a été supprimée, mais elle peut

être émulée sous la forme : (X > Y) - (X < Y). Cependant, la

plupart des cas courants d’utilisation de cmp() (fonction de

comparaison dans les tris, et la méthode __cmp__() des classes)

ont aussi été supprimés en Python 3.X.

coerce( X, Y)

Retourne un tuple contenant les deux arguments numériques

X et Y convertis en un type commun.

Cette fonction a été supprimée en Python 3.X (elle était

principalement utilisée pour les classes classiques en Python

2.X).

execfile(nom_de_fichier [, global [, local]])

Similaire à eval(), mais exécute tout le code d’un fichier

dont le nom est passé dans le paramètre nom_de_fichier

(au lieu d’une expression). À la différence des imports, cette

fonction ne crée pas un nouvel objet module pour le fichier.

Elle retourne None. Les espaces de noms pour le code dans

nom_de_fichier sont équivalents à ceux de eval().

En Python 3.X, cette fonction peut être émulée par

exec(open(nom_de_fichier).read()).

file(nom_de_fichier [, mode[, taille_buffer]])

Alias de la fonction intégrée open(), et nom de classe du type

intégré de fichier pouvant être sous-classé.

En Python 3.X, le paramètre nom_de_fichier a été supprimé :

utilisez open() pour accéder aux fichiers, et le module de

librairie standard io pour les personnaliser (io qui est utilisé

par open() en 3.X est une option en 2.X à partir de 2.6).

input([prompt]) (forme originale 2.X)

Affiche prompt, s’il est fourni, puis lit la ligne d’entrée à partir

du flux stdin (sys.stdin), et l’évalue en tant que code Python

pour retourner le résultat. En 2.X, la fonction est équivalente

à eval(raw_input(prompt)). Conseil : n’utilisez pas ceci pour

évaluer des chaînes de code qui ne sont pas dignes de confiance

car le code est exécuté.

En Python 3.X, comme raw_input() a été renommé input(),

la fonction originale Python 2.X input() n’est plus disponible,

mais elle peut être émulée par eval(input(prompt)).



Fonctions intégrées

161

intern( string)

Insère string dans la table des « chaînes internées »

et retourne cette chaîne. Les chaînes internées sont

« immortelles » et servent à optimiser les performances (elles

peuvent comparées plus rapidement avec l’identité is plutôt

que par l’égalité ==)

En Python 3.X, cette fonction a été déplacée dans

sys.intern(). Importez le module sys pour l’utiliser et

consultez la section Module sys pour des informations

détaillées.

long( X [, base])

Convertit un nombre ou une chaîne X en un entier long. Le

paramètre base ne peut être passé que si X est une chaîne. S’il

est égal à 0, la base est déterminée par le contenu de la chaîne ;

dans le cas contraire, le paramètre est utilisé comme base de la

conversion. Il s’agit d’un nom de classe d’un type qui peut être

sous-classé.

En Python 3.X, le type entier int prend en charge de manière

arbitraire la précision longue et incorpore par conséquent le

type Python 2.X long. Utilisez int() en Python 3.X.

raw_input([ prompt])

Il s’agit du nom Python 2.X de la fonction Python 3.X input()

décrite dans la section précédente : affiche prompt, et lit et

retourne, mais n’évalue pas la ligne d’entrée.

En Python 3.X, utilisez la fonction intégrée input().

reduce(fonction, itérable [, init])

Applique la fonction à deux arguments aux éléments successifs

d’un itérable, de manière à résuidre la collection à une valeur

unique. Si init est fourni, il est ajouté à l’itérable.

En Python 3.X, cette fonction est toujours disponible sous

la forme functools.reduce(). Importez le module functools

pour l’utiliser.

reload( module)

Recharge, analyse à nouveau puis réexécute un module déjà

importé dans l’espace de noms en cours du module. La réexécu-

tion remplace les premières valeurs des attributs du module.

Le module doit référencer un objet module existant ; il ne

s’agit pas d’un nouveau nom ou d’une chaîne. Ceci est utile

en mode interactif si vous voulez recharger un module après

l’avoir réparé, sans redémarrer Python. La fonction retourne



162

Chapitre 1. Python précis et concis

l’objet module. Voir aussi la table sys.modules, où les modules

importés sont conservés (et peuvent être supprimés pour forcer

les réimports).

En Python 3.X, cette fonction est toujours disponible sous la

forme imp.reload(). Importez le module imp pour l’utiliser.

unichr( I)

Retourne la chaîne Unicode formée d’un seul caractère dont le

code Unicode est l’entier I (par exemple, unichr(97) retourne

la chaîne u’a’). C’est l’inverse de ord() pour les chaînes

Unicode, et la version Unicode de chr(). L’argument doit

appartenir à la plage 0...65 535, sinon une exception ValueEr-

ror est levée.

En Python 3.X, les chaînes normales représentent des carac-

tères Unicode : utilisez à la place la fonction chr() (par

exemple, ord(’\xe4’) renvoie 228, et chr(228) ainsi que

chr(0xe4) renvoient toutes les deux ’ä’).

unicode([ objet [, encodage [, erreurs]]])

Marche de façon similaire à la fonction 3.X str() (voir str()

dans la section précédente pour des informations détaillées).

Avec un seul argument, la fonction retourne une représenta-

tion de haut niveau d’une chaîne de l’objet, mais sous la forme

d’une chaîne 2.X Unicode (pas un type str). Avec plus d’un

argument, la fonction accomplit un décodage Unicode de la

chaîne de l’objet en utilisant le codec pour l’encodage, avec

une gestion d’erreurs accomplie selon le paramètre erreurs. La

gestion d’erreur par défaut applique le mode d’erreur strict, où

toutes les erreurs d’encodage lèvent une exception ValueError.

Voir aussi le module codecs dans le manuel de la librairie

Python pour les fichiers qui prennent en charge les encodages.

En 2.X, les objets peuvent fournir une méthode __unicode__()

qui donne leur chaîne Unicode pour unicode(X).

En Python 3.X, il n’y a pas de type séparé pour Unicode (le

type str représente tous les types de texte, qu’il soit en 8 bits

ou en Unicode), et le type bytes représente les octets des

données binaires en 8 bits. Utilisez les chaînes normales str

pour le texte Unicode, bytes.decode() ou str() pour décoder

les octets bruts en Unicode selon le paramètre d’encodage, et

les objets fichier normaux avec open() pour traiter les fichiers

de texte Unicode.



Fonctions intégrées

163

xrange([ début,] stop [, pas])

Similaire à range(), mais ne stocke pas réellement la liste

complète en une seule fois (au lieu de cela, elle génère un

entier à la fois). Cela est utilie pour les boucles for quand il y

a une grande plage et peu de mémoire. Elle optimise l’espace,

mais ne procure pas en général de gain de rapidité.

En Python 3.X, la fonction originale range() est modifiée pour

retourner un itérable au lieu de produire une liste en mémoire,

ce qui incorpore la fonction Python 2.X xrange(), qui est donc

supprimée.

En outre, la fonction de fichier open() a été radicalement modifiée

en Python 3.X si bien que la mention individuelle de la variante

Python 2.X est ici garantie (en Python 2.X, codecs.open() comporte

de nombreuses fonctionnalités de la fonction Python 3.X open(),

notamment la prise en charge des transformations d’encodage Uni-

code) :

open(nom_de_fichier [, mode, [taille_buffer]])

Retourne un nouvel objet file connecté au fichier externe

nommé nom_de_fichier (une chaîne), ou lève une exception

IOError si l’ouverture du fichier échoue. Le nom du fichier est

relié au répertoire de travail en cours, à moins qu’un préfixe

de chemin ne soit spécifié. Les deux premiers arguments sont

généralement identiques que ceux qui sont employés dans la

fonction fopen() en C, et le fichier est géré par le système

stdio. Avec open(), les données du fichier sont toujours

représentées sous la forme d’une chaîne normale str dans

le script, en contenant les octets du fichier (codecs.open()

interprète le contenu du fichier en tant que texte encodé en

Unicode, représenté sous la forme d’objets unicode.)

Le paramètre mode a pour valeur par défaut ’r’ s’il est omis,

mais il peut être ’r’ pour l’entrée, ’w’ pour la sortie (écrase

d’abord le fichier), ’a’ pour l’ajout et ’rb’, ’wb’, ou ’ab’ pour

les fichiers binaires (pour supprimer les conversions de fin de

ligne en \n). Sur la plupart des systèmes, les modes peuvent

avoir un paramètre + ajouté au mode de mise à jour (par

exemple, ’r+’ pour lire/écrire, et ’w+’ pour lire /écrire, mais

initialise le fichier à vide).

Le paramètre taille_buffer a par défaut une valeur indé-

pendante de l’implémentation, mais il peut valoir 0 s’il n’y





164

Chapitre 1. Python précis et concis

a pas de tampon, 1 pour le tampon par ligne, une valeur

négative pour la valeur par défaut du sysyème, ou bien encore

une valeur spécifique pour préciser la taille du tampon. Les

transferts des données mises en tampon peuvent ne pas être

accomplis immédiatement (utilisez la méthode flush() pour

forcer l’écriture). Voir aussi le module io dans la librairie

standard Python pour des informations sur une alternative à

file en 2.X, et l’ interface normale des fichiers pour open() en

3.X.

EXCEPTIONS INTÉGRÉES

Cette section décrit les exceptions prédéfinies par Python qui peuvent

être levées par Python ou par du code écrit par un développeur au

cours de l’exécution d’un programme. Elle présente principalement

l’état des exceptions intégrées en Python 3.3 (qui a introduit de

nouvelles classes pour les erreurs liées au système qui incorporent les

anciennes classes génériques procurant des informations sur l’état),

mais fournit des détails communs à la plupart des versions de Python.

Reportez-vous aux sous-sections sur Python 3.2 et 2.X à la fin de cette

section pour les différences spécifiques à ces versions.

Depuis Python 1.5, toutes les exceptions intégrées sont des objets

classe (avant la version 1.5, il s’agissait de chaînes). Les exceptions

intégrées sont disponibles dans l’espace de noms de la portée intégrée

(voir la section Espace de noms et règles de portée), et de nombreuses

exceptions intégrées ont des informations d’état associées qui four-

nissent des détails sur les exceptions. Les exceptions définies par

l’utilisateur sont en général dérivées de cet ensemble intégré (voir la

section Instruction raise).

Superclasses : catégories

Les exceptions suivantes ne sont utilisées qu’en tant que superclasses

pour les autres exceptions :

BaseException

Il s’agit de la superclasse racine pour toutes les exceptions

intégrées. Elle n’est pas censée offrir un héritage direct aux

classes définies par l’utilisateur ; utilisez plutôt Exception pour

cela. Si str() est appelée sur une instance de cette classe, la



Exceptions intégrées

165

représentation des arguments du constructeur passés lors de la

création de l’instance est retournée (ou la chaîne vide s’il n’y

avait pas de tels arguments). Ces arguments du constructeur

d’instance sont stockés et accessibles dans l’attribut args de

l’instance sous la forme d’un tuple. Les sous-classes héritent de

ce protocole.

Exception

Il s’agit de la superclasse racine pour toutes les exceptions

intégrées et les exceptions ne faisant pas sortir du système.

C’est une sous-classe directe de BaseException.

Toutes les exceptions définies par l’utilisateur doivent être

dérivées (doivent hériter) de cette classe. Cette dérivation

est obligatoire pour les exceptions définies par l’utilisateur

en Python 3.X ; Python 2.6 et 2.7 nécessitent cela pour les

nouvelles classes, mais autorisent également les classes d’ex-

ceptions autonomes.

Les instructions try qui interceptent cette exception inter-

ceptent toutes les exceptions sauf les événements qui font sortir

du système, car cette classe est la superclasse de toutes les excep-

tions, sauf SystemExit, KeyboardInterrupt et GeneratorExit

(toutes les trois dérivent directement de BaseException).

ArithmeticError

C’est la catégorie des exceptions concernant les erreurs arith-

métiques : la superclasse de OverflowError, ZeroDivisionError

et FloatingPointError, et une sous-classe de Exception.

BufferError

Cette exception est levée quand une opération liée à un

tampon ne peut pas être accomplie. C’est une sous-classe de

Exception.

LookupError

Cette exception traite des erreurs d’indice dans les séquences

et les mappings : c’est la superclasse de IndexError et KeyError,

qui est aussi levée pour certaines erreurs de recherche d’enco-

dage Unicode. C’est une sous-classe de Exception.

OSError (Python 3.3)

Cette exception est levée quand une fonction système

déclenche une erreur liée au système, notamment en cas

d’échec d’une opération d’entrée/sortie ou sur un fichier. À

partir de Python 3.3, cette exception est une classe racine d’un

nouvel ensemble d’exceptions descriptives liées au système



166

Chapitre 1. Python précis et concis

qui sont énumérées dans la section Exceptions spécifiques

OSError, et qui incorporent des exceptions générique avec

des information d’état utilisées en 3.2 et dans les versions

précédentes, décrites dans la section Exceptions intégrées

Python 3.2.

En Python 3.3, OSError est une sous-classe de Exception,

et comprend des attributs d’informations courantes qui

fournissent des détails sur les erreurs système : errno

(code numérique), strerror (message sous la forme d’une

chaîne), winerror (sous Windows), et filename (pour

les exceptions impliquant un chemin de fichier). En

3.3, cette classe, qui incorpore les anciennes exceptions

EnvironmentError,

IOError,

WindowsError,

VMSError,

socket.error, select.error et mmap.error, est un synonyme

de os.error. Consultez rubrique os.error dans la section

Module système os pour des informations détaillées sur ces

attributs supplémetaires.

Exceptions spécifiques

Les classes suivantes sont des exceptions plus spécifiques qui sont

quand même parfois levées. En outre, NameError, RuntimeError,

SyntaxError, ValueError et Warning sont à la fois des exceptions

spécifiques et des superclasses d’autres exceptions intégrées :

AssertionError

Levée quand le test d’une instruction assert est faux.

AttributeError

Levée quand une référence d’attribut ou une assignation

échoue.

EOFError

Levée quand la fin d’un fichier est atteinte par input() (ou

raw_input() en Python 2.X). Les méthodes de lecture des

objets file retournent un objet vide quand la fin du fichier est

atteinte au lieu de lever cette exception.

FloatingPointError

Levée quand une opération en virgule flottante échoue.



Exceptions intégrées

167

GeneratorExit

Levée quand la méthode close() d’un générateur est appelée.

Cette exception est héritée directement de BaseException et

non pas de Exception puisqu’il ne s’agit pas d’une erreur.

ImportError

Levée quand une instruction import ou from n’arrive pas à

trouver un module ou un attribut. À partir de Python 3.3, les

instances, en identifiant le module qui a déclenché l’erreur,

incluent les attributs name et path, qui sont passés en tant

qu’arguments nommés au constructeur.

IndentationError

Levée quand une mauvaise indentation est détectée dans le

code source. Dérivée de SyntaxError.

IndexError

Levée quand des offsets de séquences sont en dehors des limites

(pour une recherche ou une assignation). Les indices des

objets slice sont ajustés automatiquement pour ne pas être en

dehors des limites autorisées ; si un indice n’est pas un entier,

l’exception TypeError est levée.

KeyError

Levée quand des références pointent sur des clés de mappings

qui n’existent pas (lors d’une recherche). L’assignation à une

clé qui n’existe pas crée cette clé.

KeyboardInterrupt

Levée quand l’utilisateur saisit une touche d’interruption (nor-

malement Ctrl+C ou Suppr). Pendant l’exécution, un contrôle

des interruptions est réalisé régulièrement. Cette exception

hérite directement de BaseException pour l’empêcher d’être

accidentellement interceptée par du code qui intercepte Excep-

tion, ce qui évite de quitter l’interpréteur.

MemoryError

Levée quand se produit un épuisement de la mémoire. Cela

provoque l’affichage d’une trace de la pile si un programme

gros consommateur de mémoire en est la cause.

NameError

Levée quand un nom local ou global non qualifié n’est pas

trouvé.

NotImplementedError

Levée quand il est impossible de définir les protocoles atten-

dus. Les méthodes de classes abstraites peuvent lever cette



168

Chapitre 1. Python précis et concis

exception quand elles ont besoin qu’une méthode soit redéfinie.

Cette exception est dérivée de RuntimeError (elle ne doit pas

être confondue avec NotImplemented, qui est un objet spécial

retourné par certaines méthodes surchargeant des opérateurs

quand les types d’opérandes ne sont pas pris en charge ; voir la

section Méthodes de surchargement d’opérateur).

OverflowError

Levée quand le résultat d’une opération arithmétique est

beaucoup trop grand. Cela ne peut pas se produire pour des

entiers car ils prennent en charge la précision arbitraire. Cette

exception est due à des contraintes du langage C sous-jacent,

et au fait que la plupart des opérations en virgule flottante ne

vérifient pas les dépassements de capacité.

ReferenceError

Levée en cas de références faibles : il s’agit d’outils pour conser-

ver les références à des objets qui n’empêchent pas leur recy-

clage (par exemple, les caches). Voir le module weakref dans

la librairie Python standard.

RuntimeError

C’est une exception fourre-tout qui est rarement utilisée.

StopIteration

Levée à la fin de la progression des valeurs dans les objets

itérateur. Levée par la fonction next(I) et les méthodes

I.__next__() (nommées I.next() en Python 2.X).

À partir de Python 3.3, les instances incluent un attribut value

qui reflète un argument positionnel explicite du constructeur,

ou qui est défini automatiquement avec la valeur de retour

fournie dans une instruction return d’une fonction génératrice

qui termine son itération. Sa valeur par défaut, qui est égale

à None, est aussi disponible dans le tuple normal args de

l’exception, et n’est pas utilisée par les itérations automatiques.

Comme les fonctions génératrices ne doivent pas retourner

de valeur avant 3.3 (et génèrent des erreurs de syntaxe si

elles tentent de le faire), l’usage de cette extension n’est pas

compatible avec les versions antérieures à 2.X et 3.X. Voir aussi

la section Instruction yield.

SyntaxError

Levée quand l’analyseur syntaxique rencontre une erreur de

syntaxe. Cela peut se produire durant les opérations d’import,

les appels à eval() et exec(), et lors de la lecture du code



Exceptions intégrées

169

d’un fichier du script principal ou d’une entrée standard. Les

instances de cette classe ont des attributs filename, lineno,

offset et text pour accéder aux détails ; la fonction str() de

l’instance de l’exception ne retourne que le message d’erreur

de base.

SystemError

Levée quand l’interpréteur détecte des erreurs internes qui ne

sont pas suffisamment sérieuses pour arrêter le système, mais

qui doivent quand même être signalées.

SystemExit

Levée lors d’un appel à sys.exit(N). Si cela n’est pas géré,

l’interpréteur Python s’arrête de fonctionner, et aucune trace

de la pile n’est affichée. Si la valeur passée N est un entier, elle

spécifie le code d’état de sortie du système (passé par la fonction

C de sortie) ; si la valeur est omise ou est égale à None, le code

d’état de sortie est égal à 0 (succès) ; si la valeur est d’un autre

type, la valeur de l’objet est affichée et le code d’état de sortie

est égal à 1 (échec). Cette exception est dérivée directement

de BaseException pour l’empêcher d’être accidentellement

interceptée par du code qui intercepte Exception, ce qui évite

de quitter l’interpréteur. Voir aussi sys.exit() dans la section

Module sys.

sys.exit() lève cette exception de telle sorte que les ges-

tionnaires de nettoyage (clauses finally des instructions try)

soient exécutés, et qu’un débogueur puisse exécuter un script

sans perte de contrôle. La fonction os._exit() quitte immédia-

tement quand c’est nécessaire (par exemple, dans le processus

enfant après un appel à fork()). Voit aussi le module atexit

dans la librairie standard pour la spécification de la fonction

de sortie.

TabError

Levée quand on mélange de manière incorrecte les espaces et

les tabulations dans le code source. Dérivée de IndentationEr-

ror.

TypeError

Levée quand une opération ou une fonction est appliquée à un

objet de type inapproprié.

UnboundLocalError

Levée en cas de références à des noms locaux à qui on n’a pas

encore assigné de valeurs. Dérivée de NameError.



170

Chapitre 1. Python précis et concis

UnicodeError

Levée en cas d’encodage lié à Unicode ou d’erreurs de déco-

dage ; il s’agit d’une catégorie de superclasse et d’une sous-classe

de ValueError. Conseil : certains outils Unicode peuvent aussi

lever une exception LookupError.

UnicodeEncodeError,

UnicodeDecodeError,

UnicodeTranslateError

Levée en cas d’erreurs de traitement lié à Unicode ; il s’agit de

sous-classes de UnicodeError.

ValueError

Levée quand une opération intégrée ou une fonction reçoit un

argument qui a un type correct, mais une valeur inappropriée,

et que le problème n’est pas décrit par une exception plus

spécifique, comme IndexError.

ZeroDivisionError

Levée lors d’opérations de division ou de modulo avec la valeur

0 du côté droit de l’opérande.

Exceptions spécifiques OSError

Disponible en Python 3.3 et dans les versions ultérieures, les sous-

classes suivantes de OSError identifient les erreurs sytème, et corres-

pondent aux codes d’erreurs système de EnvironmentError dans les

versions précédentes de Python (voir la section Exceptions intégrées

Python 3.2). Voir aussi la rubrique OSError dans la section Super-

classes : catégories pour les attributs informationnels communs à ses

sous-classes.

BlockingIOError

Levée quand une opération bloque sur un ensemble d’objets

lors d’une opération non bloquante. L’exception possède un

attribut supplémentaire characters_written, qui est le nombre

de caractères écrits dans le flux avant le blocage.

ChildProcessError

Levée quand une opération sur un processus enfant échoue.

ConnectionError

Superclasse pour les exceptions BrokenPipeError, Connectio-

nAbortedError, ConnectionRefusedError et ConnectionRese-

tError qui sont liées à un problème de connexion.



Exceptions intégrées

171

BrokenPipeError

Levée quand on tente d’écrire sur un pipe alors que l’autre

extrémité a été fermée, ou que l’on tente d’écrire sur un socket

qui a été fermé pendant une écriture.

ConnectionAbortedError

Levée quand une tentative de connexion est annulée par le

pair.

ConnectionRefusedError

Levée quand une tentative de connexion est refusée par le pair.

ConnectionResetError

Levée quand une connexion est réinitialisée par le pair.

FileExistsError

Levée quand on tente de créer un fichier ou un répertoire qui

existe déjà.

FileNotFoundError

Levée quand un fichier ou un répertoire qui n’existe pas est

demandé.

InterruptedError

Levée quand un appel système est interrompu par un signal

entrant.

IsADirectoryError

Levée quand une opération de fichier, comme os.remove(), est

demandée sur un répertoire.

NotADirectoryError

Levée

quand

une

opération

de

répertoire,

comme

os.listdir(), est demandée sur un objet qui n’est pas un

répertoire.

PermissionError

Levée quand des opérations sont exécutées sans que l’on ait les

droits d’accès (par exemple, des permissions sur le système de

fichiers).

ProcessLookupError

Levée quand un processus n’existe pas.

TimeoutError

Levée quand une fonction système s’arrête au niveau du sys-

tème.



172

Chapitre 1. Python précis et concis

Exceptions de catégories d’avertissements

Les exceptions suivantes sont utilisées comme catégories d’avertisse-

ment :

Warning

C’est la superclasse de toutes les catégores d’avertissement et

une sous-classe directe de Exception.

UserWarning

Avertissements générés par le code de l’utilisateur.

DeprecationWarning

Avertissements sur les fonctionnalités obsolètes.

PendingDeprecationWarning

Avertissements sur les fonctionnalités qui deviendront obso-

lètes dans le futur.

SyntaxWarning

Avertissements sur la syntaxe douteuse.

RuntimeWarning

Avertissements sur un comportement douteux pendant le

runtime.

FutureWarning

Avertissements sur les constructions dont la sémantique sera

modifiée à l’avenir.

ImportWarning

Avertissements sur les probables erreurs des les imports de

modules.

UnicodeWarning

Avertissements liés à Unicode.

BytesWarning

Avertissements liés aux objets bytes et buffer (memory-view).

ResourceWarning

Ajoutée à partir de Python 3.2, il s’agit de la superclasse pour

les avertissements liés à l’utilisation des ressources.

Avertissements

Les avertissements sont émis quand de futures modifications du

langage sont susceptibles de perturber le code lorsque la prochaine

version de Python sortira. Les avertissements peuvent être configurés

pour afficher des messages, lever des exceptions, ou être ignorés. Le



Exceptions intégrées

173

modèle de gestion des avertissements peut être utilisé pour émettre

des avertissements en appelant la fonction warnings.warn() :

warnings.warn("usage obsolète", DeprecationWarning)

En outre, vous pouvez ajouter des filtres pour désactiver certains

avertissements. Vous pouvez appliquer un motif d’expression régulière

à un message ou à un nom de module pour supprimer les avertisse-

ments ou bien faire varier leur affichage. Par exemple, vous pouvez

supprimer un avertissement sur l’utilisation du module regex obsolète

en appelant :

import warnings

warnings.filterwarnings(action = ’ignore’,

message=’.*regex module*’,

category=DeprecationWarning,

module = ’__main__’)

Cela ajoute un filtre qui assigne seulement les avertissements de

la classe DeprecationWarning déclenchés dans le module __main__,

applique une expression régulière qui ne correspond qu’au message

qui désigne le module regex obsolète, et permet d’ignorer de tels aver-

tissements. Les avertissements peuvent aussi n’être affichés qu’une

seule fois, toutes les fois que le code incriminé est exécuté, ou bien

transformés en exceptions qui provoqueront l’arrêt du programme (à

moins que les exceptions soient interceptées). Voir la documentation

du module warnings dans le manuel Python (version 2.1 et suivantes)

pour des information complémentaires. Voir aussi l’argument -W de la

section Options de la commande Python.

Exceptions intégrées Python 3.2

En Python 3.2 et dans les versions antérieures, il existe des excep-

tions supplémentaires. À partir de Python 3.3, ces dernières ont été

fusionnées dans OSError. Elles ont été conservées en 3.3 par souci de

compatibilité, mais elles seront peut-être supprimées à l’avenir :

EnvironmentError

C’est la catégorie pour les exceptions qui se produisent en

dehors de Python : il s’agit de la superclasse pour IOError et

OSError, et d’un sous-classe de Exception. L’instance levée

comprend les attributs informationnels errno et strerror (et





174

Chapitre 1. Python précis et concis

éventuellement filename pour les exceptions impliquant des

chemins de fichiers), qui sont aussi dans args, et qui fournissent

le code de l’erreur système et les détails du message d’erreur.

IOError

Levée en cas d’échec d’une opération d’entrée/sortie ou liée

à un fichier. Elle est dérivée de EnvironmentError avec des

informations d’état décrites plus haut dans cette liste.

OSError (Python 3.2)

Levée quand des erreurs se produisent dans le module os (avec

l’exception os.error). Elle est dérivée de EnvironmentError

avec des informations d’état décrites plus haut dans cette liste.

VMSError

Levée en cas d’erreurs spécifiques à VMS ; c’est une sous-classe

de OSError.

WindowsError

Levée en cas d’erreurs spécifiques à Windows ; c’est une sous-

classe de OSError.

Exceptions intégrées Python 2.X

L’ensemble des exceptions disponibles, ainsi que la forme de la

hiérarchie de la classe des exceptions, varient légèrement en Python

2.X par rapport à la description 3.X des sections précédentes. Par

exemple, en Python 2.X :

• Exception est la classe racine de niveau le plus élevé (ce n’est

pas BaseException, qui est absente en Python 2.X).

• StandardError est une sous-classe Exception supplémentaire,

qui une classe racine supérieure à toutes les exceptions inté-

grées, sauf SystemExit.

Voir la documentation de la librairie Python 2.X pour des infor-

mations détaillées concernant votre version.

ATTRIBUTS INTÉGRÉS

Certains objets exportent des attributs spéciaux qui sont prédéfinis par

Python. Vous trouverez ci-dessous une liste partielle car de nombreux





Modules de la librairie standard

175

types ont des attributs uniques bien à eux ; consultez les entrées de

ces types spécifiques dans la documentation de la librairie Python :1

X.__dict__

Dictionnaire utilisé pour stocker les attributs modifiables de

l’objet X.

I.__class__

Objet classe à partir de laquelle l’instance I a été générée. En

version 2.2 et dans les versions suivantes, cela s’applique aussi

aux types, et la plupart des objets ont un attribut __class__

(par exemple, [].__class__ == list == type([])).

C.__bases__

Tuple des classes de base de la classe C, qui sont listées dans

l’en-tête de l’instruction class de C.

C.__mro__

Chemin MRO calculé dans l’arborescence de la nouvelle classe

C (voir la section Nouvelles classes : MRO).

X.__name__

Chaîne de caractères du nom de l’objet X ; pour les classes,

c’est le nom dans l’en-tête de l’instruction ; pour les modules,

il s’agit du nom utilisé dans les imports, ou de "__main__" pour

le module au plus haut niveau d’un programme (par exemple,

fichier principal exécuté pour lancer un programme).

MODULES DE LA LIBRAIRIE STANDARD

Les modules de la librairie standard sont toujours disponibles, mais ils

doivent être importés pour être utilisés dans les modules clients. Pour

y accéder, utilisez l’une des syntaxes suivantes :

• import

module,

et récupérez les noms des attributs

(module.name)

1. À partir de Python 2.1, vous pouvez aussi lier arbitrairement des attributs

définis par l’utilisateur à des objets function, en leur assignant simplement des

valeurs ; voir la section Valeurs par défaut et attributs de fonctions. Python

2.X prend également en charge les attributs spéciaux I.__methods__ et

I.__members__ qui listent les méthodes et les noms des membres des

instances de certains types intégrés. Ils ont été supprimés en Python 3.X

et vous devez utiliser à la place la fonction dir().





176

Chapitre 1. Python précis et concis

• from module import nom, et utilisez les noms des module qui ne

sont pas qualifiés (nom)

• from module import *, et utilisez les noms des module qui ne

sont pas qualifiés (nom)

Par exemple, pour utiliser le nom argv du module sys, employez

import sys puis le nom sys.argv ou bien from sys import argv et

le nom argv. La première forme complète (module.nom) est utilisée

ici dans les en-têtes de listes de contenus uniquement pour fournir le

contexte dans les listings comportant plusieurs pages ; les descriptions

se contentent souvent d’utiliser simplement nom.

Il y a des centaines de modules dans la librairie standard, qui

sont tous susceptibles de changer au gré des évolutions du langage.

En conséquence, les sections suivantes ne sont pas exhaustives, et ne

documentent en général que les noms les plus courants utilisés dans

les modules les plus courants. Reportez-vous à la documentation de

la librairie Python pour des références plus complètes sur les modules

de la librairie standard.

Dans toutes les sections suivantes sur les modules :

• Les noms des exports listés suivis par des parenthèses sont des

fonctions qui doivent être appelées ; les autres ne sont que de

simples attributs (c’est-à-dire des noms de variables dans des

modules qui sont récupérés, mais pas appelés).

• Le contenu des modules documente l’état des modules en

Python 3.X, mais cela s’applique en général à la fois à 3.X et

2.X, sauf quand des exceptions sont mentionnées ; consultez

le manuel Python pour des informations détaillées sur les

différences entre les versions spécifiques.

MODULE SYS

Le module sys contient des outils liés à l’interpréteur : ces outils

concernent l’interpréteur ou son processus à la fois en Python 3.X et

2.X. Il donne aussi accès à certains composants de l’environnement,

comme la ligne de commande, les flux standards, et ainsi de suite.

Consultez aussi la rubrique os dans la section Module système os pour

des outils supplémentaires sur les processus :



Module sys

177

sys.argv

Liste des chaînes des arguments de la ligne de commande :

[nom_de_script, arguments...]. Similaire au tableau argv

en langage C. argv[0] peut représenter l’une des valeurs

suivantes : le nom du fichier de script (avec éventuellement

son chemin complet), la chaîne ’-c’ de l’option de la ligne

de commande -c, un nom de chemin de module de l’option

-m, un caractère ’-’ de l’option – ou une chaîne vide si aucun

nom de script ou d’option de commande n’a été passé. Voir

aussi la section Spécifications du programme à exécuter en ligne de

commande.

sys.byteorder

Indique l’ordre natif des octets (par exemple, ’big’ pour big-

endian, ’little’ pour little-endian).

sys.builtin_noms_modules

Tuple des noms des chaînes des modules C compilés dans

l’interpréteur Python.

sys.copyright

Chaîne contenant le copyright de l’interpréteur Python.

sys.displayhook( valeur)

Appelée par Python pour afficher les valeurs du résultat dans les

sessions interactives ; assigne sys.displayhook à une fonction

à seule argument pour personnaliser la sortie.

sys.dont_write_bytecode

Quand cela est vrai, Python ne va pas tenter d’écrire des

fichiers .pyc ou .pyo sur l’import des modules source (voir aussi

l’option -B de la ligne de commande dans la section Utilisation

de la ligne de commande Python pour les sélections au lancement

du programme).

sys.excepthook( type, valeur, traceback)

Appelée par Python pour afficher sur stderr les détails

des exceptions qui ne sont pas interceptées ; assigne

sys.excepthook à une fonction à trois arguments pour

personnabliser l’affichage des exceptions.

sys.exc_info()

Retourne un tuple de trois valeurs décrivant l’exception en

cours qui est gérée : (type, valeur, traceback), où type est

la classe de l’exception, valeur est l’instance de la classe de

l’exception qui est levée, et traceback un objet qui donne

accès à la pile d’appels du runtime telle qu’elle existait quand



178

Chapitre 1. Python précis et concis

l’exception s’est produite. Ceci est spécifique au thread en cours

et incorpore exc_type, exc_value et exc_traceback en Python

1.5 et dans les versions suivantes (ces trois variables étaient

présentes dans les versions antérieures de Python 2.X, mais ont

été totalement supprimées en Python 3.X). Reportez-vous au

module traceback dans le manuel de librairie Python pour le

traitemetn des objets traceback, et à la section Instruction try

pour en savoir plus sur les exceptions.

sys.exec_prefix

Fournit une chaîne indiquant le préfixe du répertoire

spécifique au site où les fichiers Python qui dépendent de la

plateforme ont été installés ; la valeur par défaut est

/usr/local ou un argument passé à la compilation. Elle est

utilisée pour localiser les modules partagés de la librairie (dans

<exec_prefix>/lib/python<version>/lib-dynload) et les

fichiers de configuration.

sys.executable

Chaîne donnant le nom du chemin complet de l’interpréteur

Python exécutant le programme appelant.

sys.exit([ N])

Sort d’un processus Python avec l’état N (par défaut égal à 0)

en levant une exception intégrée SystemExit (qui peut être

interceptée par une instruction try et ignorée si nécessaire).

Voir aussi SystemExit (dans la section Exceptions intégrées) pour

les détails de l’utilisation et la fonction os._exit() (dans la

section Module système os) pour l’outil qui sort immédiatement

sans traitement de l’exception (ce qui est utile dans les pro-

cessus enfants après un os.fork()). Consultez aussi le module

atexit dans la librairie standard Python pour la spécification

de la fonction générale de sortie.

sys.flags

Valeurs des options de la ligne de commande Python (un

attribut par option ; voir le manuel Python).

sys.float_info

Détails de l’implémentation Python des nombres en virgule

flottante via les attributs (voir le manuel Python).

sys.getcheckinterval()

En Python 3.1 et dans les versions antérieures, retourne l’inter-

valle de contrôle de l’interpréteur (voir setcheckinterval()



Module sys

179

plus loin dans cette liste). A été remplacée en Python 3.2 et

dans les versions ultérieures par getswitchinterval().

sys.getdefaultencoding()

Retourne le nom de l’encodage par défaut en cours qui est

utilisé par l’implémentation d’Unicode.

sys.getfilesystemencoding()

Retourne le nom de l’encodage utilisé pour convertir les noms

de fichiers Unicode en noms de fichiers système, ou None si

l’encodage par défaut du système est utilisé.

sys._getframe([ profondeur])

Retourne un objet frame de la pile d’appels Python (voir le

manuel de la librairie Python).

sys.getrefcount( objet)

Retourne la valeur du comoteur de la référence en cours de

l’objet (+1 pour l’argument de l’appel).

sys.getrecursionlimit()

Retourne la limite de profondeur maximum de la pile d’appels

Python ; voir aussi setrecursionlimit(), plus loin dans cette

liste.

sys.getsizeof( objet [, valeur_par_défaut])

Retourne la taille d’un objet en octets. Cet objet peut avoir

n’importe quel type. Tous les objets intégrés retournent

des résultats corrects, mais les résultats des extensions

tierces sont spécifiques à l’implémentation. Le paramère

valeur_par_défaut fournit une valeur qui sera retournée si le

type de l’objet n’implémente pas l’interface de recherche de la

taille.

sys.getswitchinterval()

En Python 3.2 et dans les versions ultérieures, retourne le

paramètre d’intervalle de commutation du thread en cours par

l’interpréteur (voir setswitchinterval() plus loin dans cette

liste). En Python 3.1 et dans les versions suivantes, utilisez

getcheckinterval().

sys.getwindowsversion()

Retourne un objet décrivant la version de Windows en cours

d’exécution (voir le manuel Python).

sys.hexversion

Numéro de version de Python, encodé sous la forme d’un

entier (il est sans doute préférable d’utiliser la fonction intégrée

hex()). Ce numéro est augmenté à chaque nouvelle version.



180

Chapitre 1. Python précis et concis

sys.implementation

Disponible à partir de Python 3.3, c’est un objet qui donne des

informations sur l’implémentation de l’interpréteur Python en

cours d’exécution (nom, version, etc.). Voir le manuel Python.

sys.int_info

Détails de l’implémentation Python des nombres entiers via

des attributs (voir le manuel Python).

sys.intern( string)

Entre string dans la table des chaînes « internées » et retourne

cette chaîne ou une copie. Ces chaînes internées améliorent

un peu la recherche dans les dictionnaires : si les clés d’un dic-

tionnaire et la clé de recherche sont internées, la comparaison

des clés (après le hachage) peut être effectuée en comparant

des pointeurs au lieu de chaînes. Normalement, les noms

utilisés dans les programmes Python sont automatiquement

internés, et les dictionnaires utilisés pour stocker les attributs

des modules, des classes et des instances ont des clés internées.

sys.last_type, sys.last_value, sys.last_traceback

Objets type, valeur et traceback de la dernière exception qui

n’a pas été interceptée (ceci est surtout utilisé pour le débogage

après un plantage).

sys.maxsize

Entier fournissant la valeur maximale d’une variable de type

Py_ssize_t. En général cette valeur est égale à 2**31

1 sur

les plateformes 32 bits et 2**63 1 sur les plateformes 64 bits.

sys.maxunicode

Entier fournissant le code maximal d’un caractère Unicode.

En Python 3.3 et dans les versions suivantes, c’est toujours

1114111 (0x10FFFF en hexadécimal) en raison du système de

stockage des chaînes de taille variable en 3.3. Avant la version

3.3, la valeur dépend de l’option de configuration qui spécifie

si les caractères Unicode sont stockés en tant que UCS-2 ou

UCS-4, soit 0xFFFF ou 0x10FFFF.

sys.modules

Dictionnaire des modules qui sont déjà chargés ; il y a une

entrée nom:objet par module. Conseil : ce dictionnaire peut

être modifié pour avoir une incidence sur les futurs imports

(par exemple, del sys.modules[’nom’] force un module à se

recharger lors du prochain import).



Module sys

181

sys.path

Liste des chaînes spécifiant le chemin de recherche de

l’import des modules. Initialisée à partir de la variable du shell

PYTHONPATH, de tout fichier de chemins .pth, et de toute

valeur par défaut dépendante de l’installation. Conseil : cet

attribut et sa liste peuvent être tous les deux modifiés pour

avoir une incidence sur les futurs imports (par exemple,

sys.path.append(’C:\\dir’) ajoute de manière dynamique

un répertoire au chemin de recherche des modules).

Le premier élément, path[0], est le dictionnaire contenant

le script qui a été utilisé pour invoquer l’interpréteur Python.

Si le répertoire du script n’est pas disponible (par exemple, si

l’interpréteur est invoqué de façon interactive ou si le script

est lu à partir de l’entrée standard), path[0] est une chaîne

vide qui indique à Python de rechercher d’abord les modules

dans le répertoire de travail en cours. Le répertoire du script est

inséré avant les entrées insérées à partir de PYTHONPATH. Voir

aussi la section Instruction import.

sys.platform

Chaîne identifiant le système sur lequel Python s’exécute :

’win32’, ’darwin’, ’linux2’, ’cygwin’, ’os2’, ’freebsd8’,

’sunos5’, ’PalmOS3’, etc. Ceci est utile pour les tests sur du

code spécifique à une plateforme.

La valeur ’win32’ est valable pour toutes les versions de

Windows, mais on teste en général sys.platform[:3]==’win’

ou sys.platform.startswith(’win’). À partir de Python

3.3, toutes les plateformes Linux sont égales à ’linux’,

mais les scripts doivent de la même manière tester avec

str.startswith(’linux’) car autrefois on utilisait ’linux2’

ou ’linux3’.

sys.prefix

Fournit une chaîne donnant le préfixe du répertoire

spécifique au site, où les fichiers Python spécifiques à

la plateforme sont installés ; la valeur par défaut est

/usr/local ou un argument passé pendant la compilation.

Les modules de la librairie Python sont installés dans le

répertoire <prefix>/lib/python<version> ; les fichiers des

en-têtes indépendants de la plateforme sont stockés dans

<prefix>/include/python<version>.



182

Chapitre 1. Python précis et concis

sys.ps1

Chaîne spécifiant le prompt principal en mode interactif ; la

valeur par défaut est >>> à moins que l’on ait assigné une autre

valeur.

sys.ps2

Chaîne spécifiant le prompt secondaire en mode interactif

pour la continuation des instructions composées ; la valeur par

défaut est ... à moins que l’on ait assigné une autre valeur.

sys.setcheckinterval( reps)

Remplacée en Python 3.2 et dans les versions suivantes par

setswitchinterval() (étudiée dans cette liste). En 3.2 et les

versions ultérieures, cette fonction est toujours présente, mais

n’a pas d’effet, car l’implémentation de la commutation des

threads et des tâches asynchrones a été réécrite.

En Python 3.1 et dans les versions antérieures, la fonction est

appelée pour définir la périodicité du contrôle des tâches par

l’interpréteur (par exemple, commutation des threads, gestion-

naires de signaux) dans reps, qui est mesurée en instructions

de machine virtuelle (la valeur par défaut est 100). En général,

une instruction Python est traduite en plusieurs instructions

de machine virtuelle. Les valeurs inférieures favorisent le

caractère réactif des threads, mais accroissent la surcharge due

à la commutation des threads.

sys.setdefaultencoding( nom)

Supprimée à partir de Python 3.2. Cette fonction sert à définir

l’encodage en cours par défaut utilisé par l’implémentation

Unicode dans nom. Conçue pour être utilisée par le module

site , elle n’est disponible que pendant le démarrage.

sys.setprofile( fonction)

Cette fonction sert à définir la fonction de profil du système à

fonction. Reportez-vous au manuel de la librairie de référence

de Python pour les détails.

sys.setrecursionlimit( profondeur)

Cette fonction sert à définir la profondeur maximum de la

pile d’appels Python à profondeur. Cette limite empêche la

récursivité infinie de provoquer un débordement de la pile C et

de planter Python. La valeur par défaut est 1 000 sous Windows,

mais cela peut varier. Des valeurs supérieures peuvent être

nécessaires pour des fonctions hautement récursives.



Module sys

183

sys.setswitchinterval( intervalle)

En Python 3.2 et dans les versions ultérieures, définit l’inter-

valle de commutation des threads de l’interpréteur à inter-

valle, qui est exprimé en secondes. Il s’agit d’une valeur

en virgule flottante (par exemple, 0.005 correspond à 5 mil-

lisecondes) qui détermine la durée idéale des tranches de

temps allouées aux threads Python s’exécutant en même temps.

La valeur réelle peut être supérieure, particulièrement si des

fonctions internes ou des méthodes qui durent longtemps sont

utilisées, et que le choix de l’ordonnancement des threads à

la fin de l’intervalle est réalisé par le système d’exploitation

(l’interpréteur Python n’a pas son propre ordonnanceur).

En Python 3.1 et dans les versions antérieures, utilisez setche-

ckinterval() à la place (étudiée dans cette liste).

sys.settrace( fonction)

Cette fonction sert à définir la fonction de trace du système

à fonction. Il s’agit de l’emplacement du programme ou de

la fonction callback de modification d’état utilisés par les

débogueurs, etc. Reportez-vous au manuel de la librairie de

référence de Python pour les détails.

sys.stdin

Objet fichier pré-ouvert, connecté initialement au flux d’entrée

standard, stdin. Peut être assigné à n’importe quel objet avec

des méthodes read pour réinitialiser l’entrée au sein d’un

script (par exemple, sys.stdin = MyObj()). Ceci est utilisé

pour l’entrée de l’interpréteur, notamment la fonction intégrée

input() (et raw_input() en Python 2.X).

sys.stdout

Objet fichier pré-ouvert, connecté initialement au flux de

sortie standard, stdout. Peut être assigné à n’importe quel objet

avec des méthodes write pour réinitialiser la sortie au sein d’un

script (par exemple, sys.stdout=open(’log’, ’a’)). Ceci est

utilisé pour certains prompts et la fonction intégrée print() (et

l’instruction print en Python 2.X). Utilisez PYTHONIOENCODING

pour contourner l’encodage dépendant de la plateforme si

nécessaire (voir la section Variables d’environnement Python), et

l’option -u pour les flux sans tampon (voir la section Options

de la commande Python).



184

Chapitre 1. Python précis et concis

sys.stderr

Objet fichier pré-ouvert, connecté initialement au flux d’erreur

standard, stderr. Peut être assigné à n’importe quel objet avec

des méthodes write pour réinitialiser stderr au sein d’un script

(par exemple, sys.stderr=wrappedsocket). Utilisé pour des

erreurs dans les prompts de l’interpréteur.

sys.__stdin__, sys.__stdout__, sys.__stderr__

Valeurs originales de stdin, stderr et stdout au démarrage

du programme (par exemple, pour restaurer ces valeurs en

dernier recours ; normalement, quand on assigne des valeurs à

sys.stdout, etc., on sauvegarde les anciennes valeurs pour les

restaurer dans une clause finally). Note : ces valeurs peuvent

être égales à None pour les applications en mode graphique sous

Windows sans console.

sys.thread_info

Détails de l’implémentation des threads Python via les attri-

buts ; nouveau en Python 3.3 (voir le manuel Python).

sys.tracebacklimit

Nombre maximum de niveaux de traceback à afficher pour les

exceptions qui ne sont pas interceptées ; la valeur par défaut

est 1 000 à moins d’avoir assigné une autre valeur.

sys.sys.version

Chaîne contenant le numéro de version de l’interpréteur

Python.

sys.version_info

Tuple contenant cinq éléments permettant d’identifier la ver-

sion de Python : majeur, mineur, micro, niveau de release,

et numéro de série. Pour Python 3.0.1, le tuple suivant est

retourné : (3, 0, 1, ’final’, 0). Dans les versions récentes,

il s’agit d’un tuple nommé dont on peut accéder aux élé-

ments par leur numéro ou bien par des noms d’attributs ;

pour Python 3.3.0, cela affiche sys.version_info(major=3,

minor=3, micro=0, releaselevel=’final’, serial=0). Voir

la documentation de la librairie Python pour de plus amples

détails.

sys.winver

Numéro de version utilisé pour former les clés de registre sur les

plateformes Windows (disponible uniquement sous Windows ;

voir la documentation de la librairie Python).





Module string

185

MODULE STRING

Le module string définit des constantes et des variables pour le

traitements des objets string. Voir aussi la section Chaînes pour des

détails sur les outils de substitution et de mise en forme des chaînes,

Template et Formatter, qui sont définis dans ce module.

Fonctions et classes

À partir de Python 2.0, la plupart des fonctions de ce module sont

aussi disponibles sous la forme de méthodes d’objets string ; les appels

qui sont basés sur des méthodes sont d’ailleurs plus efficaces et préférés

en 2.X, pour ne devenir que la seule option retenue en 3.X. Voir la

section Chaînes pour les détails et la liste de toutes les méthodes de

chaînes disponibles qui ne sont pas répétées ici. Seuls les éléments

que l’on ne trouve que dans le module string sont listés dans cette

section :

string.capwords( s, sep=None)

Sépare l’argument s en mots en utilisant s.split(), met en

majuscule l’initiale de chaque mot avec s.capitalize(), et

recombine ces mots avec s.join(). Si l’argument optionnel

sep est absent ou est égal à None, les groupes d’espaces sont rem-

placés par un seul space, et les espaces encadrant la chaîne sont

supprimés ; sinon, sep est utilisé pour séparer et recombiner les

mots.

string.maketrans( depuis, vers)

Retourne une table de traduction qui est passée à

bytes.translate() et qui fait correspondre chaque caractère

du paramètre depuis au caractère à la même position du

paramètre vers ; depuis et vers doivent avoir la même

longueur.

string.Formatter

Classe qui autorise la création de mises en forme personnalisées

en utilisant le même mécanisme que la méthode str.format(),

qui est décrite dans la section Méthode de mise en forme de

chaînes.

string.Template

Classe de substitution de modèles de chaînes, qui est décrite

dans la section Modèles de substitutions de chaînes.





186

Chapitre 1. Python précis et concis

Constantes

string.ascii_letters

La chaîne ascii_lowercase + ascii_uppercase.

string.ascii_lowercase

La chaîne ’abcdefghijklmnopqrstuvwxyz’ ; elle ne dépend pas

des paramètres régionaux et ne sera pas modifiée.

string.ascii_uppercase

La chaîne ’ABCDEFGHIJKLMNOPQRSTUVWXYZ’ ; elle ne dépend pas

des paramètres régionaux et ne sera pas modifiée.

string.digits

La chaîne ’0123456789’.

string.hexdigits

La chaîne ’0123456789abcdefABCDEF’.

string.octdigits

La chaîne ’01234567’.

string.printable

Combinaison de constantes digits, ascii_letters, punctuation

et whitespace.

string.punctuation

Chaîne des caractères qui sont considérés comme des signes de

ponctuation dans les paramètres régionaux.

string.whitespace

Chaîne contenant l’espace, la tabulation, le saut de ligne, le

retour de chariot, la tabulation verticale et le saut de page : ’

\t\n\r\v\f’.

MODULE SYSTÈME OS

Le module os est l’interface principale des services du système d’ex-

ploitation ( operating system abrégé en OS) à la fois en Python 3.X et

2.X. Il fournit une prise en charge générique de l’OS et un ensemble

d’outils standards qui sont indépendants de la platforme utilisée. Le

module os comprend des outils pour l’environnement, les processus,

les fichiers, les commandes du shell, et bien d’autres choses encore.

Il inclut aussi un sous-module imbriqué, os.path, qui fournit une

interface portable pour des utilitaires de traitement des répertoires.

Les scripts qui utilisent les modules os et os.path pour la program-

mation système sont en général portables sur la plupart des plateformes



Module système os

187

Python. Cependant, certains exports os ne sont pas disponibles sur

toutes les plateformes (par exemple, os.fork() est disponible sur

Unix et Cygwin, mais pas dans la version Windows standard de

Python). Comme la portabilité de telles fonctions peut changer dans

le temps, consultez la documentation de la librairie Python pour les

détails concernant chaque plateforme.

Les sections suivantes mettent en évidence les outils courramment

employés dans ce module. Il s’agit cependant d’une lsite partielle : consul-

tez le manuel de la librairie Python standard pour des informations

détaillées sur les très nombreux outils (plus de 200) de ce module sur

certaines plateformes, ainsi que les différences entre les plateformes

qui sont passées sous silence dans cette section. Les sous-sections

présentées ici reflètent les différents ensembles fonctionnels de ce

grand module :

• Outils d’administration : exports liés aux modules

• Constantes de portabilité : constantes de répertoires et de chemin

de recherche

• Commandes du shell : exécution des lignes de commande et des

fichiers

• Utilitaires d’environnement : environnement d’exécution et

contexte

• Outils de descripteurs de fichiers : traitement des fichiers grâce à

leurs descripteurs

• Utilitaires de noms de chemins de fichiers : traitement des fichiers

grâce à leurs noms de chemins

• Contrôle des processus : création et gestion des processus

• Module os.path : services liés aux noms de chemins des réper-

toires

Consultez également ces modules liés au système de la librairie

Python standard, qui sont étudiés dans les manuels Python : sys

(outils des processus de l’interpréteur ; voir la section Module sys), sub-

process (contrôle des commandes ; voir la section Module subprocess),

threading et queue (outils de multithreading ; voir la section Modules

de gestion du threading), socket (mise en réseau et IPC ; voir la section

Outils et modules Internet), glob (développement des noms de fichiers ;

par exemple, glob.glob(’*.py’)), tempfile (fichiers temporaires),

signal (gestion des signaux), multiprocessing (API de threading



188

Chapitre 1. Python précis et concis

pour les processus), getopt, optparse, et, en 3.2 et dans les versions

suivantes, argparse (traitement de ligne de commande).

Outils d’administration

Vous trouverez ci-dessous certains exports liés aux modules :

os.error

Alias pour l’exception intégrée OSError : voir la section Excep-

tions intégrées. Levée pour toutes les erreurs liées au module

os. Cette exception a deux attributs : errno, le code d’erreur

numérique POSIX (par exemple, la valeur de la variable C

errno ) et strerror, le message d’erreur correspondant qui est

fourni par le système d’exploitation et qui est mis en forme

par les fonctions C sous-jacentes (par exemple, par perror() et

os.strerror()). Pour les exceptions qui impliquent un nom de

chemin (par exemple, chdir(), unlink()), l’instance d’excep-

tion contient aussi l’attribut filename, qui est le nom de fichier

qui est passé. Voir le module errno dans la documentation de

la librairie Python pour les noms des codes d’erreurs définis par

l’OS sous-jacent.

os.name

Nom des modules spécifiques à l’OS dont les noms sont copiés

au sommet du module os (par exemple, posix, nt, mac, os2, ce,

ou java). Voir aussi sys.platform dans la section Module sys.

os.path

Module imbriqué pour les outils portables liés aux noms des

chemins. Par exemple, os.path.split() est un outil de noms

de répertoires indépendant des plateformes qui accomplit

l’action appropriée en fonction de l’OS.

Constantes de portabilité

Cette section décrit les outils de portabilité de fichiers, pour les réper-

toires et les chemins de recherche, les sauts de ligne, etc. Ces

constantes, qui sont définies automatiquement avec la valeur appro-

priée correspondant à la plateforme sur laquelle un script s’exécute,

sont utiles à la fois pour l’analyse et la création des chaînes dépen-

dantes des plateformes. Voir aussi la section Module os.path :



Module système os

189

os.curdir

Chaîne utilisée pour représenter le répertoire en cours (par

exemple, . pour Windows et POSIX, : pour Macintosh).

os.pardir

Chaîne utilisée pour représenter le répertoire parent (par

exemple, .. pour POSIX, :: pour Macintosh).

os.sep

Chaîne utilisée pour séparer les répertoires (par exemple, /

pour Unix, \ pour Windows, ou : pour Macintosh).

os.altsep

Chaîne de séparateur alternatif ou None (par exemple, / pour

Windows).

os.extsep

Caractère qui sépare le nom du fichier de son extension (par

exemple, .).

os.pathsep

Caractère utilisé pour séparer les composants du chemin de

recherche, comme dans les variables du shell PATH et PYTHON-

PATH (par exemple, ; pour Windows, : pour Unix).

os.defpath

Chemin de recherche par défaut utilisé par les appels

os.exec*p* s’il n’y a pas de paramètre PATH dans le shell.

os.linesep

Chaîne utilisée pour terminer les lignes sur la plateforme en

cours (par exemple, \n pour POSIX, \r pour Mac OS, et

\r\n pour Windows). Ceci n’est pas obligatoire pour l’écriture

des lignes des fichiers en mode texte (utilisez la traduction

automatique de ’\n’ des objets file ; voir open() dans la section

Fonctions intégrées).

os.devnull

Chemin du fichier du device « null » (pour le texte à ignorer).

Il s’agit de ’/dev/null’ pour POSIX, et ’nul’ pour Windows

(présent aussi dans le sous-module os.path).

Commandes du shell

Ces fonctions exécutent des lignes de commandes ou des fichiers dans le

système d’exploitation sous-jacent. En Python 2.X, ce module a des

fonctions os.popen2/3/4 qui ont été remplacées en Python 3.X par

subprocess.Popen, un outil offrant généralement un contrôle plus



190

Chapitre 1. Python précis et concis

précis des commandes (voir la section Module subprocess). Conseil :

n’utilisez pas ces outils pour lancer des chaînes de commandes shell

dans lesquelles vous n’avez pas confiance, car elles peuvent exécuter

des commandes autorisées par le processus Python :

os.system( cmd)

Exécute une chaîne de ligne de commandes shell cmd dans un

processus de sous-shell. Retourne l’état de sortie du processus

engendré. À la différence de popen(), cela ne connecte pas

aux flux standards de cmd via des pipes. Conseil : ajouter

un caractère & à la fin de cmd pour exécuter la commande

en arrière-plan sous Unix (par exemple, os.system(’python

main.py &’)) ; utilisez une commande Windows (DOS) start

pour lancer les programmes facilement sous Windows (par

exemple, os.system(’start file.html’)).

os.startfile( nom_de_chemin_de_fichier)

Ouvre un fichier avec l’application qui lui est associée. Agit

comme si on avait fait un double-clic sur le fichier dans

l’Explorateur Windows ou comme si on avait fourni le nom de

fichier comme argument à la commande Windows start (par

exemple, os.system(’start path’)). Le fichier est ouvert dans

l’application qui associée à son extension ; l’appel n’attend pas

et en général n’affiche pas de fenêtre de console Windows (que

l’on appelle aussi prompt). Cette fonction n’est valable que sous

Windows et a été ajouté dans la version 2.0.

os.popen( cmd, mode=’r’, buffering=None)

Ouvre un pipe vers ou depuis la chaîne de ligne de commande

shell cmd, pour envoyer ou capturer des données. Retourne

un objet file ouvert, qui peut être utilisé pour lire à partir

du flux de sortie standard stdout (mode ’r’ est la valeur par

défaut) de cmd ou pour écrire sur le flux d’entrée standard stdin

(mode ’w’) de cmd. Par exemple, dirlist = os.popen(’ls l

*.py’).read() lit la sortie d’une commande Unix ls.

cmd représente n’importe quelle chaîne de commandes que

vous pouvez saisir dans la console système ou le prompt du shell.

mode peut avoir la valeur ’r’ ou ’w’ et sa valeur par défaut est

’r’. buffering représente la même chose que dans la fonction

intégrée open(). cmd s’exécute de manière indépendant ; son

état de sortie est retourné par la méthode close() de l’objet

fichier qui en résulte, sauf si l’état de sortie est égal à 0 (pas



Module système os

191

d’erreur), auquel cas None est retourné. Utilisez readline() ou

les itérations de l’objet file pour lire la sortie ligne à ligne (et

éventuellement les opérations d’insertion plus complètement).

Python 2.X a aussi les variantes popen2(), popen3() et popen4()

pour se connecter à d’autres flux de commandes (par exemple,

popen2() retourne un tuple (child_stdin, child_stdout)). En

Python 3.X, ces fonctions sont supprimées ; utilisez à la place

subprocess.Popen(). Le module subprocess de la version 2.4

et des versions ultérieures permet aux scripts d’engendrer de

nouveaux processus, de se connecter à leur flux, et d’obtenir

leurs codes de retour (voir la section Module subprocess).

os.spawn*( args...)

Famille de fonctions pour engendrer des programmes et des

commandes. Voir la section Contrôle des processus plus loin,

ainsi que la documentation de la librairie Python pour les

détails. Le module subprocess est une alternative à ces fonc-

tions (voir la section Module subprocess).

Utilitaires d’environnement

Ces attributs exportent le contexte d’exécution : environnement du

shell, répertoire en cours, et ainsi de suite :

os.environ

C’est un objet comparable à un dictionnaire qui est la variable

d’environnement du shell. os.environ[’USER’] est la valeur

de la variable USER du shell (équivalent à $USER sous Unix et

%USER% sous Windows) qui est initialisée au démarrage du pro-

gramme. Les modifications faites à os.environ par l’assignation

de clés sont exportées en dehors de Python grâce à un appel

à la fonction C putenv() et sont héritées par les processus qui

sont engendrés ultérieurement de quelque manière que ce soit,

ainsi que par tout code C lié. Voir aussi le manuel Python pour

l’interface bytes de l’environnement os.environb en Python

3.2 et dans les versions ultérieures.

os.putenv( nom_variable, valeur)

Définit la variable d’environnement du shell nommée

nom_variable

avec

la

chaîne

valeur.

Assigne

les

sous-processus démarrés avec system(), popen(), spawnv(),

fork() et execv(), ainsi que d’autres fonctions. L’assignation



192

Chapitre 1. Python précis et concis

aux clés de os.environ appelle automatiquement os.putenv(),

mais les appels à os.putenv() ne mettent pas à jour

os.environ, si bien que os.environ est préférable.

os.getenv( nom_variable, valeur_par_défaut=None)

Retrourne

la

valeur

de

la

variable

d’environnement

nom_variable

si

elle

existe,

sinon

valeur_par_défaut.

Actuellement,

cela

indexe

simplement

le

dictionnaire

d’environnement

préchargé

avec

os.environ.get(nom_variable,

valeur_par_défaut).nom_variable, valeur_par_défaut, et le

résultat est de type str ; voir aussi le manuel Python pour

les règles d’encodage Unicode, et os.getenvb() pour un

équivalent bytes à partir de Python 3.2.

os.getcwd()

Retourne le nom du répertoire de travail en cours sous la forme

d’une chaîne.

os.chdir( chemin)

Modifie le répertoire de travail en cours pour ce processus avec

la valeur du paramètre chemin, chaîne qui indique le nom d’un

répertoire. Les opérations de fichiers ultérieures sont relatives

au nouveau répertoire de travail. Conseil : cela ne met pas à

jour sys.path qui est utilisé pour les imports de modules, bien

que sa première entrée puisse être un désignateur générique de

répertoire de travail en cours.

os.strerror( code)

Retourne message d’erreur correspondant à code.

os.times()

Retourne un tuple de cinq éléments contenant le temps CPU

écoulé par le processus appelant secondes exprimées en

virgule

flottante :

(temps-utilisateur, temps-système,

temps-utilisateur-enfant, temps-système-enfant,

tems-réel-écoulé). Voir aussi la section Module time.

os.umask( masque)

Définit le umask numérique à masque et retourne la valeur

initiale.

os.uname()

Retourne un tuple de chaînes indiquant le nom de l’OS (nom-

système, nom-nœud, release, version, machine).



Module système os

193

Outils de descripteurs de fichiers

Les fonctions suivantes traitent les fichiers grâce à leurs descripteurs, où

fd représente un entier qui est un descripteur de fichier. Les fichiers

basés sur le descripteur de fichiers du module os sont prévus pour les

tâches de fichiers de bas niveau et ne sont pas indentiques que les

objets fichier stdio retournés par la fonction intégrée open(). Les

objets fichier, qui ne sont pas les descripteurs de fichiers, doivent

normalement être utilisés pour le traitement de la plupart des fichiers.

Voir open() dans la section Fonctions intégrées pour les détails. Si

nécessaire, os.fdopen() et la méthode de l’objet fichier fileno()

assurent la conversion entre les deux formes, et la fonction intégrée

open() accepte un descripteur de fichier en 3.X.

Note

Le « descripteur de fichier » dont il est question ici est différent

des « descripteurs » de classes (voir la section Méthodes pour les

descripteurs pour ces derniers). Notez aussi que Python 3.4 prévoit

de modifier les descripteurs de fichiers pour qu’ils ne soient plus

hérités par défaut dans les sous-processus et de fournir de nou-

velles fonctions get_inheritable(fd) et set_inheritable(fd,

boolean) dans os pour gérer ce comportement par défaut.

os.close( fd)

Ferme le descripteur de fichierfd (pas un objet fichier).

os.dup( fd)

Retourne un double du descripteur de fichierfd.

os.dup2( fd, fd2)

Copie le descripteur de fichierfd vers fd2 (ferme d’abord fd2

s’il est ouvert).

os.fdopen( fd, * args, ** kwargs)

Retourne un objet fichier stdio connecté au descripteur de

fichierfd (un entier). Il s’agit d’un alias de la fonction intégrée

open() qui accepte les mêmes arguments, sauf que le premier

argument de fdopen() doit toujours être un descripteur de

fichier exprimé par un entier (voir open() dans la section

Fonctions intégrées). Une conversion des fichiers basés sur un

descripteur de fichier vers les objets fichier est normalement

réalisée automatiquement par la fonction open(). Conseil :



194

Chapitre 1. Python précis et concis

utilisez fileobject.fileno() pour convertir un objet fichier

en un descripteur de fichier.

os.fstat( fd)

Retourne l’état du descripteur de fichierfd (comme os.stat()).

os.ftruncate( fd, longueur)

Tronque le fichire correspondant au descripteur de fichierfd de

telle sorte qu’il ne dépasse pas la taille du paramètre longueur

exprimé en octets.

os.isatty( fd)

Retourne True si le descripteur de fichierfd est ouverte et

connecté à un device de type tty (interactif), sinon False (peut

retourner 1 ou 0 dans les anciennes versions de Python).

os.lseek( fd, pos, how)

Définit la position actuelle du descripteur de fichierfd à pos

(pour l’accès aléatoire). how peut être égal à 0 pour définir la

position relative par rapport au début du fichier, à 1 pour définir

la position relative par rapport à la position en cours, ou à 2

pour définir la position relative par rapport à la fin du fichier.

os.open( nom_fichier, flags [, mode=0o777], [dir_fd=None])

Ouvre un fichier basé sur une descripteur de fichier et retourne

le descripteur de fichier (un entier qui peut être passé à d’autres

fonctions d’opérations de fichiers du module os, et non pas

un objet fichier stdio). Cette fonction est prévue uniquement

pour les tâches de fichire de bas niveau ; elle n’est pas identique

à la fonction open() qui est préférable pour la plupart des

opérations de traitement de fichiers (voir la section Fonctions

intégrées).

nom_fichier est la chaîne du nom du chemin éventuellement

relatif du fichier. flags est un masque de bits : utilisez | pour

combiner à la fois les constantes des options spécifiques à une

plateforme et celles qui sont indépendantes d’une plateforme

qui sont définies dans le module os (voir le tableau 18, Options

pour os.open (os.flag)). Le paramètre mode a pour valeur par

défaut 0o777 (octal), et la valeur umask en cours est d’abord

masquée. dir_fd est nouveau en Python 3.3, et prend en charge

les chemins relatifs aux descripteurs de fichries de répertoires

(voir le manuel Python). Conseil : os.open() peut être utilisé

avec l’option os.O_EXCL pour assurer de manière portable le

verrouillage des fichiers lors des mises à jour concurrentes ou

de la synchronisation des processus.



Module système os

195

os.pipe()

Créer un pipe anonyme. Voir la section Contrôle des processus.

os.read( fd, n)

Lit au plus n octets à partir du descripteur de fichierfd et

retourne ces octets sous la forme d’une chaîne.

os.write( fd, str)

Écrit tous les octets de la chaîne str dans le descripteur de

fichierfd.

Tableau 18 — Options pour os.open (os.flag)

O_APPEND

O_EXCL

O_RDONLY

O_TRUNC

O_BINARY

O_NDELAY

O_RDWR

O_WRONLY

O_CREAT

O_NOCTTY

O_RSYNC

O_DSYNC

O_NONBLOCK

O_SYNC

Utilitaires de noms de chemins de fichiers

Les fonctions suivantes traitent les fichiers par leurs noms de chemins

(le path étant une chaîne). Voir aussi la section Module os.path. En

Python 2.X, ce module comprend aussi les outils de gestion des

fichiers temporaires qui ont été remplacés par le module tempfile

en Python 3.X. À partir de Python 3.3, certains de ces outils ont

gagné un argument supplémentaire optionnel, dir_fd, (qui n’est pas

mentionné ici) pour prendre en charge les chemins relatifs par rapport

aux descripteurs de fichiers des répertoires ; voir le manuel Python

pour les détails :

os.chdir( path), os.getcwd()

Outils du répertoire de travail en cours. Voir la section Utili-

taires d’environnement.

os.chmod( path, mode)

Change le mode du chemin du fichier en mode numérique.

os.chown( path, uid, gid)

Change les identifiants du propriétaire/groupe du chemin en

uid/gid numérique.

os.link(srcpath, dstpath)

Crée un lien en dur vers le fichire srcpath, nommé dstpath.



196

Chapitre 1. Python précis et concis

os.listdir( path)

Retourne une liste de noms de toutes les entrées du chemin

du répertoire. Il s’agit d’une alternative rapide et portable à la

fonction glob.glob(motif) et à l’exécution des commandes

de listing du shell avec os.popen(). Voir aussi le module glob

dans le manuel Python pour le développement des motifs des

noms de fichiers, et os.walk() plus loin dans cette section pour

le parcours complet de l’arborescence des répertoires.

En Python 3.X, cette fonction passe et retourne des bytes

au lieu de str afin de supprimer le décodage des noms de

fichiers Unicode par défaut (ce comportement s’applique aussi

à glob.glob() et os.walk()). En Python 3.2 et dans les ver-

sions ultérieures, path est égal par défaut à "." s’il est omis,

c’est-à-dire le répertoire de travail en cours.

os.lstat( path)

Similaire à os.stat(), mais ne suit pas les liens symboliques.

os.mkfifo( path [, mode=0o666])

Crée une structure FIFO (premier entré, premier sorti, que l’on

appelle aussi pipe nommé) identifiée par la chaîne path avec

des permissions d’accès accordées par un mode numérique (mais

sans ouverture). Le mode par défaut est égal à 0o666 (octal).

La valeur umask en cours est d’abord marquée à partir du mode.

Cette fonction a un argument nommé optionnel dir_fd en

3.3.

Les structures FIFO sont des pipes qui résident dans le système

de fichiers et qui peuvent être ouvertes et traitées comme

des fichiers normaux, mais qui prennent en charge les accès

synchronisés entre les clients démarrés indépendamment et

les serveur, grâce à des noms de fichiers communs. Les FIFO

existent jusqu’à leur suppression. Cette fonction est disponible

actuellement sur les plateformes de type Unix, notamment

Cygwin sous Windows, mais pas dans le Python standard sous

Windows. Les sockets peuvent souvent accomplir des tâches

similaires (voir le module socket dans la section Outils et

modules Internet ainsi que le manuel Python).

os.mkdir( path [, mode])

Crée un répertoir appelé path, avec le mode passé en paramètre.

Le mode par défaut est égal à 0o777 (octal).



Module système os

197

os.makedirs( path [, mode])

Fonction récursive de création de répertoires. Similaire à

mkdir(), mais crée tous les répertoires de niveau intermédiaire

nécessaires pour contenir le répertoire final de l’arborescence.

Lève une exception si le répertoire final existe déjà ou ne peut

pas être créé. Le mode par défaut est égal à 0o777 (octal). En

Python 3.2 et dans les versions ultérieures, cette fonction a un

argument supplémentaire optionnel exists_ok ; voir le manuel

Python.

os.readlink( path)

Retourne le chemin référencé par un lien symbolique path.

os.remove( path), os.unlink( path)

Supprime le fichier nommé path. remove() est idenfique à

unlink(). Voir aussi rmdir() et removedirs() dans cette liste

pour la suppression des répertoires.

os.removedirs( path)

Fonction récursive de suppression de répertoires. Similaire

à rmdir(), mais si le répertoire final de l’arborescence est

supprimé avec succès, les répertoires parents sont supprimés

les uns après les autres jusqu’à ce que le chemin complet soit

détruit ou qu’une erreur se produise. Lève une exception si le

répertoire final ne peut pas être supprimé.

os.rename(srcpath, dstpath)

Renomme (déplace) le fichier srcpath en dstpath. Voir aussi

os.replace() à partir de Python 3.3.

os.renames( oldpath, newpath)

Fonction récrusive pour renommer un fichier ou un répertoire.

Similaire à rename(), mais la création des répertoires intermé-

diaires pour réaliser le nouveau chemin valide est tentée en

premier. Après le changement de nom, les répertoires parents

de l’ancien nom sont supprimés à l’aide de removedirs().

os.rmdir( path)

Supprime le répertoire nommé path.

os.stat( path)

Exécute la fonction système stat pour path ; retourne un

tuple d’entiers avec des informations de bas niveau (dont les

éléments sont définis et traités par les outils du module de

librairie standard stat).



198

Chapitre 1. Python précis et concis

os.symlink( srcpath, dstpath)

Crée un lien symbolique vers le fichire srcpath, appelé dst-

path.

os.utime( path, ( atime, mtime))

Définit l’horodatage de l’accès et de la modification du fichier

path.

os.access( path, mode)

Consultez la documentation de la librairie Python ou le manuel

Unix pour les détails.

os.walk(...)

os.walk(top

[, topdown=True

[, onerror=None]

[, followlinks=False]]])

Génère les noms de fichiers de l’arborescence d’un répertoire en

parcourant l’arbre de façon ascendante ou descendante. Pour

chaque répertoire de l’arbre ancré au chemin du répertoire

éventuellement relatif désigné par la chaîne top (comprenant

top lui-même), produit un tuple de trois éléments, c’est-à-dire

un triplet, (dirpath, dirnames, filenames), où :

1. dirpath est un chaîne désignant le chemin du répertoire.

2. dirnames est une liste des noms des sous-répertoires de dirpath

(à l’exception de . et ..).

3. filenames est une liste des noms des fichiers de dirpath qui

ne sont pas des répertoires.

Notez que les noms des listes ne contiennent pas les com-

posants des chemins. Pour obtenir un chemin complet (qui

commence par top) pour un fichier ou un répertoire de

dirpath, exécutez os.path.join(dirpath, name).

Si l’argument optionnel topdown est vrai ou n’est pas spécifié,

le triplet d’un répertoire est généré avant les triplets de ses

sous-répertoires (les répertoires sont générés de façons descen-

dante). Si topdown est faux, false, le triplet d’un répertoire est

généré aprèst les triplets de ses sous-répertoires (les répertoires

sont générés de façons ascendante). Si l’argument optionnel

onerror est spécifié, il doit s’agir d’une fonction, qui sera

appelée avec un argument, une instance os.error. Par défaut,



Module système os

199

os.walk ne parcourt pas les liens symboliques qui résolvent

les répertoires ; définissez followlinks à True pour parcourir

les répertoires pointés par de tels liens, sur les systèmes qui les

prennent en charge.

Quand topdown est vrai, la liste dirnames peut être modi-

fiée pour contrôler la recherche, car os.walk() parcourt de

manière récursive seulement les sous-répertoires dont les noms

demeurent dans dirnames. Cela est pratique pour élaguer la

recherche, imposer un ordre spécifique de parcours, etc.

Python 2.X fournit aussi une fonction os.path.walk() avec un

parcours d’arbre similaire, en utilisant une fonction callback

de gestionnaire d’événement à la place d’un générateur. En

Python 3.X, os.path.walk() est supprimée en raison de sa

redondance ; utilisez os.walk() à la place. Voir aussi le module

glob dans le manuel Python pour le développement des noms

de fichiers (par exemple, glob.glob(r’*\*\*.py’)).

Contrôle des processus

Les fonctions suivantes sont utilisées pour créer et gérer les processus

et les programmes. Voir aussi la section Commandes du shell pour étudier

d’autres manières de démarrer les programmes et les fichiers. Conseil :

n’utilisez pas ces outils pour lancer des chaînes de commandes du

shell qui ne sont pas sûres car elles peuvent exécuter toute commande

autorisée par le processus Python :

os.abort()

Envoie un signal SIGABRT au processus en cours. Sous Unix,

le comportement par défaut est de produire un dump, et

sous Windows, le processus retourne immédiatement un code

d’erreur 3.

os.execl( path, arg0, arg1,...)

Équivalent à execv(path, (arg0, arg1,...)).

os.execle( path, arg0, arg1,..., env)

Équivalent à execve(path, (arg0, arg1,...), env).

os.execlp( path, arg0, arg1,...)

Équivalent à execvp(path, (arg0, arg1,...)).



200

Chapitre 1. Python précis et concis

os.execve( path, args, env)

Similaire à execv(), mais le dictionnaire env remplace la

variable shell d’environnement. env doit associer des chaînes à

des chaînes.

os.execvp( path, args)

Similaire à execv(path, args), mais reproduit les actions du

shell en cherchant un fichier exécutable dans une liste de

répertoires qui est obtenue à partir de os.environ[’PATH’].

os.execvpe( path, args, env)

Mélange de execve() et execvp(). La liste des répertoires est

obtenue à partir de os.environ[’PATH’].

os.execv( path, args)

Exécute le fichier exécutable path avec l’argument en ligne

de commande args, en remplaçant le programme en cours du

processus (l’interpréteur Python). args peut être un tuple ou

une liste de chaînes, et par convention le premier élément

est nom de l’exécutable (argv[0]). Cet appel de fonction ne

retourne jamais, à moins qu’une erreur ne se produise pendant

le démarrage du nouveau programme.

os._exit( n)

Sort immédiatement du processus avec l’état n, sans accomplir

les étapes normales d’arrêt du programme. Cette fonction est

normalement utilisée uniquement dans un processus enfant

après un fork ; la façon standard de quitter est d’appeler

sys.exit(n).

os.fork()

Engendre un processus enfant (une copie virtuelle du processus

appelant, qui s’exécute en parallèle) ; retourne 0 dans le pro-

cessus enfant et le numéro du processus du nouvel enfant dans

le processus parent. Cette fonction n’est pas disponible sous

Windows dans le Python standard, mais dans le Cygwin Python

sous Windows (popen(), system(), spawnv(), et le module

subprocess sont généralement plus portables).

os.getpid(), os.getppid()

Retourne le numéro de processus du processus (appelant) en

cours ; getppid() retourne le numéro du processus parent.

os.getuid(), os.geteuid()

Retourne l’identifiant de l’utilisateur du processus ; geteuid

retourne l’identifiant de l’utilisateur effectif.



Module système os

201

os.kill( pid, sig)

Envoie le signal sig au processus ayant l’identifiant pid, ce qui

peut éventuellement le tuer (avec certains types de signaux).

Voir aussi le module de la librairie standard signal dans le

manuel Python pour les constantes des signaux et l’enregistre-

ment des gestionnaires de signaux.

os.mkfifo( path [, mode])

Voir la section précédente Utilitaires de noms de chemins de

fichiers (fichiers nommés utilisés pour la synchronisation de

processus).

os.nice( incrément)

Ajoute incrément au gestionnaire de priorité du processus

(c’est-à-dire diminue la priorité CPU).

os.pipe()

Retourne un tuple de descripteurs de fichiers (readfd, wri-

tefd) pour lire et écrire un nouveau pipe anonyme (sans nom).

Utilisée pour la communication inter-process des processus qui

sont liés.

os.plock( op)

Verrouille en mémoire les segments du programme. op (défini

dans <sys./lock.h>) détermine les segments à verrouiller.

os.spawnv( mode, path, args)

Exécute le programme path dans un nouveau processus, en

lui passant les arguments spécifiés dans args sous la forme

d’une ligne de commande. args peut être une liste ou un tuple.

mode est une constante opérationnelle composée des noms

suivants qui sont également définis dans le module os : P_WAIT,

P_NOWAIT, P_NOWAITO, P_OVERLAY et P_DETACH. Sous Windows,

cela correspond approximativement à une combinaison de

fork() et de execv() (fork() n’est pas disponible sur le Python

standard sous Windows, bien que ce soit le cas de popen()

et system()). Voir aussi le module subprocess de la librairie

standard pour des alternatives plus riches fonctionnellement

(voir la section Module subprocess).

os.spawnve( mode, path, args, env)

Similaire à spawnv(), mais passe le contenu du mapping env

en tant que variables d’environnement du shell du programme

engendré (sinon, le processus hérite du processus parent).



202

Chapitre 1. Python précis et concis

os.wait()

Attend la fin du processus enfant. Retourne un tuple contenent

l’identifiant de l’enfant et l’état de sortie.

os.waitpid( pid, options)

Attend la fin du processus enfant ayant le numéro pid. options

est égal à 0 en utilisation normale, ou os.WNOHANG pour éviter

un blocage si aucun état de processus enfant n’est disponible.

Si pid est égal à 0, la demande s’applique à n’importe quel

enfant du groupe des processus du processus en cours. Voir

aussi les fonctions de contrôle de l’état de sortie des processus

dans la documentation de la librairie Python (par exemple,

WEXITSTATUS(status) pour extraire le code de sortie).

Module os.path

Le module os.path fournit des services supplémentaires pour gérer les

noms de chemins de répertoires et des outils de portabilité. Il s’agit

d’un module imbriqué : ses noms sont imbriqués dans le module os au

sein du sous-module os.path (par exemple, la fonction exists peut

être obtenue en important os et en utilisant le nom os.path.exists).

La plupart des fonctions de ce module ont un argument path,

qui représente le nom de chemin du répertoire d’un fichier (par

exemple, ’C:\dir1\spam.txt’). Les chemins de répertoires sont en

général codés selon les conventions de la plateforme et sont associés

au répertoire de travail en cours si aucun préfixe de répertoire n’est

fourni. Conseil : le slash fonctionne en général comme séparateur de

répertoire sur toutes les plateformes. En Python 2.X, ce module inclut

un outil os.path.walk() qui a été remplacé par os.walk() en Python

3.X (voir la section Utilitaires de noms de chemins de fichiers) :

os.path.abspath( path)

Retourne

une

version

absolue

normalisée

de

path.

Sur la plupart des plateformes, cela est équivalent à

normpath(join(os.getcwd(), path)).

os.path.basename( path)

Similaire à la seconde moitié de la paire retournée par

split(path).

os.path.commonprefix( liste)

Retourne le préfixe de chemin le plus long (caractère par

caractère) qui est un préfixe de tous les chemins de liste.



Module système os

203

os.path.dirname( path)

Similaire à la première moitié de la paire retournée par

split(path).

os.path.exists( path)

True si la chaîne path est le nom d’un chemin existant.

os.path.expanduser( path)

Retourne une chaîne qui contient path et incorpore le nom de

l’utilisateur précédé du caractère .

~

os.path.expandvars( path)

Retourne une chaîne qui contient path et incorpore les vari-

rables d’environnement $.

os.path.getatime( path)

Retourne l’horodatage du dernier accès à path (nombre de

secondes écoulées depuis epoch, qui est la date à partir de

laquelle les dates sont gérées par le système et qui dépend de la

plateforme ; epoch sous Unix est égale à 01/01/1970).

os.path.getmtime( path)

Retourne l’heure de la dernière modification de path (nombre

de secondes écoulées depuis epoch).

os.path.getsize( path)

Retourne la taille en octets du fichier path.

os.path.isabs( path)

True si la chaîne path est un chemin absolu.

os.path.isfile( path)

True si la chaîne path est un fichier régulier.

os.path.isdir( path)

True si la chaîne path est un répertoire.

os.path.islink( path)

True si la chaîne path est un lien symbolique.

os.path.ismount( path)

True si la chaînepath est un point de montage.

os.path.join( path1 [, path2 [, ...]])

Combine de manière intelligente plusieurs composants de che-

mins (en employant les conventions de séparateurs spécifiques

à la plateforme entre chaque composant).

os.path.normcase( path)

Normalise la casse d’un chemin. Cela n’a aucun effet sous

Unix ; sur les systèmes de fichiers qui ne font pas différence

entre minuscules et majuscules, la fonction convertit en minus-

cules ; sous Windows, la fonction convertit aussi le / en \.





204

Chapitre 1. Python précis et concis

os.path.normpath( path)

Normalise un nom de chemin. Supprime les séparateurs redon-

dants et les références au répertoire parent ; sous Windows, la

fonction convertit le / en \.

os.path.realpath( path)

Retourne le chemin canonique du fichier spécifié, en éliminant

les liens symboliques se trouvant dans le chemin.

os.path.samefile( path1, path2)

True si les deux arguments font référence au même fichier ou

au même répertoire.

os.path.sameopenfile( fp1, fp2)

True si les deux objets fichier font référence au même fichire.

os.path.samestat( stat1, stat2)

True si les deux tuples stat font référence au même fichire.

os.path.split( path)

Découpe le paramètre path en (head, tail), où tail est le der-

nier composant du chemin et head tout ce qui se trouve avant

tail. Similaire au tuple (dirname(path), basename(path)).

os.path.splitdrive( path)

Découpe path en une paire (’lecteur:’, tail) (sous Win-

dows).

os.path.splitext( path)

Découpe path en (root, ext), où le dernier composant de root

ne contient pas de point et où ext est vide ou commence par

un point.

os.path.walk( path, visitor, data)

Alternative à os.walk() uniquement en Python 2.X, et basée

sur la fonction callback de gestionnaire de répertoires visitor

avec l’état data, à la place d’un générateur de répertoires.

Supprimée en Python 3.X : utilisez os.walk(), et non pas

os.path.walk().

MODULE DE RECHERCHE DE MOTIFS PAR

EXPRESSIONS RÉGULIÈRES

Le module re est l’interface standard de recherche de motifs par

expression régulière en Python 3.X et 2.X. Les motifs d’expressions

régulières (en anglais regular expression, abrégé en re), et le texte qui



Module de recherche de motifs par expressions régulières

205

leur est soumis, sont spécifiés sous la forme de chaînes. Ce module

doit être importé.

Fonctions du module

L’interface de haut niveau du module comprend des outils qui

recherchent une correspondance immédiate ou qui précompilent des

motifs, et créent des objets motif (pobj à cause de l’anglais pattern que

nous avons traduit par motif) et des objets correspondance (mobj à

cause de l’anglais match que nous avons traduit par correspondance)

définis dans les sections ci-dessous :

re.compile( pattern [, flags])

Compile une chaîne pattern dans un objet motif (pobj),

pour une correspondance ultérieure. flags (combinable avec

l’opérateur | de comparaison bit à bit) comprend les options

suivantes qui sont disponibles au niveau supérieur du module

re :

re.A ou re.ASCII ou (?a)

Fait accomplir à \w, \W, \b, \B, \s et \S une correspondance uni-

quement en ASCIIau lieu d’une correspondance en Unicode.

Cela n’a d’intérêt que pour les motifs uniquement en Unicode

et cette option est ignoré pour les motifs exprimées sous forme

d’octets. Notez que pour des raisons de rétro-compatibilité, l’op-

tion re.U existe toujours (ainsi que son synonyme re.UNICODE

et son équivalent ?u), mais elle est redondante en Python 3.X

puisque les correspondances sont par défaut en Unicode pour

les chaînes (et la correspondance Unicode n’est pas autorisée

pour les octets).

re.I ou re.IGNORECASE ou (?i)

Correspondance ne faisant pas la différence entre les majus-

cules et les minuscules.

re.L ou re.LOCALE ou (?L)

Rend \w, \W, \b, \B, \s, \S, \d et \D dépendantes des paramètres

régionaux en cours (Unicode est la valeur par défaut en Python

3.X).

re.M ou re.MULTILINE ou (?m)

Correspondance pour chaque nouvelle ligne, et non pas la

chaîne complète.

re.S ou re.DOTALL ou (?s)



206

Chapitre 1. Python précis et concis

Le caractère point (.) correspond à tous les caractères, y

compris le caractère de nouvelle ligne.

re.U ou re.UNICODE ou (?u)

Rend \w, \W, \b, \B, \s, \S, \d et \D dépendantes des propriétés

des caractères Unicode (nouveauté en version 2.0, et superflu

en Python 3.X).

re.X ou re.VERBOSE ou (?x)

Ignore les espaces dans le motif, en dehors des jeux de carac-

tères.

re.match(pattern, string [, flags])

Si des caractères au début de string correspondent à la chaîne

pattern, retourne une instance d’objet correspondance (mobj),

ou None s’il n’y a pas de correspondance. flags est identique

aux options de compile().

re.search( pattern, string [, flags])

Parcourt string pour trouver une correspondance avec pat-

tern ; retourne une instance d’objet correspondance (mobj),

ou None s’il n’y a pas de correspondance. flags est identique

aux options de compile().

re.split( pattern, string [, maxsplit=0])

Découpe string selons les occurrences de pattern. Si des

parenthèses sont utilisées dans pattern, les occurrences des

motifs ou des sous-motifs sont aussi retournées.

re.sub( pattern, repl, string [, count=0])

Retourne une chaîne obtenue en remplaçant les (premières)

occurrences les plus à gauche et ne se recouvrant pas de pat-

tern (une chaîne ou un objet RE) dans string par repl. repl

peut être une chaîne ou une fonction appelée avec un argu-

ment unique (mobj), qui doit retourner la chaîne de remplace-

ment. repl peut aussi inclure des séquences d’échappement \1,

\2, etc., pour employer des sous-chaînes qui correspondent à

des groupes, ou \0 pour toutes.

re.subn( pattern, repl, string [, count=0])

Similaire à sub mais retourne un tuple (nouvelle_chaîne,

nombre_de_substitions_réalisées).

re.findall( pattern, string [, flags])

Retourne une liste de chaînes donnant toutes les correspon-

dances sans recouvrement de pattern dans string. Si un ou

plusieurs groupes sont présents dans le motif, retourne une liste

de groupes.



Module de recherche de motifs par expressions régulières

207

re.finditer( pattern, string [, flags])

Retourne un itérable de toutes les correspondances sans recou-

vrement avec le motif dans la chaîne (objets correspondance).

re.escape( string)

Retourne string avec tous les caractères non alphabétiques

précédés d’un antislash, de telle sorte qu’ils puissent être

compilés sous la forme de littéraux de chaînes.

Objets pattern

Les objets pattern (pobj) sont retournés par la fonction re.compile()

et ont les attributs suivants, dont certains créent des objets match

(mobj):

pobj.flags

L’argument flags utilisé quand les objets pattern sont compi-

lés.

pobj.groupindex

Dictionnaire de{nom_de_groupe: numéro_de_groupe} dans le

motif.

pobj.pattern

Chaîne du motif à partir que laquelle l’objet pattern a été

compilé.

pobj.match(string [, pos [, endpos]])

pobj.search(string [, pos [, endpos]])

pobj.split(string [, maxsplit=0])

pobj.sub(repl, string [, count=0])

pobj.subn(repl, string [, count=0])

pobj.findall(string [, pos[, endpos]])

pobj.finditer(string [, pos[, endpos]])

Similaire aux précédentes fonctions du module re, mais pat-

tern est implicite, et pos et endpos fournissent les indices de

début et de fin pour la correspondance. Les deux premières

fonctions peuvent créer des objets match (mobj).



208

Chapitre 1. Python précis et concis

Objets match

Les objets match (mobj) sont retournés à la suite d’opération réussies

match() et search() ; ils ont les attributs suivants (voir la documen-

tation de la librairie Python pour les autres attributs moins courants

que nous avons omis ici) :

mobj.pos, mobj.endpos

Valeurs de pos et endpos passées à search ou match.

mobj.re

Objet pattern dont les fonctions match ou search ont produit

cet objet match (voir sa chaîne pattern).

mobj.string

Chaîne passée à match ou search.

mobj.group([ g [, g]*)

Retourne une sous-chaînes dont la correspondance a été trouvé

par des groupes entre parenthèses dans le motif. Accepté zéro

ou plusieurs identificateurs de numéro ou de nom de groupe g,

impliqués par les motifs (R) et (?P<nom>R), respectivement.

S’il n’y qu’un argument, le résultat est la sous-chaîne qui

correspond au groupe dont l’identificateur a été passé. S’il y

a plusieurs arguments, le résultats est un tuple avec une sous-

chaîne qui correspond par argument. S’il n’y a pas d’argument,

retourne la totalité de la sous-chaîne qui correspond. Si un

numéro de groupe est égal à 0, la valeur de retour est la totalité

de la chaîne correspondante ; dans le cas contraire, retourne

une chaîne qui correspond aux groupes entre parenthèses. Les

groupes dans le motif sont numérotés dans la plage 1...N, de

gauche à droite.

mobj.groups()

Retourne un tuple de tous les groupes de la correspondance ;

les groupes qui ne participent pas à la correspondance ont une

valeur None.

mobj.groupdict()

Retourne un dictionnaire contenant tous les sous-groupes nom-

més de la correspondance, indexés sur le nom du sous-groupe.

mobj.start([ g]), mobj.end([ g])

Indixes de début et de fin de la sous-chaîne en correspon-

dance avec le groupe g (ou la totalité de la chaîne en cor-

respondance, s’il n’y a pas de group). Pour un objet match M,

M.string[M.start(g):M.end(g)] == M.group(g).



Module de recherche de motifs par expressions régulières

209

mobj.span([ g])

Retourne le tuple ( mobj.start( g), mobj.end( g)).

mobj.expand(template)

Retourne la chaîne obtenue en faisant la substitution des

caractères antislash dans la chaîne template, comme cela

est fait dans la méthode sub. Les caractères d’échappement,

comme \n, sont convertis dans les caractères appropriés, et

les références numériques avec un antislash (par exemple,

\1, \2) et les références avec un nom précédé d’un antislash

(par exemple, \g<1>, \g<name>) sont remplacées par le groupe

correspondant.

Syntaxe des motifs

Les chaînes de motifs sont des concaténations de formes (voir le

tableau 19, Syntaxe des motifs des expressions régulières) et de caractères

d’échappement (voir le tableau 20, Séquences spéciales des motifs des

expressions régulières). Les caractères d’échappement Python (par

exemple, \t pour la tabulation) peuvent aussi en fait partie. Les

chaînes de motifs sont comparées aux chaînes de texte, et produisent

un résultat de correspondance sous la forme d’un booléen, ainsi

qu’un groupe de sous-chaînes qui sont en correspondance avec des

sous-motifs entre parenthèses :

>>> import re

>>> pobj = re.compile(’hello[ \t]*(.*)’)

>>> mobj = pobj.match(’hello world!’)

>>> mobj.group(1)

’world!’

Dans le tableau 19, Syntaxe des motifs des expressions régulières, C

représente un caractère, R une forme d’expression régulière dans la

colonne de gauche du tableau, et m et n sont des entiers. Chaque

forme traite en général autant de caractères que possible de la chaîne

comparée, à l’exception des formes frugales (qui consomment aussi

peu que possible, tant que la totalité du motif correspond à la chaîne

cible).



210

Chapitre 1. Python précis et concis

Tableau 19 — Syntaxe des motifs des expressions régulières

Forme

Description

.

Correspond à tout caractère (y compris la nouvel e ligne

si l’option DOTALL est spécifiée).

ˆ

Correspond au début de la chaîne (de toutes les lignes

en mode MULTILINE).

$

Correspond à la fin de la chaîne (de toutes les lignes en

mode MULTILINE).

C

Tout caractère non spécial correspond à lui-même.

R*

Zéro ou plusieurs occurrences de la précédente expres-

sion régulière R (autant que possible).

R+

Une ou plusieurs occurrences de la précédente expres-

sion régulière R (autant que possible).

R?

Zéro ou une occurrence de la précédente expression

régulière R.

R{m}

Correspond exactement à m répétitions de la précédente

expression régulière R.

R{m,n}

Correspond à un nombre de répétitions (de m à n) de la

précédente expression régulière R.

R*?, R+?, R??, R{ m, n}?

Similaire à *, +, et ?, mais correspond à aussi peu de

caractères/fois que possible ; forme frugale.

[. .]

Définit un jeu de caractères ; par exemple, [a-zA-Z]

correspond à toutes les lettres (voir aussi le tableau 20,

Séquences spéciales des motifs des expressions régulières).

[ˆ. .]

Définit un jeu de caractères complémentaires : corres-

pond si un caractère ne fait pas partie du jeu.

\

Échappe des caractères spéciaux (par exemple, *?+|())

et introduit des séquences spéciales (voir le tableau .20,

Séquences spéciales des motifs des expressions régulières).

À cause des règles de Python, écrivez-le sous la forme

\\ ou r’\\’.

\\

Correspond au littéral \; à cause des règles des chaînes

Python, écrivez-le sous la forme \\\\ dans le motif, ou

r’\\’.



Module de recherche de motifs par expressions régulières

211

Tableau 19 — (suite)

\nombre

Correspond au contenu du groupe du même nombre :

r’(.+) \1’ correspond à ’42 42’.

R|R

Alternative : correspond au R de gauche ou de droite.

RR

Concaténation: correspond aux deux R.

( R)

Correspond à toute expression régulière à l’intérieur

des parenthèses, et déliminte un groupe (conserve la

sous-chaîne en correspondance).

(?: R)

Similaire à (R) mais ne délimite pas un groupe.

(?= R)

Assertion avant ( look-ahead) : correspond si R corres-

pond au caractère suivant, mais ne consomme pas les

autres caractères de la chaîne (par exemple, ’X(?=Y)’

correspond à X s’il est est suivi de Y).

(?! R)

Assertion avant négative : correspond si R ne correspond

pas au caractère suivant. C’est la négation de (?=R).

(?P< name> R)

Correspond à toute expression régulière entre les

parenthèses et délimite un groupe nommé (par exemple,

r’(?P<id>[a-zA-Z_]\w*)’ définit un groupe nommé

id).

(?P= nom)

Correspond à n’importe texte en correspondance avec

le précédent groupe nommé nom.

(?#. .)

Commentaire ; ignoré.

(?lettre)

lettre est l’un des caractères suivants : a, i, L, m, s, x,

ou u. Définit l’option (re.A, re.I, re.L, etc.) de la totalité

de l’expression régulière.

(?<= R)

Assertion arrière ( look-behind) positive : correspond si

el e est précédée par une correspondance de largeur

fixe R.

(?<! R)

Assertion arrière négative : correspond si el e n’est pas

précédée par une correspondance de largeur fixe R.

(?(id/name)yespatt|nopatt)

Va tenter d’établir une correspondance avec le motif

yespatt si le groupe dont l’id ou le name a été fourni

existe, sinon la correspondance est rercherchée avec le

paramètre optionnel nopatt.





212

Chapitre 1. Python précis et concis

Dans le tableau 20, Séquences spéciales des motifs des expressions

régulières, \b, \B, \d, \D, \s, \S, \w et \W se comportent différemment

en fonction des options, et sont par défauts des caractères Unicode

en Python 3.X, à moins que l’option ASCII (c’est-à-dire ?a) ne soit

utilisée. Conseil : employez des chaînes brutes (r’\n’) pour écrire

sous formes littérale le caractère antislash dans le tableau 20.

Tableau 20 — Séquences spéciales des motifs des expressions régulières

Séquence

Description

\nombre

Correspond au texte du groupe nombre (à partir de 1)

\A

Correspond uniquement au début de la chaîne

\b

Chaîne vide aux limites du mot

\B

Chaîne vide qui n’est pas aux limites du mot

\d

Tout chiffre décimal ([0–9])

\D

Tout caractère qui n’est pas un chiffre décimal ([ˆ0–9])

\s

Tout espace ([ \t\n\r\f\v])

\S

Tout caractère qui n’est pas un espace ([ˆ \t\n\r\f\v])

\w

Tout caractère alphanumérique

\W

Tout caractère qui n’est pas alphanumérique

\Z

Correspond uniquement à la fin de la chaîne

MODULES DE PERSISTANCE DES OBJETS

Trois modules constituent le système de persistance des objets (c’est-à-

dire le stockage des objets en Python) de la librairie standard :

dbm (anydbm en Python 2.X)

Fichiers stockant uniquement des chaînes basées sur des clés.

pickle (et cPickle en Python 2.X)

Sérialisation d’un objet en mémoire vers/depuis des flux de

fichiers.



Modules de persistance des objets

213

shelve

Stockage d’objets persistants basés sur des clés : stocke les

objets dans des fichiers dbm sous la forme de pickle.

Le module shelve implémente le stockage d’objets persistants.

shelve à son tour utilise le module pickle pour convertir (sérialisert)

des objets Python en mémoire en chaînes linéaires et utilise le

module dbm pour stocker ces chaînes linéaires en fichiers auxquels on

accède par des clés. L’ensemble de ces trois modules peut être utilisé

directement.

Note

En Python 2.X, dbm s’appelle anydbm, et le module cPickle est une

version optimisée de pickle qui peut être importée directement

et qui est utilisée directement par shelve, s’il est présent. En

Python 3.X, cPickle, qui a été renommé _pickle, est utilisé

automatiquement par pickle s’il est présent (il n’a pas besoin

d’être importé directement car il est acquis par shelve).

Vous noterez aussi qu’en Python 3.X l’interface de Berkeley

DB (bsddb) pour dbm n’est plus livrée avec Python, mais une

extension open source tierce, qui doit être installée séparément

si nécessaire (voir la documentation de la librairie Python 3.X

pour des informations complémentaires).

Modules shelve et dbm

dbm est un simple fichier texte auquel on accède par des clés : les chaînes

sont stockées et récupérées grâce à des clés. Le module dbm sélectionne

l’implémentation de fichiers accessibles par clés qui est disponible

dans votre interpréteur Python et présente aux scripts une API

semblable à un dictionnaire.

shelve est un fichier objet auquel on accède par des clés : il est utilisé

comme un simple fichiers dbm, sauf que le nom de ce module diffère

et que la valeur stockée peut être pratiquement n’importe quelle

sorte d’objet Python (bien que les clés soient toujours des chaînes).

À maints égards, les fichiers dbm et shelve fonctionnent comme des

dictionnaires qui doivent être ouverts avant leur utilisation, puis fermés

après leur modification ; toutes les opérations de mapping et certaines



214

Chapitre 1. Python précis et concis

méthodes de dictionnaires fonctionnent, et sont automatiquement

associées à des fichiers externes.

Ouvertures de fichiers

Pour shelve, importez la librairie, puis appelez sa fonction open()

pour créer un nouveau fichier shelve ou en ouvrir un existant :

import shelve

file = shelve.open(nom_de_fichier

[, flag=’c’

[, protocol=None

[, writeback=False]]])

Pour dbm, importez la librairie, puis appelez sa fonction open()

pour créer un nouveau fichier dbm ou en ouvrir un existant. Cette

opération emploie n’importe quelle librairie disponible prenant en

charge dbm : dbm.bsd, dbm.gnu, dbm.ndbm, ou dbm.dumb (cette dernière

étant une solution de repli par défaut qui est toujours disponible) :

import dbm

file = dbm.open(nom_de_fichier

[, flag=’r’

[, mode]])

nom_de_fichier pour shelve et dbm est une chaîne relative ou

absolue du nom d’un fichier externe où les données sont stockées.

flag est un paramètre identique dans shelve et dbm (shelve le

passe à dbm). Il peut être égal à ’r’ pour ouvrir une base de données

existante en lecture seule (valeur par défaut pour dbm), à ’w’ pour

ouvrir une base de données existante en lecture et en écriture, à ’c’

pour créer la base de données si elle n’existe pas (valeur par défaut

pour shelve), ou bien à ’n’, qui va toujours créer une base de données

vide. Le module dbm.dumb (utilisé par défaut en 3.X si aucune autre

librairie n’est installée) ignore le paramètre flag (la base de données

est toujours ouverte pour les mises à jour et elle est créée si elle

n’existe pas).

Pour dbm, l’argument optionnel mode est le mode Unix du fichier,

qui est utilisé seulement si la base de données doit être crée. Par

défaut, sa valeur en octal est égale à 0o666.

Puor shelve, l’argument protocol est passé de shelve à pickle.

Il fournit le numéro de protocole de pickling (décrit dans la section



Modules de persistance des objets

215

Module pickle) utilisé pour stocker les objets shelve ; sa valeur par

défaut est égale à 0 en Python 2.X, et actuellement à 3 en Python

3.X.

Par défaut, les modifications des objets récupérés dans des objets

shelve ne sont pas écrites automatiquement sur disque. Si le paramètre

optionnel writeback est défini à True, toutes les entrées auxquelles

on a accédé sont mises en mémoire cache, puis écrites sur disque à la

fermeture ; cela facilite la modification des entrées mutables dans les

objets shelve, mais cela peut consommer de la mémoire cache, ce qui

ralentit l’opération de fermeture car toutes les entrées auxquelles on

a accédé sont écrites sur le disque. Réassignez les objets à leurs clés

pour mettre à jour les objets shelve manuellement.

Opérations sur les fichiers

Une fois qu’il est créé, un objet shelve ou dbm est pratiquement

identique à une interface de dictionnaire :

fichier[clé] = valeur

Stockage : crée ou modifie l’entrée de la chaîne clé. La valeur est

une chaîne pour dbm, ou un objet presque arbitraire pour shelve.

valeur = fichier[clé]

Récupération : charge la valeur de l’entrée clé. Pour shelve,

reconstruit l’objet original en mémoire.

count = len(fichier)

Taille : retourne le nombre d’entrées stockées.

index = fichier.clés()

Index : récupère l’itérable des clés stockées (une liste en 2.X).

for clé in fichier: ...

Itération : itérateur des clés, utilisable dans n’importe quel

contexte d’itération.

found = clé in fichier

# Aussi has_key() en 2.X

uniquement



216

Chapitre 1. Python précis et concis

Requête : True s’il y a une entrée pour clé.

del fichier[clé]

Suppression : supprime l’entrée pour clé.

fichier.close()

Fermeture manuelle ; obligatoire pour écrire sur disque les mises à

jour pour quelques interfaces dbm sous-jacentes.

Module pickle

Le module pickle est un outil de sérialisation d’objet : il convertit des

objets Python en mémoire presque arbitraires vers/depuis des flux

linéaires d’octets. Ces flux d’octets peuvent être dirigés vers n’importe

quel objet fichier qui possède les méthodes de lecture et d’écriture qui

conviennent et qui sont utilisées par shelve pour sa représentation

des données internes. L’opération de unpickling recrée l’objet original

en mémoire, avec la même valeur, mais une nouvelle identité (adresse

mémoire).

Reportez-vous à la note précédente sur les modules optimisés

Python 2.X cPickle et Python 3.X’s _pickle. Consultez aussi la

méthode makefile des objets socket pour le transport des objets

sérialisés sur les réseaux sans appels manuels à des objets socket (voir

la section Outils et modules Internet et le manuel Python).

Interfaces de pickling

Ce module prend en charge les appels suivants :

P = pickle.Pickler(objet_fichier [, protocole=None])

Crée un nouvel objet pickle, pour enregistrer un objet fichier de

sortie.

P.dump(objet)

Écrit un objet sur le fichier/flux de l’objet pickle.

pickle.dump(objet, objet_fichier [, protocole=None])



Modules de persistance des objets

217

Combinaison des deux précédents appels : pickling d’un objet sur

un fichier.

string = pickle.dumps(objet [, protocole=None])

Retourne une représentation d’un objet pickle sous la forme d’une

chaîne (une chaîne bytes en Python 3.X).

Interfaces de unpickling

Ce module prend en charge les appels suivants :

U = pickle.Unpickler(objet_fichier,

encoding="ASCII", errors="strict")

Réalise une opération de unpickling de chargement à partir d’un

objet fichier d’entrée.

objet = U.load()

Lit un objet à partir d’un fichier/flux d’une opération de unpick-

ling.

objet = pickle.load(objet_fichier,

encoding="ASCII", errors="strict")

Combinaison des deux précédents appels : unpickling d’un objet

à partir d’un fichier.

objet = pickle.loads(string,

encoding="ASCII", errors="strict")

Lit un objet à partir d’une chaîne (une chaîne bytes ou compa-

tible en Python 3.X).

Notes d’utilisation des objets pickle

• En Python 3.X, les fichiers utilisés pour stocker les objets pickle

doivent toujours être ouverts en mode binaire pour tous les

protocoles, car le pickling produuit des chaînes bytes, et les

fichiers en mode texte ne prennent pas en charge l’écriture des

bytes (les fichiers en mode texte encodent et décodent le texte

Unicode en 3.X).



218

Chapitre 1. Python précis et concis

• En Python 2.X, les fichiers utilisées pour stocker les objets

pickle doivent être ouverts en mode binaire pour tous les pro-

tocoles de pickling >= 1, afin de supprimer les transformations

des fins de lignes des données binaires des objets pickle. Le

protocole 0 est basé sur l’ASCII, si bien que ses fichiers peuvent

être ouverts en mode texte ou binaire, tant que cela est fait

systématiquement.

• objet_fichier est un objet fichier ouvert, ou n’importe quel

objet qui implémente des attributs d’objet fichire appelés par

l’interface. Pickler appelle la méthode de fichier write() avec

un argument qui est une chaîne. Unpickler appelle la méthode

de fichier read() avec un argument de type compteur d’octets

et readline() sans argument.

• protocole est un argument optionnel qui sélectionne un format

pour les données des objets pickle, disponible à la fois dans le

constructeur Pickler et les fonctions dump() et dumps() du

module. Cet argument prend une valeur dans la plage 0...3, où

les numéros les plus élevés de protocoles sont généralement

plus efficaces, mais peuvent se révéler incompatibles avec les

opérations de unpickling dans les versions précédentes de

Python. Le numéro de protocole par défaut en Python 3.X

est 3, l’opération de unpickling ne pouvant pas être réalisée

en Python 2.X. Le protocole par défaut en Python 2.X est 0,

qui est moins efficace, mais davantage portable. Le protocole

1 utilise automatiquement le protocole pris en charge le plus

élevé. Lors d’une opération de unpickling, le protocole est défini

implicitement par le contenu des données de l’objet pickle.

• Les arguments nommés optionnels encoding et errors ne sont

disponibles qu’en Python 3.X. Ils sont utilisés pour décoder

des instances de chaîns 8 bits d’objet pickle de Python 2.X.

Leurs valeurs par défaut sont égales à ’ASCII’ et ’strict’,

respectivement. Voir str() dans la section Fonctions intégrées

pour des outils similaires.

• Pickler et Unpickler sont des classes exportées qui peuvent

être personnalisées par sous-classement. Voir la documentation

de la librairie Python pour les méthodes disponibles.





Module et outils graphiques tkinter

219

Note

Au moment de la rédaction de cet ouvrage, il y a eu une proposi-

tion (https://www.python.org/dev/peps/pep-3154) d’un protocole

pickle optimisé ayant pour numéro 4. Ce protocole cible Python

3.4 dans lequel il a été ajouté.

MODULE ET OUTILS GRAPHIQUES TKINTER

tkinter (appelé Tkinter en Python 2.X, et qui est un package en

Python 3.X) est une librairie graphique portable livrée avec Python

en tant que module de librairie standard. tkinter fournit un interface

objet à librairie open source Tk et implémente en natif une interface

utilisateur graphique pour les programmes codés en Python sous

Windows, X-Windows et Mac OS. Ce module, qui a fait ses preuves,

est portable, simple à utiliser, bien documenté, largement plébiscité,

et dispose d’un bon support technique. Il existe d’autres options

graphiques portables pour Python, comme wxPython et PyQT, qui

sont des extensions tierces avec un ensemble plus riche de widgets,

mais elles sont en général plus complexes à programmer.

Exemple tkinter

Dans les scripts tkinter, les widgets sont des classes personnalisables

(par exemple, Button, Frame), les options sont des arguments nommés

(par exemple, text="Appuyez"), et la composition fait référence à

l’incorporation des objets, et pas aux noms de chemins (par exemple,

Label(top,...)):

from tkinter import *

# Widgets, constantes

def msg():

# Gestionnaire de callback

print(’hello stdout...’)

top = Frame()

# Crée un conteneur

top.pack()

Label(top, text=’Hello world’).pack(side=TOP)

widget = Button(top, text=’Appuyez’, command=msg)

widget.pack(side=BOTTOM)

top.mainloop()



220

Chapitre 1. Python précis et concis

Principaux widgets tkinter

Le tableau 21, Classes des principaux widgets du module tkinter liste les

principales classes de widgets du module tkinter. Il s’agit de classes

Python qui peuvent être sous-classées et incorporées dans d’autres

objets. Pour créer un dispositif graphique à l’écran, créez une instance

de la classe correspondante, configurez-la, puis placez-la avec l’une

des méthodes d’interface de gestion de positionnement (par exemple,

Button(text=’hello’).pack()). En plus des classes du tableau 21,

le module tkinter fournit un large ensemble de noms prédéfinis

(c’est-à-dire des constantes) utilisés pour configurer les widgets (par

exemple, RIGHT, BOTH, YES) ; ces noms sont chargés automatiquement

à partir de tkinter.constants (Tkconstants en Python 2.X).

Tableau 21 — Classes des principaux widgets du module tkinter

Classe de

widget

Description

Label

Simple zone de message

Button

Simple bouton avec une étiquette

Frame

Conteneur pour d’autres objets widget

Toplevel, Tk

Fenêtres primaires gérés par le gestionnaire de fenêtres

Message

Champ d’affichage de texte sur plusieurs lignes

Entry

Simple champ de saisie de texte sur une seule ligne

Checkbutton Bouton à deux états pour les sélections à choix multiples

Radiobutton

Bouton à deux états pour les sélections à choix unique

Scale

Curseur à plusieurs positions

PhotoImage

Objet image pour placer des photos en couleur sur d’autres widgets

BitmapImage Objet image pour placer des images bitmap sur d’autres widgets

Menu

Options associées à un Menubutton ou une fenêtre primaire

Menubutton Bouton qui ouvre un Menu d’options et de sous-menus sélectionnables

Scrol bar

Barre pour faire défiler d’autres widgets (par exemple, Listbox, Canvas,

Text)



Module et outils graphiques tkinter

221

Tableau 21 — (suite)

Listbox

Liste de libel és à sélectionner

Text

Widget pour afficher et modifier du texte sur plusieurs lignes, prenant

en charge des polices de caractères, etc.

Canvas

Zone de dessin permettant de tracer des lignes, des cercles et d’afficher

des photos et du texte, etc.

OptionMenu Composite : liste de sélection déroulante

PanedWindow Interface de fenêtre comportant plusieurs volets

LabelFrame

Cadre avec un titre

Spinbox

Widget permettant une sélection multiple

Scrol edText

Nom Python 2.X (disponible dans le module tkinter.scrolledtext en

Python 3.X) ; composite : texte avec une barre de défilement

Dialog

Nom Python 2.X (disponible dans le module tkinter.dialog en Python

3.X) ; ancienne boîte de dialogue (voir les nouvel es fonctions dans la

section suivante)

Fonctions courantes de boîtes de dialogue

Module tkinter.messagebox (tkMessageBox en Python 2.X)

showinfo(title=None, message=None, **options)

showwarning(title=None, message=None, **options)

showerror(title=None, message=None, **options)

askquestion(title=None, message=None, **options)

askokcancel(title=None, message=None, **options)

askyesno(title=None, message=None, **options)

askretrycancel(title=None, message=None, **options)

Module tkinter.simpledialog (tkSimpleDialog en Python 2.X)

askinteger(title, prompt, **kw)

askfloat(title, prompt, **kw)

askstring(title, prompt, **kw)



222

Chapitre 1. Python précis et concis

Module tkinter.colorchooser (tkColorChooser en Python 2.X)

askcolor(color=None, **options)

Module tkinter.filedialog (tkFileDialog en Python 2.X)

class Open

class SaveAs

class Directory

askopenfilename(**options)

asksaveasfilename(**options)

askopenfile(mode="r", **options)

asksaveasfile(mode="w", **options)

askdirectory(**options)

Les options des fonctions des boîtes de dialogue courantes sont

defaultextension (ajoutée au nom de ficher si elle n’est pas explici-

tement donnée), filetypes (séquence de tuples (label, pattern)),

initialdir (répertoire initial, mémorisé par les classes), initialfile

(fichier initial), parent (fenêtre dans laquelle on place la boîte de

dialogue), et title (titre de la boîte de dialogue).

Outils et classes supplémentaires tkinter

Le tableau 22, Outils supplémentaires tkinter liste certains outils cour-

ramment utilisés qui ne font cependant pas partie des classes de base

et de l’ensemble des boîtes de dialogue standards. Tous ces outils font

partie de la librairie standard, à l’exception de quelques-uns dans la

dernière ligne du tableau (par exemple, Pillow) ; consultez le Web.

Comparaisons entre Tk et tkinter

Le tableau 23, Comparaisons entre Tk et tkinter compare l’API Python

tkinter à la librairie de base Tk exposée par le langage Tcl qui

est à l’origine de Tk. En général, les chaînes de commandes Tcl

correspondent à des objets du langage Python, mais plus précisément,

dans le module Python tkinter, l’interface graphique de Tk diffère

de Tcl sur les points suivants :

Création

Les widgets sont créés comme objets d’instances de classes en

appelant une classe widget.



Module et outils graphiques tkinter

223

Tableau 22 — Outils supplémentaires tkinter

Catégorie d’outil

Outils disponibles

Classes tkinter liées StringVar,

IntVar,

DoubleVar,

BooleanVar

dans

le

à des variables

module(tkinter)

Méthodes

de Méthodes de widgets pack(), grid(), place(), plus options de

gestion

de configuration dans le module

positionnement

Cal backs planifiés

Méthodes de widgets after(), wait(), update() ; cal backs

d’entrée/sortie de fichiers

Autres outils tkinter Accès au presse-papiers ; méthodes de widgets de traitement des

événements de bas niveau bind()/Event ; options des widgets

avec config() ; prise en charge des boîtes de dialogue modales

Extensions tkinter

PMW : widgets supplémentaires ; PIL (appelé aussi Pillow) :

images ; arborescence, polices de caractères, drag-and-drop,

widgets tix, widgets ttk, etc.

Maîtres (parents)

Les parents sont des objets créés préalablement, et passés aux

constructeurs de classes de widgets.

Options des widgets

Les options sont des arguments nommés du constructeur ou de

config(), ou des clés indicées.

Opérations

Les opérations des widgets (actions) deviennent des méthodes

des classes de widgets tkinter.

Callbacks

Les gestionnaires de callbacks peuvent être tout objet appe-

lable : fonction, méthode, lambda, classe avace un méthode

__call__, etc.

Extension

Les widgets sont étendus avec le mécanisme d’héritage des

classes Python.

Composition

Les interfaces sont construites en attachant des objets, et pas

en concaténant des noms.





224

Chapitre 1. Python précis et concis

Variables liées

Les variables associées à des widgets sont des objets de classes

tkinter avec des méthodes.

Tableau 23 — Comparaisons entre Tk et tkinter

Opération

Tcl/Tk

Python/tkinter

Création

frame .panel

panel = Frame()

Maîtres

button .panel.quit

quit = Button(panel)

Options

button .panel.go -fg black

go = Button(panel, fg=’black’)

Configuratio.n

panel.go config -bg red

go.config(bg=’red’) go[’bg’] = ’red’

Actions

.popup invoke

popup.invoke()

Packing

pack .panel -side left -fil x

panel.pack(side=LEFT, fil =X)

OUTILS ET MODULES INTERNET

Cette section résume les fonctionnalités des outils de scripting Internet

en Python 3.X et 2.X. Elle fournit une brève description des modules

Internet les plus couramment utilisés de la librairie standard Python.

Il ne s’agit cependant que d’un échantillon représentatif ; vous devez donc

vous reporter à la documentation de la librairie Python pour une liste

plus complète :

socket

Prise en charge des communications réseau de bas niveau

(TCP/IP, UDP, etc.). Interfaces pour envoyer et recevoir des

données avec les sockets de type BSD : socket.socket()

crée un objet avec des méthodes de gestion des sockets (par

exemple, object.bind()). La plupart des modules gérant des

serveurs et des protocoles utilisent en interne ce module.

socketserver (SocketServer en Python 2.X)

Framework pour gérer le threading et les serveurs réseau.

xdrlib

Encode les données binaires de manière portable (voir aussi

plus haut le module socket évoqué dans cette liste).



Outils et modules Internet

225

select

S’interface avec la fonction Unix et Windows select().

Attend l’activité d’un ensemble de fichiers ou de sockets.

Courramment utilisé pour le multiplexage de plusieurs flux ou

pour implémenter des temporisations. Fonctionne uniquement

pour les sockets sous Windows, pas pour les fichiers.

cgi

Prise

en

charge

des

scripts

CGI

côté

serveur :

cgi.FieldStorage() analyse le flux d’entrée ; cgi.escape()

(et html.escape() dans les versions récentes 3.X) appliques les

conventions d’échappement HTML aux flux de sortie. Pour

analyser et accéder aux informations d’un formulaire : après

l’appel de form=cgi.FieldStorage() par un script CGI, form

est un objet de type dictionnaire avec une entrée par champ

de formulaire (par exemple, form["nom"].value est le texe du

champ nom du formulaire).

urllib.request (urllib, urllib2 en Python 2.X)

Récupère les pages Web et les sorties des scripts

serveur à partir de leurs adresses Internet (les URL) :

urllib.request.urlopen(url) retourne un objet similaire

à un fichier avec des méthodes read, de même que

urllib.request.urlretrieve(remote,

local).

Prend en

charge HTTP, HTTPS, FTP et les URL de fichiers locaux.

urllib.parse (urlparse en Python 2.X)

Analyse la chaîne d’une URL et extrait ses composants.

Contient aussi des outils pour l’échappement du texte des

URL : urllib.parse.quote_plus(str) réalise l’échappement

de l’URL pour le texte inséré dans les flux de sortie HTML.

ftplib

Modules FTP. ftplib fournit des interfaces pour les trans-

ferts de fichiers Internet dans les programmes Python. Après

ftp=ftplib.FTP(’nom_de_site’), ftp a des méthodes pour se

connecter, changer de répertoire, récupérer/stocker des fichiers

et des listings, etc. Prise en charge des transferts au format

binaire et texte ; fonctionne sur toute machine équipée de

Python et d’une connexion Internet.

poplib, imaplib, smtplib

Modules gérant les protocoles de courrier électronique POP,

IMAP et SMTP.



226

Chapitre 1. Python précis et concis

Package email

Analyse et construit des messages de courrier électronique avec

des en-têtes et des pièces jointes. Assure également la prise en

charge de MIME à la fois pour le contenu et les en-têtes.

http.client (httplib en Python 2.X), nntplib, telnetlib

Modules clients pour les protocoles HTTP, NNTP (news) et

Telnet.

http.server (CGIHTTPServer, SimpleHTTPServer en

Python 2.X)

Implémentation du serveur de requêtes HTTP.

Packages xml, html (htmllib en Python 2.X)

Analyse les documents XML et HTML ainsi que le contenu

des pages Web. Le package xml prend en charge DOM, SAX

et les modèles d’analyse ElementTree, avec Expat.

Package xmlrpc (xmlrpclib en Python 2.X)

Protocole d’appel de méthodes distances XML-RPC.

uu, binhex, base64, binascii, quopri

Encode et décode les données binaires (ou autres) transmises

sous la forme de texte.

Le tableau 24 liste certains de ces modules par type de protocole ;

reportez-vous à la liste précédente pour les noms en 2.X qui diffèrent.

Tableau 24 — Sélection par protocole de modules Internet Python 3.X

Protocole

Fonctionnalité

Port

Module Python

HTTP

Pages Web

80

http.client,

url ib.request,

xmlrpc.*

NNTP

News Usenet

119

nntplib

Données par Transferts de fichiers

20

ftplib, url ib.request

défaut FTP

Contrôle FTP Transferts de fichiers

21

ftplib, url ib.request

SMTP

Envoi de courriels

25

smtplib

POP3

Réception de courriels

110

poplib

IMAP4

Réception de courriels

143

imaplib

Telnet

Lignes de commandes

23

telnetlib





Autres modules de la librairie standard

227

AUTRES MODULES DE LA LIBRAIRIE STANDARD

Cette section étudie une série de modules supplémentaires de la librai-

rie standard installée avec Python. Sauf mention contraire, les outils

traités ici s’appliquent à la fois à Python 3.X et 2.X. Reportez-vous

au manuel de la librairie de référence Python pour les détails sur tous

les outils intégrés ainsi qu’au site Web PyPI (décrit dans la section

Conseils divers) ou bien à votre moteur de recherche favori.

Module math

Le module math exporte les outils de la librairie C standard math

afin qu’ils puissent être utilisés en Python. Le tableau 25, Exports du

module math en Python 3.3, liste les fonctions de ce module en Python

3.3, avec sept ajouts récents en 3.2 et 3.3 qui sont indiqués en gras.

Les module Python 2.7 est identique, mais il n’a pas les fonctions log2

ni isfinite. Le contenu de ce tableau peut varier légèrement d’une

version à l’autre. Toutes les entrées sont des fonctions appelables

(avec des parenthèses qui ont été omises ici), à l’exception de pi et e.

Pour

des

détails

supplémentaires,

reportez-vous

à

la

documentation de la librairie Python, ou importez math et exécutez

help(math.nom_fonction) pour les arguments et les commentaires

sur n’importe quel nom de fonction de ce tableau (dir(math) vous

permet de consulter le contenu du module). Consultez aussi le

module de librairie standard cmath pour les fonctions gérant les

nombres complexes, et le système tiers NumPy (ainsi que d’autres)

sur le Web pour des fonctionnalités numériques avancées.

Tableau 25 — Exports du module math en Python 3.3

acos

acosh

asin

asinh

atan

atan2

atanh

ceil

copysign

cos

cosh

degrees

e

erf

erfc

exp

expm1

fabs

factorial

floor

fmod

frexp

fsum

gamma

hypot

isfinite

isinf

isnan

ldexp

lgamma



228

Chapitre 1. Python précis et concis

Tableau 25 — (suite)

log

log10

log1p

log2

modf

pi

pow

radians

sin

sinh

sqrt

tan

tanh

trunc

Module time

Utilitaires pour la gestion des heures et des dates : accès au temps,

mise en forme et temporisations. La liste suivante est une liste

partielle d’exports du module time. Voir aussi les sections Module

datetime, Module timeit, et la documentation de la librairie Python

pour des informations complémentaires :

time.clock()

Retourne le temps CPU ou le temps réel depuis le démarrage

du processus ou depuis le premier appel à clock(). La précision

et la sémantique dépendent de la plateforme (voir le manuel

Python). Retourne des secondes exprimées sous la forme d’un

nombre en virgule flottante. Utile pour le benchmarking et le

minutage des sections de code alternatives.

time.time()

Retourne un nombre en virgule flottante représentant le temps

UTC en secondes écoulées depuis epoch. Sous Unix, epoch est le

1er janvier 1970. Cela permet d’avoir une meilleure précision

que clock() sur certaines plateformes (voir le manuel Python).

time.ctime( secs)

Convertit une heure exprimée en secondes écoulées depuis

epoch en une chaîne représentant l’heure au format local

(par exemple, ctime(time())). L’argument est optionnel et

sa valeur par défaut est l’heure en cours s’il est omis.

time.sleep( secs)

Suspend l’exécution du processus (du thread appelant) pen-

dant secs secondes. secs peut être un nombre en virgule

flottante pour représenter des fractions de secondes.

Les deux fonctions suivantes ne sont disponibles qu’en Python 3.3

et dans les versions ultérieures. Elles sont conçues pour fournir des

données horaires de manière portable (mais elles peuvent ne pas être



Autres modules de la librairie standard

229

directement comparables à certaines fonctions des versions précé-

dentes de Python). Pour ces deux fonctions, le point de référence de

la valeur retournée est indéfini, de telle sorte que seule la différence

entre les appels consécutifs est valide :

time.perf_counter()

Retourne la valeur en fractions de secondes d’un compteur de

performance, défini comme une horloge avec la plus haute

résolution disponible pour mesurer une durée courte. Elle

inclut le temps écoulé durant les états de veille et s’applique

à l’ensemble du système. Elle peut être pensée comme une

horloge murale et, si elle est présente, elle est utilisée par défaut

dans le module timeit.

time.process_time()

Retourne la valeur en fractions de secondes de la somme du

temps système et du temps CPU utilisateur du processus en

cours. Cela n’inclut pas le temps écoulé durant la veille, et par

définition ne concerne que le temps du processus.

Module timeit

Outils portables pour mesurer le temps d’exécution d’une chaîne de code

ou d’un appel de fonction. Voir le manuel Python des informations

détaillées.

Interface en ligne de commande :

py[thon] -m timeit [-n number] [-r repeat]

[-s setup]* [-t] [-c] [-p] [-h] [statement]*

Où number est le nombre de fois où les instructions sont exécutées

(la valeur par défaut est une puissance calculée de 10), repeat

est le nombre d’exécutions à réaliser (la valeur par défaut est 3),

setup (zéro ou plus, chaque valeur avec l’option –s) est le code

à exécuter avant les instrusctions, statement (zéro ou plus) est le

code à exécuter, -h affiche l’aide, et -t, -c, et -p spécifient les

timers à utiliser (time.time(), time.clock(), ou à partir de Python

3.3 time.process_time() ; sinon time.perf_counter() est la valeur

par défaut en 3.3 et dans les versions ultérieures). Les résultats

affichés fournissent le meilleur temps parmi les différentes exécutions

du paramètre repeat, ce qui permet de neutraliser les fluctuations

transitoires de la charge du système.



230

Chapitre 1. Python précis et concis

Interface de l’API de la librairie :

timeit.Timer(stmt=’pass’, setup=’pass’, timer=dflt)

Elle est utilisée par les fonctions suivantes. stmt et setup sont une

chaîne de code (utilisez ; ou \n pour séparer plusieurs instructions,

et des espaces ou \t pour l’indentation), ou un appelable sans

argument. La valeur par défaut de la fonction timer, dflt, dépend de

la plateforme et de la version.

timeit.repeat(stmt=’pass’, setup=’pass’,

timer=dflt, repeat=3, number=1000000)

Crée une instance Timer avec les paramètres stmt et setup ainsi

que la fonction timer, puis exécute sa méthode repeat avec le

compteur repeat pendant number exécutions. Retourne une liste des

résultats du minutage : on prend la fonction min() pour le meilleur

résultat au cours des repeat fois.

timeit.timeit(stmt=’pass’, setup=’pass’,

timer=dflt, number=1000000)

Crée une instance Timer avec les paramètres stmt et setup ainsi

que la fonction timer, puis exécute sa méthode timeit pendant

number exécutions. Exécute une seule fois setup ; retourne le temps

d’exécution de stmt pendant number fois.

Module datetime

Outils pour la gestion des dates : soustraction de dates, ajout de jours

à des dates, et ainsi de suite. Voir aussi la section Module time, et la

documentation de la librairie Python pour les détails.

>>> from datetime import date, timedelta

>>> date(2017, 11, 15) - date(2017, 10, 29) # Entre

datetime.timedelta(17)

>>> date(2017, 11, 15) + timedelta(60)

# Futur

datetime.date(2018, 1, 14)

>>> date(2017, 11, 15) - timedelta(410)

# Passé

datetime.date(2016, 10, 1)



Autres modules de la librairie standard

231

Module random

Fonctions variées de randomisation : nombres alétoires, mélanges, et

sélections. Voir le manuel Python pour des informations détaillées.

>>> import random

>>> random.random() # Nombre aléatoire en virgule flottante

[0, 1)

0.7082048489415967

>>> random.randint(1, 10) # Nombre aléatoire entier [x, y]

8

>>> L = [1, 2, 3, 4]

>>> random.shuffle(L) # Mélange de L

>>> L

[2, 1, 4, 3]

>>> random.choice(L) # Choix d’un élément aléatoire

4

Module json

Utilitaires pour traduire les dictionnaires Python et les structures

de listes vers/depuis du texte au format JSON, qui est un format

portable de représentation de données utilisé par les systèmes comme

MongoDB (par BSON), et SL4A d’Android (dans JSON-RPC). Voir

aussi la sérialisation native d’objets Python dans la section Module

pickle, la prise en charge de XML dans la section Outils et modules

Internet, et les autres concepts de base de données dans la section API

de base de données SQL Python.

>>> R = {’job’: [’dev’, 1.5], ’emp’: {’who’: ’Bob’}}

>>> import json

>>> json.dump(R, open(’savejson.txt’, ’w’))

>>> open(’savejson.txt’).read()

’{"emp": {"who": "Bob"}, "job": ["dev", 1.5]}’

>>> json.load(open(’savejson.txt’))

{’emp’: {’who’: ’Bob’}, ’job’: [’dev’, 1.5]}

>>> R = dict(title=’PyRef5E’, pub=’orm’, year=2014)

>>> J = json.dumps(R, indent=4)

>>> P = json.loads(J)

>>> P

{’year’: 2014, ’title’: ’PyRef5E’, ’pub’: ’orm’}

>>> print(J)

{



232

Chapitre 1. Python précis et concis

"year": 2014,

"title": "PyRef5E",

"pub": "orm"

}

Module subprocess

Outils pour exécuter des lignes de commandes, en introduisant un

de leurs trois flux, en récupérant des codes de sortie, et en spécifiant

l’execution du shell, qui sont des alternatives à certaines fonctions

du module os comme os.popen() et os.spawnv() ; voir la section

Module système os et le manuel Python pour des détails complémen-

taires. Conseil : n’utilisez pas ces outils pour lancer des chaînes de

commandes shell dans lesquelles vous n’avez pas confiance, car elles

peuvent exécuter des commandes autorisées par le processus Python.

Dans le , script suivant m.py affiche sa ligne de commande sys.argv :

>>> from subprocess import call, Popen, PIPE

>>> call(’python m.py -x’, shell=True)

[’m.py’, ’-x’]

0

>>> pipe = Popen(’python m.py -x’, stdout=PIPE)

>>> pipe.communicate()

(b"[’m.py’, ’-x’]\r\n", None)

>>> pipe.returncode

0

>>> pipe = Popen(’python m.py -x’, stdout=PIPE)

>>> pipe.stdout.read()

b"[’m.py’, ’-x’]\r\n"

>>> pipe.wait()

0

Module enum

Disponible à partir de Python 3.4, ce module fournit une prise en

charge standard des énumérations qui sont des ensemble de noms

symboliques (c’est-à-dire des membres) liés à des valeurs de constantes

uniques. Il ne faut pas confondre cela avec la fonction enumerate(),

qui est utilisée pour les résultats de l’itérateur de nombres séquentiels

(voir la section Fonctions intégrées):

>>> from enum import Enum

>>> class PyBooks(Enum):

Learning5E = 2013



Autres modules de la librairie standard

233

Programming4E = 2011

PocketRef5E = 2014

>>> print(PyBooks.PocketRef5E)

PyBooks.PocketRef5E

>>> PyBooks.PocketRef5E.name,

PyBooks.PocketRef5E.value

(’PocketRef5E’, 2014)

>>> type(PyBooks.PocketRef5E)

<enum ’PyBooks’>

>>> isinstance(PyBooks.PocketRef5E, PyBooks)

True

>>> for book in PyBooks: print(book)

...

PyBooks.Learning5E

PyBooks.Programming4E

PyBooks.PocketRef5E

>>> bks = Enum(’Books’, ’LP5E PP4E PR5E’)

>>> list(bks)

[<Books.LP5E: 1>, <Books.PP4E: 2>, <Books.PR5E: 3>]

Module struct

Le module struct fournit une interface pour analyser et construire

des données binaires compactées sous la forme de chaînes, selon des

formats conçus pour être équivalents aux structures du langage C. Il

est souvent utilisé conjointement avec les modes des fichiers binaires

’rb’ et ’wb’ de la fonction open(), ou d’autres sources de données

binaires. Voir la documentation de la librairie Python pour les types

de données format et les codes endian.

chaîne = struct.pack( format, v1, v2, ...)

Retourne une chaîne (un bytes en 3.X et un str en 2.X)

contenant la valeur v1, v2, etc., compactée selon la chaîne

format donnée. L’arguments doit correspondre aux valeurs

requises exactement par les codes des types de la chaîne format.

La chaîne format peut spécifier le format endian du résultat

dans son premier caractère, ainsi que le compteur de répétitions

pour les codes des types individuels.



234

Chapitre 1. Python précis et concis

tuple = struct.unpack( format, chaîne)

Décompacte la chaîne (un bytes en 3.X et un str en 2.X) dans

un tuple de valeurs d’objets Python, selon la chaîne format

donnée.

struct.calcsize( format)

Retourne la taille de la structure (et par conséquent de la

chaîne d’octets) correspondant au format donné.

Vous trouverez ci-dessous un exemple comment compacter et

décompacter des données en utilisant struct en Python 3.X

(Python 2.X utilise des chaînes normales str au lieu de types

bytes ; Python 3.X nécessite des bytes pour les valeurs s à

partir de 3.2, et pas des str ; ’4si’, dans l’exemple suivant, est

identique en C à char[4]+int) :

>>> import struct

>>> data = struct.pack(’4si’, b’spam’, 123)

>>> data

b’spam{\x00\x00\x00’

>>> x, y = struct.unpack(’4si’, data)

>>> x, y

(b’spam’, 123)

>>> open(’data’, ’wb’).write(

struct.pack(’>if’, 1, 2.0))

8

>>> open(’data’, ’rb’).read()

b’\x00\x00\x00\x01@\x00\x00\x00’

>>> struct.unpack(’>if’, open(’data’, ’rb’).read())

(1, 2.0)

Modules de gestion du threading

Les threads sont des processus légers qui partagent la mémoire globale

(c’est-à-dire les portées lexicales et les valeurs internes de l’interpré-

teur) et exécutent des fonctions en parallèle (en même temps) au sein

du même processus. Les modules de threads Python fonctionnent de

manière portable entre les plateformes. Ils sont conçus pour exécuter

des tâches non bloquantes dans des contextes d’entrées/sorties et

d’interface utilisateur.





API de base de données SQL Python

235

Voir aussi setcheckinterval() et setswitchinterval() dans la

section Module sys, ainsi que le module de librairie standard multi-

processing qui implémente de manière portable une API de gestion

des threads pour les processus engendrés :

_thread (nommé thread en Python 2.X)

Module de thread basique et de bas niveau, avec des

outils pour démarrer, arrêter et synchroniser des fonctions

exécutées

en parallèle.

Pour engendrer un thread :

_thread.start_new_thread(fonction,

args

[,

kargs])

exécute fonction dans un nouveau thread, avec des arguments

positionnels à partir du tuple args, et des arguments nommés

à partir du dictionnaire kargs. start_new_thread est un

synonyme pour start_new (qui est documenté comme étant

obsolète en 3.X). Pour synchroniser les threads, utilisez

des verrous de thread : lock=thread.allocate_lock();

lock.acquire(); update-objects; lock.release().

threading

Le module threading se base sur thread pour fournir des

outils personnalisables de threading : Thread, Condition, Sema-

phore, Lock, Timer, threads des démons, jointures de threads

(attentes), etc. Sous-classez Thread pour surcharger la méthode

d’action run. Cest fonctionnellement plus riche que _thread,

mais cela nécessite aussi plus de code que dans les exemples

plus simples.

queue (nommé Queue en Python 2.X)

File d’attente FIFO multiproducteur, multiconsommateur

d’objets Python particulièrement utile pour les applications

employant des threads. Verrouille automatiquement ses

opérations get() et put() pour synchroniser l’accès aux

données de la file d’attente. Voir la documentation de la

librairie Python.

API DE BASE DE DONNÉES SQL PYTHON

L’API Python de base de données relationnelle SQL offre la porta-

bilité des scripts entre les différentes versions des bases de données

SQL du marché. Pour chaque éditeur, installez le module d’extension

spécifique à l’éditeur, mais écrivez vos scripts en vous conformant

à l’API portable de base de données. Vos scripts au standard SQL



236

Chapitre 1. Python précis et concis

pourront majoritairement continuer à fonctionner sans modifications

après avoir migré pour un autre éditeur de base de données.

Notez que la plupart des modules d’extension de base de données

ne font pas partie de la librairie Python standard ; il s’agit de compo-

sants tiers qui doivent être récupérés, puis installés séparément. Il y a

cependant une exception : la version SQLite qui est incluse en tant

que module de librairie Python standard, sqlite3, et qui est conçue

pour le stockage et le prototypage des données.

Voir aussi la section Modules de persistance des objets pour des

alternatives de stockage plus simples. Il existe d’autres outils de base

de données populaires, notamment MongoDB, qui permet de stocker

des documents au format JSON ; on trouve aussi des bases de données

orientées objet, comme ZODB, d’autres outils, comme SQLAlchemy

et SQLObject, ainsi que des API orientées stockage en ligne, comme

le magasin de donnés de App Engine.

Exemple d’utilisation de l’API

L’exemple suivant utilise le module SQLite, et omet certaines valeurs

de retour afin de le rendre plus concis. Les utilisations de base de

données professionnelles, comme MySQL, PostgreSQL et Oracle sont

similaires, mais nécessitent des paramètres de connexion différent et

l’installation de modules d’extension, qui peuvent prendre en charge

des extensions SQL spécifiques à un éditeur qui ne sont pas portables :

>>> from sqlite3 import connect

>>> conn = connect(r’C:\code\temp.db’)

>>> curs = conn.cursor()

>>> curs.execute(’create table emp (who, job, pay)’)

>>> prefix = ’insert into emp values ’

>>> curs.execute(prefix + "(’Bob’, ’dev’, 100)")

>>> curs.execute(prefix + "(’Sue’, ’dev’, 120)")

>>> curs.execute("select * from emp where pay > 100")

>>> for (who, job, pay) in curs.fetchall():

...

print(who, job, pay)

...

Sue dev 120

>>> result = curs.execute("select who, pay from emp")

>>> result.fetchall()



API de base de données SQL Python

237

[(’Bob’, 100), (’Sue’, 120)]

>>> query = "select * from emp where job = ?"

>>> curs.execute(query, (’dev’,)).fetchall()

[(’Bob’, ’dev’, 100), (’Sue’, ’dev’, 120)]

Interface du module

Les sections suivantes fournissent une liste partielle des exports ;

reportez-vous à la documentation complète de l’API disponible à

http://www.python.org pour les détails ignorés ici. Voici les principaux

outils de l’interface du module (dbmod) :

dbmod.connect(paramètres...)

Constructeur d’un objet connexion (conn) qui représente

une connexion à la base de données. Les paramètres sont

spécifiques à l’éditeur.

dbmod.paramstyle

Chaîne fournissant le type de mise en forme des marqueurs de

paramètres (par exemple, style qmark = ?).

dbmod.Warning

Exception levée pour les avertissements importants, comme la

perte de données.

dbmod.Error

Exception qui est la classe de base de toutes les autres excep-

tions indiquant des erreurs.

Objets connexion

Les objets connexion (conn) répondent aux méthodes suivantes :

conn.close()

Ferme la connexion immédiatement (plutôt que lors de l’appel

de __del__).

conn.commit()

Valide toutes les transactions en attente dans la base de

données.

conn.rollback()

Effectue un rollback de la base de données et revient au

point de départ de la transaction en attente ; la fermeture

d’une connexion sans validation préalable des modifications

provoque un rollback implicite.



238

Chapitre 1. Python précis et concis

conn.cursor()

Retourne un nouvel objet curseur (curs) pour la soumission

d’une chaîne SQL à la connexion.

Objets curseur

Les objets curseur (curs) représentent des curseurs de base de données,

qui sont utilisés pour gérer le contexte d’une opération d’accès aux

données :

curs.description

Séquence de séquences de sept éléments, chaque élément

contenant des informations qui décrivent une colonne de résul-

tat : (nom, type_de_code, taille_affichage, taille_interne,

précision, échelle, null_ok).

curs.rowcount

Spécifie le nombre de lignes produites par la dernière variante

execute* (pour les instructions DQL comme select) ou le

nombre de lignes modifiées (pour les instructions DML comme

update ou insert).

curs.callproc(nom_procédure [, paramètres])

Appelle une procédure stockée dont le nom est passé en

paramètre. La séquences des paramètres doit contenir une

entrée pour chaque argument attendu par la procédure ; le

résultat est retourné sous la forme d’une copie modifiée des

entrées.

curs.close()

Ferme le curseur immédiatement (plutôt que lors de l’appel de

__del__).

curs.execute(opération [, paramètres])

Prépare et exécute une opération de base de données (requête

ou commande) ; les paramètres peuvent être spécifiés sous la

forme d’une liste de tuples pour insérer plusieurs lignes en

une seule opération (mais il est préférable d’utiliser execute-

many()).

curs.executemany(opération, séquence_de_paramètres)

Prépare une opération de base de données (requête ou com-

mande) et l’exécute avec tous les paramètres de la séquence

ou des mappings de la séquence séquence_de_paramètres.

Équivalent à plusieurs appels de execute().





Conseils supplémentaires

239

curs.fetchone()

Récupère la ligne suivante d’un ensemble de lignes résultant

d’une requête, en retournant une seule séquence, ou None

quand il n’y a plus de données disponibles. Utile pour les grands

ensembles de données ou si la base de données est lente.

curs.fetchmany([size= curs.arraysize])

Récupère l’ensemble suivant de lignes d’un résultat de requête,

en retournant une séquence de séquences (par exemple, une

liste de tuples). Une séquence vide est retournée quand il n’y

a plus de données disponibles.

curs.fetchall()

Récupère toutes les lignes (ou toutes celles qui restent) d’un

résultat de requête, en les retournant sous la forme d’une

séquence de séquences (par exemple, une liste de tuples).

Objets types et constructeurs

Date(année, mois, jour)

Construit un objet stockant une date.

Time(heure, minute, seconde)

Construit un objet stockant une valeur horaire.

None

Les valeurs SQL NULL sont représentées par la valeur Python

None en entrée et en sortie.

CONSEILS SUPPLÉMENTAIRES

Cette section présente brièvement des conseils d’utilisation ainsi que

des astuces de codage courantes qui vont au-delà de celles qui sont

dispensées tout au long de cet ouvrage. Consultez la documentation

Python (http://www.python.org/doc/) et le Web pour des informations

complémentaires sur les sujets évoqués ici.

Conseils de base concernant le langage

• S[:] réalise une copie de haut niveau (shallow) d’une

séquence ; copy.deepcopy(X) réalise des copies complètes ;

list(L) et D.copy() copie des listes et des dictionnaires (voir

L.copy() pour les listes à partir de 3.3).



240

Chapitre 1. Python précis et concis

• L[:0]=itérable insère plusieurs éléments dans un itérable au

début de la liste L.

• L[len(L):]=itérable, L.extend(itérable), et L+=itérable

insèrent plusieurs éléments dans un itérable à la fin de la liste

L.

• L.append(X) et X=L.pop() peuvent être utilisés pour implémen-

ter des opérations de piles, où X une pile d’éléments et la fin de

la liste est le sommet de la pile.

• Utilisez for key in D.keys() pour parcourrir les dictionnaires

ou simplement for key in D dans la version 2.2 et dans les

versions ultérieures. En Python 3.X, ces deux formes sont

équivalentes, puique keys() retourne une vue itérable.

• Utilisez for key in sorted(D) pour parcourrir les clés des

dictionnaires de façon triée en version 2.4 et dans les versions

ultérieures ; la forme K=D.keys(); K.sort(); for key in K:

fonctionne aussi en Python 2.X mais pas en Python 3.X,

puisque les résultats de keys() sont des objets vue, pas des

listes.

• X=A or B or None assigne X au premier objet vrai parmi A et B,

ou None si les deux sont faux (c’est-à-dire sont égaux à 0 ou

vides).

• X,Y = Y,X permute les valeurs de X et Y sans nécessiter l’assigna-

tion de X à une valeur temporaire explicit.

• red, green, blue = range(3) assigne une série d’entiers sous

la forme d’une énumération simple de noms ; les attributs de

classes et les dictionnaires peuvent aussi servir d’énumérations.

En Python 3.4 et dans les versions ultérieures, reportez-vous

aux énumérations plus riches et plus fonctionnelles du module

standard enum.

• Utilisez les isntructions try/finally pour garantir qu’un code

de fin est exécuté ; ceci est particulièrement utile pour les

opérations de verrouillage (par exemple, pose d’un verrou avant

l’instruction try, et libération du verrou dans le bloc finally).

• Utilisez les instructions with/as pour garantir que le code

de fin spécifique à un objet est exécuté pour les objets qui

prennent en charge uniquement le protocole de gestionnaire

de contextes (par exemple, fermeture automatique de fichier,

libération automatique de verrou sur un thread).



Conseils supplémentaires

241

• Incorporez les itérables dans un appel à list() pour visualiser

les résultats de manière interactive en Python 3.X, et pour vous

assurer que les traversées multiples fonctionnent correctement ;

cela inclut range(), map(), zip(), filter(), dict.keys(), et

d’autres encore.

Conseils concernant l’environnement

• Utilisez if __name__ == ’__main__’: pour ajouter du code de

test ou pour appeler une foncton principale à la fin des fichiers

d’un module ; cette expression est vraie uniquement quand

un fichier est exécuté, pas quand il est importé en tant que

composant de librairie.

• Pour charger le contenu d’un fichier en une seule expression,

utilisez data=open(filename).read(). En dehors de CPython,

les appels explicites de fermeture peuvent être nécessaires pour

forcer une récupération immédiate des ressources système (par

exemple, dans des boucles).

• Pour parcourir les lignes d’un fichier texte, utilisez for line in

file en version 2.2 et dans les versions ultérieures (dans les ver-

sions plus anciennes, utilisez for line in file.xreadlines()).

• Pour récupérer les arguments de la ligne de commande, utilisez

sys.argv.

• Pour accéder aux paramètres d’environnement du shell, utilisez

os.environ.

• Les

flux standards

sont :

sys.stdin,

sys.stdout

et

sys.stderror.

• Pour retourner une liste de fichiers correspondant à un motif

donné, utilisez : glob.glob(pattern).

• Pour retourner une liste de fichiers et de sous-répertoires d’un

chemin (par exemple, “.”), utilisez : os.listdir(path).

• Pour parcourir la totalité de l’arborescence de répertoires,

utilisez os.walk() en Python 3.X et 2.X (os.path.walk() est

aussi disponible uniquement en Python 2.X).

• Pour exécuter des commandes du shell dans des scripts

Python,

vous

pouvez

utiliser

os.system(cmdline),

output=os.popen(cmdline, ’r’).read(). La dernière forme

lit la sortie standard du programme, et peut aussi être utilisée

pour la lecture ligne à ligne et les opérations d’intercalage.



242

Chapitre 1. Python précis et concis

• D’autres flux sont disponibles dans le module subprocess à la

fois en Python 3.X et 2.X, et les appels à os.popen2/3/4() uni-

quement en Python 2.X. Les fonctions os.fork()/os.exec*()

ont des effets similaires dans les plateformes Unix.

• Pour qu’un fichier devienne un script exécutable dans une

plateforme Unix, ajouter une ligne semblable à #!/usr/bin/env

python ou #!/usr/local/bin/python au sommet du fichier et

accordez-lui les permissions d’un ficher exécutable avec une

commande chmod.

• Sous Windows, on peut cliquer sur un fichier pour l’exécuter

directement si les associations des noms de fichiers sont cor-

rectement enregistrées. À partir de la version 3.3, le lanceur

Windows reconnaît aussi les lignes #! de style Unix : voir la

section Utilisation du lanceur Windows.

• print() et input() (appelées print et raw_input() en Python

2.X) utilisent les flux sys.stdout et sys.stdin : assignez-les à

des objets semblables à des fichiers pour rediriger en interne les

entrées/sorties, ou bien utilisez la forme print(..., file=F)

en Python 3.X (ou la forme print >> F, ... en Python 2.X).

• Définissez la variable d’environnement PYTHONIOENCODING à

utf8 (ou une autre valeur) si votre scripts n’arrive pas à afficher

le texte Unicode non-ASCII, comme les noms de fichiers et

leur contenu.

Conseils d’utilisation

• Utilisez from __future__ import nom_de_fonctionnalité pour

activer les modifications en attente du langage qui pourraient

faire planter le code existant, mais activez la compatibilité de

version.

• Les intuitions concernant les performances des programmes en

Python sont en général fausses : faites toujours des tests avant

d’optimiser ou de migrer en C. Utilisez les modules profile,

time et timeit (ainsi que cProfile).

• Consultez les modules unittest (appelé aussi PyUnit) et doc-

test les outils de tests automatisés livrés avec la librairie

Python standard ; unittest est un framework sophistiqué ;

doctest analyse les chaînes de documentation pour des tests et

des résultats afin d’exécuter à nouveau des sessions interactives.



Conseils supplémentaires

243

• La fonction dir([objet]) est utile pour inspecter les espaces

de noms des attributs ; print(objet.__doc__) fournit une

documentation brute des chaînes de documentation.

• La fonction help([objet]) fournit une aide interactive pour les

modules, les fonctions, les types, les méthodes des types, etc. ;

help(str) fournit de l’aide sur le type str ; help(’module’)

fournit de l’aide sur les modules même s’ils n’ont pas encore été

importés ; et help(’sujet’) fournit de l’aide sur des mots-clés

et certains sujets (utilisez ’topics’ pour une liste des rubriques

d’aide).

• Consultez le module pydoc et le script livré avec Python pour

extraire et afficher les chaînes de documentation associées aux

modules, fonctions, classes, et méthodes ; python -m pydoc -b

lance l’interface du navigateur PyDoc à partir de 3.2 (sinin

utilisez à la place –g de l’option –b pour le mode de client

graphique).

• Voir la section Avertissements, ainsi que l’option -W de la

section Options de la commande Python, pour des détails sur la

désactivation des avertissements sur les fonctionnalités bientôt

obsolètes émis par l’interpréteur.

• Consultez Distutils, eggs, et les lignes suivantes pour les autres

options de distribution des programmes Python.

• Consultez PyInstaller, py2exe, cx_freeze, py2app, etc. pour le packaging des programmes Python en tant que fichiers exécutables autonomes (par exemple, fichiers .exe sous Windows).

• Consultez NumPy, SciPy, Sage et les packages liés aux exten-

sions qui transforment Python en outil de programmation

scientifique ou numérique avec des objets vecteur, des librairies

mathématique, etc. Regardez aussi du côté du nouveau module

statistics en Python 3.4.

• Consultez ZODB ainsi que d’autres pour une prise en com-

plète des bases de données orientées objet qui permettent à

Python le stockage natif des objets avec des clés, mais aussi

SQLObject, SQLAlchemy, etc. pour d’autre bases de données

relationnelles qui autorisent l’utilisation des classes avec des

tables relationnelles. Consultez MongoDB pour une base de

données au format JSON qui ne soit pas standard SQL.



244

Chapitre 1. Python précis et concis

• Consultez Django, App Engine, Web2py, Zope, Pylons, Turbo-Gears ainsi que d’autres frameworks de développement Web

pour Python.

• Consultez SWIG (parmi d’autres) pour la génération automa-

tique de code faisant le lien entre les librairies C et C++ dans

les scripts Python.

• Consultez IDLE pour un IDE graphique livré avec Python, doté

d’un éditeur avec une coloration syntaxique, des explorateurs

d’objets, un débogueur, etc. ; regardez aussi du côté de Python-

Win, Komodo, Eclipse, NetBeans et d’autres IDE.

• Consultez l’aide d’ Emacs pour des astuces sur l’édition et

l’exécution du code dans l’éditeur Emacs. La plupart des

autres éditeurs prennent également en charge Python (par

exemple, l’indentation automatique, la coloration syntaxique),

notamment VIM et IDLE ; une page est consacrée aux éditeurs

Python à http://www.python.org.

• Pour le portage du code en Python 3.X, utilisez l’option de ligne

de commande 3 en Python 2.X pour émettre des avertissements

d’incompatibilité, et consultez le script 2to3, qui convertit

automatiquement la plus grande partie du code 2.X en code

Python 3.X. Voir aussi six, un système qui fournit une couche

de compatibilité 2.X/3.X, 3to2, qui aspire à convertir le code

3.X pour qu’il s’exécute sur des interpréteurs 2.X, et pies, qui

favorise aussi la compatibilité entre les différentes versions.

Conseils divers

• Sites Web auxquels il est intéressant de se référer :

– http://www.python.org (le site officiel de Python)

– http://www.python.org/pypi

(outils

Python

supplémentaires)

– http://learning-python.com/books (le site de l’auteur de cet

ouvrage)

• Philosophie Python : import this.

• Vous devez écrire spam et eggs au lieu de foo et bar dans les

exemples Python.

• Voyez toujours le bon côté des choses.





Index

A

attributs intégrés 174

avertissement 172

__abs__ 20, 132

abs, fonction 137

__add__ 18, 20, 129

B

alétoire 231

-B, option Python 4

all, fonction 137

-b, option Python 4

and 17

base de données

__and__ 20, 130

curseurs 238

any, fonction 137

base de données relationnelle

apply, fonction 159

235

argument

BaseException, exception 164

arbitraire 78

__bases__ 175

format 85

basestring, fonction 159

nommé 78

bin, fonction 138

nommé en Python 3.X 86

binaire

positionnel 78

méthodes 129

ArithmeticError, exception 165

méthodes augmentées 131

ascii, fonction 137, 158

méthodes du côté droit 130

assert, instruction 105

bloc 69

AssertionError, exception 166

BlockingIOError, exception 170

assignation 74

boîte de dialogue 221

augmentée 75

bool 67

séquence 76

__bool__ 123, 134

attribut 108

bool, fonction 138

pseudoprivé 113

booléen 67

AttributeError, exception 166

boucle 82



246

Python

break, instruction 83

modèle de substitution 35

BrokenPipeError, exception 171

syntaxe de la méthode de

buffer, fonction 159

formatage 33

BufferError, exception 165

Unicode 44

bytearray

chemin 202

méthodes Python 3.X 36

nom 195

bytearray, fonction 138

ChildProcessError, exception

bytes

170

méthodes Python 3.X 36

chr, fonction 139

__bytes_ 134

__class__ 115, 175

__bytes__ 123

class, instruction 98

bytes, fonction 138

classe 112

BytesWarning, exception 172

attributs privés 114

création 98

de base 98

C

décorateur 99

__call__ 123

méthodes 121

callable, fonction 139

nouveau style 114

casse, sensibilité 71

nouveau type en Python

cgi 225

3.X 114

chaîne 25

opérations 120

codes des types de

classmethod, fonction 139

formatage 31

closure 110

constantes 186

__cmp__ 135

conversion 68

__cmp__ 17

expressions de formatage 29

cmp, fonction 160

méthode de formatage 31

code d’échappement 28

méthodes 185

__coerce__ 136

méthodes de

coerce, fonction 160

concaténation 41

collection 65

méthodes de découpage 41

commentaire 70

méthodes de formatage 41

compile, fonction 139

méthodes de recherche 40

__complex__ 20, 132

méthodes de test de

complex, fonction 140

contenu 43

compréhension

méthodes Python 3.X 37

expression 54

mise en forme 29

conn.close 237



Index

247

conn.commit 237

D

conn.cursor 238

-d, option Python 4

ConnectionAbortedError,

date 230

exception 171

datetime, module 230

ConnectionError, exception 170

dbm, module 212

ConnectionRefusedError,

dbmod.connect 237

exception 171

dbmod.Error 237

ConnectionResetError,

dbmod.paramstyle 237

exception 171

dbmod.Warning 237

connexion, objet de base de

D.clear 57

données 237

D.copy 57

conn.rollback 237

décorateur 88, 99

constantes de portabilité 188

def, instruction 84

__contains__ 18, 127

définition

__contains__ 18

format des arguments 85

contexte

__del__ 122

gestionnaire 106

del, instruction 84

protocole de gestionnaire

__delattr__ 124

107

delattr, fonction 140

continue, instruction 84

__delete__ 133

contrôle de flux 69

__delitem__ 19, 129

conversion de types 67

__delslice__ 136

courrier électronique 226

__delslice__ 18

CPython 2

DeprecationWarning, exception

172

curs.callproc 238

descripteur

curs.close 238

méthodes 132

curs.description 238

DFLR 115

curseur, objet de base de données

D.get 57

238

D.has_key 58

curs.execute 238

__dict__ 175

curs.executemany 238

dict, fonction 140

curs.fetchall 239

dict.fromkeys 58

curs.fetchmany 239

dictionnaire 55

curs.fetchone 239

littéraux 56

curs.rowcount 238

opérations 56



248

Python

__dir__ 127

enumerate, fonction 140

dir, fonction 140

EnvironmentError, exception

D.items 57

173

D.iteritems 58

environnement

__div__ 136

utilitaires 191

__div__ 20

EOFError, exception 166

__divmod__ 20, 130

__eq__ 125

divmod, fonction 140

erreur

D.keys 57

traitement 101

documentation 70

DOM 226

espace 70

D.pop 57

espace de noms 108

D.popitem 57

eval, fonction 141

D.setdefault 57

exception 101

D.update 57

chaînée 103

D.values 57

classes 104

D.viewitems 58

déclenchement 103

superclasses 164

E

Exception, exception 165

E "__add__, 20

exceptions d’avertissement 172

-E, option Python 4

exceptions intégrées 164

échappement 27

Python 2.X 174

Ellipsis 67

Python 3.2 173

ensemble 65

exceptions OSError 170

appartenance 66

exceptions spécifiques 166

différence 66

exec, fonction 141, 159

intersection 66

execfile, fonction 160

littéraux 65

__exit__ 134

mise à jour 66

expression

opérations 66

instruction 77

sous-ensemble 66

sur-ensemble 66

lambda 87

union 66

expression générateur 53

__enter__ 133

expression régulière 204

entier 22

motif 207

enum, module 232

syntaxe des motifs 209



Index

249

F

génératrice en Python 3.X

91

False 16

valeur par déaut des

fichier 60, 147, 163

attributs 87

attributs 63

fonctions intégrées 137

descripteurs 193

Python 2.X 158

gestionnaires de contextes

fonctions mathématiques 227

63

for, instruction 82

méthodes 61

__format__ 123

nom 195

format, fonction 142

opérations 215

from, instruction 96

ouverture 148, 190, 194,

214

frozenset, fonction 142

utilisation 64

ftplib 225

file.close 62

FutureWarning, exception 172

file.closed 63

FileExistsError, exception 171

G

file.fileno 63

__ge__ 125

file.flush 63

file.isatty 63

GeneratorExit, exception 167

file.mode 63

gestionnaire de contextes

file.name 63

méthodes 133

FileNotFoundError, exception

__get__ 133

171

__getattr__ 115, 124

file.seek 62

getattr, fonction 142

file.tell 62

__getattribute__ 115, 125

file.truncate 63

__getitem__ 18, 19, 128

filter, fonction 141

__getslice__ 135

__float__ 20, 132

__getslice__ 18

float, fonction 142

global, instruction 92

FloatingPointError, exception

globals, fonction 142

166

__gt__ 125

__floordiv__ 20, 130

fonction

H

annotation en Python 3.X

86

-h, option Python 4

décorateur 88

hasattr, fonction 142

factory 89

__hash__ 123



250

Python

hash, fonction 142

__imul__ 131

help, fonction 143

indentation

héritage

règles 69

DFLR 115

IndentationError, exception 167

graphe en diamant 117

__index__ 132, 134

MRO 116

IndexError, exception 167

nouvel algorithme 117

infile.read 61

nouvel ordre de priorité 119

infile.readline 61

règles 113

infile.readlines 61

règles formelles 115

__init__ 122

__hex__ 136

input, fonction 143, 160

hex, fonction 143

instance 112

HTML 226

instance, objet 99

http.client 226

__instancecheck__ 127

http.server 226

instruction 70, 73

assignation 74

I

expression 77

int 22

-i, option Python 4

__int__ 20, 132

__iadd__ 131

int, fonction 144

__iand__ 131

intern, fonction 161

id, fonction 143

Internet

if, instruction 82

modules 224, 226

__ifloordiv__ 131

InterruptedError, exception 171

__ilshift__ 131

__invert__ 20, 132

imaplib 225

IOError, exception 174

immutable 22, 25, 59, 65

__ior__ 131

__imod__ 131

__ipow__ 131

import

IronPython 2

algorithme 95

__irshift__ 131

chemin 93

IsADirectoryError, exception

package 94

171

relatif 97

isinstance, fonction 144

__import__ 143

issubclass, fonction 144

import, instruction 93

__isub__ 131

ImportError, exception 167

__iter__ 18, 52, 128

ImportWarning, exception 172

__iter__ 18



Index

251

iter, fonction 144

ligne de commande 4

itérable 52

-3, option 8

itérateur 52

arguments 7

itération

-c, option 6

protocole 52

-m, option 6

__itruediv__ 131

-, option 6

__ixor__ 131

programme à exécuter 6

-Q, option 7

J

-R, option 8

json, module 231

-t, option 7

Jython 2

-tt, option 7

L.index 49

K

L.insert 49

list, fonction 145

KeyboardInterrupt, exception

liste 48

167

compréhensions 51

KeyError, exception 167

expressions de

compréhensions 50

L

opérations 49

lambda 87

locals, fonction 145

lanceur

long 22

directives de fichiers 11

__long__ 136

lignes de commandes 11

__long__. 20

variables d’environnement

long, fonction 161

12

LookupError, exception 165

lanceur Windows 10

L.pop 50

L.append 49

L.remove 50

L.clear 50

L.reverse 49

L.copy 50

__lshift__ 20, 130

L.count 50

L.sort 49

__le__ 125

__len__ 18, 19, 127

__lt__ 125

len, fonction 145

L.extend 49

M

librairie standard

modules 175

map, fonction 51, 145



252

Python

mapping 55

motif

méthodes 127

expression régulière 207

opérations 56

séquences spéciales 212

match, objet du module re 208

syntaxe 210

math, module 227

__mro__ 175

max, fonction 146

MRO 116, 117

MemoryError, exception 167

__mul__ 18, 20, 129

memoryview, fonction 146, 159

mutable 48, 55, 65

__metaclass_ 137

métaclasse 100

méthode

N

binaire 129

__name__ 175

binaire augmentée 131

NameError, exception 167

surchargement d’opérateur

120

__ne__ 125

surchargement des noms

__neg__ 20, 132

121

__new__ 121

min, fonction 146

__next__ 52, 128, 134

mobj, objet match 208

next, fonction 146

mobj.endpos 208

nom

mobj.expand 209

format 71

mobj.group 208

non qualifié 109

mobj.groupdict 208

qualifié 108

mobj.groups 208

nombre 22

mobj.pos 208

méthodes 129, 132

mobj.re 208

nommage 71

mobj.span 209

conventions 72

mobj.start 208

None 67

mobj.string 208

nonlocal, instruction 92

__mod__ 20, 130

__nonzero__ 135

modèle de programmation 1

NotADirectoryError, exception

module 93, 175

171

attributs privés 113

NotImplemented 67

import 96

NotImplementedError,

mot réservé 71, 72

exception 167



Index

253

O

os.defpath 189

os.devnull 189

-O, option Python 5

os.dup 193

object, fonction 147

os.dup2 193

objet

os.environ 191

persistance 212

os.error 188

programmation 112

OSError, exception 165, 174

__oct__ 136

os.execl 199

oct, fonction 147

os.execle 199

-OO, option Python 5

os.execlp 199

open, fonction 60, 147, 163

os.execv 200

opérateur

os.execve 200

binaire 129

os.execvp 200

booléen 16, 17

os.execvpe 200

de comparaison 17

os._exit 200

dictionnaire 19

os.extsep 189

mapping 19

os.fdopen 193

numérique 20

os.fork 200

priorité 14

os.fstat 194

surchargement 120

os.ftruncate 194

type séquence 18, 20

os.getcwd 192

type séquence mutable 19

os.getenv 192

utilisation 13

os.geteuid 200

opérateurs

os.getpid 200

catégories 16

os.getppid 200

or 17

os.getuid 200

__or__ 20, 130

os.isatty 194

ord, fonction 151

os.kill 201

os, module 186

os.linesep 189

os.abort 199

os.link 195

os.access 198

os.listdir 196

os.altsep 189

os.lseek 194

os.chdir 192, 195

os.lstat 196

os.chmod 195

os.makedirs 197

os.chown 195

os.mkdir 196

os.close 193

os.mkfifo 196, 201

os.curdir 189

os.name 188



254

Python

os.nice 201

os.read 195

os.open 194

os.readlink 197

options 195

os.remove 197

os.pardir 189

os.removedirs 197

os.path 188

os.rename 197

os.path, module 202

os.renames 197

os.path.abspath 202

os.rmdir 197

os.path.basename 202

os.sep 189

os.path.commonprefix 202

os.spawn 191

os.path.dirname 203

os.spawnv 201

os.path.exists 203

os.spawnve 201

os.path.expanduser 203

os.startfile 190

os.path.expandvars 203

os.stat 197

os.path.getatime 203

os.strerror 192

os.path.getmtime 203

os.symlink 198

os.path.getsize 203

os.system 190

os.path.isabs 203

os.times 192

os.path.isdir 203

os.umask 192

os.path.isfile 203

os.uname 192

os.path.islink 203

os.utime 198

os.path.ismount 203

os.wait 202

os.path.join 203

os.waitpid 202

os.path.normcase 203

os.walk 198

os.path.normpath 204

os.write 195

os.path.realpath 204

outfile.write 62

os.path.samefile 204

outfile.writelines 62

os.path.sameopenfile 204

OverflowError, exception 168

os.path.samestat 204

os.pathsep 189

P

os.path.split 204

os.path.splitdrive 204

package 94

os.path.splitext 204

espaces de noms 95

os.path.walk 204

pass, instruction 83

os.pipe 195, 201

pattern, objet du module re 207

os.plock 201

PendingDeprecationWarning,

os.popen 190

exception 172

os.putenv 191

PermissionError, exception 171



Index

255

persistance 212

Python

pickle, module 212, 216

conseils 239

pickle, objet 217

conseils d’utilisation 242

pickling 216

environnement 241

pipe 195

instructions 73

pobj, objet pattern 207

langage 239

pobj.flags 207

pobj.groupindex 207

ligne de commande 4

pobj.pattern 207

options de la ligne de

poplib 225

commande 4

portabilité 188, 202

syntaxe 69

portée

Python 2.X

englobante 111

instructions 107

globale 109

Python 3.X

imbriquée 110

mots réservés 72

intégrée 109

PYTHONCASEOK, variable 9

lexicale 108, 109

PYTHONDEBUG, variable 10

locale 109

PYTHONDONTWRITEBYTECODE,

noms non qualifiés 110

variable 10

règles 108

PYTHONFAULTHANDLER,

__pos__ 20, 132

variable 9

__pow__ 20, 130

PYTHONHASHSEED,

pow, fonction 151

variable 9

print, fonction 151, 159

PYTHONHOME, variable 9

print, instruction 79

PYTHONINSPECT, variable 10

Python 2.X 81

priorité des opérateurs 14

PYTHONIOENCODING,

variable 9

ProcessLookupError, exception

171

PYTHONNOUSERSITE,

processus

variable 10

contrôle 199

PYTHONOPTIMIZE, variable

programmation orientée objet

10

112

PYTHONPATH, variable 8

property, fonction 151

PYTHONSTARTUP, variable 9

protocole d’itération 52

PYTHONUNBUFFERED,

PyPy 2

variable 10



256

Python

PYTHONVERBOSE, variable

re.subn 206

10

return, instruction 89

PYTHONWARNINGS,

__reversed__ 129

variable 10

reversed, fonction 152

__rfloordiv__ 130

Q

__rlshift__ 130

__rmod__ 130

-q, option Python 5

__rmul__ 130

rollback 237

R

__ror__ 130

__round_ 134

__radd__ 130

__round__ 132

raise, instruction 103

round, fonction 152

en Python 2.X 104

__rpow__ 130

__rand__ 130

__rrshift__ 130

random, module 231

__rshift__ 20, 130

range, fonction 152

__rsub__ 130

raw, fonction 161

__rtruediv__ 130

__rdivmod__ 130

RuntimeError, exception 168

re, module 204

RuntimeWarning, exception 172

re.compile 205

__rxor__ 130

re.escape 207

ReferenceError, exception 168

re.findall 206

S

re.finditer 207

-S, option Python 5

règles de nommage 71

-s, option Python 5

règles syntaxiques 69

SAX 226

reload, fonction 161

S.capitalize 41

re.match 206

S.casefold 42

répertoire

S.center 42

arborescence 198

S.count 40

__repr__ 122

select 225

repr, fonction 152

S.endswith 40

re.search 206

séquence 59

ResourceWarning, exception 172

assignation 76

re.split 206

conversion 68

re.sub 206

méthodes 127



Index

257

__set__ 133

S.swapcase 42

set, fonction 153

Stackless 2

__setattr__ 124

staticmethod, fonction 154

setattr, fonction 153

S.title 43

__setitem__ 19, 129

StopIteration 52

__setslice__ 135

StopIteration, exception 168

__setslice__ 18

str 25

S.expandtabs 41

__str__ 123

S.find 40

str, fonction 154

S.format 41

S.translate 43

shell

string 25

commandes 189

codes des types de

shelve, module 213

formatage 31

S.index 40

constantes 186

S.is* 43

conversion 68

S.join 41

expressions de formatage 29

slice, fonction 153

littéral 26

slicing 21

méthode de formatage 31

S.ljust 42

méthodes 185

__slots_ 126

méthodes de

S.lower 42

concaténation 41

S.lstrip 42

méthodes de découpage 41

smtplib 225

méthodes de formatage 41

socket 224

méthodes de recherche 40

socketserver 224

méthodes de test de

sorted, fonction 153

contenu 43

SQL 235

méthodes Python 3.X 37

SQLite 236

mise en forme 29

S.replace 41

modèle de substitution 35

S.rfind 40

opérations 27

S.rindex 40

syntaxe de la méthode de

S.rjust 42

formatage 33

S.rstrip 42

string, module 185

S.split 41

string.ascii_letters 186

S.splitlines 41

string.ascii_lowercase 186

S.startswith 40

string.ascii_uppercase 186

S.strip 42

string.capwords 185



258

Python

string.digits 186

sys.float_info 178

string.Formatter 185

sys.getcheckinterval 178

string.hexdigits 186

sys.getdefaultencoding 179

string.maketrans 185

sys.getfilesystemencoding 179

string.octdigits 186

sys._getframe 179

string.printable 186

sys.getrecursionlimit 179

string.punctuation 186

sys.getrefcount 179

string.Template 185

sys.getsizeof 179

string.whitespace 186

sys.getswitchinterval 179

struct, module 233

sys.getwindowsversion 179

__sub__ 20, 129

sys.hexversion 179

__subclasscheck__ 127

sys.implementation 180

subprocess, module 232

sys.int 180

sum, fonction 155

sys.intern 180

super, fonction 155

sys.last_traceback 180

superclasse 98, 155

sys.last_type 180

S.upper 42

sys.last_value 180

surchargement

sys.maxsize 180

méthodes 120

sys.maxunicode 180

surchargement d’opérateur

sys.modules 180

méthodes 134

sys.path 181

syntaxe 69

sys.platform 181

SyntaxError, exception 168

sys.prefix 181

SyntaxWarning, exception 172

sys.ps1 182

sys, module 176

sys.ps2 182

sys.argv 177

sys.setcheckinterval 182

sys.builtin 177

sys.setdefaultencoding 182

sys.byteorder 177

sys.setprofile 182

sys.copyright 177

sys.setrecursionlimit 182

sys.displayhook 177

sys.setswitchinterval 183

sys.dont_write_bytecode 177

sys.settrace 183

sys.excepthook 177

sys.__stderr 184

sys.exc_info 177

sys.stderr 184

sys.exec_prefix 178

sys.__stdin 184

sys.executable 178

sys.stdin 183

sys.exit 178

sys.__stdout 184

sys.flags 178

sys.stdout 183



Index

259

sys.sys.version 184

transaction 237

système

True 16

administration 188

__truediv__ 20, 129, 134

système d’exploitation 186

__truediv__ 20

SystemError, exception 169

try, instruction 101

SystemExit, exception 169

clauses 101

sys.thread_info 184

en Python 2.X 102

sys.tracebacklimit 184

format des clauses 101

sys.version_info 184

tuple 59

sys.winver 184

littéraux 59

S.zfill 42

opérations 59

tuple, fonction 156

T

typage dynamique 13

type

TabError, exception 169

booléen 67

T.count 60

bytearray 25

temps d’exécution 229

bytes 25

threading 234

conversion 67

time, module 228

décimal 24

time.clock 228

fraction 24

time.ctime 228

numérique 23

timeit, module 229

str 25

TimeoutError, exception 171

unicode 25

time.perf_counter 229

type, fonction 157

time.process_time 229

TypeError, exception 169

time.sleep 228

types intégrés 22

time.time 228

T.index 59

U

tkinter

classes supplémentaires 223 -u, option Python 5

comparaison avec Tk 222

UnboundLocalError, exception

widgets 220

169

tkinter, module 219

unichr, fonction 162

tkinter.colorchooser, module 222 __unicode__ 136

tkinter.filedialog, module 222

Unicode 44

tkinter.messagebox, module 221

bytearray 46

tkinter.simpledialog, module 221

bytes 46



260

Python

Python 2.X 44, 47

VMSError, exception 174

Python 3.X 44, 45

vue 55

unicode, fonction 162

UnicodeDecodeError, exception

W

170

UnicodeEncodeError, exception -W, option Python 5

170

Warning, exception 172

UnicodeError, exception 170

while, instruction 82

UnicodeTranslateError,

WindowsError, exception 174

exception 170

with, instruction 105

UnicodeWarning, exception 172

unpickling 217

X

urllib.parse 225

urllib.request 225

-X, option Python 6

UserWarning, exception 172

-x, option Python 5

xdrlib 224

V

XML 226

XML-RPC 226

-V, option Python 5

__xor__ 20, 130

-v, option Python 5

xrange, fonction 163

ValueError, exception 170

variable

typage dynamique 13

Y

variables d’environnement 8

yield, instruction 90

options de la commande

Python 10

Z

vars, fonction 158

virgule flottante 22

zip, fonction 158





Document Outline


Table des matières

1. Python précis et concis Introduction

Conventions typographiques

Utilisation de la ligne de commande Python

Variables d'environnement de Python

Utilisation du lanceur Windows

Types intégrés et opérateurs

Types intégrés spécifiques

Instructions et syntaxe

Instructions spécifiques

Espace de noms et règles de portée

Programmation orientée objet

Méthodes de surchargement d'opérateur

Fonctions intégrées

Exceptions intégrées

Attributs intégrés

Modules de la librairie standard

Module sys

Module string

Module système os

Module de recherche de motifs par expressions régulières

Modules de persistance des objets

Module et outils graphiques tkinter

Outils et modules Internet

Autres modules de la librairie standard

API de base de données SQL Python

Conseils supplémentaires





Index





