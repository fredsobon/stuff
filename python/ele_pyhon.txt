==== notes sur eleform python3 ====

== intro :

language interpreté tres complet et polyvalent (tres nombreuses utilisations et modules ..)
shell python invoqué par python3 
boogie@x61-boogie:~/lab/python$ python3
Python 3.5.2 (default, Jul  5 2016, 12:43:10) 
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 2 + 4
6
>>> 4 / 3
1.3333333333333333
>>> print("lapin")
lapin

Tout ce qui est de la forme  nom(quelque_chose) est une fonction.
On peut connaitre le type de notre objet grace à la fonction type :

>>> type(3)
<class 'int'>
>>> type(6.7)
<class 'float'>
>>> type("lapin")
<class 'str'>
>>> type(True)
<class 'bool'>
>>> type("2")
<class 'str'>

On remarque que dans le dernier exemple le fait d"entourer notre chiffre par des "" est de fait considéré comme du texte par python.

 Declaration de variable se fait très simplement : 
>>> a = "lapin"
>>> type(a)
<class 'str'>
On peut supprimer une variable avec l'instruction del :
>>> del a
>>> a
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'a' is not defined

Tout est objet en python : on va utiliser les objets comme container pour manipuler les données.

= caractères :
On peut saisir le texte entre : " ' et même """ :
le triple guillemet permet de s'affranchir des caractères à protéger et permet le multiligne :

>>> "lapin"
'lapin'
>>> "l'appel du lapin"
"l'appel du lapin"
>>> """lulu dit : "l'appel du lapin" """
'lulu dit : "l\'appel du lapin" '
>>> """ hello
... darling 
... hoho ! """
' hello\ndarling \nhoho ! '
>>> a= """ hello
... darling 
... hoho ! """
>>> a
' hello\ndarling \nhoho ! '

On peut ajouter des sauts de ligne nous même 

>>> print("lapin\n nain")
lapin
 nain
On peut faire des opérations uniquement sur des données de même type ..sinon erreur .

>>> "Lapin" + 1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Can't convert 'int' object to str implicitly

= operateurs arithmetiques : 
On peut par contre traiter du texte avec des opérateurs arithmetiques :
>>> "Lapin" + "1"
'Lapin1'
>>> "lapin" * 2
'lapinlapin'
>>> a = "lapin"
>>> b = 3
>>> a * b
'lapinlapinlapin'
Le type Node est utilisé pour définir "rien" :
>>> None
>>> a = None
>>> a
>>> type(a)
<class 'NoneType'>


== controle de flux et structures conditionnelles :

= input :

Pour interragir avec le user on va utiliser la fonction  input. 
La fonction  input s'utilise toujours avec une variable ou un autre appel de  fonction :
on va donc  definir une variable qui va recupérer le resultat de la commande input :

>>> ans = input("how are you ? ")
how are you ? cool
>>> ans
'cool'
>>> type(ans)
<class 'str'>

= convertion de type : 
On peut convertir un type en un autre . Quand un user via la fonction input saisit un nombre celui ci est vu comme une string : il faut donc le convertir si on veut faire des opérations dessus . ex : 
>>> number = input("how old are U ? ")
how old are U ? 44
>>> type(number)
<class 'str'>
>>> number + 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Can't convert 'int' object to str implicitly
>>> number = int(number)
>>> number + 2
46
= operateurs logiques : 

On va pouvoir utiliser des operateurs logiques pour tester nos valeurs :
>>> number = 44
>>> number > 43
True
>>> number < 32
False
>>> number >= 44
True
>>> number <= 44
True
>>> number == 44
True
>>> number == 43
False
>>> number != 44
False
>>> number == 43
False
>>> number != 43
True

Le resultat est un booleen.
 = number < 45
>>> res
True
>>> type(res)
<class 'bool'>

= operateur in : 
On peut utiliser l'operateur special "in" qui va permettre de tester  plus largement 

>>> animal = input("what is your favorite animal ? ")
what is your favorite animal ? a little cat
>>> "cat" in animal
True
>>> "lion" in animal
False
Ici on test la presence d'une chaine de caractere parmi plusieurs (la reponse du user utilise 3 mots )

On peut utiliser la negation egalement :
not in :

>>> "a" not in "abcd"
False
>>> "a" not in "bcd"
True


On peut combiner plusieurs conditions et utiliser la logique booleenne pour prendre des décisions : 
-> condition "ou" :
>>>True or False
True
>>> True or True
True
>>> False or True
True
>>> False or False
False

-> condition "et" tout doit être vrai 
>>> True and True
True
>>> True and False
False
>>> False and True
False
>>> False and False
False

= tests conditionnels : "if else" :
il est imperatif de respecter l'indentation de 4 espaces 

>>> if True:
...     print("okey !!")
... 
okey !!
On peut chainer les fonctions entre elles :
>>> prix = 30
>>> money = int(input("how many dollards have you got ? "))
how many dollards have you got ? 30
On voit donc que la donnee saisi par le user est directement converti en entier grace à  int.

>>> money = int(input("how many dollards have you got ? "))
how many dollards have you got ? 40
>>> if money > prix:
...     print("hey you can buy this stuff")
... 
hey you can buy this stuff

Cette fois ci avec "if" et "else" 

>>> prix = 30
>>> money = int(input("how many dollards have you got ? "))
how many dollards have you got ? 15
>>> if money > prix:
...     print("hey you can buy this stuff")
... else:
...     print("no way u got to work harder!")
... 
no way u got to work harder!

On peut augmenter le nombre de conditions ex ici on peut acheter si on a assez d'argent et si il reste des articles à vendre :
>>> stock = 10
>>> if money > prix and stock > 0:
...     print("hey you can buy this stuff")
...     stock = stock - 1
... else:
...     print("no way u got to work harder or choose another shop !")
... 
no way u got to work harder or choose another shop !
= if elif else : 
la construction se fait basiquement comme ceci : (l'exemple est nul puisqur vrai ou faux et pas de condition sup pour else ..) 

>>>if False:
...     print("ko!")
... elif True:
...     print("choix intermediaire")
... else:
...     print("ben pas de condition du tout") 
... 
choix intermediaire

/!\ syntaxe de code a respecter pep8 voir sur le net :
4 espaces d'indentation et un ":" sans espace apres les keywords de type else: ..., pas d'espace entre les fonctions et les parentheses.
on essaye d'aerer le code : espace entre les assignations de variables 
Le python a été créer pour de la lisibilité puisqu'on lit plus souvent du code que l'on en ecrit.

exercice 1 : "etes vous majeur ?"

ok = 18
>>> age = int(input("how old are you ?"))
how old are you ?17
>>> if age >= ok:
...     print("no problemo welcome!")
... else:
...     print("sorry but got to eat soup!")
... 
sorry but got to eat soup!


== Boucles : 

= while : est comme un if : une condition va être testée et une action réalisée ou non . La difference est qu'en fonction du resultat de l'evaluation on retourne dans la boucle while.
Il faut donc que des elements modifient les param de la conditions sinon on est dans une boucle infinie :

>>> sister = 5
>>> brother = 2
>>> while sister > brother:
...     print("girl is older!")
...     brother = brother + 1 # ou plus simple brother += 1
... 
girl is older!
girl is older!
girl is older!

exemple avec un import du module random pour definir un nombre entier 
>>> import random
# on appelle la fonction randint du module random pour générer un nombre aléatoire entre 1 et 100 
>>> number = random.randint(1, 100)
>>> number
90
>>> ans = None
>>> while ans != number:
...     ans = int(input("guess the correct number!"))
...     if ans > number:
...         print("too high")
...     elif ans < number:
...         print("too low")
...     else:
...         print("bingo")
... 
too low
guess the correct number!91
too high
guess the correct number!54
too low
guess the correct number!90
bingo
>>> 

= commentaires en python :
le commentaire est un "#" 
= debug et analyse des erreurs :
il est important de comprendre les messages d'erreur de python : les stacktrace qu'il renvoit sont assez explicites mais des fichiers de scripts assez longs vont nécéssité des outils et l'affichage de messages précis.
ex :
si on supprime la fonction de convertion de type dans notre ligne :

ans = input("guess the correct number!") on a en lancant le script :
ogie@x61-boogie:~/lab/python$ ./ra.py 
guess the correct number!54
Traceback (most recent call last):
  File "./ra.py", line 10, in <module>
    if ans > number:
TypeError: unorderable types: str() > int()

== structure de données : collections : list /tuple :

python utilise la philosophie duck typing : on s'interresse aux caracteristiques des objets ( slicable, indexable, iterable )
-indexer : on peut recup a un index particulier un elemeent de notre objet.
les caracteres , les listes sont indexables
- slicable : decoupable en tranche 
list, caracteres sont slicable 
- iterable : on peut prendre les elements un par un pour les traiter : les listes, et caracteres sont iterables

= liste collection d'element ordonnée :
>>> fruit = []
>>> type(fruit)
<class 'list'>

methode sur list :
>>> fruit.append("banane")
>>> fruit
['banane']
>>> fruit.append("ananas")
>>> fruit
['banane', 'ananas']
pour acceder a un element on  utilise l'index. on commence à compter à partir de 0 
>>> fruit[0]
'banane'
>>> fruit[2]
'citron'
on peut modifier l'element d'une liste :
>>> fruit[2] = "pomme"
>>> fruit[2]
'pomme'
>>> fruit
['banane', 'ananas', 'pomme']
on peut acceder a un element via un index negatif :
>>> fruit[-2]
'ananas'
si on tente d'acceder a un element de la liste qui n'existe pas python leve une erreur :
>>> fruit[21]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range

on peut acceder a des caracteres par leur index mais on ne peut pas les modifier :
>>> phrase = "lapin nain"
>>> phrase[2]
'p'
>>> phrase[2] = "Z"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment

- pop :
va nous servir a supprimer par defaut le dernier element d'une liste :
>>> fruit.pop()
'pomme'
>>> fruit
['banane', 'ananas']
on peut supprimer un element en donnant son index : 
>>> couleur = ['vert' , 'jaune' , 'rouge' ]
>>> couleur.pop(1)
'jaune'
>>> couleur
['vert', 'rouge']

- insert : va nous permettre de rajouter un element parmi ceux existant dans notre list :
>>> couleur.insert(1, 'jaune')
>>> couleur
['vert', 'jaune', 'rouge']

 les listes sont mutables : modifiables
les entiers / chaine de caracteres sont non mutable : on prend un element on le supprime et on le recree

les listes sont infinies modulo la memoire du pc.

Elles sont slicables :
>>> couleur
['vert', 'jaune', 'rouge', 'purple']
>>> len(couleur)
4
slice intervale : premier element d'index inclu, dernier exclu
>>> couleur[1:3]
['jaune', 'rouge']

on peut utiliser des bornes :
>>> couleur[:3]
['vert', 'jaune', 'rouge']
>>> couleur[1:]
['jaune', 'rouge', 'purple']
>>> couleur
['vert', 'jaune', 'rouge', 'purple']
>>> couleur[1:-1]
['jaune', 'rouge']

on peut setter un "pas" pour extraire les elements.
ex  tous les deux elements dans l'intervalle 1 à 6 :
>>> couleur
['vert', 'jaune', 'rouge', 'purple', 'pink', 'grey']
>>> couleur[1:6:2]
['jaune', 'purple', 'grey']
on peut donc inverser notre liste :
>>> couleur
['vert', 'jaune', 'rouge', 'purple', 'pink', 'grey']
>>> couleur[::-1]
['grey', 'pink', 'purple', 'rouge', 'jaune', 'vert']
ceci est valable pour les chaine de caracteres ( slicables mais non mutables) :
>>> "hello world!"[::-1]
'!dlrow olleh'
les listes peuvent contenir des types differents mais c'est non conseille.

-fonction list :
>>> list("hello world")
['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
si on converti cette liste en caractere on a une representation en caractere de la liste :
>>> str(list("hello world"))
"['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']"
> on voit les guillements qui entourent notre liste.

- tuple : ressemble aux listes (slicable etc ..) : il n'est pas mutable.
ce qui est utile quand on veut s'assurer qu'aucune modif ne sera faite sur nos entrées. le tuple est un peu plus rapide egalement.
>>> fix = ("lapin", "coincoin")
>>> type(fix)
<class 'tuple'>
>>> fix[1]
'coincoin'
>>> fix[1] = "loup"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment


== boucle for : ==

caracteres, list et tuples sont iterables 
L'iteration est le coeur de python 
>>> lang = "python"
>>> for lettre in lang:
...     print(lettre)
... 
p
y
t
h
o
n
un iterable est un objet sur lequel  on peut appliquer une boucle "for"
>>> couleur
['vert', 'jaune', 'rouge', 'purple', 'pink', 'grey']
>>> fix
('lapin', 'coincoin')
liste et tuple sont iterables :
>>> for c in couleur:
...     print(c)
... 
vert
jaune
rouge
purple
pink
grey
>>> for animal in fix:
...     print(animal)
... 
lapin
coincoin


== exercice :

#!/usr/bin/env python3

import random
# on appelle la fonction randint du module random pour générer un nombre aléatoire entre 1 et 100
number = random.randint(1, 100)
# on declare une variable vide qui servira à enregistrer les reponses du user :
ans = None
# on cree une liste vide qu'on alimentera à chaque saisi du user pour l'afficher à la fin du jeu :
liste = []
# notre condition principale qui permettra d'executer la boucle tant que la condition n'est pas réalisée:
while ans != number:
# on recupere l'entree saisie par le joueur, on la convertie en entier et on associe la variable ans à la valeur retournee :
     ans = int(input("guess the correct number!"))
# on ajoute la reponse dans la liste :
     liste.append(ans)
# conditions : pour gagner et sortie de boucle quand le nombre  est trouvé
     if ans > number:
         print("too high")
     elif ans < number:
         print("too low")
     else:
         print("bingo")
# on recupere le numbre d'element de notre liste
number = len(liste)
# on affiche au joueur le nombre de coups qu'il a utilisé pour gagné : 
print("ok you win in " + str(number) + "hits")
print("here are the differents hits you played : \n")
# on affiche les différents coups :
for hit in liste:
    print("-" + str(hit))

on peut modifier notre code pour l'alleger :
la section else: n'est pas nécéssaire car on est sorti de la boucle dès qu'on a trouvé le bon nombre ..on laisse pour la clarté .
on peut alléger print en supprimant le + en ajoutant comme separateur d'argument le virgule et la conversion en str : que print fait nativement :
print("ok you win in ", number, "hits")
print("-",hit)

Certaines fonctions acceptent plusieurs paramètres d'autres non.

=v 94

