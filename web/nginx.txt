#### Nginx : ####

## Specs :
Nginx utilise des sockets asynchrones de connexion.Un process nginx par "core" peut gérer des milliers de connexions http, avec une consommation cpu et mémoire bien moins élevée. Les fichiers de conf et l'optimisation de la config est bien plus simple qu'apache.

apt-get install nginx
yum install nginx
*prerequis : 

-gcc est obligatoire ( nginx est en c)
root@centos67 ~]# gcc
gcc: no input files   >>> c'est ok le packet est installé. 

-pcre :La librairie PCRE pour les regexps (pour les rewrites etc ....) 
[root@centos67 ~]# yum install pcre pcre-devel

-zlib : cette librairie permet d'avoir les algos compression 
[root@centos67 ~]# yum install zlib zlib-devel

- openssl : implémentation obligatoire pour ssl et tsl :
[root@centos67 ~]# yum install openssl openssl-devel

On peut voir les options avec lesquelles nginx est compilé : 
nginx -V

On peut avoir tous les modules d'installés et de configurés via les packages : ex geoip, libgd, libxml2, libxslt

Nginx peut servir de proxy mail également.

Droits d'accès : 
le process "master" doit être démarré en root sinon pas d'acces au port 80 et 443
le process "worker" va être lancé avec le compte user défini dans le fichier de conf.

Le fichier de conf a toujours la priorité maximale ( même si on a compilé le packet à la main ).

Test de config :
[root@centos67 ~]# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

Il est possible de tester un fichier de conf particulier :
[root@centos67 ~]# nginx -t -c /root/nginx.conf 
nginx: the configuration file /root/nginx.conf syntax is ok
nginx: configuration file /root/nginx.conf test is successful


###  configuration basique :

##  configuration des directives

fichier de conf /etc/nginx/nginx.conf 
on fonctionne sur un mode directive de type :
clé             valeur;
ex:
worker_process  1;

/!\ toutes les directives finissent par un ";" 

# Directives principales : elles sont ici du "core" de nginx (celles des modules seront vues plus loin)

# utilisateur. On peut rajouter un deuxieme nom celui du groupe autoriser à faire tourner le process : 
user              nginx;  
# nginx fonctionne avec un "single" process
worker_processes  1; 

# On peut avoir une inclusion de conf via un fichier externe : dans ce cas c'est comme si l'on avait l'intégration du fichier ( ce mecanisme est récursif on peut avoir l'incusion de fichiers de fichiers ....) 
NB: le globbing fonctionne pour les "include".Ex include sites/*.conf; > Ok

Sur une installation "neuve" on peut voir l'inclusion de plusieurs fichiers :

[root@centos67 nginx]# grep -rin include *
conf.d/default.conf:13:    include /etc/nginx/default.d/*.conf;
conf.d/default.conf:45:    #    include        fastcgi_params;
nginx.conf:21:    include       /etc/nginx/mime.types;
nginx.conf:40:    include /etc/nginx/conf.d/*.conf;
nginx.conf.default:18:    include       mime.types;
nginx.conf.default:70:        #    include        fastcgi_params;
On peut avoir de base ce type de fichiers :

Standard name Description
nginx.conf    Base configuration of the application.
mime.types    A list of file extensions and their associated MIME types.
fastcgi.conf  FastCGI-related configuration.
proxy.conf    Proxy-related configuration.
sites.conf    Configuration of the websites served by Nginx, also known as virtual
              hosts. It's recommended to create separate files for each domain.


nginx.conf :
    user        nginx nginx;
    worker_processes  4;
    include     other_settings.conf;

other_settings.conf :
    error_log logs/error.log;
    pid logs /nginx.pid;        
 
Le résultat final sera vu comme tel pour nginx : 
    user              nginx nginx;
    worker_processes  4;
    include     other_settings.conf;
    error_log logs/error.log;
    pid logs /nginx.pid;        
Les fichiers de base fournis  à l'install de nginx peuvent être regroupés et renommés sans souci.

## Block de directives : 

Les blocs de directives sont apportés avec les modules : l'activation d'un nouveau module forme un nouveau block de directive qui permet une construction logique de config. Ex : le bloc event est apporté par le module Events . 
events {
    worker_connections 1024;
}
Les directives ne peuvent être définies qu'à l'interrieur de la section.

/!\ ATTENTION : certaines directives doivent être placées dans la section "main" / root : block principal et leur action se fait en global sur le serveur web.

Les directives peuvent s'imbriquer : entre les {} :

Exemple pour configurer un serveur web : certains blocs sont obligatoires :
http  {
      server  {
            listen 80;
            server_name example.com;
            access_log /var/log/nginx/exemple.com.log;
            location ^~ /admin/ {
                index index.php;
             }
        }
}
-> le bloc server permet de configurer un vhost : dans ce cas cette conf s'applique à toutes requettes http ayant dans leur header le nom exemple.com dans le champ HOST
On peut rajouter des sections "location" qui permettent de spécifier certaines conf quand l'URI de la requette match avec le path défini.
NB: la config des blocs est héritée dans les blocs "enfants". Ici on a tous les logs qui tombent a un endroit mais on peut désactiver le loggin pour une section particulière en réutilisant la directive "access_log". Exemple :

Ici on override la conf server en definissant une location ou on ne loggera pas les infos (^~/admin) : la directive access_log à off "override" la partie de conf server :

            location ^~ /admin/ {
                index index.php;
                access_log off;
             }
->ici on override la conf de la section server.

## exemple de fichier de conf : 
user              nginx;
worker_processes  1;
# path des errors logs :
error_log  /var/log/nginx/error.log;
# 
pid        /var/run/nginx.pid;
# 
events {
    worker_connections  1024;
}
#   
http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';
    access_log  /var/log/nginx/access.log  main;
    sendfile        on;
    #tcp_nopush     on;
    #keepalive_timeout  0;
    keepalive_timeout  65;
    #gzip  on;
    # Load config files from the /etc/nginx/conf.d directory
    # The default server is in conf.d/default.conf
    include /etc/nginx/conf.d/*.conf;
}

* Syntaxes particulières :
on peut utiliser des regles de syntaxe dédiées pour configurer certaines directives. Ex :

rewrite ^/(.*)\.(png|jpg|gif)$ /image.php? file=$1&format=$2 last;

* Diminutifs :
on peut devoir utiliser des diminutifs pour représenter des valeurs.Ex :

client_max_body_size 2M;
client_max_body_size 2048k;
ou
client_body_timeout 3m;
client_body_timeout 180s;
client_body_timeout 180;
client_body_timeout 1m30s;
client_body_timeout '1m 30s 500ms';  # on peut cumuler les valeurs.

* Variables :
On peut devoir utiliser des variables pour configurer des directives :
ex : le  module "core" defini la variable $nginx_version 
l'utilisation du logformat peut recupérer des valeurs comme :
log_format main '$pid - $nginx_version - $remote_addr';

Attention toutes les directives ne permettent pas l'utilisation de variables (ex : error_log logs/error-$nginx_version.log; ne fonctionne pas.)

* strings :
on peut definir les valeurs de chaines de caracteres des directives concernées de trois forme :
normal , entre "" et entre ''.
comme en shell il faut ajouter un \ pour proteger un caractère ex : \$

= Modules de base :

-> core : config de base, process managment, securité
-> events : mecanique interne et réseau
-> configuration : gestion des inclusions


* Core module :
au demarrage de nginx un seul process existe : process Master en principe lancé en root:root
Il lance a son tour des process 'worker' qui seront utilisé par un user/group dédié pour dialoguer avec le client.

On peut definir le nombre de worker ainsi que le nombre de connexions que chaque worker peut gérer.
La plupart des directives du "core" doivent être placées à la racine du serveur et ne peuvent être utilisé qu'une seule fois.Cependant pour certaines directives utilisables plusieurs fois : dans plusieurs contextes.
ex: 
user nginx nginx;
master_process on;
worker_processes 4;

* Event module : 
Ce module embarque des directives importantes sur les performances et les mecanismes reseau du serveur.La bloc events doit être placée à la racine du serveur : imperatif sinon le serveur sera HS.
ex: 
user nginx nginx;
master_process on;
worker_processes 4;
events {
  worker_connections 1024;
  use epoll;
}
[...]


* Configuration module :
permet l'inclusion et la directive peut être placée et appellée à plusieurs endroits dans la conf du server :
ex : 
include /file/path.conf;
include sites/*.conf;

* Config de base adaptée :
en principe de base nginx fonctionne sur beaucoup d'environnment sans config particulière.
De base quand aucune configs particulière n'est chargée : la conf par defaut est chargée ( on peut donc trouver le fichier de conf initial "light" mais cela peut simplement indiquer le chargement par defaut des conf de base.
examen de notre conf neuve :

[root@centos67 nginx]# cat nginx.conf
user              nginx; # user lancant nginx
worker_processes  1; # nombre de worker lancés au boot. On fixe la valeur de 1 worker par cpu core dispo sur le server.

log_not_ found on; # on peut definir si les 404 sont loggées ou pas (ex : favicon ou robot.txt crawlé ..) : attention c'est un composant du module core : donc à mettre en début de conf .


error_log  /var/log/nginx/error.log; # emplacement des logs d'erreurs
#error_log  /var/log/nginx/error.log  notice;
#error_log  /var/log/nginx/error.log  info;

pid        /var/run/nginx.pid; # emplacement du pid

events {
    worker_connections  1024; # nombre de connexion http simultanée par worker : plus on a de ram et cpu plus on peut augmenter la conf.
}

http {
    include       /etc/nginx/mime.types; # include des types mimes 
    default_type  application/octet-stream;
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';    # definition du log format 

    access_log  /var/log/nginx/access.log  main;  # emplacement des logs d'acces

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;
    
    # Load config files from the /etc/nginx/conf.d directory
    # The default server is in conf.d/default.conf
    include /etc/nginx/conf.d/*.conf;

}


== Configuration Http : 

* module 'core' :
 
c'est le composant qui contient tout ce qui est fondamental pour le serveur http : block, directives, variables.
L'organisation du serveur http s'articule autour des trois blocks : http, server et location.
On a donc tout de suite après la structure essentielle du fichier de conf , le module events (seule place possible dans la conf) PUIS les blocks suivants : http, server et location.
-http :
Sa place est traditionnellement après le module events mais ce n'est pas obligatoire et on peut declarer plusieurs blocs http sachant que les dernieres directives déclarées sont celles qui sont prises en compte : override des précédentes identiques si elles existent.
-server :
ce bloc sert à définir un site et doit être inclu dans le bloc http
-location :
permet de definir des specificité de conf pour certains emplacements du site. Ce bloc doit être inclu dans le bloc server ou dans un autre bloc location.

On a donc le bloc principal http qui va contenir tous nos sites compris dans la /les blocs servers qui vont eux mêmes contenir un ou des blocs location permettant de definir l'acces à des ressources uri particulières : les notions d'héritages et d'override sont donc à prendre en compte. On peut donc modifier le comportement sur le site en fonction de paramètres dédiés et possible (quand cela est possible en terme de bloc, directives et logique (on ne met pas de bloc server dans un bloc location par exemple...)
Ex : 

http {
   # Enable gzip compression at the http block level
   gzip on;
   server {
       server_name localhost;
         listen 80;
       # At this stage, gzip still set to on
       location /downloads/ {
            gzip off;
     #      This directive only applies to documents found
     #      in /downloads/
       }
   }
}

Principale directives :

- Socket et hostname :
server bloc : on defini le hostname ou ip de notre virtualhost et la directive listen :
->listen : (contexte : server )
listen adresse port <options>;
listen 127.0.0.1;
listen 80 default; 
listen [:::a8c9:1234]:80; # IPv6 addresses must be put between square brackets
listen 443 ssl; # ssl est une options pour gerer le ssl 
listen unix:/tmp/nginx.sock; # cette directive permet les sockets unix

-> server_name : (contexte : server)
permet de definir un ou plusieurs noms au server : quand la requette http arrive nginx examine le champ HOST et passe cette requette à la première section server qui lui correspond.
Si aucun champ ne correspond alors nginx passe la requette au premier bloc qui match un catch-all du type : 
listen *:80
Cette directive prend les wildcards et les regexps :
   server_name    www.website.com;
   server_name    www.website.com website.com;
   server_name    *.website.com;
   server_name    .website.com; # combines both *.website.com and website.
   com
   server_name    *.website.*;
   server_name    ~^\.example\.com$;
Note that you may use an empty string as the directive value in order to catch all of the requests that do not come with a Host header, but only after at least one regular name (or "_" for a dummy hostname):
   server_name website.com "";
   server_name _ "";

-> server_name_in_redirect : (contexte :http,server, location)
s'applique pour les redirections internes (cf rewriterules) deux params on (prend le champ hostname  et off( prend le champ host de la requete)

-> tcp_nodelay :(contexte :http,server, location)
permet d'activer ou non l'option tcp_nodelay pour les connections tcp keepalive (dans le cas de certaines applications qui envoient un surplus d'information quand le temps de réponse du serveur est trop long pour elles.)
param on ou off : par défaut à on.

->tcp_nopush : (contexte : http,server,location)
s'applique uniquement si la directive sendfile est settée. tcp_nopush on ou off permet à on de transmettre toutes l'entête http de la reponse en un seul packet tcp.

->sendfile : (contexte : http,server,location)
on ou off . A on : nginx va permettre au kernel de gerer la transmission d'un fichier . A off c'est nginx qui va gérer. En fonction de l'emplacement du fichier (exemple sur montage nfs ) on peut avoir de gros probleme de performance.

-Path et documents 

->root : (contexte http,server,location,if) va nous permettre de définir l'emplacement racine d'oû notre server web pourra fournir les documents .
par défaut la veleur de la directive est à html.
ex : 
root /home/website.com/public_html;

->alias : (contexte : location )
uniquement dans le bloc location. permet de fournir un autre chemin pour acceder a un document. ex :
http {
   server {
         server_name localhost;
         root /var/www/website.com/html;
          location /admin/ {
          alias /var/www/locked/;
       }
   }
}
Ici les requettes envoyées à http://localhost vont permettre d'avoir le contenu de /var/www/website.com/html par contre les requettes http://localhost/admin/ vont permettre d'avoir acces à /var/www/locked/
Nb :ne pas oublier de mettre le "/" de fin à l'url.

-> error_page : (contexte : http,server,location,if .variables acceptées.)
permet de definir des codes http aux uri et de substituer un code http par un autre 
error_page 404 /not_found.html;
error_page 500 501 502 503 504 /server_error.html;
error_page 403 http://website.com/;
error_page 404 @notfound; # jump to a named location block
error_page 404 =200 /index.html; # in case of 404 error, redirect to index.html with a 200 OK response code

-> if_modified_since : (contexte : http,server,location) 
defini le comportement quand nginx lit le header http : If-Modified-Since ( souvent utilisé par les bots /crawler des moteurs de recherche )
Le bot indique la date de son dernier passage : si le doc n'a pas été modifié nginx renvoie une 304 Not Modified
if_modified_since : off (le header If-Modified-Since est ignoré) exact ( si la date de la requete est identique à la date du fichier 304 Not Modified renvoyé au client. Si la date de la requette est anterieure ou posterieure alors un 200 est envoyé au client)  ou before ( si la date du header est anterrieur ou egal a la date du doc : un 304 Not Modified est envoyé )option. Par defaut setté à exact.

->index : (http,server,location .variables acceptées)
Defini la page par defaut renvoyé au client si la requette ne definie pas de fichier (ex :  http://localhost )
on peut definir plusieurs documents : le premier listé sera servi.
Si aucun doc n'est defini : autoindex pourra être utilisé par nginx ( le module doit être activé) sinon une 403 sera renvoyée.
Default value: index.html
   index index.php index.html index.htm;
   index index.php index2.php /catchall.php;
 
- Requettes clients :

On peut parmi toutes choses configurer le mécanisme de keep-alive et de logging de requettes.



