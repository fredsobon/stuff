#### Nginx : ####

## Specs :
Nginx utilise des sockets asynchrones de connexion.Un process nginx par "core" peut gérer des milliers de connexions http, avec une consommation cpu et mémoire bien moins élevée. Les fichiers de conf et l'optimisation de la config est bien plus simple qu'apache.

apt-get install nginx
yum install nginx
*prerequis : 

-gcc est obligatoire ( nginx est en c)
root@centos67 ~]# gcc
gcc: no input files   >>> c'est ok le packet est installé. 

-pcre :La librairie PCRE pour les regexps (pour les rewrites etc ....) 
[root@centos67 ~]# yum install pcre pcre-devel

-zlib : cette librairie permet d'avoir les algos compression 
[root@centos67 ~]# yum install zlib zlib-devel

- openssl : implémentation obligatoire pour ssl et tsl :
[root@centos67 ~]# yum install openssl openssl-devel

On peut voir les options avec lesquelles nginx est compilé : 
nginx -V

On peut avoir tous les modules d'installés et de configurés via les packages : ex geoip, libgd, libxml2, libxslt

Nginx peut servir de proxy mail également.

Droits d'accès : 
le process "master" doit être démarré en root sinon pas d'acces au port 80 et 443
le process "worker" va être lancé avec le compte user défini dans le fichier de conf.

Le fichier de conf a toujours la priorité maximale ( même si on a compilé le packet à la main ).

Test de config :
[root@centos67 ~]# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

Il est possible de tester un fichier de conf particulier :
[root@centos67 ~]# nginx -t -c /root/nginx.conf 
nginx: the configuration file /root/nginx.conf syntax is ok
nginx: configuration file /root/nginx.conf test is successful


###  configuration basique :

##  configuration des directives

fichier de conf /etc/nginx/nginx.conf 
on fonctionne sur un mode directive de type :
clé             valeur;
ex:
worker_process  1;

/!\ toutes les directives finissent par un ";" 

# Directives principales : elles sont ici du "core" de nginx (celles des modules seront vues plus loin)

# utilisateur. On peut rajouter un deuxieme nom celui du groupe autoriser à faire tourner le process : 
user              nginx;  
# nginx fonctionne avec un "single" process
worker_processes  1; 

# On peut avoir une inclusion de conf via un fichier externe : dans ce cas c'est comme si l'on avait l'intégration du fichier ( ce mecanisme est récursif on peut avoir l'incusion de fichiers de fichiers ....) 
NB: le globbing fonctionne pour les "include".Ex include sites/*.conf; > Ok

Sur une installation "neuve" on peut voir l'inclusion de plusieurs fichiers :

[root@centos67 nginx]# grep -rin include *
conf.d/default.conf:13:    include /etc/nginx/default.d/*.conf;
conf.d/default.conf:45:    #    include        fastcgi_params;
nginx.conf:21:    include       /etc/nginx/mime.types;
nginx.conf:40:    include /etc/nginx/conf.d/*.conf;
nginx.conf.default:18:    include       mime.types;
nginx.conf.default:70:        #    include        fastcgi_params;
On peut avoir de base ce type de fichiers :

Standard name Description
nginx.conf    Base configuration of the application.
mime.types    A list of file extensions and their associated MIME types.
fastcgi.conf  FastCGI-related configuration.
proxy.conf    Proxy-related configuration.
sites.conf    Configuration of the websites served by Nginx, also known as virtual
              hosts. It's recommended to create separate files for each domain.


nginx.conf :
    user        nginx nginx;
    worker_processes  4;
    include     other_settings.conf;

other_settings.conf :
    error_log logs/error.log;
    pid logs /nginx.pid;        
 
Le résultat final sera vu comme tel pour nginx : 
    user              nginx nginx;
    worker_processes  4;
    include     other_settings.conf;
    error_log logs/error.log;
    pid logs /nginx.pid;        
Les fichiers de base fournis  à l'install de nginx peuvent être regroupés et renommés sans souci.

## Block de directives : 

Les blocs de directives sont apportés avec les modules : l'activation d'un nouveau module forme un nouveau block de directive qui permet une construction logique de config. Ex : le bloc event est apporté par le module Events . 
events {
    worker_connections 1024;
}
Les directives ne peuvent être définies qu'à l'interrieur de la section.

/!\ ATTENTION : certaines directives doivent être placées dans la section "main" / root : block principal et leur action se fait en global sur le serveur web.

Les directives peuvent s'imbriquer : entre les {} :

Exemple pour configurer un serveur web : certains blocs sont obligatoires :
http  {
      server  {
            listen 80;
            server_name example.com;
            access_log /var/log/nginx/exemple.com.log;
            location ^~ /admin/ {
                index index.php;
             }
        }
}
-> le bloc server permet de configurer un vhost : dans ce cas cette conf s'applique à toutes requettes http ayant dans leur header le nom exemple.com dans le champ HOST
On peut rajouter des sections "location" qui permettent de spécifier certaines conf quand l'URI de la requette match avec le path défini.
NB: la config des blocs est héritée dans les blocs "enfants". Ici on a tous les logs qui tombent a un endroit mais on peut désactiver le loggin pour une section particulière en réutilisant la directive "access_log". Exemple :

Ici on override la conf server en definissant une location ou on ne loggera pas les infos (^~/admin) : la directive access_log à off "override" la partie de conf server :

            location ^~ /admin/ {
                index index.php;
                access_log off;
             }
->ici on override la conf de la section server.

## exemple de fichier de conf : 
user              nginx;
worker_processes  1;
# path des errors logs :
error_log  /var/log/nginx/error.log;
# 
pid        /var/run/nginx.pid;
# 
events {
    worker_connections  1024;
}
#   
http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';
    access_log  /var/log/nginx/access.log  main;
    sendfile        on;
    #tcp_nopush     on;
    #keepalive_timeout  0;
    keepalive_timeout  65;
    #gzip  on;
    # Load config files from the /etc/nginx/conf.d directory
    # The default server is in conf.d/default.conf
    include /etc/nginx/conf.d/*.conf;
}

* Syntaxes particulières :
on peut utiliser des regles de syntaxe dédiées pour configurer certaines directives. Ex :

rewrite ^/(.*)\.(png|jpg|gif)$ /image.php? file=$1&format=$2 last;

* Diminutifs :
on peut devoir utiliser des diminutifs pour représenter des valeurs.Ex :

client_max_body_size 2M;
client_max_body_size 2048k;
ou
client_body_timeout 3m;
client_body_timeout 180s;
client_body_timeout 180;
client_body_timeout 1m30s;
client_body_timeout '1m 30s 500ms';  # on peut cumuler les valeurs.

* Variables :
On peut devoir utiliser des variables pour configurer des directives :
ex : le  module "core" defini la variable $nginx_version 
l'utilisation du logformat peut recupérer des valeurs comme :
log_format main '$pid - $nginx_version - $remote_addr';

Attention toutes les directives ne permettent pas l'utilisation de variables (ex : error_log logs/error-$nginx_version.log; ne fonctionne pas.)

* strings :
on peut definir les valeurs de chaines de caracteres des directives concernées de trois forme :
normal , entre "" et entre ''.
comme en shell il faut ajouter un \ pour proteger un caractère ex : \$

= Modules de base :

-> core : config de base, process managment, securité
-> events : mecanique interne et réseau
-> configuration : gestion des inclusions


* Core module :
au demarrage de nginx un seul process existe : process Master en principe lancé en root:root
Il lance a son tour des process 'worker' qui seront utilisé par un user/group dédié pour dialoguer avec le client.

On peut definir le nombre de worker ainsi que le nombre de connexions que chaque worker peut gérer.
La plupart des directives du "core" doivent être placées à la racine du serveur et ne peuvent être utilisé qu'une seule fois.Cependant pour certaines directives utilisables plusieurs fois : dans plusieurs contextes.
ex: 
user nginx nginx;
master_process on;
worker_processes 4;

* Event module : 
Ce module embarque des directives importantes sur les performances et les mecanismes reseau du serveur.La bloc events doit être placée à la racine du serveur : imperatif sinon le serveur sera HS.
ex: 
user nginx nginx;
master_process on;
worker_processes 4;
events {
  worker_connections 1024;
  use epoll;
}
[...]


* Configuration module :
permet l'inclusion et la directive peut être placée et appellée à plusieurs endroits dans la conf du server :
ex : 
include /file/path.conf;
include sites/*.conf;

* Config de base adaptée :
en principe de base nginx fonctionne sur beaucoup d'environnment sans config particulière.
De base quand aucune configs particulière n'est chargée : la conf par defaut est chargée ( on peut donc trouver le fichier de conf initial "light" mais cela peut simplement indiquer le chargement par defaut des conf de base.
examen de notre conf neuve :

[root@centos67 nginx]# cat nginx.conf
user              nginx; # user lancant nginx
worker_processes  1; # nombre de worker lancés au boot. On fixe la valeur de 1 worker par cpu core dispo sur le server.

log_not_ found on; # on peut definir si les 404 sont loggées ou pas (ex : favicon ou robot.txt crawlé ..) : attention c'est un composant du module core : donc à mettre en début de conf .


error_log  /var/log/nginx/error.log; # emplacement des logs d'erreurs
#error_log  /var/log/nginx/error.log  notice;
#error_log  /var/log/nginx/error.log  info;

pid        /var/run/nginx.pid; # emplacement du pid

events {
    worker_connections  1024; # nombre de connexion http simultanée par worker : plus on a de ram et cpu plus on peut augmenter la conf.
}

http {
    include       /etc/nginx/mime.types; # include des types mimes 
    default_type  application/octet-stream;
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';    # definition du log format 

    access_log  /var/log/nginx/access.log  main;  # emplacement des logs d'acces

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;
    
    # Load config files from the /etc/nginx/conf.d directory
    # The default server is in conf.d/default.conf
    include /etc/nginx/conf.d/*.conf;

}


== Configuration Http : 

* module 'core' :
 
c'est le composant qui contient tout ce qui est fondamental pour le serveur http : block, directives, variables.
L'organisation du serveur http s'articule autour des trois blocks : http, server et location.
On a donc tout de suite après la structure essentielle du fichier de conf , le module events (seule place possible dans la conf) PUIS les blocks suivants : http, server et location.
-http :
Sa place est traditionnellement après le module events mais ce n'est pas obligatoire et on peut declarer plusieurs blocs http sachant que les dernieres directives déclarées sont celles qui sont prises en compte : override des précédentes identiques si elles existent.
-server :
ce bloc sert à définir un site et doit être inclu dans le bloc http
-location :
permet de definir des specificité de conf pour certains emplacements du site. Ce bloc doit être inclu dans le bloc server ou dans un autre bloc location.

On a donc le bloc principal http qui va contenir tous nos sites compris dans la /les blocs servers qui vont eux mêmes contenir un ou des blocs location permettant de definir l'acces à des ressources uri particulières : les notions d'héritages et d'override sont donc à prendre en compte. On peut donc modifier le comportement sur le site en fonction de paramètres dédiés et possible (quand cela est possible en terme de bloc, directives et logique (on ne met pas de bloc server dans un bloc location par exemple...)
Ex : 

http {
   # Enable gzip compression at the http block level
   gzip on;
   server {
       server_name localhost;
         listen 80;
       # At this stage, gzip still set to on
       location /downloads/ {
            gzip off;
     #      This directive only applies to documents found
     #      in /downloads/
       }
   }
}

Principale directives :

- Socket et hostname :
server bloc : on defini le hostname ou ip de notre virtualhost et la directive listen :
->listen : (contexte : server )
listen adresse port <options>;
listen 127.0.0.1;
listen 80 default; 
listen [:::a8c9:1234]:80; # IPv6 addresses must be put between square brackets
listen 443 ssl; # ssl est une options pour gerer le ssl 
listen unix:/tmp/nginx.sock; # cette directive permet les sockets unix

-> server_name : (contexte : server)
permet de definir un ou plusieurs noms au server : quand la requette http arrive nginx examine le champ HOST et passe cette requette à la première section server qui lui correspond.
Si aucun champ ne correspond alors nginx passe la requette au premier bloc qui match un catch-all du type : 
listen *:80
Cette directive prend les wildcards et les regexps :
   server_name    www.website.com;
   server_name    www.website.com website.com;
   server_name    *.website.com;
   server_name    .website.com; # combines both *.website.com and website.
   com
   server_name    *.website.*;
   server_name    ~^\.example\.com$;
Note that you may use an empty string as the directive value in order to catch all of the requests that do not come with a Host header, but only after at least one regular name (or "_" for a dummy hostname):
   server_name website.com "";
   server_name _ "";

-> server_name_in_redirect : (contexte :http,server, location)
s'applique pour les redirections internes (cf rewriterules) deux params on (prend le champ hostname  et off( prend le champ host de la requete)

-> tcp_nodelay :(contexte :http,server, location)
permet d'activer ou non l'option tcp_nodelay pour les connections tcp keepalive (dans le cas de certaines applications qui envoient un surplus d'information quand le temps de réponse du serveur est trop long pour elles.)
param on ou off : par défaut à on.

->tcp_nopush : (contexte : http,server,location)
s'applique uniquement si la directive sendfile est settée. tcp_nopush on ou off permet à on de transmettre toutes l'entête http de la reponse en un seul packet tcp.

->sendfile : (contexte : http,server,location)
on ou off . A on : nginx va permettre au kernel de gerer la transmission d'un fichier . A off c'est nginx qui va gérer. En fonction de l'emplacement du fichier (exemple sur montage nfs ) on peut avoir de gros probleme de performance.

-Path et documents 

->root : (contexte http,server,location,if) va nous permettre de définir l'emplacement racine d'oû notre server web pourra fournir les documents .
par défaut la veleur de la directive est à html.
ex : 
root /home/website.com/public_html;

->alias : (contexte : location )
uniquement dans le bloc location. permet de fournir un autre chemin pour acceder a un document. ex :
http {
   server {
         server_name localhost;
         root /var/www/website.com/html;
          location /admin/ {
          alias /var/www/locked/;
       }
   }
}
Ici les requettes envoyées à http://localhost vont permettre d'avoir le contenu de /var/www/website.com/html par contre les requettes http://localhost/admin/ vont permettre d'avoir acces à /var/www/locked/
Nb :ne pas oublier de mettre le "/" de fin à l'url.

-> error_page : (contexte : http,server,location,if .variables acceptées.)
permet de definir des codes http aux uri et de substituer un code http par un autre 
error_page 404 /not_found.html;
error_page 500 501 502 503 504 /server_error.html;
error_page 403 http://website.com/;
error_page 404 @notfound; # jump to a named location block
error_page 404 =200 /index.html; # in case of 404 error, redirect to index.html with a 200 OK response code

-> if_modified_since : (contexte : http,server,location) 
defini le comportement quand nginx lit le header http : If-Modified-Since ( souvent utilisé par les bots /crawler des moteurs de recherche )
Le bot indique la date de son dernier passage : si le doc n'a pas été modifié nginx renvoie une 304 Not Modified
if_modified_since : off (le header If-Modified-Since est ignoré) exact ( si la date de la requete est identique à la date du fichier 304 Not Modified renvoyé au client. Si la date de la requette est anterieure ou posterieure alors un 200 est envoyé au client)  ou before ( si la date du header est anterrieur ou egal a la date du doc : un 304 Not Modified est envoyé )option. Par defaut setté à exact.

->index : (http,server,location .variables acceptées)
Defini la page par defaut renvoyé au client si la requette ne definie pas de fichier (ex :  http://localhost )
on peut definir plusieurs documents : le premier listé sera servi.
Si aucun doc n'est defini : autoindex pourra être utilisé par nginx ( le module doit être activé) sinon une 403 sera renvoyée.
Default value: index.html
   index index.php index.html index.htm;
   index index.php index2.php /catchall.php;
 
- Requettes clients :
On peut parmi toutes choses configurer le mécanisme de keep-alive et de logging de requettes.

-> keepalive_requests (contexte : http,server,location) : nombre maximum de requette servies pour  une connection keep-alive
valeur par defaut 100 

-> keepalive_timeout (contexte :http,server,location) : nombre de seconde maximum avant la fermeture de la connection tcp keepalive ( certains navigateurs ferment d'office une page à 60 secondes.)
keepalive_timeout 75;
keepalive_timeout 75 60;

-> sent_timeout :  Context: http, server, location
delai qui permet de fermer une connection http après une durée d'inactivité du client :
send_timeout Default value: 60

CF : doc nginx pour les directives portant sur les headers, body ,connection etc ...

- Mimes types : 

type : (contexte : http,server,location)
permet de faire la correspondance entre les mimes types et les extensions : nginx fait le lien entre le fichier et le mimes types : ensuite le mimes types est envoyé dans le header de la requette retour au client :ce qui pourrait indiquer una action a faire pour le navigateur client (exemple on requette un fichier pdf : dans le header on a un mimes type 'application/pdf' du coup notre navigateur peut charger un plugin plutot que downloader le fichier ..)
nginx se sert d'un include pour charger un maximum de mimes types classiques :

include mimes.types;
-> si notre fichier n'est pas reconnu dans la liste alors on va chercher dans la directive defaut_type si elle est définie.
On peut overrider le mimes types : exemple ici on va pouvoir downloader en definissant un default_type à application/octet-stream dans la location /downloads/ :
     http {
        include mime.types;
        location /downloads/ {
            # removes all MIME types
            types { }
            default_type application/octet-stream;
         }
     }
Il est plus sur de configurer le module HTTP header ( voir plus loin.)
Les valeurs par defaut si le mimes types n'esst pas défini :
types {
  text/html html;
  image/gif gif;
  image/jpeg jpg;
}

- Limit et Restrictions :

-> limit_except (Context: location) : va nous permettre de definir les methodes http acceptées.
On defini explicitement les methodes autorisées ( les autres sont rejettées ) et les autorisations exemple plage ip 
exemple :
location /admin/ {
    limit_except GET {
      allow 192.168.1.0/24;
      deny all;
    }
}
ici les requettes sont limitées au get SAUF pour la plage 192.168.1.0/24 qui peut tout faire .
NB : le GET authorisé implique de fait le HEAD ( on a donc les deux autorisés)

-> limit_rate  (Context: http, server, location, if)
limitation du taux de transfert par connexion client en bytes/s
ex :     limit_rate 500k; (Default value: No limit)

-> satisfy :  (Context: location )
The satisfy directive defines whether clients require all access conditions to be valid (satisfy all) or at least one (satisfy any).
    location /admin/ {
          allow 192.168.1.0/24;
          deny all;
          auth_basic "Authentication required";
          auth_basic_user_file conf/htpasswd;
    }
In the previous example, there are two conditions for clients to be able to access the resource:
Through the allow and deny directives (HTTP Access module), we only allow clients that have a local IP address, all other clients are denied access
Through the auth_basic and auth_basic_user_file directives (HTTP Auth Basic module), we only allow clients that provide a valid username and password
With satisfy all, the client must satisfy both conditions in order to gain access to the resource. With satisfy any, if the client satisfies either condition, they are
granted access.
Syntax: satisfy any | all
Default value: all

->internal : (Context: location)
This directive specifies that the location block is internal. In other words, the specified resource cannot be accessed by external requests.
    server {
         server_name .website.com;
         location /admin/ {
              internal;
         }
    }
With the previous configuration, clients will not be able to browse http://website.com/admin/. Such requests will be met with 404 Not Found errors. The only way to access the resource is via internal redirects (check the Rewrite module section for more information on internal redirects).

- Gestion du cache et du traitement des fichiers :

It's important for your websites to be built upon solid foundations. File access and caching is a critical aspect of web serving. In this perspective, Nginx lets you perform precise tweaking with the use of the following directives.

-> disable_symlinks
This directive allows you to control the way Nginx handles symbolic links when they are to be served. By default (directive value is off) symbolic links are allowed and Nginx follows them. You may decide to disable the following of symbolic links
under different conditions by specifying one of these values:
on: If any part of the requested URI is a symbolic link, access to it is denied and Nginx returns a 403 HTTP error page.

if_not_owner: Similar to the above, but access is denied only if the link and the object it points to have different owners.
The optional parameter from= allows you to specify a part of the URL that will not be checked for symbolic links. For example, disable_symlinks on from=$document_root will tell Nginx to normally follow symbolic links in the URI up to the $document_root folder. If a symbolic link is found in the URI parts after that, access to the requested file will be denied.

-> directio
Context: http, server, location
If this directive is enabled, files with a size greater than the specified value will be
read with the Direct I/O system mechanism. This allows Nginx to read data from
the storage device and place it directly in memory with no intermediary caching
process involved.
Syntax: Size value, or off
Default value: off

->open_file_cache (Context: http, server, location) 
This directive allows you to enable the cache which stores information about open files. It does not actually store file contents itself but only information such as:
File descriptors (file size, modification time, and so on).
The existence of files and directories.
File errors, such as Permission denied, File not found, and so on. Note that this can be disabled with the open_file_cache_errors directive.
This directive accepts two arguments:
max=X, where X is the amount of entries that the cache can store. If this amount is reached, older entries will be deleted in order to leave room for newer entries.
Optionally inactive=Y, where Y is the amount of seconds that a cache entry should be stored. By default, Nginx will wait 60 seconds before clearing a cache entry. If the cache entry is accessed, the timer is reset. If the cache entry is accessed more than the value defined by open_file_cache_min_uses, the cache entry will not be cleared (until Nginx runs out of space and decides to clear out older entries).
Syntax: open_file_cache max=X [inactive=Y] | off
Default value: off
Example:
     open_file_cache max=5000 inactive=180;

etc : voir doc nginx 

- Diverses directives :

->log_not_found (Context: http, server, location)
Enables or disables logging of 404 Not Found HTTP errors. If your logs get filled with 404 errors due to missing favicon.ico or robots.txt files, you might want to turn this off.
Syntax: on or off
Default value: on

->log_subrequest (Context: http, server, location) 
Enables or disables logging of sub-requests triggered by internal redirects (see the Rewrite module section) or SSI requests (see the Server Side Includes module section).
Syntax: on or off
Default value: off

->resolver (Context: http, server, location)
Specifies the name servers that should be employed by Nginx to resolve hostnames to IP addresses and vice-versa. DNS query results are cached for some time, either by respecting the TTL provided by the DNS server, or by specifying a time value to the
valid argument.
Syntax: IP addresses, valid=Time value
Default value: None (system default)
    resolver 127.0.0.1; # use local DNS
    resolver 8.8.8.8 8.8.4.4 valid=1h; # use Google DNS and cache results
    for 1 hour

->resolver_timeout (Context: http, server, location)
Timeout for a hostname resolution query.
Syntax: Time value (in seconds)
Default value: 30

->server_tokens (Context: http, server, location)
This directive allows you to define whether or not Nginx should inform the clients of the running version number. There are two situations where Nginx indicates its version number:
In the server header of HTTP responses (such as nginx/1.2.9). If you set server_tokens to off, the server header will only indicate Nginx.
On error pages, Nginx indicates the version number in the footer. If you set server_tokens to off, the footer of error pages will only indicate Nginx.
If you are running an older version of Nginx and do not plan to update it, it might be a good idea to hide your version number for security reasons.
Syntax: on or off
Default value: on

->underscores_in_headers (Context: http, server)
Allows or disallows underscores in custom HTTP header names. If this directive is set to on, the following example header is considered valid by Nginx: test_
header: value.
Syntax: on or off
Default value: off

->post_action (Context: http, server, location, if)
Defines a post-completion action, a URI that will be called by Nginx after the request has been completed.
Syntax: URI or named location block.
Example:
    location /payment/ {
        post_action /scripts/done.php;
    }

- Variables de modules :

Beaucoup de variables sont utiles pour certaines directives mais toutes ne sont pas utilisables par tous les modules.
3 types de variables existent : celles envoyées dans les headers du client, celles des headers envoyées au client par nginx et celles definies en interne par nginx.

->Request headers
Nginx lets you access the client request headers under the form of variables that you will be able to employ later on in the configuration:
  Variable                  Description
  $http_host                Value of the Host HTTP header, a string indicating the
                            hostname that the client is trying to reach.
  $http_user_agent          Value of the User-Agent HTTP header, a string indicating the
                            web browser of the client.
  $http_referer             Value of the Referer HTTP header, a string indicating the URL
                            of the previous page from which the client comes.
  $http_via                 Value of the Via HTTP header, which informs us about
                            possible proxies used by the client.
  $http_x_forwarded_        Value of the X-Forwarded-For HTTP header, which shows the
  for                       actual IP address of the client if the client is behind a proxy.
  $http_cookie              Value of the Cookie HTTP header, which contains the cookie
                            data sent by the client.
  $http_...                 Additional headers sent by the client can be retrieved using
                            $http_ followed by the header name in lowercase and with
                            dashes (-) replaced by underscores (_).
-> Response headers
In a similar fashion, you are allowed to access the HTTP headers of the response that was sent to the client. These variables are not available at all times they will only carry a value after the response is sent, for instance, at the time of writing messages in the logs.
Variable                       Description
$sent_http_content_            Value of the Content-Type HTTP header, indicating the
type                           MIME type of the resource being transmitted.
$sent_http_content_            Value of the Content-Length HTTP header informing the
length                         client of the response body length.
$sent_http_location            Value of the Location HTTP header, which indicates that
                               the location of the desired resource is different than the
                               one specified in the original request.
$sent_http_last_               Value of the Last-Modified HTTP header corresponding to
modified                       the modification date of the requested resource.

$sent_http_connection         Value of the Connection HTTP header, defining whether
                              the connection will be kept alive or closed.
$sent_http_keep_alive         Value of the Keep-Alive HTTP header that defines the
                              amount of time a connection will be kept alive.
$sent_http_transfer_          Value of the Transfer-Encoding HTTP header, giving
encoding                      information about the response body encoding method
                              (such as compress, gzip).
$sent_http_cache_             Value of the Cache-Control HTTP header, telling us
control                       whether the client browser should cache the resource or
                              not.
$sent_http_...                Additional headers sent to the client can be retrieved
                                using $sent_http_ followed by the header name, in
                                lowercase and with dashes (-) replaced by underscores (_).
-> Nginx generated
Apart from the HTTP headers, Nginx provides a large amount of variables concerning the request, the way it was and will be handled, as well as settings in use with the current configuration.
Variable                Description
$arg_XXX                Allows you to access the query string (GET parameters), where
                        XXX is the name of the parameter you want to utilize.
$args                   All of the arguments of the query string combined together.
$binary_remote_         IP address of the client as binary data (4 bytes).
addr
$body_bytes_sent        Amount of bytes sent in the body of the response.
$connection_            Amount of requests already served by the current connection.
requests
$content_length         Equates to the Content-Length HTTP header.
$content_type           Equates to the Content-Type HTTP header.
$cookie_XXX             Allows you to access cookie data where XXX is the name of the
                        parameter you want to utilize.
$document_root          Returns the value of the root directive for the current request.
$document_uri           Returns the current URI of the request. It may differ from the
                        original request URI if internal redirects were performed. It is
                        identical to the $uri variable.

$host             This variable equates to the Host HTTP header of the request.
                  Nginx itself gives this variable a value for cases where the Host
                  header is not provided in the original request.
$hostname         Returns the system hostname of the server computer
$https            Set to on for HTTPS connections, empty otherwise.
$is_args          If the $args variable is defined, $is_args equates to ?. If
                  $args is empty, $is_args is empty as well. You may use this
                  variable for constructing an URI that optionally comes with a
                  query string, such as index.php$is_args$args. If there is
                  any query string argument in the request, $is_args is set to ?,
                  making this a valid URI.
$limit_rate       Returns the per-connection transfer rate limit, as defined by the
                  limit_rate directive. You are allowed to edit this variable by
                  using set (directive from the Rewrite module):
                      set $limit_rate 128k;
$nginx_version    Returns the version of Nginx you are running.
$pid              Returns the Nginx process identifier.
$query_string     Identical to $args.
$remote_addr      Returns the IP address of the client.
$remote_port      Returns the port of the client socket.
$remote_user      Returns the client username if they used authentication.
$realpath_root    Returns the document root in the client request, with symbolic
                  links resolved into the actual path.
$request_body     Returns the body of the client request, or - if the body is empty.
$request_body_    If the request body was saved (see the client_body_in_
file              file_only directive) this variable indicates the path of the
                  temporary file.
$request_         Returns OK if the request is completed, an empty string
completion        otherwise.
$request_filename Returns the full filename served in the current request.
$request_method   Indicates the HTTP method used in the request, such as GET
                  or POST.
$request_uri      Corresponds to the original URI of the request, remains
                  unmodified all along the process (unlike $document_
                  uri/$uri).
$scheme           Returns either http or https, depending on the request.

$server_addr     Returns the IP address of the server. Be aware as each use of the
                 variable requires a system call, which could potentially affect
                 overall performance in the case of high-traffic setups.
$server_name     Indicates the value of the server_name directive that was
                 used while processing the request.
$server_port     Indicates the port of the server socket that received the request
                 data.
$server_protocol Returns the protocol and version, usually HTTP/1.0 or
                 HTTP/1.1.
$tcpinfo_rtt,    If your operating system supports the TCP_INFO socket option,
$tcpinfo_rttvar, these variables will be populated with information on the
$tcpinfo_snd_    current client TCP connection.
cwnd, $tcpinfo_
rcv_space
$time_iso8601,   Provides the current time respectively in ISO 8601 and local
$time_local      formats for use with the access_log directive.
$uri             Identical to $document_uri.


- Location :
On peut finement configurer notre server a travers le protocole ( bloc http) , le server (bloc server) et l'uri ( bloc location)

->Location modifier
Nginx allows you to define location blocks by specifying a pattern that will be matched against the requested document URI.
   server {
        server_name website.com;
        location /admin/ {
        # The configuration you place here only applies to
        # http://website.com/admin/
        }
   }

Instead of a simple folder name, you can indeed insert complex patterns. The syntax
of the location block is:
    location [=|~|~*|^~|@] pattern { ... }

The first optional argument is a symbol called location modifier that will define the way Nginx matches the specified pattern and also defines the very nature of the pattern (simple string or regular expression). The following paragraphs detail the
different modifiers and their behavior.

->The = modifier

The requested document URI must match the specified pattern exactly. The pattern
here is limited to a simple literal string; you cannot use a regular expression:
    server {
          server_name website.com;
          location = /abcd {
          ...
          }
    }
The configuration in the location block:
Applies to http://website.com/abcd (exact match)
Applies to http://website.com/ABCD (it is case-sensitive if your operating system uses a case-sensitive filesystem)
Applies to http://website.com/abcd?param1&param2 (regardless of query string arguments)
Does not apply to http://website.com/abcd/ (trailing slash)
Does not apply to http://website.com/abcde (extra characters after the specified pattern)

->No modifier
The requested document URI must begin with the specified pattern. You may not use regular expressions:
    server {
          server_name website.com;
          location /abcd {
            ...
          }
    }

The configuration in the location block:
Applies to http://website.com/abcd (exact match)
Applies to http://website.com/ABCD (it is case-sensitive if your operating system uses a case-sensitive filesystem)
Applies to http://website.com/abcd?param1&param2 (regardless of query string arguments)
Applies to http://website.com/abcd/ (trailing slash)
Applies to http://website.com/abcde (extra characters after the specified pattern)

-> The ~ modifier
The requested URI must be a case-sensitive match to the specified regular expression:
    server {
         server_name website.com;
         location ~ ^/abcd$ {
         ...
         }
    }
The ^/abcd$ regular expression used in this example specifies that the pattern
must begin (^) with /, be followed by abc, and finish ($) with d. Consequently,
the configuration in the location block:
Applies to http://website.com/abcd (exact match)
Does not apply to http://website.com/ABCD (case-sensitive)
Applies to http://website.com/abcd?param1&param2 (regardless of query string arguments)
Does not apply to http://website.com/abcd/ (trailing slash) due to the specified regular expression
Does not apply to http://website.com/abcde (extra characters) due to the specified regular expression With operating systems such as Microsoft Windows, ~ and ~* are both case-insensitive, as the OS uses a case-insensitive filesystem.

->The ~* modifier 
The requested URI must be a case-insensitive match to the specified regular expression:
    server {
         server_name website.com;
         location ~* ^/abcd$ {
         ...
         }
    }
The regular expression used in the example is similar to the previous one.
Consequently, the configuration in the location block:
Applies to http://website.com/abcd (exact match)
Applies to http://website.com/ABCD (case-insensitive)
Applies to http://website.com/abcd?param1&param2 (regardless of query string arguments)
Does not apply to http://website.com/abcd/ (trailing slash) due to the specified regular expression 
Does not apply to http://website.com/abcde (extra characters) due to the specified regular expression

-> The ^~ modifier
Similar to the no-symbol behavior, the location URI must begin with the specified
pattern. The difference is that if the pattern is matched, Nginx stops searching for
other patterns (read the section below about search order and priority).

->The @ modifier
Defines a named location block. These blocks cannot be accessed by the client,
but only by internal requests generated by other directives, such as try_files or
error_page.

- Priorité et recherche :
comme on peut definir plusieurs bloc de location , nginx va chercher le bloc location qui correspond au mieux avec la requette ,l'uri .

server {
    server_name website.com;
    location /files/ {
      # applies to any request starting with "/files/"
      # for example /files/doc.txt, /files/, /files/temp/
    }
    location = /files/ {
      # applies to the exact request to "/files/"
      # and as such does not apply to /files/doc.txt
      # but only /files/
    }
}

Important :  l'ordre des regles d'acces est lié aux priorités des "modifier" : 

When a client visits http://website.com/files/doc.txt, the first location block
applies. However, when they visit http://website.com/files/, the second block
applies (even though the first one matches) because it has priority over the first one
(it is an exact match).
The order you established in the configuration file (placing the /files/ block before
the = /files/ block) is irrelevant. Nginx will search for matching patterns in a
specific order:
      1.     location blocks with the = modifier: If the specified string exactly matches
          the requested URI, Nginx retains the location block.

      2.     location blocks with no modifier: If the specified string exactly matches the
          requested URI, Nginx retains the location block.
      
      3.     location blocks with the ^~ modifier: If the specified string matches the
          beginning of the requested URI, Nginx retains the location block.
      
      4.     location blocks with ~ or ~* modifier: If the regular expression matches the
          requested URI, Nginx retains the location block.
      
      5.     location blocks with no modifier: If the specified string matches the
          beginning of the requested URI, Nginx retains the location block.

In that extent, the ^~ modifier begins to make sense, and we can envision cases where it becomes useful.

Case 1:
  server {
      server_name website.com;
      location /doc {
         # requests beginning with "/doc"
      }
      location ~* ^/document$ {
         requests exactly matching "/document"
      }
  }
You might wonder: when a client requests http://website.com/document, which of these two location blocks applies? Indeed, both blocks match this request. Again, the answer does not lie in the order in which the blocks appear in the configuration
files. In this case, the second location block will apply as the ~* modifier has priority over the other.

Case 2:
     server {
           server_name website.com;
           location /document {
             # requests beginning with "/document"
           }
           location ~* ^/document$ {
             # requests exactly matching "/document"
           }
     }
The question remains the same what happens when a client sends a request to download http://website.com/document? There is a trick here. The string specified in the first block now exactly matches the requested URI. As a result, Nginx prefers it over the regular expression.

Case 3:
     server {
           server_name website.com;
           location ^~ /doc {
              # requests beginning with "/doc"
           }
           location ~* ^/document$ {
           # requests exactly matching "/document"
           }
     }
This last case makes use of the ^~ modifier. Which block applies when a client visits http://website.com/document? The answer is the first block. The reason being that ^~ has priority over ~*. As a result, any request with a URI beginning with / doc will be affected to the first block, even if the request URI matches the regular expression defined in the second block.


== Modules Configuration :

La richesse de nginx reside dans ses modules.

= Rewrite rules :

Le principe permet une réécriture complète des urls avant de transmettre le document au user.
ex :http://example.com/article.php?id=1234&comment=3a devient grâce aux rewrite http://website.com/article-1234-32-US-
economy-strengthens.html : bien plus pratique pour les users et utile pour le SEO.
L'utilisation des regexps est essentielle :

String Pattern Matches? Explanation
hello  ^hello$ Yes      The string begins by character h (^h),
                        followed by e, l, l, and then finishes by o
                        (o$).
hell   ^hello$ No       The string begins by character h (^h),
                        followed by e, l, l but does not finish by o.
Hello  ^hello$ Depends  If the engine performing the match is case-
                        sensitive, the string doesn't match the pattern.

Exemple d'adresse mail : ^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$

->PCRE syntax
Dans sa forme la plus simple il s'agit d'un caractère 
x match par exemple 
[a-z] ou des groupe [a-z0-9]. matches any character between a and z
hell[a-z0-9] match hello and hell4, but not hell or hell!.

Metacharacter     Description

^                 The entity after this character must be found at the beginning.
Beginning         Example pattern: ^h
                  Matching strings: hello, h, hh
                  Non-matching strings: character, ssh

$                 The entity before this character must be found at the end.
End               Example pattern: e$
                  Matching strings: sample, e, file
                  Non-matching strings: extra, shell

.                 Matches any character.
Any               Example pattern: hell
                  Matching strings: hello, hellx, hell5, hell!
                  Non-matching strings: hell, helo


[ ]         Matches any character within the specified set.
Set         Syntax: [a-z] for a range, [abcd] for a set, and [a-z0-9] for
            two ranges. Note that if you want to include the character in a
            range, you need to insert it right after the [ or just before the ].
            Example pattern: hell[a-y123-]
            Matching strings: hello, hell1, hell2, hell3, hell-
            Non-matching strings: hellz, hell4, heloo, he-llo

[^ ]        Matches any character that is not within the specified set.
Negate set  Example pattern: hell[^a-np-z0-9]
            Matching strings: hello, hell;
            Non-matching strings: hella, hell5

|           Matches the entity placed either before or after the |.
Alternation Example pattern: hello|welcome
            Matching strings: hello, welcome, helloes, awelcome
            Non-matching strings: hell, ellow, owelcom

( )         Groups a set of entities, often to be used in conjunction with |.
Grouping    Example pattern: ^(hello|hi) there$
            Matching strings: hello there, hi there.
            Non-matching strings: hey there, ahoy there

\           Allows you to escape special characters.
Escape      Example pattern: Hello\.
            Matching strings: Hello., Hello. How are you?, Hi!
            Hello...
            Non-matching strings: Hello, Hello, how are you?

Quantificateur :

Quantifier         Description
*                  The entity preceding * must be found 0 or more times.
0 or more times    Example pattern: he*llo
                   Matching strings: hllo, hello, heeeello
                   Non-matching strings: hallo, ello

+                  The entity preceding + must be found 1 or more times.
1 or more times    Example pattern: he+llo
                   Matching strings: hello, heeeello
                   Non-matching strings: hllo, helo

?                  The entity preceding ? must be found 0 or 1 time.
0 or 1 time        Example pattern: he?llo
                   Matching strings: hello, hllo
                   Non-matching strings: heello, heeeello

{x}                The entity preceding {x} must be found x times.
x times            Example pattern: he{3}llo
                   Matching strings: heeello, oh heeello there!
                   Non-matching strings: hello, heello, heeeello

{x,}               The entity preceding {x,} must be found at least x times.
At least x times   Example pattern: he{3,}llo
                   Matching strings: heeello, heeeeeeello
                   Non-matching strings: hllo, hello, heello

{x,y}              The entity preceding {x,y} must be found between x and y times.
x to y times       Example pattern: he{2,4}llo
                   Matching strings: heello, heeello, heeeello
                   Non-matching strings: hello, heeeeello

/!\  As you probably noticed, the { and } characters in the regular expressions conflict
with the block delimiter of the Nginx configuration file syntax language. If you want
to write a regular expression pattern that includes curly brackets, you need to place
the pattern between quotes (single or double quotes):
    rewrite hel{2,}o /hello.php; # invalid
    rewrite "hel{2,}o" /hello.php; # valid
    rewrite 'hel{2,}o' /hello.php; # valid

-Captures

One last feature of the regular expression mechanism is the ability to capture sub-expressions. Whatever text is placed between parentheses ( ) is captured and can be used after the matching process.
Here are a couple of examples to illustrate the principle:

Pattern                                       String           Captured
^(hello|hi) (sir|mister)$                     hello sir        $1 = hello
                                                               $2 =  sir

^(hello (sir))$                               hello sir        $1 =  hello sir
                                                               $2 =  sir

^(.*)$                                        nginx rocks      $1 =  nginx rocks

^(.{1,3})([0-9]{1,4})([?!]{1,2})$             abc1234!?        $1 =  abc
                                                               $2 = 1234
                                                               $3 = !?
Named captures are also supported:            /admin/doc       $folder = admin
^/(?<folder>[^/]*)/(?<file>.*)$                                $file = doc

When you use a regular expression in Nginx, for example, in the context of a location
block, the buffers that you capture can be employed in later directives:

    server {
          server_name website.com;
          location ~* ^/(downloads|files)/(.*)$ {
              add_header Capture1 $1;
              add_header Capture2 $2;
          }
    }

In the preceding example, the location block will match the request URI against a regular expression. A couple of URIs that would apply here: /downloads/file.txt, /files/archive.zip, or even /files/docs/report.doc. Two parts are captured $1 will contain either downloads or files and $2 will contain whatever comes after /downloads/ or /files/. Note that the add_header directive (syntax: add_header header_name header_value, see the HTTP headers module section) is employed here to append arbitrary headers to the client response for the sole purpose of demonstration.


->  Internal requests
Nginx differentiates external and internal requests. External requests directly
originate from the client; the URI is then matched against possible location blocks:
    server {
         server_name website.com;
         location = /document.html {
              deny all; # example directive
         }
    }
A client request to http://website.com/document.html would directly fall into
the above location block.

Opposite to this, internal requests are triggered by Nginx via specific directives. In
default Nginx modules, there are several directives capable of producing internal
requests: error_page, index, rewrite, try_files, add_before_body, add_after_
body (from the Addition module), the include SSI command, and more.
There are two different kinds of internal requests:
Internal redirects Nginx redirects the client requests internally. The URI is
        changed, and the request may therefore match another location block and
        become eligible for different settings. The most common case of internal
        redirects is when using the Rewrite directive, which allows you to rewrite the
        request URI.
Sub-requests: Additional requests that are triggered internally to generate
        content that is complementary to the main request. A simple example would
        be with the Addition module. The add_after_body directive allows you
        to specify a URI that will be processed after the original one, the resulting
        content being appended to the body of the original request. The SSI module
        also makes use of sub-requests to insert content with the include command.

-> error_page
Detailed in the module directives of the Nginx HTTP Core module, error_page
allows you to define the server behavior when a specific error code occurs. The
simplest form is to affect a URI to an error code:
    server {
         server_name website.com;
         error_page 403 /errors/forbidden.html;
         error_page 404 /errors/not_found.html;
    }
When a client attempts to access a URI that triggers one of these errors, Nginx is
supposed to serve the page corresponding to the error code. In fact, it does not just
Consequently, you can end up falling back on a different configuration, like in the
following example:
    server {
         server_name website.com;
         root /var/www/vhosts/website.com/httpdocs/;
         error_page 404 /errors/404.html;
         location /errors/ {
             alias /var/www/common/errors/;
             internal;
         }
    }
When a client attempts to load a document that does not exist, they will initially
receive a 404 error. We employed the error_page directive to specify that 404 errors
should create an internal redirect to /errors/404.html. As a result, a new request
is generated by Nginx with the URI /errors/404.html. This URI falls under the
location /errors/ block so the configuration applies.
              Logs can prove to be particularly useful when working with redirects
              and URL rewrites. Be aware that information on internal redirects will
              show up in the logs only if you set the error_log directive to debug.
              You can also get it to show up at the notice level, under the condition
              that you specify rewrite_log on; wherever you need it.

A raw, but trimmed, excerpt from the debug log summarizes the mechanism:
    ->http request line: "GET /page.html HTTP/1.1"
    ->http uri: "/page.html"
    ->test location: "/errors/"
    ->using configuration ""
    ->http filename: "/var/www/vhosts/website.com/httpdocs/page.html"
    -> open() "/var/www/vhosts/website.com/httpdocs/page.html" failed (2:
    No such file or directory), client: 127.0.0.1, server: website.com,
    request: "GET /page.html HTTP/1.1", host:"website.com"
    ->http finalize request: 404, "/page.html?" 1
    ->http special response: 404, "/page.html?"
    ->internal redirect: "/errors/404.html?"
    ->test location: "/errors/"
    ->using configuration "/errors/"
    ->http filename: "/var/www/common/errors/404.html"
    ->http finalize request: 0, "/errors/404.html?" 1

Note that the use of the internal directive in the location block forbids clients
from accessing the /errors/ directory. This location can only be accessed from an
internal redirect.
The mechanism is the same for the index directive (detailed further on in the Index
module) if no file path is provided in the client request, Nginx will attempt to serve
the specified index page by triggering an internal redirect.

->  Rewrite
While the previous directive error_page is not actually part of the Rewrite module,
detailing its functionality provides a solid introduction to the way Nginx handles
requests.
Similar to how the error_page directive redirects to another location, rewriting the
URI with the rewrite directive generates an internal redirect:
    server {
         server_name website.com;
         root /var/www/vhosts/website.com/httpdocs/;
         location /storage/ {
               internal;
               alias /var/www/storage/;
         }
         location /documents/ {
               rewrite ^/documents/(.*)$ /storage/$1;
         }
    }
A client query to http://website.com/documents/file.txt initially matches
the second location block (location /documents/). However, the block contains
a rewrite instruction that transforms the URI from /documents/file.txt to /
storage/file.txt. The URI transformation reinitializes the process - the new
URI is matched against the location blocks. This time, the first location block
(location /storage/) matches the URI (/storage/file.txt).

Again, a quick peek at the debug log confirms the mechanism:
->http request line: "GET /documents/file.txt HTTP/1.1"
->http uri: "/documents/file.txt"
->test location: "/storage/"
->test location: "/documents/"
->using configuration "/documents/"
->http script regex: "^/documents/(.*)$"
->"^/documents/(.*)$" matches "/documents/file.txt", client: 127.0.0.1, server: website.com, request: "GET /documents/file.txt
HTTP/1.1", host: "website.com"
->rewritten data: "/storage/file.txt", args: "", client: 127.0.0.1,
server: website.com, request: "GET /documents/file.txt HTTP/1.1",
host: "website.com"
->test location: "/storage/"
->using configuration "/storage/"
->http filename: "/var/www/storage/file.txt"
->HTTP/1.1 200 OK
->http output filter "/storage/test.txt?"

=== ATTENTION aux boucles infinies avec les regexp et les rewrites rules :
    server {
         server_name website.com;
         location /documents/ {
              rewrite ^(.*)$ /documents/$1;
         }
    }
You thought you were doing well, but this configuration actually triggers internal
redirects /documents/anything to /documents//documents/anything. Moreover,
since the location patterns are re-evaluated after an internal redirect, /documents//
documents/anything becomes /documents//documents//documents/anything. ===

Heureusement nginx a une mecanique de protection interne qui limite à 10 boucles max avant de tomber en erreur 500.

-> SSI : server side include.
A potential source of sub-requests is the Server Side Include (SSI) module. The purpose of SSI is for the server to parse documents before sending the response to the client in a somewhat similar fashion to PHP or other preprocessors.
Within a regular HTML file (for example), you have the possibility to insert tags corresponding to commands interpreted by Nginx:
    <html>
    <head>
       <!--# include file="header.html" -->
    </head>
    <body>
       <!--# include file="body.html" -->
    </body>
    </html>
Nginx processes these two commands; in this case, it reads the contents of head.
html and body.html and inserts them into the document source, which is then sent
to the client.

Several commands are at your disposal; they are detailed in the SSI module section
in this chapter. The one we are interested in for now is the include command :
including a file into another file:
    <!--# include virtual="/footer.php?id=123" -->
The specified file is not just opened and read from a static location. Instead, a whole
subrequest is processed by Nginx, and the body of the response is inserted instead of
the include tag.

-> Conditional structure
The Rewrite module introduces a new set of directives and blocks, among which is
the if conditional structure:
    server {
         if ($request_method = POST) {
           ...
         }
    }
This gives you the possibility to apply a configuration according to the specified
condition. If the condition is true, the configuration is applied; otherwise, it isn't.
The following table describes the different syntaxes accepted when forming a condition:

   Operator         Description

   None             The condition is true if the specified variable or data is not equal to an
                    empty string or a string starting with character 0:
                       if ($string) {
                          ...
                       }

   =, !=            The condition is true if the argument preceding the = symbol is
                    equal to the argument following it. The following example can be
                    read as "if the request_method is equal to POST, then apply the
                    configuration":
                       if ($request_method = POST) {
                          ...
                       }
                    The != operator does the opposite: "if the request method is different
                    than GET, then apply the configuration":
                       if ($request_method != GET) {
                          ...
                       }

   ~, ~*, !~,       The condition is true if the argument preceding the ~ symbol matches
   !~*              the regular expression pattern placed after it:
                       if ($request_filename ~ "\.txt$") {
                          ...
                       }
                    ~ is case-sensitive, ~* is case-insensitive. Use the ! symbol to negate
                    the matching:
                       if ($request_filename !~* "\.php$") {
                          ...
                       }
                    Note that you can insert capture buffers in the regular expression:
                       if ($uri ~ "^/search/(.*)$") {
                          set $query $1;
                          rewrite ^ http://google.com/search?q=$query;

    -f, !-f Tests the existence of the specified file:
           if (-f $request_filename) {
             ... # if the file exists
           }
           Use !-f to test the non-existence of the file:
           if (!-f $request_filename) {
             ... # if the file does not exist
           }
-d, !-d Similar to the -f operator, for testing the existence of a directory.
-e, !-e Similar to the -f operator, for testing the existence of a file, directory,
        or symbolic link.
-x, !-x Similar to the -f operator, for testing if a file exists and is executable.

-> Directives
The Rewrite module provides you with a set of directives that do more than just
rewriting a URI. The following table describes these directives along with the context
in which they can be employed:
  
  Directive           Description
  
  rewrite             As discussed previously, the rewrite directive allows you to
  Context: server,    rewrite the URI of the current request, thus resetting the treatment
  location, if        of the said request.
                      Syntax: rewrite regexp replacement [flag];
                      Where regexp is the regular expression the URI should match in
                      order for the replacement to apply.
                      Flag may take one of the following values:

                         -last: The current rewrite rule should be the last to be
                             applied. After its application, the new URI is processed by
                             Nginx and a location block is searched for. However,
                             further rewrite instructions will be disregarded.

                         -break: The current rewrite rule is applied, but Nginx
                             does not initiate a new request for the modified URI (does
                             not restart the search for matching location blocks). All
                             further rewrite directives are ignored.

                         -redirect: Returns a 302 Moved temporarily HTTP
                             response, with the replacement URI set as value of the
                             location header.

                         -permanent: Returns a 301 Moved permanently HTTP
                             response, with the replacement URI set as the value of the
                             location header.

                         -If you specify a URI beginning with http:// as the
                             replacement URI, Nginx will automatically use the
                             redirect flag.
                    -Note that the request URI processed by the directive is a
                        relative URI: It does not contain the hostname and protocol.
                        For a request such as http://website.com/documents/
                        page.html, the request URI is /documents/page.html.
                    -Is decoded: The URI corresponding to a request such as
                        http://website.com/my%20page.html would be /my
                        page.html.
                    -Does not contain arguments: For a request such as http://
                        website.com/page.php?id=1&p=2, the URI would be
                        /page.php. When rewriting the URI, you don't need to
                        consider including the arguments in the replacement URIâ
                        Nginx does it for you. If you wish for Nginx to not include
                        the arguments in the rewritten URI, then insert a ? at the
                        end of the replacement URI: rewrite ^/search/(.*)$
                        /search.php?q=$1?.
                    -Examples:
                        rewrite    ^/search/(.*)$ /search.php?q=$1;
                        rewrite    ^/search/(.*)$ /search.php?q=$1?;
                        rewrite    ^ http://website.com;
                        rewrite    ^ http://website.com permanent;

break                   The break directive is used to prevent further rewrite directives.
Context: server,        Past this point, the URI is fixed and cannot be altered.
location, if            Example:
                         if (-f $uri) {
                            break; # break if the file exists
                            }
                            if ($uri ~ ^/search/(.*)$) {
                            set $query $1;
                            rewrite ^ /search.php?q=$query?;
                            }       
                 This example rewrites /search/anything-like queries to /
                 search.php?q=anything. However, if the requested file exists
                 (such as /search/index.html), the break instruction prevents
                 Nginx from rewriting the URI.

return           Interrupts the request treatment process and returns the specified
Context: server, HTTP status code or specified text.
location, if     Syntax: return code | text;
                 Where code is picked among the following status codes: 204, 400,
                 402 to 406, 408, 410, 411, 413, 416, and 500 to 504. In addition,
                 you may use the Nginx-specific code 444 in order to return a HTTP
                 200 OK status code with no further header or body data. You
                 may also specify the raw text that will be returned to the user as
                 response body.
                 Example:
                     if ($uri ~ ^/admin/) {
                       return 403;
                       # the instruction below is NOT executed
                       # as Nginx already completed the request
                       rewrite ^ http://website.com;
                     }

set              Initializes or redefines a variable. Note that some variables cannot
Context: server, be redefined, for example, you are not allowed to alter $uri.
location, if     Syntax: set $variable value;
                 Examples:
                     set $var1 "some text";
                     if ($var1 ~ ^(.*) (.*)$) {
                       set $var2 $1$2; #concatenation
                       rewrite ^ http://website.com/$var2;
                     }

uninitialized_   If set to on, Nginx will issue log messages when the configuration
variable_warn    employs a variable that has not yet been initialized.
Context: http,   Syntax: on or off
server,              uninitialized_variable_warn on;
location, if

rewrite_log      If set to on, Nginx will issue log messages for every operation
Context: http,   performed by the rewrite engine at the notice error level (see
server,          error_log directive).
location, if     Syntax: on or off
                 Default value: off
                     rewrite_log off;

Exemples classiques de rewrites rules :

Common rewrite rules
Here is a set of rewrite rules that satisfy basic needs for dynamic websites that
wish to beautify their page links thanks to the URL rewriting mechanism. You
will obviously need to adjust these rules according to your particular situation
as every website is different.
->Performing a search
This rewrite rule is intended for search queries. Search keywords are included in
the URL.
  Input URI         http://website.com/search/some-search-keywords
  Rewritten URI     http://website.com/search.php?q=some-search-keywords
  Rewrite rule      rewrite ^/search/(.*)$ /search.php?q=$1?;

->User profile page
Most dynamic websites that allow visitors to register, offer a profile view page. URLs
of this form can be employed, containing both the user ID and the username.
  Input URI           http://website.com/user/31/James
  Rewritten URI       http://website.com/user.php?id=31&name=James
  Rewrite rule        rewrite ^/user/([0-9]+)/(.+)$ /user.
                      php?id=$1&name=$2?;
->Multiple parameters
Some websites may use different syntaxes for the argument string, for example, by
separating non-named arguments with slashes.
  Input URI         http://website.com/index.php/param1/param2/param3
  Rewritten URI     http://website.com/index.php?p1=param1&p2=param2&p3=
                    param3
  Rewrite rule      rewrite ^/index.php/(.*)/(.*)/(.*)$ /index.
                    php?p1=$1&p2=$2&p3=$3?;


= SSI :

a examiner : les commandes permettant de générer à partir de txt du html coté serveur : utile pour maintenance. 

= Divers modules :

-> Acces et logging 

-index 
pour fournir les fichiers de base lors d'une requette simple(sans fichier précisé par ex : http://localhost > renvoit http://localhost/index.php / html .. en fonction de la conf nginx.

    index index.php index.html index.htm;
    index index.php index2.php /catchall.php;
This directive is valid in the following contexts: http, server, location.


-Autoindex
If Nginx cannot provide an index page for the requested directory, the default behavior is to return a 403 Forbidden HTTP error page. With the following set of directives, you enable an automatic listing of the files that are present in the
requested directory:
Three columns of information appear for each file : the filename, the file date and
time, and the file size in bytes.
Directive                   Description

autoindex                   Enables or disables automatic directory listing for directories
Context: http, server,      missing an index page.
location                    Syntax: on or off

autoindex_exact_            If set to on, this directive ensures that the listing displays file
size                        sizes in bytes. Otherwise, another unit is employed, such as
Context: http, server,      KB, MB, or GB.
location                    Syntax: on or off
                            Default value: on

autoindex_localtime         By default, this directive is set to off, so the date and time of
Context: http, server,      files in the listing appears as GMT time. Set it to on to make
location                    use of the local server time.
                            Syntax: on or off
                            Default value: off

-Log :
This module controls the behavior of Nginx regarding access logs. It is a key module
for system administrators as it allows analyzing the runtime behavior of web
applications. It is composed of three essential directives:
Directive                Description

access_log               This parameter defines the access log file path, the format
Context: http, server,   of entries in the access log by selecting a template name, or
location                 disables access logging.
                         Syntax: access_log path [format [buffer=size]] |
                         off;
                         Some remarks concerning the directive syntax:
                            -Use access_log off to disable access logging at the
                               current level
                            -The format argument corresponds to a template declared
                               with the log_format directive, described below
                            -If the format argument is not specified, the default format
                               is employed (combined)
                            -You may use variables in the file path
log_format               Defines a template to be utilized by the access_log directive,
Context: http, server,   describing the contents that should be included in an entry of
location                 the access log.
                          Syntax: log_format template_name format_string;
                          The default template is called combined and matches the
                          following example:
EXEMPLE : 
                             log_format combined '$remote_addr - $remote_user
                             [$time_local] '"$request" $status
                             $body_bytes_sent '"$http_referer"
                             "$http_user_agent"';
                             # Other example
                             log_format simple '$remote_addr $request';

open_log_file_cache       Configures the cache for log file descriptors. Please refer to the
                          open_file_cache directive of the HTTP Core module for
Context: http, server,    additional information.
location                  Syntax: open_log_file_cache max=N [inactive=time]
                          [min_uses=N] [valid=time] | off;
                          The arguments are similar to the open_file_cache and other
                          related directives; the difference being that this applies to access
                          log files only.
The Log module also enables several new variables, though they are only accessible
when writing log entries:

-$connection: The connection number
-$pipe: The variable is set to "p" if the request was pipelined
-$time_local: Local time (at the time of writing the log entry)
-$msec: Local time (at the time of writing the log entry) to the microsecond
-$request_time: Total length of the request processing, in milliseconds
-$status: Response status code
-$bytes_sent: Total number of bytes sent to the client
-$body_bytes_sent: Number of bytes sent to the client for the response body
-$apache_bytes_sent: Similar to $body_bytes, which corresponds to the %B parameter of Apache's mod_log_config
-$request_length: Length of the request body

-> Limits and restrictions
The following modules allow you to regulate access to the documents of your
websites - require users to authenticate, match a set of rules, or simply restrict
access to certain visitors.

-Auth_basic module
The auth_basic module enables the basic authentication functionality. With the
two directives that it reveals, you can make it so that a specific location of your
website (or your server) is restricted to users that authenticate using a username
and password:
 
    location /admin/ {
          auth_basic "Admin control panel";
          auth_basic_user_file access/password_file;
    }

The first directive, auth_basic, can be set to either off or a text message usually
referred to as authentication challenge or authentication realm. This message is displayed
by web browsers in a username/password box when a client attempts to access the
protected resource.
The second one, auth_basic_user_file, defines the path of the password file
relative to the directory of the configuration file. A password file is formed of lines
respecting the following syntax: username:password[:comment]. 

The password must be encrypted with the crypt(3) function, for example, using the htpasswd
command-line utility from Apache.
If you aren't too keen on installing Apache on your system just for the sake of the htpasswd tool, you may resort to online tools as there are plenty of them available. Fire up your favorite search engine and type "online htpasswd".

-Access : 
Two important directives are brought up by this module: allow and deny. They let you allow or deny access to a resource for a specific IP address or IP address range. Both directives have the same syntax: allow IP | CIDR | all, where IP is an IP
address, CIDR is an IP address range (CIDR syntax), and all specifies that the
directive applies to all clients:

     location {
         allow 127.0.0.1; # allow local IP address
         deny all; # deny all other IP addresses
     }

Note that rules are processed from top-down if your first instruction is deny all,
all possible allow exceptions that you place afterwards will have no effect. The
opposite is also true if you start with allow all, all possible deny directives that
you place afterwards will have no effect, as you already allowed all IP addresses.

-Limit connections
The mechanism induced by this module is a little more complex than regular ones.
It allows you to define the maximum amount of simultaneous connections to the
server for a specific zone.
The first step is to define the zone using the limit_conn_zone directive:
     Directive syntax: limit_conn_zone $variable zone=name:size;
     $variable is the variable that will be used to differentiate one client from another, typically $binary_remote_addr the IP address of the client in binary format (more efficient than ASCII)
     name is an arbitrary name given to the zone
     size is the maximum size you allocate to the table storing session states

The following example defines zones based on the client IP addresses:
     limit_conn_zone $binary_remote_addr zone=myzone:10m;
Now that you have defined a zone, you may limit connections using limit_conn:
     limit_conn zone_name connection_limit;

When applied to the previous example it becomes:
     location /downloads/ {
         limit_conn myzone 1;
     }
As a result, requests that share the same $binary_remote_addr are subject to the
connection limit (one simultaneous connection). If the limit is reached, all additional
concurrent requests will be answered with a 503 Service unavailable HTTP
response. If you wish to log client requests that are affected by the limits you have
set, enable the limit_conn_log_level directive and specify the log level (info |
notice | warn | error).

-Limit request
In a similar fashion, the Limit request module allows you to limit the amount of
requests for a defined zone.
Defining the zone is done via the limit_req_zone directive; its syntax differs from
the Limit zone equivalent directive:
     limit_req_zone $variable zone=name:max_memory_size rate=rate;

The directive parameters are identical, except for the trailing rate: expressed in
requests per second (r/s) or requests per minute (r/m). It defines a request rate that
will be applied to clients where the zone is enabled. To apply a zone to a location,
use the limit_req directive:
     limit_req zone=name burst=burst [nodelay];

The burst parameter defines the maximum possible bursts of requests when the
amount of requests received from a client exceeds the limit defined in the zone,
the responses are delayed in a manner that respects the rate that you defined. To a
certain extent, only a maximum of burst requests will be accepted simultaneously.
Past this limit, Nginx returns a 503 Service Unavailable HTTP error response:
     limit_req_zone $binary_remote_addr zone=myzone:10m rate=2r/s;
     ...
     location /downloads/ {
         limit_req zone=myzone burst=10;
     }
If you wish to log client requests that are affected by the limits you have set, enable
the limit_req_log_level directive and specify the log level (info | notice | warn
| error).

>-Content and encoding
The following set of modules provides functionalities having an effect on the
contents served to the client, either by modifying the way the response is encoded,
by affecting the headers, or by generating a response from scratch.

-Empty GIF
The purpose of this module is to provide a directive that serves a 1 x 1 transparent
GIF image from the memory. Such files are sometimes used by web designers to
tweak the appearance of their website. With this directive, you get an empty GIF
straight from the memory instead of reading and processing an actual GIF file from
the storage space.
To utilize this feature, simply insert the empty_gif directive in the location of
your choice:
     location = /empty.gif {
           empty_gif;
     }
-FLV and MP4
FLV and MP4 are separate modules enabling a simple functionality that becomes
useful when serving Flash (FLV) or MP4 video files. It parses a special argument
of the request, start, which indicates the offset of the section the client wishes
to download or pseudo-stream. The video file must thus be accessed with the
following URI: video.flv?start=XXX. This parameter is prepared automatically
by mainstream video players such as JWPlayer.
                       This module is not included in the default Nginx build.
To utilize this feature, simply insert the flv or mp4 directive in the location of
your choice:
     location ~* \.flv {
           flv;
     }
     location ~* \.mp4 {
           mp4;
     }
Be aware that in case Nginx fails to seek to the requested position within the video
file, the request will result in a 500 Internal Server Error HTTP response.
JWPlayer sometimes misinterprets this error and simply displays a "Video not
found" error message.

-HTTP headers
Two directives are introduced by this module that will affect the header of the
response sent to the client.
First, add_header Name value lets you add a new line in the response headers,
respecting the following syntax: Name: value. The line is added only for responses
of the following code: 200, 201, 204, 301, 302, and 304. You may insert variables in
the value argument.

Additionally, the expires directive allows you to control the value of the Expires
and Cache-Control HTTP header sent to the client, affecting requests of the same code,
as listed above. It accepts a single value among the following:
     -off: Does not modify either headers.
     -A time value: The expiration date of the file is set to the current time +,
         the time you specify. For example, expires 24h will return an expiry
         date set to 24 hours from now.
     -epoch: The expiration date of the file is set to January 1, 1970. The
         Cache-Control header is set to no-cache.
     -max: The expiration date of the file is set to December 31, 2037. The
         Cache-Control header is set to 10 years.

-Gzip filter
This module allows you to compress the response body with the Gzip algorithm
before sending it to the client. To enable Gzip compression, use the gzip directive
(on or off) at the http, server, location, and even the if level (though that is
not recommended). The following directives will help you further configure the
filter options:
Directive             Description
gzip_buffers          Defines the amount and size of buffers to be used for storing the
Context: http,        compressed response.
server, location      Syntax: gzip_buffers amount size;
                      Default: gzip_buffers 4 4k (or 8 k depending on the OS).
gzip_comp_level       Defines the compression level of the algorithm. The specified value
Context: http,        ranges from 1 (low compression, faster for the CPU) to 9 (high
server, location      compression, slower).
                      Syntax: Numeric value.
                      Default: 1
gzip_disable          Disables Gzip compression for requests where the User-Agent
Context: http,        HTTP header matches the specified regular expression.
server, location      Syntax: Regular expression
                      Default: None
gzip_http_       Enables Gzip compression for the specified protocol version.
version
                 Syntax: 1.0 or 1.1
Context: http,
                 Default: 1.1
server, location
gzip_min_length  If the response body length is inferior to the specified value, it is
Context: http,   not compressed.
server, location Syntax: Numeric value (size)
                 Default: 0
gzip_proxied     Enables or disables Gzip compression for the body of responses
Context: http,   received from a proxy (see reverse-proxying mechanisms in later
server, location chapters).
                 The directive accepts the following parameters; some can be
                 combined:
                     -off/any: Disables or enables compression for all requests
                     -expired: Enables compression if the Expires header
                        prevents caching
                     -no-cache/no-store/private: Enables compression
                        if the Cache-Control header is set to no-cache, no-store, or
                        private
                     -no_last_modified: Enables compression in case the Last-
                        Modified header is not set
                     -no_etag: Enables compression in case the ETag header is
                        not set
                     -auth: Enables compression in case an Authorization header
                        is set
gzip_types       Enables compression for types other than the default text/html
Context: http,   MIME type.
server, location Syntax:
                     gzip_types mime_type1 [mime_type2...]
                     gzip_types *;
                 Default: text/html (cannot be disabled)
gzip_vary        Adds the Vary: Accept-Encoding HTTP header to the response.
Context: http,   Syntax: on or off
server, location
                 Default: off

-> Charset filter
With the Charset filter module, you can control the character set of the response
body more accurately. Not only are you able to specify the value of the charset
argument of the Content-Type HTTP header (such as Content-Type: text/
html; charset=utf-8), but Nginx can also re-encode data to a specified encoding
method automatically.
 
 Directive              Description
 charset                This directive adds the specified encoding to the Content-Type
 Context: http,         header of the response. If the specified encoding differs from the
 server, location,      source_charset one, Nginx re-encodes the document.
 if                     Syntax: charset encoding | off;
                        Default: off
                        Example: charset utf-8;
 
 source_charset         Defines the initial encoding of the response; if the value specified in
 Context: http,         the charset directive differs, Nginx re-encodes the document.
 server, location,      Syntax: source_charset encoding;
 if
 
 override_              When Nginx receives a response from the proxy or FastCGI
 charset                gateway, this directive defines whether or not the character
 Context: http,         encoding should be checked and potentially overridden.
 server, location,      Syntax: on or off
 if
                        Default: off
 charset_types          Defines the MIME types that are eligible for re-encoding.
 Context: http,         Syntax:
 server, location         charset_types mime_type1 [mime_type2...];
                          charset_types *Â ;
                        Default: text/html, text/xml, text/plain, text/vnd.wap.
                        wml, application/x-javascript, application/rss+xml
 charset_map            Lets you define character re-encoding tables. Each line of the table
 Context: http          contains two hexadecimal codes to be exchanged. You will find re-
                        encoding tables for the koi8-r character set in the default Nginx
                        configuration folder (koi-win and koi-utf).
                        Syntax: charset_map src_encoding dest_encoding { ...}


-> Memcached :
Memcached is a daemon application that can be connected to via sockets. Its main
purpose, as the name suggests, is to provide an efficient distributed key/value
memory caching system. The Nginx Memcached module provides directives allowing
you to configure access to the Memcached daemon.
 Directive                            Description
 memcached_pass                       Defines the hostname and port of the Memcached
 Context: location, if                daemon.
                                      Syntax: memcached_pass hostname:port;
                                      Example: memcached_pass localhost:11211;
 memcached_bind                       Forces Nginx to use the specified local IP address
 Context: http, server, location      for connecting to the Memcached server. This can
                                      come in handy if your server has multiple network
                                      cards connected to different networks.
                                      Syntax: memcached_bind IP_address;
                                      Example: memcached_bind 192.168.1.2;
 memcached_connect_timeout            Defines the connection timeout in milliseconds
 Context: http, server, location      (default: 60,000). Example: memcached_connect_
                                      timeout 5000;
 memcached_send_timeout               Defines the data writing operations timeout
 Context: http, server, location      in milliseconds (default: 60,000). Example:
                                      memcached_send_timeout 5,000;
 memcached_read_timeout               Defines the data reading operations timeout
 Context: http, server, location      in milliseconds (default: 60,000). Example:
                                      memcached_read_timeout 5,000;
 memcached_buffer_size                Defines the size of the read and write buffer, in
 Context: http, server, location      bytes (default: page size). Example: memcached_
                                      buffer_size 8k;
 memcached_next_upstream              When the memcached_pass directive is connected
 Context: http, server, location      to an upstream block (see Upstream module),
                                      this directive defines the conditions that should
                                      be matched in order to skip to the next upstream
                                      server.
                                      Syntax: Values selected among error timeout,
                                      invalid_response, not_found, or off
                                      Default: error timeout
                                      Example: memcached_next_upstream off;

  
Additionally, you will need to define the $memcached_key variable that defines the
key of the element that you are placing or fetching from the cache. You may, for
instance, use set $memcached_key $uri or set $memcached_key $uri?$args.
Note that the Nginx Memcached module is only able to retrieve data from the cache;
it does not store the result of requests. Storing data in the cache should be done by
a server-side script. You just need to make sure to employ the same key naming
scheme in both your server-side scripts and the Nginx configuration. As an example,
we could decide to use memcached to retrieve data from the cache before passing the
request to a proxy, if the requested URI is not found (see Chapter 7, From Apache to
Nginx, for more details about the Proxy module):
    server {
         server_name example.com;
         [...]
         location / {
              set $memcached_key $uri;
              memcached_pass 127.0.0.1:11211;
              error_page 404 @notcached;
         }
         location @notcached {
              internal;
              # if the file is not found, forward request to proxy
              proxy_pass 127.0.0.1:8080;
         }
    }

-> Image filter
This module provides image processing functionalities through the GD Graphics
Library (also known as gdlib).

Make sure to employ the following directives on a location block that filters image
files only, such as location ~* \.(png|jpg|gif)$ {... }.
  Directive                 Description
  image_filter              Lets you apply a transformation on the image before sending
  Context: location         it to the client. There are five options available:
                                -test: Makes sure that the requested document is an
                                    image file, returns a 415 Unsupported media type
                                    HTTP error if the test fails.
                                -size: Composes a simple JSON response indicating
                                    information about the image such as the size and
                                    type (for example; { "img": { "width":50,
                                    "height":50, "type":"png"}}). If the file is
                                    invalid, a simple {} is returned.
                                -resize width height: Resizes the image to the
                                    specified dimensions.
                                -crop width height: Selects a portion of the image
                                    of the specified dimensions.
                                -rotate 90 | 180 | 270: Rotates the image by the
                                    specified angle (in degrees).
                            Example: image_filter resize 200 100;
  image_filter_buffer       Defines the maximum file size for images to be processed.
  Context: http, server,    Default: image_filter_buffer 1m;
  location
  image_filter_jpeg_        Defines the quality of output JPEG images.
  quality
                            Default: image_filter_jpeg_quality 75;
  Context: http, server,
  location
  image_filter_             By default, PNG and GIF images keep their existing
  transparency              transparency during operations you perform using the Image
  Context: http, server,    Filter module. If you set this directive to off, all existing
  location                  transparency will be lost but the image quality will be
                            improved.
                            Syntax: on or off
                            Default: on
  image_filter_             Sharpens the image by specified percentage (value may
  sharpen                   exceed 100).
  Context: http, server,    Syntax: Numeric value
  location
                            Default: 0
  
  
Please note that when it comes to JPG images, Nginx automatically strips off
metadata (such as EXIF) if it occupies more than 5 percent of the total space of
the file.

-> XSLT
The Nginx XSLT module allows you to apply an XSLT transform on an XML file or
response received from a backend server (proxy, FastCGI, and so on) before serving
the client.
                   This module is not included in the default Nginx build.
 Directive            Description
 xml_entities         Specifies the DTD file containing symbolic element definitions.
 Context: http,       Syntax: File path
 server, location     Example: xml_entities xml/entities.dtd;
 xslt_stylesheet      Specifies the XSLT template file path with its parameters. Variables
 Context: location    may be inserted in the parameters.
                      Syntax: xslt_stylesheet template [param1] [param2â¦];
                      Example: xslt_stylesheet xml/sch.xslt param=value;
 xslt_types           Defines additional MIME types to which the transforms may apply,
 Context: http,       other than text/xml.
 server, location     Syntax: MIME type
                      Example:
                         xslt_types text/xml text/plain;
                         xslt_types *;
 xslt_paramxslt_      Both directives allow defining parameters for XSLT stylesheets. The
 string_param         difference lies in the way the specified value is interpreted: using
 Context: http,       xslt_param, XPath expressions in the value are processed; while
 server, location     xslt_string_param should be used for plain character strings.
                      Syntax: xslt_param key value;

-> About your visitors
The following set of modules provides extra functionality that will help you find out
more information about the visitors, such as by parsing client request headers for
browser name and version, assigning an identifier to requests presenting similarities,
and so on.
  
-Browser
The Browser module parses the User-Agent HTTP header of the client request in
order to establish values for variables that can be employed later in the configuration.
The three variables produced are:
     -$modern_browser: If the client browser is identified as being a modern
         web browser, the variable takes the value defined by the modern_browser_
         value directive.
     -$ancient_browser: If the client browser is identified as being an old web
         browser, the variable takes the value defined by ancient_browser_value.
     -$msie: This variable is set to 1 if the client is using a Microsoft IE browser.

To help Nginx recognize web browsers, telling the old from the modern, you need to
insert multiple occurrences of the ancient_browser and modern_browser directives:
     modern_browser opera 10.0;
With this example, if the User-Agent HTTP header contains Opera 10.0, the client
browser is considered modern.
-Map
Just like the Browser module, the Map module allows you to create maps of values
depending on a variable:
     map $uri $variable {
       /page.html 0;
       /contact.html 1;
       /index.html 2;
       default 0;
     }
     rewrite ^ /index.php?page=$variable;
Note that the map directive can only be inserted within the http block. Following this
example, $variable may have three different values. If $uri was set to /page.html,
$variable is now defined as 0; if $uri was set to /contact.html, $variable is
now 1; if $uri was set to /index.html, $variable now equals 2. For all other cases
(default), $variable is set to 0. The last instruction rewrites the URL accordingly.
Apart from default, the map directive accepts another special keyword: hostnames.
It allows you to match hostnames using wildcards such as *.domain.com.

-Two additional directives allow you to tweak the way Nginx manages the
mechanism in memory:
    -map_hash_max_size: Sets the maximum size of the hash table holding a map
    -map_hash_bucket_size: The maximum size of an entry in the map
Regular expressions may also be used in patterns if you prefix them with ~ (case
sensitive) or ~* (case insensitive):
    map $http_referer $ref {
    ~google "Google";
         ~* yahoo "Yahoo";
         \~bing "Bing"; # not a regular expression due to the \ before the
    tilde
    default $http_referer; # variables may be used
    }

->Geo
The purpose of this module is to provide functionality that is quite similar to the
map directive affecting a variable based on client data (in this case, the IP address).
The syntax is slightly different in the extent that you are allowed to specify address
ranges (in CIDR format):

    geo $variable {
       default unknown;
       127.0.0.1      local;
       123.12.3.0/24 uk;
       92.43.0.0/16 fr;
    }

Note that the above block is being presented to you just for the sake of the example
and does not actually detect U.K. and French visitors; you'll want to use the GeoIP
module if you wish to achieve proper geographical location detection. In this block,
you may insert a number of directives that are specific to this module:
    -delete: Allows you to remove the specified subnetwork from the mapping.
    -default: The default value given to $variable in case the user's IP address
        does not match any of the specified IP ranges.
    -include: Allows you to include an external file.
    -proxy: Defines a subnet of trusted addresses. If the user IP address is among
        the trusted, the value of the X-Forwarded-For header is used as IP address
        instead of the socket IP address.
    -proxy_recursive: If enabled, this will look for the value of the
        X-Forwarded-For header even if the client IP address is not trusted.
    -ranges: If you insert this directive as the first line of your geo block, it
        allows you to specify IP ranges instead of CIDR masks. The following
        syntax is thus permitted: 127.0.0.1-127.0.0.255              LOCAL;

->GeoIP
Although the name suggests some similarities with the previous one, this optional
module provides accurate geographical information about your visitors by making
use of the MaxMind (www.maxmind.com) GeoIP binary databases. You need to
download the database files from the MaxMind website and place them in your
Nginx directory.
This module is not included in the default Nginx build.

All you have to do then is specify the database path with either directive:
    geoip_country country.dat; # country information db
    geoip_city city.dat; # city information db
    geoip_org geoiporg.dat; # ISP/organization db

The first directive enables several variables: $geoip_country_code (two-letter
country code), $geoip_country_code3 (three-letter country code), and $geoip_
country_name (full country name). The second directive includes the same
variables but provides additional information: $geoip_region, $geoip_city,
$geoip_postal_code, $geoip_city_continent_code, $geoip_latitude, $geoip_
longitude, $geoip_dma_code, $geoip_area_code, $geoip_region_name. The third
directive offers information about the organization or ISP that owns the specified IP
address, by filling up the $geoip_org variable.
If you need the variables to be encoded in UTF-8, simply add the utf8 keyword at the end of the geoip_ directives.

-> UserID filter
This module assigns an identifier to clients by issuing cookies. The identifier can be
accessed from variables $uid_got and $uid_set further in the configuration.
 Directive                  Description
 userid                     Enables or disables issuing and logging of cookies.
 Context: http, server,     The directive accepts four possible values:
 location
                               -on: Enables v2 cookies and logs them
                               -v1: Enables v1 cookies and logs them
                               -log: Does not send cookie data but logs incoming
                                   cookies
                               -off: Does not send cookie data
                            Default value: userid off;
 userid_service             Defines the IP address of the server issuing the cookie.
 Context: http, server,     Syntax: userid_service ip;
 location
                            Default: IP address of the server
 userid_name                Defines the name assigned to the cookie.
 Context: http, server,     Syntax: userid_name name;
 location
                            Default value: The user identifier
 userid_domain              Defines the domain assigned to the cookie.
 Context: http, server,     Syntax: userid_domain domain;
 location
                            Default value: None (the domain part is not sent)
 userid_path                Defines the path part of the cookie.
 Context: http, server,     Syntax: userid_path path;
 location
                            Default value: /
 userid_expires             Defines the cookie expiration date.
 Context: http, server,     Syntax: userid_expires date | max;
 location
                            Default value: No expiration date
 userid_p3p                 Assigns a value to the P3P header sent with the cookie.
 Context: http, server,     Syntax: userid_p3p data;
 location
                            Default value: None

  
  
-> Referer
A simple directive is introduced by this module: valid_referers. Its purpose is to
check the Referer HTTP header from the client request and possibly to deny access
based on the value. If the referrer is considered invalid, $invalid_referer is set to
1. In the list of valid referrers, you may employ three kinds of values:
     -None: The absence of a referrer is considered to be a valid referrer
     -Blocked: A masked referrer (such as XXXXX) is also considered valid
     -A server name: The specified server name is considered to be a valid referrer
Following the definition of the $invalid_referer variable, you may, for example,
return an error code if the referrer was found invalid:
     valid_referers none blocked *.website.com *.google.com;
       if ($invalid_referer) {
       return 403;
     }
Be aware that spoofing the Referer HTTP header is a very simple process, so
checking the referrer of client requests should not be used as a security measure.


-> Real IP
This module provides one simple feature : it replaces the client IP address by the
one specified in the X-Real-IP HTTP header for clients that visit your website behind
a proxy or for retrieving IP addresses from the proper header if Nginx is used as a
backend server (it essentially has the same effect as Apache's mod_rpaf, see Chapter
7, From Apache to Nginx, for more details). To enable this feature, you need to insert
the real_ip_header directive that defines the HTTP header to be exploited : either
X-Real-IP or X-Forwarded-For. The second step is to define trusted IP addresses.

In other words, the clients that are allowed to make use of those headers. This can
be done thanks to the set_real_ip_from directive, which accepts both IP addresses
and CIDR address ranges:
     real_ip_header X-Forwarded-For;
     set_real_ip_from 192.168.0.0/16;
     set_real_ip_from 127.0.0.1;
     set_real_ip_from unix:; # trusts all UNIX-domain sockets

->Split Clients
The Split Clients module provides a resource-efficient way to split the visitor base
into subgroups based on the percentages that you specify. To distribute visitors into
one group or another, Nginx hashes a value that you provide (such as the visitor's
IP address, cookie data, query arguments, and so on) and decides which group the
visitor should be affected to. The following example configuration divides visitors
up into three groups based on their IP address. If a visitor is affected to the first 50
percent, the value of $variable will be set to group1:
    split_clients "$remote_addr" $variable {
       50% "group1";
       30% "group2";
       20% "group3";
    }
    location ~ \.php$ {
       set $args "${query_string}&group=${variable}";
    }

= SSL and security
Nginx provides secure HTTP functionalities through the SSL module but also offers
an extra module called Secure Link that helps you protect your website and visitors in
a totally different way.

->SSL
The SSL module enables HTTPS support, HTTP over SSL/TLS in particular. It gives
you the possibility to serve secure websites by providing a certificate, a certificate
key, and other parameters defined with the following directives:

Directive              Description

ssl_certificate        Sets the path of the PEM certificate.
Context: http, server  Syntax: File path

ssl_certificate_key    Sets the path of the PEM secret key file.
Context: http, server  Syntax: File path

ssl_client_certificate Sets the path of the client PEM certificate.
Context: http, server  Syntax: File path

ssl_crl                Orders Nginx to load a CRL (Certificate Revocation
Context: http, server  List) file, which allows checking the revocation status of
                       certificates.
ssl_dhparam            Sets the path of the Diffie-Hellman parameters file.
Context: http, server  Syntax: File path.

ssl_protocols          Specifies the protocol that should be employed.
Context: http, server  Syntax: ssl_protocols [SSLv2] [SSLv3]
                       [TLSv1] [TLSv1.1] [TLSv1.2];
                       Default: ssl_protocols SSLv2 SSLv3 TLSv1;
ssl_ciphers            Specifies the ciphers that should be employed. The
Context: http, server  list of available ciphers can be obtained running the
                       following command from the shell: openssl ciphers.
                       Syntax: ssl_ciphers cipher1[:cipher2...;
                       Default: ssl_ciphers ALL:!ADH:RC4+RSA:+HIGH:
                       +MEDIUM:+LOW:+SSLv2:+EXP;
ssl_prefer_server_     Specifies whether server ciphers should be preferred
ciphers                over client ciphers.
Context: http, server  Syntax: on or off
                       Default: off
ssl_verify_client      Enables verifying certificates transmitted by the client
Context: http, server  and sets the result in the $ssl_client_verify. The
                       optional_no_ca value verifies the certificate if there
                       is one, but does not require it to be signed by a trusted
                       CA certificate.
                       Syntax: on | off | optional | optional_no_ca
                       Default: off
ssl_verify_depth       Specifies the verification depth of the client certificate
Context: http, server  chain.
                       Syntax: Numeric value
                       Default: 1
  
ssl_session_cache                 Configures the cache for SSL sessions.
Context: http, server             Syntax: off, none, builtin:size or
                                   shared:name:size
                                   Default: off (disables SSL sessions)
ssl_session_timeout               When SSL sessions are enabled, this directive defines
Context: http, server             the timeout for using session data.
                                   Syntax: Time value
                                   Default: 5 minutes

Additionally, the following variables are made available:
    -$ssl_cipher: Indicates the cipher used for the current request
    -$ssl_client_serial: Indicates the serial number of the client certificate
    -$ssl_client_s_dn and $ssl_client_i_dn: Indicates the value of the
        Subject and Issuer DN of the client certificate
    -$ssl_protocol: Indicates the protocol at use for the current request
    -$ssl_client_cert and $ssl_client_raw_cert: Returns client
        certificate data, which is raw data for the second variable
    -$ssl_client_verify: Set to SUCCESS if the client certificate was
        successfully verified
    -$ssl_session_id: Allows you to retrieve the ID of an SSL session

- Setting up an SSL certificate
Although the SSL module offers a lot of possibilities, in most cases only a couple of
directives are actually useful for setting up a secure website. This guide will help
you configure Nginx to use an SSL certificate for your website (in the example, your
website is identified by secure.website.com). Before doing so, ensure that you
already have the following elements at your disposal:

    1/ A  .key file generated with the following command: openssl genrsa -out
        secure.website.com.key 1024 (other encryption levels work too).
    2/ A .csr file generated with the following command: 
openssl req -new -key secure.website.com.key -out secure.website.com.csr.
    3/ Your website certificate file, as issued by the Certificate Authority, for
        example, secure.website.com.crt. (Note: In order to obtain a certificate
        from the CA, you will need to provide your .csr file.)
    4/ The CA certificate file as issued by the CA (for example, gd_bundle.crt if
        you purchased your certificate from GoDaddy.com).
  
The first step is to merge your website certificate and the CA certificate together with
the following command:
     cat secure.website.com.crt gd_bundle.crt > combined.crt
You are then ready to configure Nginx to serve secure content:

     server {
         listen 443;
         server_name secure.website.com;
         ssl on;
         ssl_certificate /path/to/combined.crt;
         ssl_certificate_key /path/to/secure.website.com.key;
         ...
     }


->Secure link
Totally independent from the SSL module, Secure link provides a basic protection by
checking the presence of a specific hash in the URL before allowing the user to access
a resource:
     location /downloads/ {
     secure_link_md5    "secret";
     secure_link $arg_hash,$arg_expires;
         if ($secure_link = "") {
            return 403;
         }
     }
With such a configuration, documents in the /downloads/ folder must be accessed
via a URL containing a query string parameter hash=XXX (note the $arg_hash in
the example), where XXX is the MD5 hash of the secret you defined through the
secure_link_md5 directive. The second argument of the secure_link directive
is a UNIX timestamp defining the expiration date. The $secure_link variable
is empty if the URI does not contain the proper hash or if the date has expired.
Otherwise, it is set to 1.

->Other miscellaneous modules
The remaining three modules are optional (which all need to be enabled at compile
time) and provide additional advanced functionality.

-Stub status
The Stub status module was designed to provide information about the current state
of the server, such as the amount of active connections, the total handled requests,
and more. To activate it, place the stub_status directive in a location block. All
requests matching the location block will produce the status page:
      location = /nginx_status {
           stub_status on;
           allow 127.0.0.1; # you may want to protect the information
           deny all;
      }
                    This module is not included in the default Nginx build.
An example result produced by Nginx:
      Active connections: 1
      server accepts handled requests
        10 10 23
      Reading: 0 Writing: 1 Waiting: 0
It's interesting to note that there are several server monitoring solutions such as
Monitorix that offer Nginx support through the stub status page by calling it at
regular intervals and parsing the statistics.

-Degradation
The HTTP Degradation module configures your server to return an error page when
your server runs low on memory. It works by defining a memory amount that is to
be considered low, and then specifies the locations for which you wish to enable the
degradation check:
      degradation sbrk=500m; # to be inserted at the http block level
      degrade 204; # in a location block, specify the error code (204 or
      444) to return in case the server condition has degraded

-Google-perftools
This module interfaces the Google Performance Tools profiling mechanism for the
Nginx worker processes. The tool generates a report based on performance analysis
of the executable code. More information can be discovered from the official website
of the project http://code.google.com/p/google-perftools/.
                     This module is not included in the default Nginx build.
In order to enable this feature, you need to specify the path of the report file that will
be generated using the google_perftools_profiles directive:
    google_perftools_profiles logs/profiles;

-WebDAV
WebDAV is an extension of the well-known HTTP protocol. While HTTP was
designed for visitors to download resources from a website (in other words,
reading data) WebDAV extends the functionality of web servers by adding write
operations such as creating files and folders, moving and copying files, and more.
The Nginx WebDAV module implements a small subset of the WebDAV protocol:
                     This module is not included in the default Nginx build.
 Directive                  Description
 dav_methods                Selects the DAV methods you want to enable.
 Context: http, server,     Syntax: dav_methods [off | [PUT] [DELETE]
 location                   [MKCOL] [COPY] [MOVE]];
                            Default: off
 dav_access                 Defines access permissions at the current level.
 Context: http, server,     Syntax: dav_access [user:r|w|rw] [group:r|w|rw]
 location                   [all:r|w|rw];
                            Default: dav_access user:rw;
 create_full_put_           This directive defines the behavior when a client requests to
 path                       create a file in a directory that does not exist. If set to on, the
 Context: http, server,     directory path is created. If set to off, the file creation fails.
 location                   Syntax: on or off
                            Default: off
 Directive              Description
 min_delete_depth       This directive defines a minimum URI depth for deleting files
 Context: http, server, or directories when processing the DELETE command.
 location               Syntax: Numeric value
                        Default: 0
- Third-party modules
The Nginx community has been growing larger over the past few years and
many additional modules were written by third-party developers. These can
be downloaded from the official wiki website 

http://wiki.nginx.org/nginx3rdPartyModules.


== Php et python avec nginx :

= FastCgi 
Historiquement le web livrait des pages statiques en html: le client demandait une page, le serveur web recevait la requette puis générait la page html et renvoyait la reponse au client.
Vint ensuite l'introduction de languages plus evolué pour le web (php, python) : le client demande une page, le serveur web recoit la requette (fait eventuellement un traitement : rewrite etc ..) puis la passe la requette au processeur php via un canal de communication : CGI (common gateway interface) : le traitement php se fait, une page est renvoyé au serveur web va cgi et celui ci renvoie le doc au client.
Le cgi est un protocole qui decrit la manière dont un serveur web (gere les connexion, reseau, comm avec le client) et une application cgi (php, python : qui gere les données) travaillent conjointement.
En pratique quand un serveur web doit envoyer une requette a l'appli cgi : il execute une commande '/usr/bin/php' .
Les infos du clients (user agent ...) sont fournies via arguments ou variables et les data sont transmisent via les methodes http post, put etc ...sur la sortie standart ; l'application traite la requette et renvoie le document sur la sortie standart au serveur web.
Des limitations apparaissent :
> chaque requette client : génere la creation d'un process par le serveur web 
> les infos ne sont pas conservées entre les processus ( pas de partage memoire ..)
> le systeme peut vite est submergé en cas de requettes massives à traiter ( génération de process ...)
> séparer le serveur web du serveur php semble compliqué coir impossible.

La creation des FASTCGI a donc été poussée pour pallier ces limites avec notamment les améliorations suivantes :
-> gestion de processus persistants qui peuvent traiter plusieurs requettes http ( plus de demaarage , execution a chaque requette)
-> le serveur web et l'appli communique par socket : tcp ou local ipc : on peut dissocier physiquement  le serveur web de l'appli php, python
-> le serveur web envoie la requette et recoit la reponse du cgi via une seule connection 
-> la communication se faisant via socket : le language communicant avec le serveur web peut en theorie être de toute sorte.

Une des difficulté réside dans l'etablissement de la communication entre le serveur web et le language .
Le module FASTCGI va nous permettre de configurer notre systeme.

Nb : il existe des autres modules pour le traitement : uWCGI : principalement pour du python et SCGI : plus ancien que FASTCGI. Les modules comportent des directives assez similaires avec FASTCGI
Les modules FASTCGI / uWCGI / SCGI sont embarqués dans le package nginx de base 



= FastCGI : configuration principales & Main directives :


Les directives suivantes permettent de passer les requettes au process fastcgi 
Par defaut les conf de base "fastcgi_params" conviennent à la plupart des confs

- fastcgi_pass : defini la manière dont la communication s'etablie entre le serveur web et l'application :socket tcp ou unix 

Examples:
fastcgi_pass localhost:9000;
fastcgi_pass 127.0.0.1:9000;
fastcgi_pass unix:/tmp/fastcgi.socket;
# Using an upstream block 
upstream fastcgi {
  server 127.0.0.1:9000;
  server 127.0.0.1:9001;
}
location ~* \.php$ {
      fastcgi_pass fastcgi;
}

- fastcgi_param : doit fournir en arguments : le script qui sera invoqué pour passer la requette à l'appli et  la query string ( NB que pour les methodes http comme POST ayant plusieurs parametres : tout est normalement présent dans le fichier fcgi_params fournis par nginx) : SEUL le nom du script et son path pour envoyer les requettes est a définir )

Example:
fastcgi_param SCRIPT_FILENAME /home/website.com/www$fastcgi_script_name;
fastcgi_param QUERY_STRING $query_string;





Directives :            Description : 

fastcgi_pass            This directive specifies that the request should be
Context: location       passed to the FastCGI server, by indicating its location:
if                         -For TCP sockets, the syntax is:
                            fastcgi_pass hostname:port;
                        
                        -For Unix Domain sockets, the syntax is:
                            fastcgi_pass unix:/path/to/fastcgi.
                            socket;
                        You may also refer to upstream blocks (read the
                            following sections for more information):
                            fastcgi_pass myblock;
                      
Examples:
fastcgi_pass localhost:9000;
fastcgi_pass 127.0.0.1:9000;
fastcgi_pass unix:/tmp/fastcgi.socket;
# Using an upstream block
upstream fastcgi {
  server 127.0.0.1:9000;
  server 127.0.0.1:9001;
}
location ~* \.php$ {
      fastcgi_pass fastcgi;
}



fastcgi_param          This directive allows you to configure the request
Context: http, server, passed to FastCGI. Two parameters are strictly
location               required for all FastCGI requests: SCRIPT_FILENAME
                       and QUERY_STRING.
Example:
fastcgi_param SCRIPT_FILENAME /home/website.com/www$fastcgi_script_name;
fastcgi_param QUERY_STRING $query_string;

                       As for POST requests, additional parameters are
                       required: REQUEST_METHOD, CONTENT_TYPE, and
                       CONTENT_LENGTH:
                           fastcgi_param REQUEST_METHOD $request_
                           method;
                           fastcgi_param CONTENT_TYPE $content_
                           type;
                           fastcgi_param CONTENT_LENGTH $con
                           tent_length;
                       The fastcgi_params file that you will find in the
                       Nginx configuration folder already includes all of
                       the necessary parameter definitions, except for the
                       SCRIPT_FILENAME,which you need to specify for
                       each of your FastCGI configurations.
                       If the parameter name begins with HTTP_, it will
                       override potentially existing HTTP headers of the
                       client request.
                       You may optionally specify the if_not_empty
                       keyword, forcing Nginx to transmit the parameter
                       only if the specified value is not empty.
                       Syntax: fastcgi_param PARAM value [if_not_
                       empty];

fastcgi_bind           This directive binds the socket to a local IP address,
Context: http, server, allowing you to specify the network interface you
location               want to use for FastCGI communications.
                       Syntax: fastcgi_bind IP_address;



fastcgi_pass_header      This directive specifies the additional headers that
Context: http, server,   should be passed to the FastCGI server.
location                 Syntax: fastcgi_pass_header headername;
Example:
fastcgi_pass_header Authorization;

fastcgi_hide_header      This directive specifies the headers that should be
Context: http, server,   hidden from the FastCGI server (headers that Nginx
location                 does not forward).
                         Syntax: fastcgi_hide_header headername;
Example:
fastcgi_hide_header X-Forwarded-For;

fastcgi_index            The FastCGI server does not support automatic
Context: http, server,   directory indexes. If the requested URI ends with a /,
location                 Nginx appends the value fastcgi_index.
                         Syntax: fastcgi_index filename;
Example:
fastcgi_index index.php;

fastcgi_ignore_client_   This directive lets you define what happens if the
abort                    client aborts their request to the web server. If the
Context: http, server,   directive is turned on, Nginx ignores the abort
location                 request and finishes processing the request. If it's
                         turned off, Nginx does not ignore the abort request.
                         It interrupts the request treatment and aborts related
                         communication with the FastCGI server.
                         Syntax: on or off
                         Default: off

fastcgi_intercept_errors This directive defines whether or not Nginx should
Context: http, server,   process the errors returned by the gateway or directly
location                 return error pages to the client. (Note: Error processing
                         is done via the error_page directive of Nginx.)
                         Syntax: on or off
                         Default: off

fastcgi_read_timeout    This directive defines the timeout for the response
Context: http, server,  from the FastCGI application. If Nginx does not
location                receive the response after this period, the 504
                        Gateway Timeout HTTP error is returned.
                        Syntax: Numeric value (in seconds)
                        Default: 60 seconds

fastcgi_connect_timeout This directive defines the backend server connection
Context: http, server,  timeout. This is different than the read/send timeout.
location                If Nginx is already connected to the backend server,
                        the fastcgi_connect_timeout is not applicable.
                        Syntax: Time value (in seconds)
                        Default: 60 seconds

fastcgi_send_timeout    This is the timeout for sending data to the backend
Context: http, server,  server. The timeout isn't applied to the entire response
location                delay but rather between two write operations.
                        Syntax: Time value (in seconds)
                        Default value: 60

fastcgi_split_path_info A directive particularly useful for URLs of the
Context: location       following form: http://website.com/page.php/param1/param2/.
                       
                        The directive splits the path information according to
                        the specified regular expression:
                           fastcgi_split_path_info ^(.+\.php)(.*)$;
                        This affects two variables:
                           -$fastcgi_script_name: The filename of
                              the actual script to be executed (in the example:
                              page.php)
                           -$fastcgi_path_info: The part of the URL
                              that is after the script name (in the example: /
                              param1/param2/)
                        These can be employed in further parameter
                        definitions:
                           fastcgi_param SCRIPT_FILENAME
                           /home/website.com/www$fastcgi_script_
                           name;
                           fastcgi_param PATH_INFO
                           $fastcgi_path_info;
                        Syntax: Regular expression

fastcgi_store            This directive enables a simple cache store where
Context: http, server,   responses from the FastCGI application are stored
location                 as files on the storage device. When the same URI is
                         requested again, the document is directly served from
                         the cache store instead of forwarding the request to
                         the FastCGI application.
                         This directive enables or disables the cache store.
                         Syntax: on or off

fastcgi_store_access     This directive defines the access permissions applied
Context: http, server,   to the files created in the context of the cache store.
location                 Syntax: fastcgi_store_access [user:r|w|rw]
                         [group:r|w|rw] [all:r|w|rw];
                         Default: fastcgi_store_access user:rw;

fastcgi_temp_path        This directive sets the path of temporary and cache
Context: http, server,   store files.
location                 Syntax: File path
                         Example:
                            fastcgi_temp_path /tmp/nginx_fastcgi;

fastcgi_max_temp_file_   Set this directive to 0 to disable the use of temporary
size                     files for FastCGI requests or to specify a maximum
Context: http, server,   file size.
location                 Default value: 1 GB
                         Syntax: Size value
                         Example: fastcgi_max_temp_file_size 5m;

fastcgi_temp_file_write_ This directive sets the write buffer size when saving
size                     temporary files to the storage device.
Context: http, server,   Syntax: Size value
location
                         Default value: 2 * proxy_buffer_size

fastcgi_buffers          This directive sets the amount and size of buffers that
Context: http, server,   will be used for reading the response data from the
location                 FastCGI application.
                         Syntax: fastcgi_buffers amount size;
                         Default: 8 buffers, 4 k or 8 k each, depending on
                         platform
                         Example:
                         fastcgi_buffers 8 4k;

fastcgi_buffer_size    This directive sets the size of the buffer for reading
Context: http, server, the beginning of the response from the FastCGI
location               application, which usually contains simple header
                       data.
                       The default value corresponds to the size of 1 buffer,
                       as defined by the previous directive (fastcgi_
                       buffers).
                       Syntax: Size value
                       Example:
                       fastcgi_buffer_size 4k;

fastcgi_send_lowat     This option allows you to make use of the SO_
Context: http, server, SNDLOWAT flag for TCP sockets under FreeBSD only.
location               This value defines the minimum number of bytes in
                       the buffer for output operations.
                       Syntax: Numeric value (size)
                       Default value: 0

fastcgi_pass_request_  This directive defines whether or not, respectively,
body                   the request body and extra request headers should be

fastcgi_pass_request_  passed on to the backend server.
headers                Syntax: on or off;
Context: http, server, Default: on
location

fastcgi_ignore_headers This directive prevents Nginx from processing one
Context: http, server, or more of the following headers from the backend
location               server response:
                          X-Accel-Redirect
                          X-Accel-Expires
                          Expires
                          Cache-Control
                          X-Accel-Limit-Rate
                          X-Accel-Buffering
                          X-Accel-Charset
                       Syntax: fastcgi_ignore_headers header1
                       [header2 ...;

fastcgi_next_upstream  When fastcgi_pass is connected to an upstream
Context: http, server, block, this directive defines the cases where requests
location               should be abandoned and re-sent to the next
                       upstream server of the block. The directive accepts a
                       combination of values among the following:
                          -error: An error occurred while
                              communicating or attempting to communicate
                              with the server
                          -timeout: A timeout occurs during transfers or
                              connection attempts
                          -invalid_header: The backend server
                              returned an empty or invalid response
                          -http_500, http_502, http_503, http_504,
                              http_404: In case such HTTP errors occur,
                              Nginx switches to the next upstream
                          -off: Forbids from using the next upstream
                              server
Examples:
fastcgi_next_upstream error timeout
http_504;
fastcgi_next_upstream timeout invalid_header;


fastcgi_catch_stderr   This directive allows you to intercept some of the error
Context: http, server, messages sent to stderr (Standard Error stream) and
location               store them in the Nginx error log.
                       Syntax: fastcgi_catch_stderr filter;
                       Example: fastcgi_catch_stderr "PHP Fatal
                       error:";

fastcgi_keep_conn      When set to on, Nginx will conserve the connection to
Context: http, server, the FastCGI server, thus reducing overhead.
location               Syntax: on or off (default: off).
                       Note that there is no equivalent directive in the
                       uWSGI and SCGI modules.


= FastCgi : gestion de cache 

Une fois la conf de basse faite on peut vouloir optimiser le système :

Directive                    Description

fastcgi_cache                This directive defines a cache zone. The identifier given to
Context: http, server,       the zone is to be reused in further directives.
location                     Syntax: fastcgi_cache zonename;

Example: fastcgi_cache cache1;


fastcgi_cache_key            This directive defines the cache key. In other words, what
Context: http, server,       differentiates a cache entry from another. If the cache key
location                     is set to $uri, as a result, all requests with a similar $uri
                              will correspond to the same cache entry. It's not enough
                              for most dynamic websites, you also need to include the
                              query string arguments in the cache key so that /index.
                              php and /index.php?page=contact do not point to the
                              same cache entry.
                              Syntax: fastcgi_cache_key key;
Example: fastcgi_cache "$scheme$host$request_uri $cookie_user";

fastcgi_cache_methods        This directive defines the HTTP methods eligible for
Context: http, server,       caching. GET and HEAD are included by default and cannot
location                     be disabled. You may, for example, enable caching of POST
                              requests.
                              Syntax: fastcgi_cache_methods METHOD;
Example: fastcgi_cache_methods POST;

fastcgi_cache_min_uses        This directive defines the minimum amount of hits before a
                              request is eligible for caching. By default, the response of a
 Context: http, server,       request is cached after one hit (next requests with the same
 location                     cache key will receive the cached response).
                              Syntax: Numeric value
Example: fastcgi_cache_min_uses 1;

fastcgi_cache_path     This directive indicates the directory for storing cached
Context: http, server, files, as well as other parameters.
location               Syntax: fastcgi_cache_path path
                       [levels=numbers]
                       keys_zone=name:size [inactive=time] [max_
                       size=size] [loader_files=number] [loader_
                       sleep=time] [loader_threshold=time];
                       The additional parameters are:
                          -levels: Indicates the depth of subdirectories (1:2
                               indicates that subfolders will be created down to
                               two levels)
                          -keys_zone: Selects the zone you previously
                               declared with the fastcgi_cache directive, and
                               indicates the size to occupy in memory
                          -inactive: If a cached response is not used within
                               the specified time frame, it's removed from the
                               cache (default: 10 minutes)
                          -max_size: Defines the maximum size of the entire
                               cache
                          -loader_files, loaded_sleep, loader_
                               threshold: Configures the cache loader: the
                               amount of files it processes in one read cycle
                               (loader_files, default: 100 files), the pause time
                               between read cycles (loader_sleep, default:
                               50ms), and the maximum duration of a read cycle
                               (loader_threshold, default: 200ms).

Example: fastcgi_cache_path /tmp/nginx_cachelevels=1:2 zone=zone1:10m inactive=10m max_size=200M;


fastcgi_cache_use_stale     This directive defines whether or not Nginx should serve
                            stale cached data in certain circumstances (in regards to
Context: http, server, the gateway). If you use fastcgi_cache_use_stale
location               timeout, and if the gateway times out, then Nginx will
                       serve cached data.
                       Syntax: fastcgi_cache_use_stale [updating]
                       [error] [timeout] [invalid_header]
                       [http_500];
Example: fastcgi_cache_use_stale error timeout;

fastcgi_cache_valid            This directive allows you to customize the caching time
 Context: http, server,        for different kinds of response codes. You may cache
 location                      responses associated to 404 error codes for 1 minute, and
                               on the opposite cache, 200 OK responses for 10 minutes
                               or more. This directive can be inserted more than once,
                               demonstrated as follows:
fastcgi_cache_valid 404 1m;
fastcgi_cache_valid 500 502 504 5m;
fastcgi_cache_valid 200 10;
                               Syntax: fastcgi_cache_valid code1 [code2...] time;


fastcgi_no_cache              You may want to disable caching for requests that meet
 Context: http, server,        certain conditions. The directive accepts a series of
 location                      variables. If at least one of these variables has a value (not
                               an empty string, and not 0), this request will not be stored
                               in cache.
                               Syntax: fastcgi_no_cache $variable1
                               [$variable2] [...];
Example: fastcgi_no_cache $args_nocaching;
 
fastcgi_cache_bypass           This directive functions in a similar manner to fastcgi_
 Context: http, server,        no_cache, except that it tells Nginx whether or not
 location                      the request should be loaded from cache, if it can be (as
                               opposed to deciding whether to store the request result in
                               cache).
                               Syntax: fastcgi_cache_bypass $variable1
                               [$variable2] [...];
Example: fastcgi_cache_bypass $cookie_bypass_cache;

fastcgi_cache_lock,             If set to on, fastcgi_cache_lock prevents repopulating
Exemple : 
fastcgi_cache_lock on;

fastcgi_cache_lock_timeout      existing cache elements for the duration specified by
                                fastcgi_cache_lock_timeout.
Context: http, server, location        
Example:
fastcgi_cache_lock_timeout 10s;


Here is a full Nginx FastCGI cache configuration example, making use of most of the
cache-related directives described in the preceding table:

    fastcgi_cache phpcache;
    fastcgi_cache_key "$scheme$host$request_uri"; # $request_uri includes
    the request arguments (such as /page.php?arg=value)
    fastcgi_cache_min_uses 2; # after 2 hits, a request receives a cached
    response
    fastcgi_cache_path /tmp/cache levels=1:2 keys_zone=phpcache:10m inac
    tive=30m max_size=500M;
    fastcgi_cache_use_stale updating timeout;
    fastcgi_cache_valid 404 1m;
    fastcgi_cache_valid 500 502 504 5m;

Since these directives are valid for pretty much any virtual host configuration, you
may want to save these in a separate file (fastcgi_cache) that you include at the
appropriate place:
    server {
         server_name website.com;
         location ~* \.php$ {
               fastcgi_pass 127.0.0.1:9000;
               fastcgi_param SCRIPT_FILENAME
    /home/website.com/www$fastcgi_script_name;
               fastcgi_param PATH_INFO $fastcgi_script_name;
               include fastcgi_params;
               include fastcgi_cache;
         }
    }


