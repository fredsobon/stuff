### great bash  : shortcut des videos###

== chapter 1 : 

bash --version
GNU bash, version 4.3.42(1)-release (x86_64-pc-linux-gnu)
Copyright (C) 2013 Free Software Foundation, Inc.
Licence GPLv3+ : GNU GPL version 3 ou ultérieure <http://gnu.org/licenses/gpl.html>

##  io : redirections :
standart input 
program
standart output
standart error

boogie@x61:/tmp$ ls -ld orbit-boogie
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie
boogie@x61:/tmp$ ls -ld orbit-boogie > out.txt
boogie@x61:/tmp$ cat out.txt 
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie

boogie@x61:/tmp$ ls not_here > out.txt
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type
boogie@x61:/tmp$ cat out.txt

boogie@x61:/tmp$ ls not_here 2> err.txt
boogie@x61:/tmp$ cat err.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type

# Redirection séparrée : 
boogie@x61:/tmp$ ls -ld orbit-boogie not_here > out.txt 2>err.txt 
boogie@x61:/tmp$ cat out.txt 
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie
boogie@x61:/tmp$ cat err.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type
-Redirection globale : on peut vouloir regrouper les sorties et les erreurs au sein du même fichier 

boogie@x61:/tmp$ ls -ld orbit-boogie not_here &> all.txt
boogie@x61:/tmp$ cat all.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie

- Attention l'ordre des redirections est important :

- ici on redirige notre entrée vers un fichier puis on redirige les erreurs vers le fichier de sortie standard : tout est donc correctement regroupé : sortie + erreur au sein de notre fichier : 
boogie@x61:/tmp$ ls -ld orbit-boogie not_here > out.txt 2>&1 
boogie@x61:/tmp$ cat out.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie


#  Redirection vers programme :

boogie@x61:/tmp$ cat out.txt 
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie
boogie@x61:/tmp$ wc < out.txt 
 1  9 60

- pipe :
boogie@x61:/tmp$ ls |wc 
     10      10     251
 
On peut combiner la puissance des redirections et le pipe. On peut par exemple rediriger les erreurs vers la sortie standart puis envoyer le tout à une autre commande via le "|" : les erreurs sont bien capturées :

Si on essaye de faire un ls sur un fichier qui n'existe pas : on a un message d'erreur sur la sortie 
boogie@x61:/tmp$ ls lapin
ls: impossible d'accéder à lapin: Aucun fichier ou dossier de ce type
En redirigeant l'erreur vers la sortie puis en envoyant le tout a wc via le pipe : on peut avoir le résultat de wc concernant l'erreur générée.
boogie@x61:/tmp$ ls lapin 2>&1 | wc
      1      12      72

# Heredoc :

On peut rediriger vers une commande un flux / texte saisi en entrée 

boogie@x61:/tmp$ wc << EOF
> this is a test
> EOF
 1  4 15

On a donc l'utilisation d'une chaine de caractère ici EOF (on peut saisir ce que l'on veut) qui va servir d'étiquette , on saisit le texte qu'on veut puis quand on a fini on ressaisi notre etiquette : le resultat de notre commande apparait ensuite.
On peut par exemple sans avoir besoin d'un fichier séparer chercher un num dans une liste. On crée un fichier et on l'appelle avec bash 

boogie@x61:/tmp$ cat ph
grep -i $* << EOF
titi 444
tata 555
tutu 666
toto 777
EOF

boogie@x61:/tmp$ bash ph toto
toto 777
 






=== chapter 3 : variables  

- printf :
on peut formatter plus facilement la sortie écran via printf : on va pouvoir "remplir" des champs prédéfini via des types de données : exemple \d : digit \s : string . Afin d'avoir un prompt "normal" (cad avec un retour chariot on alimente notre ligne avec un \n : 

boogie@x61:~$ a="lapin"
boogie@x61:~$ b=23
boogie@x61:~$ printf "hello %s %d \n" $a $b
hello lapin 23 


# Paramètres positionnels de script :
- $0 : le nom du script exécuté :

cat t.sh 
echo " le nom du script executé est toujours référencé par la variable \$0  ici : $0"

- $1, $2, $3 : paramètres positionnels  :

boogie@x61:~$ cat t.sh 
echo "le premier param est \$1. Ici : $1 "
echo "le deuxième param est \$2. Ici : $2 "
echo "le troisième param est \$3. Ici : $3 "

va nous donner par exemple : 

boogie@x61:~$ bash t.sh Bureau/ Documents/ GNS3/
le premier param est $1. Ici : Bureau/ 
le deuxième param est $2. Ici : Documents/ 
le troisième param est $3. Ici : GNS3/ 


- Paramètres en arguments : $* , "$*"  $@ et $# 

$* et $@ : affichent tous les paramètres passés en arguments : il n'y a de base pas de différence de comportement entre les deux symboles SAUF quand vont intervenir des espaces dans les arguments (nom de fichiers) et ou la différence apparaitra quandl'utilisation de " ' sera faite.
$# va afficher le nombre de paramètre passé en argument.

Exemple : 
boogie@x61:/tmp$ cat t.sh 
#! /bin/bash

a=$*
b=$@
c=$#
echo " ok avec \$* les arguments sont les suivants :" $a
echo " ok avec \$@ les arguments sont les suivants :" $b
echo " ok le nombre d'arguments récpéré grâce à \$# est  le suivant :" $c

ce qui nous donne par exemple : 
boogie@x61:/tmp$ ./t.sh vagrant-boogie-13171/ vagrant-boogie-13318/
 ok avec $* les arguments sont les suivants : vagrant-boogie-13171/ vagrant-boogie-13318/
 ok avec $@ les arguments sont les suivants : vagrant-boogie-13171/ vagrant-boogie-13318/
 ok le nombre d'arguments récpéré grâce à $# est  le suivant : 2

# Il existe une différence concrète entre $* ; "$*" et  "$@".Il est très important de savoir que $* sans guillemet ne permet pas une interprétation complète correcte : un nom composé sera vu comme plusieurs fichiers distincts. Le "$*" lui 
verra un seul paramètre passé en argumant : même s'il s'agit d'une liste de plusieurs fichiers. Le $@ est la meilleure façon de gérer tous les paramètres passés en arguments: 


script a.sh : 
#!/bin/bash

echo " in a script => invoke script with $* "
./b $*
echo ==
echo " in a script => invoke script with '"$*"' "
./b "$*"
echo ==
echo " in a script => invoke script with '"$@"' " 
./b "$@"
echo ==

script b :

#!/bin/bash

echo "in b script => invoke with $# arg"
echo "in b script => first arg $1 is '"$1"'
echo "in b script =>second arg $2 is '"$2"'

Résultat : on voit que l'on a des résultats très différents sur le nombre d'arg passés : 

boogie@x61:/tmp$ bash a.sh test* lapin\ nain 
 in a script => invoke script with testi testo lapin nain 
in b script => invoke with 4 arg
==
 in a script => invoke script with 'testi testo lapin nain' 
in b script => invoke with 1 arg
==
 in a script => invoke script with 'testi testo lapin nain' 
in b script => invoke with 3 arg
==

la bonne réponse est la numero 3 : on a trois fichiers "lapin  nain" testo et testi 


# Remplacement de variable :
Des caractères spéciaux : % %% et # ## vont permettrent de modifier l'affichage et le traitement de variables (SANS modifier la valeur initiale de celle-ci).

- % et %% : vont permettrent de supprimer un suffixe : 

boogie@x61:~$ test=abba
boogie@x61:~$ echo $test
abba
boogie@x61:~$ echo ${test}
abba
- ici on supprime le dernier caractère : 
boogie@x61:~$ echo ${test%a}
abb
boogie@x61:~$ echo ${test%b*}
ab
- Ici on supprime le premier ensemble comportant un "b" suivi de 0 ou plusieurs caractères :
boogie@x61:~$ echo ${test%%b*}
a
 
- A l'inverse : # et ## vont permettre de supprimer un préfixe :

boogie@x61:~$ echo $test
- Ici on supprime le premier a rencontré 
boogie@x61:~$ echo ${test#a}
bba
- Ici on supprime tous les ensembles de "b" précédés de 0 ou plusieurs caractères 
boogie@x61:~$ echo ${test##*b}
a


- Modification de variable en affichage ( usage proche du sed ) :

boogie@x61:/tmp$ a=lapin
boogie@x61:/tmp$ echo $a
lapin
boogie@x61:/tmp$ echo ${a/pin/}
la
boogie@x61:/tmp$ echo ${a/lapin/}

boogie@x61:/tmp$ echo ${a/lapin/mout}
mout
boogie@x61:/tmp$ echo ${a/lap/mout}
moutin

- Comptage du nombre de caractères d'une variable :

boogie@x61:/tmp$ echo $a
lapin
boogie@x61:/tmp$ echo ${#a}
5


- Interval de caractère d'une variable :
il est tout  fait possible de faire un extract de sous chaine d'une variable en définissant le numéro du caractère de début et le nombre de caractère composant notre sous chaine désirée :
boogie@x61:/tmp$ a=lapin
boogie@x61:/tmp$ echo ${a:1:2}
ap
On commence à compter les caractères à partir de "0" : 
ogie@x61:/tmp$ echo ${a:0:3}
lap

=== chapter 4 : flow control 

# arithmétique / calcul :

= la syntaxe "(( ))" est directement liée au calcul dans bash.Nous n'avons pas besoin de placer un $ en la définissant.

boogie@x61:/tmp$ for ((i=0 ; i < 10 ; i+=1 )); do echo $i ;done
0
1
2
3
4
5
6
7
8
9
boogie@x61:/tmp$ for ((i=0 ; i < 10 ; i+=3 )); do echo $i ;done
0
3
6
9


- Pour afficher les caractères d'une variable passé en argument :

boogie@x61:/tmp$ cat c

#!/bin/bash

var=$1
num=${#1}

echo " arg is $1 , num is $num "

for  ((i=0 ; i < ${num}  ; i+=1 ))
    do echo "$var contains ${var:$i:1}" 
done

boogie@x61:/tmp$ ./c lapin
 arg is lapin , num is 5 
lapin contains l
lapin contains a
lapin contains p
lapin contains i
lapin contains n


== read :

permet une interraction directe avec le user : 

boogie@x61:/tmp$ read lapin
coco
boogie@x61:/tmp$ echo $lapin
coco
On peut avoir une option de "prompt" : 
boogie@x61:/tmp$ read -p "hey what is yo name :" lapin
hey what is yo name :coco
boogie@x61:/tmp$ echo $lapin
coco

boogie@x61:/tmp$ read a b 
lapin nain
boogie@x61:/tmp$ echo $a 
lapin
boogie@x61:/tmp$ echo $b
nain
Attention les variables ne vont contenir qu'une chaine de caractère par défaut : s'il y a trop de chaine : la dernière variable héritera de tout le reste :
boogie@x61:/tmp$ read a b 
lapin blanc nain
boogie@x61:/tmp$ echo $a 
lapin
boogie@x61:/tmp$ echo $b
blanc nain
boogie@x61:/tmp$ read a b c
lapin nain rouge et blanc
boogie@x61:/tmp$ echo $a 
lapin
boogie@x61:/tmp$ echo $b
nain
boogie@x61:/tmp$ echo $c
rouge et blanc

boogie@x61:/tmp$ cat d
#!/bin/bash
# parsing des propriétés d'un fichier : ls -l fichier |./d < notre script

read rights links user  group size month day time filename

echo " rights are $rights for filename $filename "  

boogie@x61:/tmp$ ls -l a.sh |./d
 rights are -rwxr-xr-x for filename a.sh 


