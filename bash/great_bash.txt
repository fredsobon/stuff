### great bash  : shortcut des videos###

== chapter 1 : 

bash --version
GNU bash, version 4.3.42(1)-release (x86_64-pc-linux-gnu)
Copyright (C) 2013 Free Software Foundation, Inc.
Licence GPLv3+ : GNU GPL version 3 ou ultérieure <http://gnu.org/licenses/gpl.html>

##  io : redirections :
standart input 
program
standart output
standart error

boogie@x61:/tmp$ ls -ld orbit-boogie
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie
boogie@x61:/tmp$ ls -ld orbit-boogie > out.txt
boogie@x61:/tmp$ cat out.txt 
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie

boogie@x61:/tmp$ ls not_here > out.txt
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type
boogie@x61:/tmp$ cat out.txt

boogie@x61:/tmp$ ls not_here 2> err.txt
boogie@x61:/tmp$ cat err.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type

# Redirection séparrée : 
boogie@x61:/tmp$ ls -ld orbit-boogie not_here > out.txt 2>err.txt 
boogie@x61:/tmp$ cat out.txt 
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie
boogie@x61:/tmp$ cat err.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type

-Redirection globale : on peut vouloir regrouper les sorties et les erreurs au sein du même fichier 

boogie@x61:/tmp$ ls -ld orbit-boogie not_here &> all.txt
boogie@x61:/tmp$ cat all.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie

- Attention l'ordre des redirections est important :

- ici on redirige notre entrée vers un fichier puis on redirige les erreurs vers le fichier de sortie standard : tout est donc correctement regroupé : sortie + erreur au sein de notre fichier : 
boogie@x61:/tmp$ ls -ld orbit-boogie not_here > out.txt 2>&1 
boogie@x61:/tmp$ cat out.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie


#  Redirection vers programme :

boogie@x61:/tmp$ cat out.txt 
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie
boogie@x61:/tmp$ wc < out.txt 
 1  9 60

- pipe :
boogie@x61:/tmp$ ls |wc 
     10      10     251
 
On peut combiner la puissance des redirections et le pipe. On peut par exemple rediriger les erreurs vers la sortie standart puis envoyer le tout à une autre commande via le "|" : les erreurs sont bien capturées :

Si on essaye de faire un ls sur un fichier qui n'existe pas : on a un message d'erreur sur la sortie 
boogie@x61:/tmp$ ls lapin
ls: impossible d'accéder à lapin: Aucun fichier ou dossier de ce type
En redirigeant l'erreur vers la sortie puis en envoyant le tout a wc via le pipe : on peut avoir le résultat de wc concernant l'erreur générée.
boogie@x61:/tmp$ ls lapin 2>&1 | wc
      1      12      72

# Heredoc :

On peut rediriger vers une commande un flux / texte saisi en entrée 

boogie@x61:/tmp$ wc << EOF
> this is a test
> EOF
 1  4 15

On a donc l'utilisation d'une chaine de caractère ici EOF (on peut saisir ce que l'on veut) qui va servir d'étiquette , on saisit le texte qu'on veut puis quand on a fini on ressaisi notre etiquette : le resultat de notre commande apparait ensuite.
On peut par exemple sans avoir besoin d'un fichier séparer chercher un num dans une liste. On crée un fichier et on l'appelle avec bash 

boogie@x61:/tmp$ cat ph
grep -i $* << EOF
titi 444
tata 555
tutu 666
toto 777
EOF

boogie@x61:/tmp$ bash ph toto
toto 777
 

=== chapter 3 : variables  

- printf :
on peut formatter plus facilement la sortie écran via printf : on va pouvoir "remplir" des champs prédéfini via des types de données : exemple \d : digit \s : string . Afin d'avoir un prompt "normal" (cad avec un retour chariot on alimente notre ligne avec un \n : 

boogie@x61:~$ a="lapin"
boogie@x61:~$ b=23
boogie@x61:~$ printf "hello %s %d \n" $a $b
hello lapin 23 


# Paramètres positionnels de script :
- $0 : le nom du script exécuté :

cat t.sh 
echo " le nom du script executé est toujours référencé par la variable \$0  ici : $0"

- $1, $2, $3 : paramètres positionnels  :

boogie@x61:~$ cat t.sh 
echo "le premier param est \$1. Ici : $1 "
echo "le deuxième param est \$2. Ici : $2 "
echo "le troisième param est \$3. Ici : $3 "

va nous donner par exemple : 

boogie@x61:~$ bash t.sh Bureau/ Documents/ GNS3/
le premier param est $1. Ici : Bureau/ 
le deuxième param est $2. Ici : Documents/ 
le troisième param est $3. Ici : GNS3/ 


- Paramètres en arguments : $* , "$*"  $@ et $# .Cas particulier pour $?
Tout d'abord $? nous renseigne sut le code retour de la dernière commande invoquée :
$?=0 de base nous dis que la dernière commande s'est passée avec succès.
$?=1 est une convention définissant une erreur .
On peut renseigner nous même nos propres code de sortie à la fin d'une commande parmi les 255 possibilité offertes (de 0 a 254 en nombre)

$* et $@ : affichent tous les paramètres passés en arguments : il n'y a de base pas de différence de comportement entre les deux symboles SAUF quand vont intervenir des espaces dans les arguments (nom de fichiers) et ou la différence apparaitra quandl'utilisation de " ' sera faite.
$# va afficher le nombre de paramètre passé en argument.

Exemple : 
boogie@x61:/tmp$ cat t.sh 
#! /bin/bash

a=$*
b=$@
c=$#
echo " ok avec \$* les arguments sont les suivants :" $a
echo " ok avec \$@ les arguments sont les suivants :" $b
echo " ok le nombre d'arguments récpéré grâce à \$# est  le suivant :" $c

ce qui nous donne par exemple : 
boogie@x61:/tmp$ ./t.sh vagrant-boogie-13171/ vagrant-boogie-13318/
 ok avec $* les arguments sont les suivants : vagrant-boogie-13171/ vagrant-boogie-13318/
 ok avec $@ les arguments sont les suivants : vagrant-boogie-13171/ vagrant-boogie-13318/
 ok le nombre d'arguments récpéré grâce à $# est  le suivant : 2

# Il existe une différence concrète entre $* ; "$*" et  "$@".Il est très important de savoir que $* sans guillemet ne permet pas une interprétation complète correcte : un nom composé sera vu comme plusieurs fichiers distincts. Le "$*" lui 
verra un seul paramètre passé en argumant : même s'il s'agit d'une liste de plusieurs fichiers. Le $@ est la meilleure façon de gérer tous les paramètres passés en arguments: 


script a.sh : 
#!/bin/bash

echo " in a script => invoke script with $* "
./b $*
echo ==
echo " in a script => invoke script with '"$*"' "
./b "$*"
echo ==
echo " in a script => invoke script with '"$@"' " 
./b "$@"
echo ==

script b :

#!/bin/bash

echo "in b script => invoke with $# arg"

Résultat : on voit que l'on a des résultats très différents sur le nombre d'arg passés : 

boogie@x61:/tmp$ bash a.sh test* lapin\ nain 
 in a script => invoke script with testi testo lapin nain 
in b script => invoke with 4 arg
==
 in a script => invoke script with 'testi testo lapin nain' 
in b script => invoke with 1 arg
==
 in a script => invoke script with 'testi testo lapin nain' 
in b script => invoke with 3 arg
==

la bonne réponse est la numero 3 : on a trois fichiers "lapin  nain" testo et testi 


# Remplacement de variable :
Des caractères spéciaux : % %% et # ## vont permettrent de modifier l'affichage et le traitement de variables (SANS modifier la valeur initiale de celle-ci).

- % et %% : vont permettrent de supprimer un suffixe : 

boogie@x61:~$ test=abba
boogie@x61:~$ echo $test
abba
boogie@x61:~$ echo ${test}
abba
- ici on supprime le dernier caractère : 
boogie@x61:~$ echo ${test%a}
abb
boogie@x61:~$ echo ${test%b*}
ab
- Ici on supprime le premier ensemble comportant un "b" suivi de 0 ou plusieurs caractères :
boogie@x61:~$ echo ${test%%b*}
a
 
- A l'inverse : # et ## vont permettre de supprimer un préfixe :

boogie@x61:~$ echo $test
- Ici on supprime le premier a rencontré 
boogie@x61:~$ echo ${test#a}
bba
- Ici on supprime tous les ensembles de "b" précédés de 0 ou plusieurs caractères 
boogie@x61:~$ echo ${test##*b}
a


- Modification de variable en affichage ( usage proche du sed ) :

boogie@x61:/tmp$ a=lapin
boogie@x61:/tmp$ echo $a
lapin
boogie@x61:/tmp$ echo ${a/pin/}
la
boogie@x61:/tmp$ echo ${a/lapin/}

boogie@x61:/tmp$ echo ${a/lapin/mout}
mout
boogie@x61:/tmp$ echo ${a/lap/mout}
moutin

- Comptage du nombre de caractères d'une variable :

boogie@x61:/tmp$ echo $a
lapin
boogie@x61:/tmp$ echo ${#a}
5


- Interval de caractère d'une variable :
il est tout  fait possible de faire un extract de sous chaine d'une variable en définissant le numéro du caractère de début et le nombre de caractère composant notre sous chaine désirée :
boogie@x61:/tmp$ a=lapin
boogie@x61:/tmp$ echo ${a:1:2}
ap
On commence à compter les caractères à partir de "0" : 
ogie@x61:/tmp$ echo ${a:0:3}
lap

=== chapter 4 : flow control 

= for loop : 

# arithmétique / calcul :

= la syntaxe "(( ))"  son équivalent direct est "let" est directement liée au calcul dans bash.Nous n'avons pas besoin de placer un $ en la définissant.

boogie@x61:/tmp$ for ((i=0 ; i < 10 ; i+=1 )); do echo $i ;done
0
1
2
3
4
5
6
7
8
9
boogie@x61:/tmp$ for ((i=0 ; i < 10 ; i+=3 )); do echo $i ;done
0
3
6
9


- Pour afficher les caractères d'une variable passé en argument :

boogie@x61:/tmp$ cat c

#!/bin/bash

var=$1
num=${#1}

echo " arg is $1 , num is $num "

for  ((i=0 ; i < ${num}  ; i+=1 ))
    do echo "$var contains ${var:$i:1}" 
done

boogie@x61:/tmp$ ./c lapin
 arg is lapin , num is 5 
lapin contains l
lapin contains a
lapin contains p
lapin contains i
lapin contains n

== while loop :
équivalent de l'exercice précédent avec un "while" : "tant que" vrai alors .... : attention à la boucle infinie, il faut également mettre un compteur pour sortir de la boucle : 

boogie@x61:/tmp$ cat e
#!/bin/bash

var=$1
num=${#1}

echo " arg is $1 , num is $num "

#let  i=0 
(( i=0 )) 
while  ((i < ${num} ))
    do 
    echo "$var contains ${var:$i:1}"
#    let i=$i+1  
    (( i=$i+1 ))  
done

boogie@x61:/tmp$ ./e lapin
 arg is lapin , num is 5 
lapin contains l
lapin contains a
lapin contains p
lapin contains i
lapin contains n



== read :

permet une interraction directe avec le user : 

boogie@x61:/tmp$ read lapin
coco
boogie@x61:/tmp$ echo $lapin
coco
On peut avoir une option de "prompt" : 
boogie@x61:/tmp$ read -p "hey what is yo name :" lapin
hey what is yo name :coco
boogie@x61:/tmp$ echo $lapin
coco

boogie@x61:/tmp$ read a b 
lapin nain
boogie@x61:/tmp$ echo $a 
lapin
boogie@x61:/tmp$ echo $b
nain
Attention les variables ne vont contenir qu'une chaine de caractère par défaut : s'il y a trop de chaine : la dernière variable héritera de tout le reste :
boogie@x61:/tmp$ read a b 
lapin blanc nain
boogie@x61:/tmp$ echo $a 
lapin
boogie@x61:/tmp$ echo $b
blanc nain
boogie@x61:/tmp$ read a b c
lapin nain rouge et blanc
boogie@x61:/tmp$ echo $a 
lapin
boogie@x61:/tmp$ echo $b
nain
boogie@x61:/tmp$ echo $c
rouge et blanc

boogie@x61:/tmp$ cat d
#!/bin/bash
# parsing des propriétés d'un fichier : ls -l fichier |./d < notre script

read rights links user  group size month day time filename

echo " rights are $rights for filename $filename "  

boogie@x61:/tmp$ ls -l a.sh |./d
 rights are -rwxr-xr-x for filename a.sh 


= case : 

branchement conditionnel : la lecture se fait sequentiellement.Chaque cas est traité l'un après l'autre.

Exemple on demande la saisie d'un chiffre : on attend donc soit un pair soit un impair (grâce au "pipe" qui nous donne le choix selectif). Si une lettre min ou maj est saisi (grâce aux intervals du bash )ou plusieurs lettres (grâce au pattern matching) un caractère special est saisi ... on lève un message.
On nottera na possibilité de saisir des options et des intervals dans les choix possibles : 

boogie@x61:/tmp$ cat f.sh 
#!/bin/bash

echo -n "gimme me a digit please : "
read var

case "$var" in 
            2 |4 |6 |8) echo "hey chiffre pair!"
            ;;
            1|3|5|7|9) echo "yop : chiffre impair!" 
            ;;
            [a-zA-Z]) echo "hey ..un chiffre svp pas une lettre .."
               exit 1
            ;;
            [a-zA-Z]*) echo "hey ..un chiffre pas plusieurs lettres .."
                exit 2
            ;;
            *) echo "hey ..un chiffre svp pas un caractère special.."
               exit 3
esac 



=== chapter 5 - shell math and logic : 

De base quand on declare une variable avec des chiffres ou nombres : bash ne les considère que sous forme "string" :
boogie@x61:/tmp$ a=4
boogie@x61:/tmp$ b=5
boogie@x61:/tmp$ c=4+5
boogie@x61:/tmp$ echo $c
4+5
boogie@x61:/tmp$ c=$a+$b
boogie@x61:/tmp$ echo $c
4+5
Si on veut faire des opérations arithmetiques il faut déclarer le type "entier" pour notre variable le mot clé "declare" ou "typeset" est à utiliser (ils ont la même action):

declare -i a=5
b=$(( $a + 4))
echo $b
9


Le mot clé "let" va indiquer que le mot clé suivant (uniquement lui) sera dédié au calcul arithmétique. Il n'y a donc qu'un seul argument authorisé avec le mot clé "let". Afin d'éviter les soucis d'espaces ont entoure par des "" notre expression

Exemple de script additionnant le nombre de fichiers , leur taille et la liste de leur nom passé en argument : 

#!/bin/bash

# on definit deux variable de type "integeré et une liste vide que l'on va compléter à chaque itération de boucle :
declare -i total=0
declare -i countfile=0
filelst=""

while read perm link user group size month day hour file
  do
    echo "$file is the file proceed"
    echo "hey  $file is $size bytes  long"
    shift 1
    total+=$size
    countfile+=1
    filelst="$filelst $file"
done
echo "$total is the space on disk for $countfile files which are $filelst"

Ce qui nous donne : 

boogie@x61:/tmp$ ls -l a.sh f.sh test.txt|./d.sh
a.sh is the file proceed
hey  a.sh is 155 bytes  long
f.sh is the file proceed
hey  f.sh is 529 bytes  long
test.txt is the file proceed
hey  test.txt is 30 bytes  long
714 is the space on disk for 3 files which are  a.sh f.sh test.txt

Il est possible de définir de plusieurs manières un calcul arithmétique :

boogie@x61:/tmp$ let "f=4 + 7"
boogie@x61:/tmp$ echo $f
11
boogie@x61:/tmp$ g=$(( 4 + 7 ))
boogie@x61:/tmp$ echo $g
11
boogie@x61:/tmp$ echo "$(( $f + $g ))"
22

/!\  : ATTENTION on ne travaille que sur des entiers : les decimaux sont "tronqués".

* Décisions / choix branchements mathématiques :

On peut faire des "if" mathématiques grâce aux "(( ))"
On a les mêmes opérateurs que dans les languages comme le c ( < , <= , >, >= , == , != ..qu'on peut combiner avec le && , || ..)
boogie@x61:/tmp$ cat m.sh 
#!/bin/bash

# vars :

var=$1
factor=5

if (( $var < 10 ))
then 
    echo "nop : too small!"
    exit 1
fi

if (( $var >= 100 ))
then 
    echo "nop : too big!"
    exit 2
fi

if (( $var == 5 * $factor || cheat != 0 ))
then 
    echo "bingO!"
else
    echo "not so bad ...you can reach it !"
    exit 3
fi

Ce qui donne : 
boogie@x61:/tmp$ ./m.sh 4
nop : too small!

boogie@x61:/tmp$ ./m.sh 123
nop : too big!

boogie@x61:/tmp$ ./m.sh 25
bingO!

boogie@x61:/tmp$ ./m.sh 29
not so bad ...you can reach it !

boogie@x61:/tmp$ cheat=1 ./m.sh 29
bingO!

boogie@x61:/tmp$ cheat=1 ./m.sh 11
bingO!

boogie@x61:/tmp$ cheat=1 ./m.sh 99
bingO!

* creation de calculatrice : rpn (reverse polish notation ) : ex : 5 6 + ; 3 5 \* ; 4 6 + 1 / etc .....

boogie@x61:/tmp$ cat u.sh 
#!/bin/bash

echo "$1 == $2 == $3 " 

echo " now shift 1 : "
shift 1
echo "$1 == $2 == $3 " 

echo " now shift 2 : "
shift 2
echo "$1 == $2 == $3 " 

ce qui donne : 
boogie@x61:/tmp$ ./u.sh  bla blou blon
bla == blou == blon 
 now shift 1 : 
blou == blon ==  
 now shift 2 : 
 ==  ==  

On va devoir établir que la calculatrice doit comporter un nombre impair d'arguments ( 2 chiffres et un signe , un shift de 2 etc .... )
boogie@x61:/tmp$ cat v.sh 
#!/bin/bash
# simple arguments check
if (( $# != 3 ))
then 
    echo " $0 usage is that 3 characters are mandatory : <num> <num> <sign>"
    exit 1 
fi

# simple rpn calculator : shift number $2 with sign $3 : 
var=$(( $1 $3 $2 ))
echo " this is the result : $var"
  
Version "illimitée" avec test de nombre d'argument impair et décalage suite au calcul .
Temps que le nombre d'arguments est supérieur à 0 on continue à compter et décaller.

boogie@x61:/tmp$ cat w.sh 
#!/bin/bash

# simple arguments check
if (( $# % 2 == 0 ))
then 
    echo " $0 usage odd  parameters are mandatory : <num> <num> <sign> <num> <sign> and so ..."
    exit 1 
fi
var=$(( $1 $3 $2 ))
shift 3
while (( $# > 0 ))
do
    var=$(( $var $2 $1 ))
    shift 2
done 
echo " here it is $var "

* Test complet avec if [ ] et les differents test : cf man bash
 
boogie@x61:/tmp$ cat l.sh 
#!/bin/bash

a=$1

if [ ! -e ${a} ]
then
    echo "usage $0 gimme me something to eat ! "
    exit 2
fi

if [ -d $a ]
then 
    echo "yum a directory!"
fi


