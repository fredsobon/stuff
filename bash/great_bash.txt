### great bash  : shortcut des videos###

== chapter 1 : 

bash --version
GNU bash, version 4.3.42(1)-release (x86_64-pc-linux-gnu)
Copyright (C) 2013 Free Software Foundation, Inc.
Licence GPLv3+ : GNU GPL version 3 ou ultérieure <http://gnu.org/licenses/gpl.html>

##  io : redirections :
standart input 
program
standart output
standart error

boogie@x61:/tmp$ ls -ld orbit-boogie
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie
boogie@x61:/tmp$ ls -ld orbit-boogie > out.txt
boogie@x61:/tmp$ cat out.txt 
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie

boogie@x61:/tmp$ ls not_here > out.txt
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type
boogie@x61:/tmp$ cat out.txt

boogie@x61:/tmp$ ls not_here 2> err.txt
boogie@x61:/tmp$ cat err.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type

# Redirection séparrée : 
boogie@x61:/tmp$ ls -ld orbit-boogie not_here > out.txt 2>err.txt 
boogie@x61:/tmp$ cat out.txt 
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie
boogie@x61:/tmp$ cat err.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type

-Redirection globale : on peut vouloir regrouper les sorties et les erreurs au sein du même fichier 

boogie@x61:/tmp$ ls -ld orbit-boogie not_here &> all.txt
boogie@x61:/tmp$ cat all.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie

- Attention l'ordre des redirections est important :

- ici on redirige notre entrée vers un fichier puis on redirige les erreurs vers le fichier de sortie standard : tout est donc correctement regroupé : sortie + erreur au sein de notre fichier : 
boogie@x61:/tmp$ ls -ld orbit-boogie not_here > out.txt 2>&1 
boogie@x61:/tmp$ cat out.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie


#  Redirection vers programme :

boogie@x61:/tmp$ cat out.txt 
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie
boogie@x61:/tmp$ wc < out.txt 
 1  9 60

- pipe :
boogie@x61:/tmp$ ls |wc 
     10      10     251
 
On peut com la puissance des redirections et le pipe. On peut par exemple rediriger les erreurs vers la sortie standart puis envoyer le tout à une autre commande via le "|" : les erreurs sont bien capturées :

Si on essaye de faire un ls sur un fichier qui n'existe pas : on a un message d'erreur sur la sortie 
boogie@x61:/tmp$ ls lapin
ls: impossible d'accéder à lapin: Aucun fichier ou dossier de ce type
En redirigeant l'erreur vers la sortie puis en envoyant le tout a wc via le pipe : on peut avoir le résultat de wc concernant l'erreur générée.
boogie@x61:/tmp$ ls lapin 2>&1 | wc
      1      12      72

# Heredoc :

On peut rediriger vers une commande un flux / texte saisi en entrée 

boogie@x61:/tmp$ wc << EOF
> this is a test
> EOF
 1  4 15

On a donc l'utilisation d'une chaine de caractère ici EOF (on peut saisir ce que l'on veut) qui va servir d'étiquette , on saisit le texte qu'on veut puis quand on a fini on ressaisi notre etiquette : le resultat de notre commande apparait ensuite.
On peut par exemple sans avoir besoin d'un fichier séparer chercher un num dans une liste. On crée un fichier et on l'appelle avec bash 

boogie@x61:/tmp$ cat ph
grep -i $* << EOF
titi 444
tata 555
tutu 666
toto 777
EOF

boogie@x61:/tmp$ bash ph toto
toto 777
 

=== chapter 3 : variables  

- printf :
on peut formatter plus facilement la sortie écran via printf : on va pouvoir "remplir" des champs prédéfini via des types de données : exemple %d : digit %s : string . Afin d'avoir un prompt "normal" (cad avec un retour chariot on alimente notre ligne avec un \n : 

boogie@x61:~$ a="lapin"
boogie@x61:~$ b=23
boogie@x61:~$ printf "hello %s %d \n" $a $b
hello lapin 23 


# Paramètres positionnels de script :
- $0 : le nom du script exécuté :

cat t.sh 
echo " le nom du script executé est toujours référencé par la variable \$0  ici : $0"

- $1, $2, $3 : paramètres positionnels  :

boogie@x61:~$ cat t.sh 
echo "le premier param est \$1. Ici : $1 "
echo "le deuxième param est \$2. Ici : $2 "
echo "le troisième param est \$3. Ici : $3 "

va nous donner par exemple : 

boogie@x61:~$ bash t.sh Bureau/ Documents/ GNS3/
le premier param est $1. Ici : Bureau/ 
le deuxième param est $2. Ici : Documents/ 
le troisième param est $3. Ici : GNS3/ 


- Paramètres en arguments : $* , "$*"  $@ et $# .Cas particulier pour $?
Tout d'abord $? nous renseigne sut le code retour de la dernière commande invoquée :
$?=0 de base nous dis que la dernière commande s'est passée avec succès.
$?=1 est une convention définissant une erreur .
On peut renseigner nous même nos propres code de sortie à la fin d'une commande parmi les 255 possibilité offertes (de 0 a 254 en nombre)

$* et $@ : affichent tous les paramètres passés en arguments : il n'y a de base pas de différence de comportement entre les deux symboles SAUF quand vont intervenir des espaces dans les arguments (nom de fichiers) et ou la différence apparaitra quandl'utilisation de " ' sera faite.
$# va afficher le nombre de paramètre passé en argument.

Exemple : 
boogie@x61:/tmp$ cat t.sh 
#! /bin/bash

a=$*
b=$@
c=$#
echo " ok avec \$* les arguments sont les suivants :" $a
echo " ok avec \$@ les arguments sont les suivants :" $b
echo " ok le nombre d'arguments récpéré grâce à \$# est  le suivant :" $c

ce qui nous donne par exemple : 
boogie@x61:/tmp$ ./t.sh vagrant-boogie-13171/ vagrant-boogie-13318/
 ok avec $* les arguments sont les suivants : vagrant-boogie-13171/ vagrant-boogie-13318/
 ok avec $@ les arguments sont les suivants : vagrant-boogie-13171/ vagrant-boogie-13318/
 ok le nombre d'arguments récpéré grâce à $# est  le suivant : 2

# Il existe une différence concrète entre $* ; "$*" et  "$@".Il est très important de savoir que $* sans guillemet ne permet pas une interprétation complète correcte : un nom composé sera vu comme plusieurs fichiers distincts. Le "$*" lui 
verra un seul paramètre passé en argumant : même s'il s'agit d'une liste de plusieurs fichiers. Le $@ est la meilleure façon de gérer tous les paramètres passés en arguments: 


script a.sh : 
#!/bin/bash

echo " in a script => invoke script with $* "
./b $*
echo ==
echo " in a script => invoke script with '"$*"' "
./b "$*"
echo ==
echo " in a script => invoke script with '"$@"' " 
./b "$@"
echo ==

script b :

#!/bin/bash

echo "in b script => invoke with $# arg"

Résultat : on voit que l'on a des résultats très différents sur le nombre d'arg passés : 

boogie@x61:/tmp$ bash a.sh test* lapin\ nain 
 in a script => invoke script with testi testo lapin nain 
in b script => invoke with 4 arg
==
 in a script => invoke script with 'testi testo lapin nain' 
in b script => invoke with 1 arg
==
 in a script => invoke script with 'testi testo lapin nain' 
in b script => invoke with 3 arg
==

la bonne réponse est la numero 3 : on a trois fichiers "lapin  nain" testo et testi 


# Remplacement de variable :
Des caractères spéciaux : % %% et # ## vont permettrent de modifier l'affichage et le traitement de variables (SANS modifier la valeur initiale de celle-ci).

- % et %% : vont permettrent de supprimer un suffixe : 

boogie@x61:~$ test=abba
boogie@x61:~$ echo $test
abba
boogie@x61:~$ echo ${test}
abba
- ici on supprime le dernier caractère : 
boogie@x61:~$ echo ${test%a}
abb
boogie@x61:~$ echo ${test%b*}
ab
- Ici on supprime le premier ensemble comportant un "b" suivi de 0 ou plusieurs caractères :
boogie@x61:~$ echo ${test%%b*}
a
 
- A l'inverse : # et ## vont permettre de supprimer un préfixe :

boogie@x61:~$ echo $test
- Ici on supprime le premier a rencontré 
boogie@x61:~$ echo ${test#a}
bba
- Ici on supprime tous les ensembles de "b" précédés de 0 ou plusieurs caractères 
boogie@x61:~$ echo ${test##*b}
a


- Modification de variable en affichage ( usage proche du sed ) :

boogie@x61:/tmp$ a=lapin
boogie@x61:/tmp$ echo $a
lapin
boogie@x61:/tmp$ echo ${a/pin/}
la
boogie@x61:/tmp$ echo ${a/lapin/}

boogie@x61:/tmp$ echo ${a/lapin/mout}
mout
boogie@x61:/tmp$ echo ${a/lap/mout}
moutin

- Comptage du nombre de caractères d'une variable :

boogie@x61:/tmp$ echo $a
lapin
boogie@x61:/tmp$ echo ${#a}
5


- Interval de caractère d'une variable :
il est tout  fait possible de faire un extract de sous chaine d'une variable en définissant le numéro du caractère de début et le nombre de caractère composant notre sous chaine désirée :
boogie@x61:/tmp$ a=lapin
boogie@x61:/tmp$ echo ${a:1:2}
ap
On commence à compter les caractères à partir de "0" : 
ogie@x61:/tmp$ echo ${a:0:3}
lap

=== chapter 4 : flow control 

= for loop : 

# arithmétique / calcul :

= la syntaxe "(( ))"  son équivalent direct est "let" est directement liée au calcul dans bash.Nous n'avons pas besoin de placer un $ en la définissant.

boogie@x61:/tmp$ for ((i=0 ; i < 10 ; i+=1 )); do echo $i ;done
0
1
2
3
4
5
6
7
8
9
boogie@x61:/tmp$ for ((i=0 ; i < 10 ; i+=3 )); do echo $i ;done
0
3
6
9


- Pour afficher les caractères d'une variable passé en argument :

boogie@x61:/tmp$ cat c

#!/bin/bash

var=$1
num=${#1}

echo " arg is $1 , num is $num "

for  ((i=0 ; i < ${num}  ; i+=1 ))
    do echo "$var contains ${var:$i:1}" 
done

boogie@x61:/tmp$ ./c lapin
 arg is lapin , num is 5 
lapin contains l
lapin contains a
lapin contains p
lapin contains i
lapin contains n

== while loop :
équivalent de l'exercice précédent avec un "while" : "tant que" vrai alors .... : attention à la boucle infinie, il faut également mettre un compteur pour sortir de la boucle : 

boogie@x61:/tmp$ cat e
#!/bin/bash

var=$1
num=${#1}

echo " arg is $1 , num is $num "

#let  i=0 
(( i=0 )) 
while  ((i < ${num} ))
    do 
    echo "$var contains ${var:$i:1}"
#    let i=$i+1  
    (( i=$i+1 ))  
done

boogie@x61:/tmp$ ./e lapin
 arg is lapin , num is 5 
lapin contains l
lapin contains a
lapin contains p
lapin contains i
lapin contains n



== read :

permet une interraction directe avec le user : 

boogie@x61:/tmp$ read lapin
coco
boogie@x61:/tmp$ echo $lapin
coco
On peut avoir une option de "prompt" : 
boogie@x61:/tmp$ read -p "hey what is yo name :" lapin
hey what is yo name :coco
boogie@x61:/tmp$ echo $lapin
coco

boogie@x61:/tmp$ read a b 
lapin nain
boogie@x61:/tmp$ echo $a 
lapin
boogie@x61:/tmp$ echo $b
nain
Attention les variables ne vont contenir qu'une chaine de caractère par défaut : s'il y a trop de chaine : la dernière variable héritera de tout le reste :
boogie@x61:/tmp$ read a b 
lapin blanc nain
boogie@x61:/tmp$ echo $a 
lapin
boogie@x61:/tmp$ echo $b
blanc nain
boogie@x61:/tmp$ read a b c
lapin nain rouge et blanc
boogie@x61:/tmp$ echo $a 
lapin
boogie@x61:/tmp$ echo $b
nain
boogie@x61:/tmp$ echo $c
rouge et blanc

boogie@x61:/tmp$ cat d
#!/bin/bash
# parsing des propriétés d'un fichier : ls -l fichier |./d < notre script

read rights links user  group size month day time filename

echo " rights are $rights for filename $filename "  

boogie@x61:/tmp$ ls -l a.sh |./d
 rights are -rwxr-xr-x for filename a.sh 


= case : 

branchement conditionnel : la lecture se fait sequentiellement.Chaque cas est traité l'un après l'autre.

Exemple on demande la saisie d'un chiffre : on attend donc soit un pair soit un impair (grâce au "pipe" qui nous donne le choix selectif). Si une lettre min ou maj est saisi (grâce aux intervals du bash )ou plusieurs lettres (grâce au pattern matching) un caractère special est saisi ... on lève un message.
On notera la possibilité de saisir des options et des intervals dans les choix possibles : 

boogie@x61:/tmp$ cat f.sh 
#!/bin/bash

echo -n "gimme me a digit please : "
read var

case "$var" in 
            2 |4 |6 |8) echo "hey chiffre pair!"
            ;;
            1|3|5|7|9) echo "yop : chiffre impair!" 
            ;;
            [a-zA-Z]) echo "hey ..un chiffre svp pas une lettre .."
               exit 1
            ;;
            [a-zA-Z]*) echo "hey ..un chiffre pas plusieurs lettres .."
                exit 2
            ;;
            *) echo "hey ..un chiffre svp pas un caractère special.."
               exit 3
esac 



=== chapter 5 - shell math and logic : 

De base quand on declare une variable avec des chiffres ou nombres : bash ne les considère que sous forme "string" :
boogie@x61:/tmp$ a=4
boogie@x61:/tmp$ b=5
boogie@x61:/tmp$ c=4+5
boogie@x61:/tmp$ echo $c
4+5
boogie@x61:/tmp$ c=$a+$b
boogie@x61:/tmp$ echo $c
4+5
Si on veut faire des opérations arithmetiques il faut déclarer le type "entier" pour notre variable le mot clé "declare" ou "typeset" est à utiliser (ils ont la même action). On utilise l'option "-i" (integer) avec le mot clé declare dans ce cas précis :

declare -i a=5
b=$(( $a + 4))
echo $b
9


Le mot clé "let" va indiquer que le mot clé suivant (uniquement lui) sera dédié au calcul arithmétique. Il n'y a donc qu'un seul argument authorisé avec le mot clé "let". Afin d'éviter les soucis d'espaces ont entoure par des "" notre expression

Exemple de script additionnant le nombre de fichiers , leur taille et la liste de leur nom passé en argument : 

#!/bin/bash

# on definit deux variable de type "integer et une liste vide que l'on va compléter à chaque itération de boucle :
declare -i total=0
declare -i countfile=0
filelst=""

while read perm link user group size month day hour file
  do
    echo "$file is the file proceed"
    echo "hey  $file is $size bytes  long"
    shift 1
    total+=$size
    countfile+=1
    filelst="$filelst $file"
done
echo "$total is the space on disk for $countfile files which are $filelst"

Ce qui nous donne : 

boogie@x61:/tmp$ ls -l a.sh f.sh test.txt|./d.sh
a.sh is the file proceed
hey  a.sh is 155 bytes  long
f.sh is the file proceed
hey  f.sh is 529 bytes  long
test.txt is the file proceed
hey  test.txt is 30 bytes  long
714 is the space on disk for 3 files which are  a.sh f.sh test.txt

Il est possible de définir de plusieurs manières un calcul arithmétique :

boogie@x61:/tmp$ let "f=4 + 7"
boogie@x61:/tmp$ echo $f
11
boogie@x61:/tmp$ g=$(( 4 + 7 ))
boogie@x61:/tmp$ echo $g
11
boogie@x61:/tmp$ echo "$(( $f + $g ))"
22

/!\  : ATTENTION on ne travaille que sur des entiers : les decimaux sont "tronqués".

* Décisions / choix branchements mathématiques :

On peut faire des "if" mathématiques grâce aux "(( ))"
On a les mêmes opérateurs que dans les languages comme le c ( < , <= , >, >= , == , != ..qu'on peut combiner avec le && , || ..)
boogie@x61:/tmp$ cat m.sh 
#!/bin/bash

# vars :

var=$1
factor=5

if (( $var < 10 ))
then 
    echo "nop : too small!"
    exit 1
fi

if (( $var >= 100 ))
then 
    echo "nop : too big!"
    exit 2
fi

if (( $var == 5 * $factor || cheat != 0 ))
then 
    echo "bingO!"
else
    echo "not so bad ...you can reach it !"
    exit 3
fi

Ce qui donne : 
boogie@x61:/tmp$ ./m.sh 4
nop : too small!

boogie@x61:/tmp$ ./m.sh 123
nop : too big!

boogie@x61:/tmp$ ./m.sh 25
bingO!

boogie@x61:/tmp$ ./m.sh 29
not so bad ...you can reach it !

boogie@x61:/tmp$ cheat=1 ./m.sh 29
bingO!

boogie@x61:/tmp$ cheat=1 ./m.sh 11
bingO!

boogie@x61:/tmp$ cheat=1 ./m.sh 99
bingO!

* creation de calculatrice : rpn (reverse polish notation ) : ex : 5 6 + ; 3 5 \* ; 4 6 + 1 / etc .....

boogie@x61:/tmp$ cat u.sh 
#!/bin/bash

echo "$1 == $2 == $3 " 

echo " now shift 1 : "
shift 1
echo "$1 == $2 == $3 " 

echo " now shift 2 : "
shift 2
echo "$1 == $2 == $3 " 

ce qui donne : 
boogie@x61:/tmp$ ./u.sh  bla blou blon
bla == blou == blon 
 now shift 1 : 
blou == blon ==  
 now shift 2 : 
 ==  ==  

On va devoir établir que la calculatrice doit comporter un nombre impair d'arguments ( 2 chiffres et un signe , un shift de 2 etc .... )
boogie@x61:/tmp$ cat v.sh 
#!/bin/bash
# simple arguments check
if (( $# != 3 ))
then 
    echo " $0 usage is that 3 characters are mandatory : <num> <num> <sign>"
    exit 1 
fi

# simple rpn calculator : shift number $2 with sign $3 : 
var=$(( $1 $3 $2 ))
echo " this is the result : $var"
  
Version "illimitée" avec test de nombre d'argument impair et décalage suite au calcul .
Temps que le nombre d'arguments est supérieur à 0 on continue à compter et décaller.

boogie@x61:/tmp$ cat w.sh 
#!/bin/bash

# simple arguments check
if (( $# % 2 == 0 ))
then 
    echo " $0 usage odd  parameters are mandatory : <num> <num> <sign> <num> <sign> and so ..."
    exit 1 
fi
var=$(( $1 $3 $2 ))
shift 3
while (( $# > 0 ))
do
    var=$(( $var $2 $1 ))
    shift 2
done 
echo " here it is $var "

* Test complet avec if [ ] et les differents test : cf man bash
 
boogie@x61:/tmp$ cat l.sh 
#!/bin/bash

a=$1

if [ ! -e ${a} ]
then
    echo "usage $0 gimme me something to eat ! "
    exit 2
fi

if [ -d $a ]
then 
    echo "yum a directory!"
fi

On peut faire les differents tests de comparaison = ; != etc mais attention c'est une comparaison de chaines. 
Pour comparer des entiers il faut utiliser les test  -eq , -le , gt etc ..ou alors se servir des "(( ))" qui autorisent les test de type < , == etc ...

* Test améliorés avec "[[ ]]" :

on peut se servir du globbing shell pour faire une comparaison de chaine grâce aux double crochet sans avoir de surprise 

boogie@x61:/tmp$ cat c.sh 
#!/bin/bash

# est ce que notre $1 fini bien par .txt : 0 ou plusieurs caractères suivis de ".txt" 
if [[ $1 == *.txt ]]
then 
    echo "yep it is ==> $1"
fi
Ce qui donne la sortie suivante quand on lance en argument un pattern qui match l'expression : 

boogie@x61:/tmp$ ./c.sh test.txt
yep it is ==> test.txt

On a aussi une seconde expression : la SEULE dans bash qui utilise les regexps comme dans sed et grep :

if [[ $1 =~ t.s..t.. ]]
then 
   echo  "mouarf not so far : $1"
fi
boogie@x61:/tmp$ ./c.sh tast.taz 
mouarf not so far : tast.taz

Toutes les constructions de regexps peuvent être utilisées : 
if [[ $1 =~ t*s..t[a-z]{2} ]]
then 
   echo  "mouarf not so far : $1"
fi

Attention dans le cas précis d'utilisation de =~ pour les regexps il ne faut surtout pas encadrer par des " ' le pattern sinon on annule la recherche par regexp.

[[ == ]] => shell pattern matching
[[ =~ ]] => regexp pattern matching


== Chapitre 6 : définition de fonction 
Il est possible dans bash de créer des fonctions : elles ne seront executées qu'après leur appel.
Trois forme de définition sont possible : avec le keyword function et () ou uniquement avec function ou uniquement avec () :
#!/bin/bash

function one ()
{
  echo "function one with keyword function and ()"
}
function two
{
  echo "function two -> without () "
}
tree ()
{ 
 echo " third form -> without function keyword "
}
one
two
tree
Ce qui nous donne : 
boogie@x61:/tmp$ ./fn.sh 
function one with keyword function and ()
function two -> without () 
 third form -> without function keyword 

Il est possible d'effectuer un groupement de commande avec {} mais aussi (), (( )) et [[]] : les implications sont différentes on sait par exemple que (()) va effectuer des commandes arithmetiques.
Avec l'utilisation de () : on travaille dans un sous-shell  donc attention aux variables .

/!\ ATTENTION à toujours définir nos fonctions en début de script (comme pour les variables) avant de les invoquer.

= paramètres positionnels dans les fonctions : 
attention ils sont redéfinis dans la fonction 

boogie@x61:/tmp$ cat t.sh 

fn ()
{
echo "inside function here's the parameters : $1 $2"
}
echo "before function $1 $2"
fn bla bloublou
echo "after function $1 $2"
Ce qui donne :

boogie@x61:/tmp$ ./t.sh zz tt
before function zz tt
inside function here's the parameters : bla bloublou
after function zz tt

Seule $0 ne change pas : il n'y a pas de redifinition dans la fonction.

= Portée des variables : 

Par defaut toutes les variables sont "globales" dans un script et vues de manières identiques dans une fonction.

Il est toujours important de définir si besoin des variables dans notre fonction : le mot clé local est utile dans ce cas car : la variable ne sera utilisée que dans le contexte de la fonction : elle sera libérée de la mémoire dès la fonction executée : economie , meilleur gestion de la mémoire et protection du systeme.

Les mots clé "declare" "typeset" et "local" ont la même action dans une fonction.

boogie@x61:/tmp$ cat t.sh 

fn ()
{
local a="titi"
echo "inside function here's the parameters : $1 $2 et puis la var a : $a"
}
echo "before function $1 $2 et puis la var a : $a "
fn bla bloublou
echo "after function $1 $2 et puis la var a :  $a"

Ce qui donne :
boogie@x61:/tmp$ ./t.sh zz tt
before function zz tt et puis la var a :  
inside function here's the parameters : bla bloublou et puis la var a : titi
after function zz tt et puis la var a : 

Depuis bash version 4.2 on peut définir dans notre fonction une variable globale avec :
declare -g : donc des que la fonction est lue la variable sera vue a l'exterrieur de la fonction aussi :

boogie@x61:/tmp$ cat t.sh 

fn ()
{
#local a="titi"
declare -g a="titi"
echo "inside function here's the parameters : $1 $2 et puis la var a : $a"
}

echo "before function $1 $2 et puis la var a : $a "

fn bla bloublou

echo "after function $1 $2 et puis la var a :  $a"

ce qui nous donne :
boogie@x61:/tmp$ ./t.sh zz tt
before function zz tt et puis la var a :  
inside function here's the parameters : bla bloublou et puis la var a : titi
after function zz tt et puis la var a :  titi
 
= Substitution indirecte :
il est possible de retrouver la valeur d'une variable en appelant une autre variable définie avec la syntaxe :
${!var} :
boogie@x61:/tmp$ a=lapin
boogie@x61:/tmp$ var=a
boogie@x61:/tmp$ echo ${!var}
lapin

Il peut être interessant de stocker les fonctions dans une bibliotheque ..ou dans un fichier et les appeller en sourcant le chemin du rep ou du fichier :
source function.sh
. function.sh

=== Chapitre 7 : les tableaux.
On se sert des tableaux pour traiter  beaucoup de données du même type.
On peut recupérer les différents éléments d'un tableau. On recupere les differents élements "sous divisés" d'une variable.
 
Pour définir un tableau on utilise la notation  var[index] et pour recupérer les valeurs du tableau on utilise la notation "${var[index]}"

boogie@x61:/tmp$ index=5
boogie@x61:/tmp$ var[index]=222
boogie@x61:/tmp$ echo ${var[5]}
222

On doit déclarer explicitement un tableau ( array ) dans notre script avec declare -a :

boogie@x61:/tmp$ cat tab.sh 
#!/bin/bash

declare -a tab
tab=( zero one two three four [5]=five six seven eight nine ten)

echo "print the first record of our array ==> ${tab[0]}"
echo "hey print now the seven element => ${tab[7]}"

ce qui nous donne : 
boogie@x61:/tmp$ ./tab.sh 
print the first record of our array ==> zero
hey print now the seven element => seven

On va pour l'exemple creer un script qui va utiliser l'index du tableau pour nous donner le nom de cet index saisi dans notre liste de mot.
Notre script va nous permettre de convertir chaque chiffre saisi en mot correspondant.
ex : 3  > trois  

#!/bin/bash

declare -a tab
tab=( zero one two three four [5]=five six seven eight nine ten )

enter=$1

printf "here it is ==> %s \n" ${tab[$enter]}

Ce qui nous donne :
boogie@x61:/tmp$ ./ar.sh 3
here it is ==> three 
