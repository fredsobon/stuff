### great bash  : shortcut des videos###

useful url : 
http://www.tldp.org/LDP/Bash-Beginners-Guide/html/
http://wiki.bash-hackers.org/scripting/bashchanges


== chapter 1 : 

bash --version
GNU bash, version 4.3.42(1)-release (x86_64-pc-linux-gnu)
Copyright (C) 2013 Free Software Foundation, Inc.
Licence GPLv3+ : GNU GPL version 3 ou ultérieure <http://gnu.org/licenses/gpl.html>

##  io : redirections :
standart input 
program
standart output
standart error

boogie@x61:/tmp$ ls -ld orbit-boogie
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie
boogie@x61:/tmp$ ls -ld orbit-boogie > out.txt
boogie@x61:/tmp$ cat out.txt 
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie

boogie@x61:/tmp$ ls not_here > out.txt
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type
boogie@x61:/tmp$ cat out.txt

boogie@x61:/tmp$ ls not_here 2> err.txt
boogie@x61:/tmp$ cat err.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type

# Redirection séparrée : 
boogie@x61:/tmp$ ls -ld orbit-boogie not_here > out.txt 2>err.txt 
boogie@x61:/tmp$ cat out.txt 
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie
boogie@x61:/tmp$ cat err.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type

-Redirection globale : on peut vouloir regrouper les sorties et les erreurs au sein du même fichier 

boogie@x61:/tmp$ ls -ld orbit-boogie not_here &> all.txt
boogie@x61:/tmp$ cat all.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie

- Attention l'ordre des redirections est important :

- ici on redirige notre entrée vers un fichier puis on redirige les erreurs vers le fichier de sortie standard : tout est donc correctement regroupé : sortie + erreur au sein de notre fichier : 
boogie@x61:/tmp$ ls -ld orbit-boogie not_here > out.txt 2>&1 
boogie@x61:/tmp$ cat out.txt 
ls: impossible d'accéder à not_here: Aucun fichier ou dossier de ce type
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie


#  Redirection vers programme :

boogie@x61:/tmp$ cat out.txt 
drwx------ 2 boogie boogie 1024 janv.  1  1970 orbit-boogie
boogie@x61:/tmp$ wc < out.txt 
 1  9 60

- pipe :
boogie@x61:/tmp$ ls |wc 
     10      10     251
 
On peut combiner la puissance des redirections et le pipe. On peut par exemple rediriger les erreurs vers la sortie standart puis envoyer le tout à une autre commande via le "|" : les erreurs sont bien capturées :

Si on essaye de faire un ls sur un fichier qui n'existe pas : on a un message d'erreur sur la sortie 
boogie@x61:/tmp$ ls lapin
ls: impossible d'accéder à lapin: Aucun fichier ou dossier de ce type
En redirigeant l'erreur vers la sortie puis en envoyant le tout a wc via le pipe : on peut avoir le résultat de wc concernant l'erreur générée.
boogie@x61:/tmp$ ls lapin 2>&1 | wc
      1      12      72

# Heredoc :

On peut rediriger vers une commande un flux / texte saisi en entrée 

boogie@x61:/tmp$ wc << EOF
> this is a test
> EOF
 1  4 15

On a donc l'utilisation d'une chaine de caractère ici EOF (on peut saisir ce que l'on veut) qui va servir d'étiquette , on saisit le texte qu'on veut puis quand on a fini on ressaisi notre etiquette : le resultat de notre commande apparait ensuite.
On peut par exemple sans avoir besoin d'un fichier séparer chercher un num dans une liste. On crée un fichier et on l'appelle avec bash 

boogie@x61:/tmp$ cat ph
grep -i $* << EOF
titi 444
tata 555
tutu 666
toto 777
EOF

boogie@x61:/tmp$ bash ph toto
toto 777
 

# trap :

La commande trap va permettre d'executer une commande fournie en argument à la reception d'un signal : trap <commande> signal.Exemple :
trap "/bin/date" EXIT
la liste des signaux est disponible avec trap -l :
boogie@x61:~$ trap -l
 1) SIGHUP   2) SIGINT   3) SIGQUIT  4) SIGILL   5) SIGTRAP
 6) SIGABRT  7) SIGBUS   8) SIGFPE   9) SIGKILL 10) SIGUSR1
11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP
21) SIGTTIN 22) SIGTTOU 23) SIGURG  24) SIGXCPU 25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF 28) SIGWINCH    29) SIGIO   30) SIGPWR
31) SIGSYS  34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX    

=== chapter 3 : variables  

-Evaluation :

On doit toujours "coller" la definition de notre variable, le signe "=" et son contenu:
var=bla
var="bla bla"
var='$bla'
var='$bla blue $bla'
On peut vérifier si une variable existe avec l'option "set -u":
boogie@x61:/tmp$ set -u
boogie@x61:/tmp$ echo $lapin
bash: lapin : variable sans liaison
boogie@x61:/tmp$ echo $mm
bash: mm : variable sans liaison
On peut reswitcher avec "set +u" :
boogie@x61:/tmp$ set +u
boogie@x61:/tmp$ echo $mm
> pas de sortie (variable non définie : mais pas de message informatif.)

On doit entourer notre variable par des {} pour eviter de mauvaises surprises : 

boogie@x61:/tmp$ var=lapin_nain
boogie@x61:/tmp$ echo $var
lapin_nain
boogie@x61:/tmp$ a=$var_titi
boogie@x61:/tmp$ echo $a
boogie@x61:/tmp$ a=${var}_titi
boogie@x61:/tmp$ echo $a
lapin_nain_titi

Action par defaut : quand les scripts utilise les valeurs des variables : il est important qu'ils puissent s'executer correctement : c'est pourquoi on peut définir des actions 'par défaut' :
On peut utiliser ${} avec 4 modificateurs :

-${var:-defaut} -> utilisera defaut si var n'est pas definie ou nulle  :
boogie@x61:/tmp$ var=titi
boogie@x61:/tmp$ echo ${var:-lapin}
titi
boogie@x61:/tmp$ var=
boogie@x61:/tmp$ echo ${var:-lapin}
lapin
boogie@x61:/tmp$ echo ${babar:-lapin}
lapin

-${var:=defaut} -> vaudra toujours defaut si var n'est pas definie ou nulle :
boogie@x61:/tmp$ echo ${babar}

boogie@x61:/tmp$ echo ${babar:=lapin}
lapin
boogie@x61:/tmp$ echo ${babar}
lapin

- ":" l'utilisation de ce caractère est début d'expression va bypasser le résulat d'une expression qui n'existe pas et donc ne pas afficher de résultat d'erreur : on continu le traitement sans se soucier du message. Le ":" signifie "aucune opération"

boogie@x61:/tmp$ ${blabla:=yop}
bash: yop : commande introuvable
boogie@x61:/tmp$ : ${blabla:=yop}

- "?" : l'utilisation de ce signe va nous permettre de stopper le script et d'afficher le message après le "?" si la variable n'est pas définie ou est nulle : c'est une précaution :
boogie@x61:/tmp$ blo=
boogie@x61:/tmp$ echo ${blo}

boogie@x61:/tmp$ ${blo:?attention var non définie}
bash: blo: attention var non définie
Si on ne renseigne rien après le "?" , le shell renvoie un message par défaut :
boogie@x61:/tmp$ ${blo:?}
bash: blo : paramètre vide ou non défini

- "+" : l'utilisation de "+" nous permet de fixer la valeur d'une variable définie au préalable :
boogie@x61:/tmp$ a=lapin
boogie@x61:/tmp$ echo $a
lapin
boogie@x61:/tmp$ echo ${a:+babar}
babar
Si la variable est vide ou non définie elle ne sort rien :
boogie@x61:/tmp$ a=
boogie@x61:/tmp$ echo ${a:+babar}

Les opérateurs ${:-} ; ${:=} ${:?} ${:+} travaillent sur les variables vides ou indéfinies.
Pour les variables vraiment indéfinies les formes suivantes existent :
${-} ; ${=} ${?} ${+}


* Export :
On rend disponible nos variables pour tous les environements du shell en les exportant.La commande export suivie de l'option "-p" nous permet de voir nos variables exportées.

boogie@x61:/tmp$ export -p |grep blabla
boogie@x61:/tmp$ export blabla=lapin
boogie@x61:/tmp$ export -p |grep blabla
declare -x blabla="lapin"

On peut flagger une variable "non exportable" avec export -n :
boogie@x61:/tmp$ export -n blu
boogie@x61:/tmp$ export -p |grep blu
boogie@x61:/tmp$ export -n blu=yop
boogie@x61:/tmp$ export -p |grep blu

Il est aussi possible d'exporter une fonction avec export -f :



- printf :
on peut formatter plus facilement la sortie écran via printf : on va pouvoir "remplir" des champs prédéfini via des types de données : exemple %d : digit %s : string . Afin d'avoir un prompt "normal" (cad avec un retour chariot on alimente notre ligne avec un \n : 

boogie@x61:~$ a="lapin"
boogie@x61:~$ b=23
boogie@x61:~$ printf "hello %s %d \n" $a $b
hello lapin 23 


# Paramètres positionnels de script :
- $0 : le nom du script exécuté :

cat t.sh 
echo " le nom du script executé est toujours référencé par la variable \$0  ici : $0"

- $1, $2, $3 : paramètres positionnels  :

boogie@x61:~$ cat t.sh 
echo "le premier param est \$1. Ici : $1 "
echo "le deuxième param est \$2. Ici : $2 "
echo "le troisième param est \$3. Ici : $3 "

va nous donner par exemple : 

boogie@x61:~$ bash t.sh Bureau/ Documents/ GNS3/
le premier param est $1. Ici : Bureau/ 
le deuxième param est $2. Ici : Documents/ 
le troisième param est $3. Ici : GNS3/ 


- Paramètres en arguments : $* , "$*"  $@ et $# .Cas particulier pour $?
Tout d'abord $? nous renseigne sut le code retour de la dernière commande invoquée :
$?=0 de base nous dis que la dernière commande s'est passée avec succès.
$?=1 est une convention définissant une erreur .
On peut renseigner nous même nos propres code de sortie à la fin d'une commande parmi les 255 possibilité offertes (de 0 a 254 en nombre)

$* et $@ : affichent tous les paramètres passés en arguments : il n'y a de base pas de différence de comportement entre les deux symboles SAUF quand vont intervenir des espaces dans les arguments (nom de fichiers) et ou la différence apparaitra quandl'utilisation de " ' sera faite.
$# va afficher le nombre de paramètre passé en argument.

Exemple : 
boogie@x61:/tmp$ cat t.sh 
#! /bin/bash

a=$*
b=$@
c=$#
echo " ok avec \$* les arguments sont les suivants :" $a
echo " ok avec \$@ les arguments sont les suivants :" $b
echo " ok le nombre d'arguments récpéré grâce à \$# est  le suivant :" $c

ce qui nous donne par exemple : 
boogie@x61:/tmp$ ./t.sh vagrant-boogie-13171/ vagrant-boogie-13318/
 ok avec $* les arguments sont les suivants : vagrant-boogie-13171/ vagrant-boogie-13318/
 ok avec $@ les arguments sont les suivants : vagrant-boogie-13171/ vagrant-boogie-13318/
 ok le nombre d'arguments récpéré grâce à $# est  le suivant : 2

# Il existe une différence concrète entre $* ; "$*" et  "$@".Il est très important de savoir que $* sans guillemet ne permet pas une interprétation complète correcte : un nom composé sera vu comme plusieurs fichiers distincts. Le "$*" lui 
verra un seul paramètre passé en argumant : même s'il s'agit d'une liste de plusieurs fichiers. Le $@ est la meilleure façon de gérer tous les paramètres passés en arguments: 


script a.sh : 
#!/bin/bash

echo " in a script => invoke script with $* "
./b $*
echo ==
echo " in a script => invoke script with '"$*"' "
./b "$*"
echo ==
echo " in a script => invoke script with '"$@"' " 
./b "$@"
echo ==

script b :

#!/bin/bash

echo "in b script => invoke with $# arg"

Résultat : on voit que l'on a des résultats très différents sur le nombre d'arg passés : 

boogie@x61:/tmp$ bash a.sh test* lapin\ nain 
 in a script => invoke script with testi testo lapin nain 
in b script => invoke with 4 arg
==
 in a script => invoke script with 'testi testo lapin nain' 
in b script => invoke with 1 arg
==
 in a script => invoke script with 'testi testo lapin nain' 
in b script => invoke with 3 arg
==

la bonne réponse est la numero 3 : on a trois fichiers "lapin  nain" testo et testi 


# Remplacement de variable :
Des caractères spéciaux : % %% et # ## vont permettrent de modifier l'affichage et le traitement de variables (SANS modifier la valeur initiale de celle-ci).

- % et %% : vont permettrent de supprimer un suffixe : 

boogie@x61:~$ test=abba
boogie@x61:~$ echo $test
abba
boogie@x61:~$ echo ${test}
abba
- ici on supprime le dernier caractère : 
boogie@x61:~$ echo ${test%a}
abb
boogie@x61:~$ echo ${test%b*}
ab
- Ici on supprime le premier ensemble comportant un "b" suivi de 0 ou plusieurs caractères :
boogie@x61:~$ echo ${test%%b*}
a
 
- A l'inverse : # et ## vont permettre de supprimer un préfixe :

boogie@x61:~$ echo $test
- Ici on supprime le premier a rencontré 
boogie@x61:~$ echo ${test#a}
bba
- Ici on supprime tous les ensembles de "b" précédés de 0 ou plusieurs caractères 
boogie@x61:~$ echo ${test##*b}
a


- Modification de variable en affichage ( usage proche du sed ) :

boogie@x61:/tmp$ a=lapin
boogie@x61:/tmp$ echo $a
lapin
boogie@x61:/tmp$ echo ${a/pin/}
la
boogie@x61:/tmp$ echo ${a/lapin/}

boogie@x61:/tmp$ echo ${a/lapin/mout}
mout
boogie@x61:/tmp$ echo ${a/lap/mout}
moutin

- Comptage du nombre de caractères d'une variable :

boogie@x61:/tmp$ echo $a
lapin
boogie@x61:/tmp$ echo ${#a}
5


- Interval de caractère d'une variable :
il est tout  fait possible de faire un extract de sous chaine d'une variable en définissant le numéro du caractère de début et le nombre de caractère composant notre sous chaine désirée :
boogie@x61:/tmp$ a=lapin
boogie@x61:/tmp$ echo ${a:1:2}
ap
On commence à compter les caractères à partir de "0" : 
ogie@x61:/tmp$ echo ${a:0:3}
lap

=== chapter 4 : flow control 

= for loop : 

# arithmétique / calcul :

De base une constante numérique est considérée en base 10
Si elle commence par un 0 -> c'est de la base binaire :
Si elle commence par un 0x -> c'est de la base hexadecimale :

/!\ Attention au comportement et à l'écriture d'opération : l'ordre des priorité des opérations est respectée .
Idem pour l'utilisation des variables et du caractère "$" les définissant .
boogie@x61:/tmp$ a=3+5
boogie@x61:/tmp$ b=$(( a * 2 ))
boogie@x61:/tmp$ echo $b
16
boogie@x61:/tmp$ b=$(( $a * 2 ))
boogie@x61:/tmp$ echo $b
13


= la syntaxe "(( ))"  son équivalent direct est "let" est directement liée au calcul dans bash.Nous n'avons pas besoin de placer un $ en la définissant.

boogie@x61:/tmp$ for ((i=0 ; i < 10 ; i+=1 )); do echo $i ;done
0
1
2
3
4
5
6
7
8
9
boogie@x61:/tmp$ for ((i=0 ; i < 10 ; i+=3 )); do echo $i ;done
0
3
6
9


- Pour afficher les caractères d'une variable passé en argument :

boogie@x61:/tmp$ cat c

#!/bin/bash

var=$1
num=${#1}

echo " arg is $1 , num is $num "

for  ((i=0 ; i < ${num}  ; i+=1 ))
    do echo "$var contains ${var:$i:1}" 
done

boogie@x61:/tmp$ ./c lapin
 arg is lapin , num is 5 
lapin contains l
lapin contains a
lapin contains p
lapin contains i
lapin contains n

== while loop :
équivalent de l'exercice précédent avec un "while" : "tant que" vrai alors .... : attention à la boucle infinie, il faut également mettre un compteur pour sortir de la boucle : 

boogie@x61:/tmp$ cat e
#!/bin/bash

var=$1
num=${#1}

echo " arg is $1 , num is $num "

#let  i=0 
(( i=0 )) 
while  ((i < ${num} ))
    do 
    echo "$var contains ${var:$i:1}"
#    let i=$i+1  
    (( i=$i+1 ))  
done

boogie@x61:/tmp$ ./e lapin
 arg is lapin , num is 5 
lapin contains l
lapin contains a
lapin contains p
lapin contains i
lapin contains n



== read :

permet une interraction directe avec le user : 

boogie@x61:/tmp$ read lapin
coco
boogie@x61:/tmp$ echo $lapin
coco
On peut avoir une option de "prompt" : 
boogie@x61:/tmp$ read -p "hey what is yo name :" lapin
hey what is yo name :coco
boogie@x61:/tmp$ echo $lapin
coco

boogie@x61:/tmp$ read a b 
lapin nain
boogie@x61:/tmp$ echo $a 
lapin
boogie@x61:/tmp$ echo $b
nain
Attention les variables ne vont contenir qu'une chaine de caractère par défaut : s'il y a trop de chaine : la dernière variable héritera de tout le reste :
boogie@x61:/tmp$ read a b 
lapin blanc nain
boogie@x61:/tmp$ echo $a 
lapin
boogie@x61:/tmp$ echo $b
blanc nain
boogie@x61:/tmp$ read a b c
lapin nain rouge et blanc
boogie@x61:/tmp$ echo $a 
lapin
boogie@x61:/tmp$ echo $b
nain
boogie@x61:/tmp$ echo $c
rouge et blanc

boogie@x61:/tmp$ cat d
#!/bin/bash
# parsing des propriétés d'un fichier : ls -l fichier |./d < notre script

read rights links user  group size month day time filename

echo " rights are $rights for filename $filename "  

boogie@x61:/tmp$ ls -l a.sh |./d
 rights are -rwxr-xr-x for filename a.sh 


= case : 

branchement conditionnel : la lecture se fait sequentiellement.Chaque cas est traité l'un après l'autre.

Exemple on demande la saisie d'un chiffre : on attend donc soit un pair soit un impair (grâce au "pipe" qui nous donne le choix selectif). Si une lettre min ou maj est saisi (grâce aux intervals du bash )ou plusieurs lettres (grâce au pattern matching) un caractère special est saisi ... on lève un message.
On notera la possibilité de saisir des options et des intervals dans les choix possibles : 

boogie@x61:/tmp$ cat f.sh 
#!/bin/bash

echo -n "gimme me a digit please : "
read var

case "$var" in 
            2 |4 |6 |8) echo "hey chiffre pair!"
            ;;
            1|3|5|7|9) echo "yop : chiffre impair!" 
            ;;
            [a-zA-Z]) echo "hey ..un chiffre svp pas une lettre .."
               exit 1
            ;;
            [a-zA-Z]*) echo "hey ..un chiffre pas plusieurs lettres .."
                exit 2
            ;;
            *) echo "hey ..un chiffre svp pas un caractère special.."
               exit 3
esac 



=== chapter 5 - shell math and logic : 

De base quand on declare une variable avec des chiffres ou nombres : bash ne les considère que sous forme "string" :
boogie@x61:/tmp$ a=4
boogie@x61:/tmp$ b=5
boogie@x61:/tmp$ c=4+5
boogie@x61:/tmp$ echo $c
4+5
boogie@x61:/tmp$ c=$a+$b
boogie@x61:/tmp$ echo $c
4+5
Si on veut faire des opérations arithmetiques il faut déclarer le type "entier" pour notre variable le mot clé "declare" ou "typeset" est à utiliser (ils ont la même action). On utilise l'option "-i" (integer) avec le mot clé declare dans ce cas précis :

declare -i a=5
b=$(( $a + 4))
echo $b
9


Le mot clé "let" va indiquer que le mot clé suivant (uniquement lui) sera dédié au calcul arithmétique. Il n'y a donc qu'un seul argument authorisé avec le mot clé "let". Afin d'éviter les soucis d'espaces ont entoure par des "" notre expression

Exemple de script additionnant le nombre de fichiers , leur taille et la liste de leur nom passé en argument : 

#!/bin/bash

# on definit deux variable de type "integer et une liste vide que l'on va compléter à chaque itération de boucle :
declare -i total=0
declare -i countfile=0
filelst=""

while read perm link user group size month day hour file
  do
    echo "$file is the file proceed"
    echo "hey  $file is $size bytes  long"
    shift 1
    total+=$size
    countfile+=1
    filelst="$filelst $file"
done
echo "$total is the space on disk for $countfile files which are $filelst"

Ce qui nous donne : 

boogie@x61:/tmp$ ls -l a.sh f.sh test.txt|./d.sh
a.sh is the file proceed
hey  a.sh is 155 bytes  long
f.sh is the file proceed
hey  f.sh is 529 bytes  long
test.txt is the file proceed
hey  test.txt is 30 bytes  long
714 is the space on disk for 3 files which are  a.sh f.sh test.txt

Il est possible de définir de plusieurs manières un calcul arithmétique :

boogie@x61:/tmp$ let "f=4 + 7"
boogie@x61:/tmp$ echo $f
11
boogie@x61:/tmp$ g=$(( 4 + 7 ))
boogie@x61:/tmp$ echo $g
11
boogie@x61:/tmp$ echo "$(( $f + $g ))"
22

/!\  : ATTENTION on ne travaille que sur des entiers : les decimaux sont "tronqués".

* Décisions / choix branchements mathématiques :

On peut faire des "if" mathématiques grâce aux "(( ))"
On a les mêmes opérateurs que dans les languages comme le c ( < , <= , >, >= , == , != ..qu'on peut combiner avec le && , || ..)
boogie@x61:/tmp$ cat m.sh 
#!/bin/bash

# vars :

var=$1
factor=5

if (( $var < 10 ))
then 
    echo "nop : too small!"
    exit 1
fi

if (( $var >= 100 ))
then 
    echo "nop : too big!"
    exit 2
fi

if (( $var == 5 * $factor || cheat != 0 ))
then 
    echo "bingO!"
else
    echo "not so bad ...you can reach it !"
    exit 3
fi

Ce qui donne : 
boogie@x61:/tmp$ ./m.sh 4
nop : too small!

boogie@x61:/tmp$ ./m.sh 123
nop : too big!

boogie@x61:/tmp$ ./m.sh 25
bingO!

boogie@x61:/tmp$ ./m.sh 29
not so bad ...you can reach it !

boogie@x61:/tmp$ cheat=1 ./m.sh 29
bingO!

boogie@x61:/tmp$ cheat=1 ./m.sh 11
bingO!

boogie@x61:/tmp$ cheat=1 ./m.sh 99
bingO!

* creation de calculatrice : rpn (reverse polish notation ) : ex : 5 6 + ; 3 5 \* ; 4 6 + 1 / etc .....

boogie@x61:/tmp$ cat u.sh 
#!/bin/bash

echo "$1 == $2 == $3 " 

echo " now shift 1 : "
shift 1
echo "$1 == $2 == $3 " 

echo " now shift 2 : "
shift 2
echo "$1 == $2 == $3 " 

ce qui donne : 
boogie@x61:/tmp$ ./u.sh  bla blou blon
bla == blou == blon 
 now shift 1 : 
blou == blon ==  
 now shift 2 : 
 ==  ==  

On va devoir établir que la calculatrice doit comporter un nombre impair d'arguments ( 2 chiffres et un signe , un shift de 2 etc .... )
boogie@x61:/tmp$ cat v.sh 
#!/bin/bash
# simple arguments check
if (( $# != 3 ))
then 
    echo " $0 usage is that 3 characters are mandatory : <num> <num> <sign>"
    exit 1 
fi

# simple rpn calculator : shift number $2 with sign $3 : 
var=$(( $1 $3 $2 ))
echo " this is the result : $var"
  
Version "illimitée" avec test de nombre d'argument impair et décalage suite au calcul .
Temps que le nombre d'arguments est supérieur à 0 on continue à compter et décaller.

boogie@x61:/tmp$ cat w.sh 
#!/bin/bash

# simple arguments check
if (( $# % 2 == 0 ))
then 
    echo " $0 usage odd  parameters are mandatory : <num> <num> <sign> <num> <sign> and so ..."
    exit 1 
fi
var=$(( $1 $3 $2 ))
shift 3
while (( $# > 0 ))
do
    var=$(( $var $2 $1 ))
    shift 2
done 
echo " here it is $var "

* Test complet avec if [ ] et les differents test : cf man bash
 
boogie@x61:/tmp$ cat l.sh 
#!/bin/bash

a=$1

if [ ! -e ${a} ]
then
    echo "usage $0 gimme me something to eat ! "
    exit 2
fi

if [ -d $a ]
then 
    echo "yum a directory!"
fi

On peut faire les differents tests de comparaison = ; != etc mais attention c'est une comparaison de chaines. 
Pour comparer des entiers il faut utiliser les test  -eq , -le , gt etc ..ou alors se servir des "(( ))" qui autorisent les test de type < , == etc ...

* Test améliorés avec "[[ ]]" :

on peut se servir du globbing shell pour faire une comparaison de chaine grâce aux double crochet sans avoir de surprise 

boogie@x61:/tmp$ cat c.sh 
#!/bin/bash

# est ce que notre $1 fini bien par .txt : 0 ou plusieurs caractères suivis de ".txt" 
if [[ $1 == *.txt ]]
then 
    echo "yep it is ==> $1"
fi
Ce qui donne la sortie suivante quand on lance en argument un pattern qui match l'expression : 

boogie@x61:/tmp$ ./c.sh test.txt
yep it is ==> test.txt

On a aussi une seconde expression : la SEULE dans bash qui utilise les regexps comme dans sed et grep :

if [[ $1 =~ t.s..t.. ]]
then 
   echo  "mouarf not so far : $1"
fi
boogie@x61:/tmp$ ./c.sh tast.taz 
mouarf not so far : tast.taz

Toutes les constructions de regexps peuvent être utilisées : 
if [[ $1 =~ t*s..t[a-z]{2} ]]
then 
   echo  "mouarf not so far : $1"
fi

Attention dans le cas précis d'utilisation de =~ pour les regexps il ne faut surtout pas encadrer par des " ' le pattern sinon on annule la recherche par regexp.

[[ == ]] => shell pattern matching
[[ =~ ]] => regexp pattern matching


== Chapitre 6 : définition de fonction 
Il est possible dans bash de créer des fonctions : elles ne seront executées qu'après leur appel.
Trois forme de définition sont possible : avec le keyword function et () ou uniquement avec function ou uniquement avec () :
#!/bin/bash

function one ()
{
  echo "function one with keyword function and ()"
}
function two
{
  echo "function two -> without () "
}
tree ()
{ 
 echo "third form -> without function keyword "
}
one
two
tree
Ce qui nous donne : 
boogie@x61:/tmp$ ./fn.sh 
function one with keyword function and ()
function two -> without () 
third form -> without function keyword 

Il est possible d'effectuer un groupement de commande avec {} mais aussi (), (( )) et [[]] : les implications sont différentes on sait par exemple que (()) va effectuer des commandes arithmetiques.
Avec l'utilisation de () : on travaille dans un sous-shell  donc attention aux variables .

/!\ ATTENTION à toujours définir nos fonctions en début de script (comme pour les variables) avant de les invoquer.

= paramètres positionnels dans les fonctions : 
attention ils sont redéfinis dans la fonction 

boogie@x61:/tmp$ cat t.sh 

fn ()
{
echo "inside function here's the parameters : $1 $2"
}
echo "before function $1 $2"
fn bla bloublou
echo "after function $1 $2"
Ce qui donne :

boogie@x61:/tmp$ ./t.sh zz tt
before function zz tt
inside function here's the parameters : bla bloublou
after function zz tt

Seule $0 ne change pas : il n'y a pas de redifinition dans la fonction.

= Portée des variables : 

Par defaut toutes les variables sont "globales" dans un script et vues de manières identiques dans une fonction.

Il est toujours important de définir si besoin des variables dans notre fonction : le mot clé local est utile dans ce cas car : la variable ne sera utilisée que dans le contexte de la fonction : elle sera libérée de la mémoire dès la fonction executée : economie , meilleur gestion de la mémoire et protection du systeme.

Les mots clé "declare" "typeset" et "local" ont la même action dans une fonction.

boogie@x61:/tmp$ cat t.sh 

a=tutu
fn ()
{
local a="titi"
echo "inside function here's the parameters : $1 $2 et puis la var a : $a"
}
echo "before function $1 $2 et puis la var a : $a "
fn bla bloublou
echo "after function $1 $2 et puis la var a :  $a"

Ce qui donne :
boogie@x61:/tmp$ ./t.sh zz tt
before function zz tt et puis la var a : tutu 
inside function here's the parameters : bla bloublou et puis la var a : titi
after function zz tt et puis la var a : tutu

Depuis bash version 4.2 on peut définir dans notre fonction une variable globale avec :
declare -g : donc des que la fonction est lue la variable sera vue a l'exterrieur de la fonction aussi :

boogie@x61:/tmp$ cat t.sh 

a=tutu
fn ()
{
declare -g a="titi"
echo "inside function here's the parameters : $1 $2 et puis la var a : $a"
}

echo "before function $1 $2 et puis la var a : $a "

fn bla bloublou

echo "after function $1 $2 et puis la var a :  $a"

ce qui nous donne :
boogie@x61:/tmp$ ./t.sh zz tt
before function zz tt et puis la var a : tutu 
inside function here's the parameters : bla bloublou et puis la var a : titi
after function zz tt et puis la var a :  titi

* return :
c'est un mot clé classique qui va nous permettre d'indiquer un status de retour suite à l'exécution d'une commande.
On pourra l'interroger avec "$?" comme pour connaitre le code de sortie d'exit :

boogie@x61:/tmp$ cat a.sh 
#!/bin/bash

 what_time () {
    d=$(date +%F-%H:%M)
    printf "heyyo rolex %s ! \n" $d
    return 4
}
what_time 
echo $?

Ce qui nous donnera :
boogie@x61:/tmp$ ./a.sh 
heyyo rolex 2016-03-19-09:50 ! 
4


= Substitution indirecte :
il est possible de retrouver la valeur d'une variable en appelant une autre variable définie avec la syntaxe :
${!var} :
boogie@x61:/tmp$ a=lapin
boogie@x61:/tmp$ var=a
boogie@x61:/tmp$ echo ${!var}
lapin

Il peut être interessant de stocker les fonctions dans une bibliotheque ..ou dans un fichier et les appeller en sourcant le chemin du rep ou du fichier :
source function.sh

/!\ Quand on source un script : il est directement invoqué au sein du shell actuel sans la création d'un nouveau process. Les variables sont elles disponibles pour tous les environnements suivants.


. function.sh

=== Chapitre 7 : les tableaux.

On se sert des tableaux pour traiter  beaucoup de données du même type.
On peut recupérer les différents éléments d'un tableau. On recupere les differents élements "sous divisés" d'une variable.
 
Pour définir un tableau on utilise la notation  var[index] et pour recupérer les valeurs du tableau on utilise la notation "${var[index]}"

boogie@x61:/tmp$ index=5
boogie@x61:/tmp$ var[index]=222
boogie@x61:/tmp$ echo ${var[5]}
222

On doit déclarer explicitement un tableau ( array ) dans notre script avec declare -a :

boogie@x61:/tmp$ cat tab.sh 
#!/bin/bash

declare -a tab
tab=( zero one two three four [5]=five six seven eight nine ten)

echo "print the first record of our array ==> ${tab[0]}"
echo "hey print now the seven element => ${tab[7]}"

ce qui nous donne : 
boogie@x61:/tmp$ ./tab.sh 
print the first record of our array ==> zero
hey print now the seven element => seven

On va pour l'exemple creer un script qui va utiliser l'index du tableau pour nous donner le nom de cet index saisi dans notre liste de mot.
Notre script va nous permettre de convertir chaque chiffre saisi en mot correspondant.
ex : 3  > trois  

#!/bin/bash

declare -a tab
tab=( zero one two three four [5]=five six seven eight nine ten )

enter=$1

printf "here it is ==> %s \n" ${tab[$enter]}

Ce qui nous donne :
boogie@x61:/tmp$ ./ar.sh 3
here it is ==> three 

Version améliorée : on va convertir tous les chiffres saisis en entrée par la valeur de leur index dans le tableau. Si ce qui est saisi n'est pas un chiffre alors on l'affiche tel quel :

#!/bin/bash

# on defini notre tableau 
declare -a tab
tab=(zero one two three four five six seven eight nine ten)

# on boucle sur les arguments fournis
for arg 
do
# on cree un compteur et on l'incremente tant qu'il est inferrieur au nombre de caractère fournis en param
    for (( i=0 ; i<${#arg} ; i++ ))
    do
# on isole chaque caractere du param
        piece=${arg:$i:1}
# test : si c'est un chiffre alors on associe sa valeur a l'indice du tableau et on a donc sa valeur en lettre 
        case $piece in 
            [0-9])res=${tab[$piece]}
                 ;;
# on isole le caractère qu'on affichera simplement puisque ce n'est pas un chiffre 
                *) res=$piece
        esac
# on affiche donc la valeur du resultat(chiffre ecrit en lettre ou caractère inchangé)  et un espace. NB on affiche tout sur la même ligne donc pas de "\n" associé à printf
        printf "%s " $res
    done
# on rajoute une ligne vide pour avoir notre prompt ( pour corriger l'effet de notre précédent printf )
    echo
done

Ce qui nous donne :
boogie@x61:/tmp$ ./a.sh 5_allo_7
five _ a l l o _ seven 
boogie@x61:/tmp$ ./a.sh '#HEY#777'
# H E Y # seven seven seven

* Utilisation des tableaux dans une boucle :

On peut directement associer à un index de tableau des variables passées à read avec l'option "-a"
boogie@x61:/tmp$ cat b.sh 
#!/bin/bash

read -a inputfile

echo ${inputfile[0]}
echo ${inputfile[2]}
echo ${inputfile[8]}
Ce qui donne : 
boogie@x61:/tmp$ ls -l toto |./b.sh 
-rw-r--r--
boogie
toto

On peut donc recupérer via un tableau le nombre de fichiers par date 

#!/bin/bash

# pour memo la sortie de la commande envoyée à read est structurée comme telle :
# boogie@x61:/tmp$ ls -l yop_10 
#-rw-r--r-- 1 boogie boogie 0 mars  11 21:16 yop_10


while read -a input
do
    day_of_month=${input[6]} # On recupère le champ 6 => date du jour
    (( number[$day_of_month]=number[$day_of_month] + 1)) # on incremente par pas de 1 le nombre de fichiers donnés à la date
done

for ((i=0 ; i < 32 ; i++))  # on etabli le calendrier 
do
{
    printf "for the day of the month %2d we have %d files \n" $i ${number[$i]} # on affiche le jour du mois avec le nombre de fichiers à cette date. On formate a l'aide de printf %2d : digit de 2 numero : format des jours du mois connu.
}
done
Ce qui nous donne par exemple après la création de 10 fichiers :
 for i in $(seq -w 1 10) ;  do touch yop_$i ;done
On voit bien 10 fichiers crées le 11 du mois :
boogie@x61:/tmp$ ls -l yo* |./c.sh |more
...
for the day of the month  9 we have 0 files 
for the day of the month 10 we have 0 files 
for the day of the month 11 we have 10 files 
for the day of the month 12 we have 0 files 
...

On va pouvoir se servir de paramètres speciaux pour "éliminer" de la sortie ecran les entrées ne comportant pas de fichiers.

- Dans un premier temps on peut avoir la sortie du nombre de fichiers total pour chaque date : la date n'est ici pas encore présente :

#!/bin/bash


# memo sur ce que va recevoir notre script en entree :  boogie@x61:/tmp$ ls -l yop_10 
#-rw-r--r-- 1 boogie boogie 0 mars  11 21:16 yop_10


while read -a input
do
day_of_month=${input[6]}
(( nb_of_file[$day_of_month]=nb_of_file[$day_of_month]+1 ))
done

# On utilise le "@" qui va nous permettre d'avoir toutes les valeurs de notre tableau.On va pouvoir afficher le compte de fichiers par date

for count in "${nb_of_file[@]}" 
do
    printf "this is the number of files ..only %s \n" $count
done

Ce qui nous donne après la création de fichiers pour tests :
for i in $(seq -w 1 5) ;  do touch -d 16-03-07 yyp_$i ;done
for i in $(seq -w 1 10) ;  do touch -d 16-03-10 yap_$i ;done
for i in $(seq -w 1 10) ;  do touch -d 16-03-11 yop_$i ;done
for i in $(seq -w 1 10) ;  do touch yup_$i ;done

boogie@x61:/tmp$ ls -l y* |./tab.sh 
this is the number of files ..only 5 
this is the number of files ..only 10 
this is the number of files ..only 10 
this is the number of files ..only 10 

Les valeurs à "0" ne sont pas définies. On peut utiliser la forme "${!nb_of_file[@]}" pour avoir les index définis
On va donc pouvoir récupérer en sortie les dates ayant au moins un fichier au compteur sans passer par un "if" qui filtrerait les dates sans fichiers :

boogie@x61:/tmp$ cat tab.sh 
#!/bin/bash


# memo sur ce que va recevoir notre script en entree :  boogie@x61:/tmp$ ls -l yop_10 
#-rw-r--r-- 1 boogie boogie 0 mars  11 21:16 yop_10


while read -a input
do
day_of_month=${input[6]}
(( nb_of_file[$day_of_month]=nb_of_file[$day_of_month]+1 ))
done

for index in "${!nb_of_file[@]}"
do
    printf "for the date %2d  we have %d \n" ${index} ${nb_of_file[$index]}
done

Ce qui nous donne :
boogie@x61:/tmp$ ls -l y* |./tab.sh 
for the date  7  we have 5 
for the date  8  we have 4 
for the date 10  we have 10 
for the date 11  we have 10 
for the date 12  we have 10 


* Tableau associatif : 
On peut vouloir travailler sur autre chose que des entiers : disponible à partir de bash 4.0 :
on doit déclarer ce type de tableau avec declare suivie de l'option -A : ce qui va nous permettre d'avoir des strings en index.
Exemple :
declare -A animal

animal["cat"]=10
animal["lapin"]=5

echo ${animal["cat"]}
10
 
On va maintenant filtrer pour illustrer l'exemple sur le mois :
#!/bin/bash

# memo sur ce que va recevoir notre script en entree :  boogie@x61:/tmp$ ls -l yop_10
#-rw-r--r-- 1 boogie boogie 0 mars  11 21:16 yop_10


while read -a input
do
# declare -A month : on peut ne pas declarer month comme un tableau : cela fonctionne sans cette declaration d'ou le #
month=${input[5]}

declare -A nb_of_file # on déclare notre compteur de fichier "nb_of_file" comme un tableau associatif

(( nb_of_file["$month"]=${nb_of_file["$month"]} +1 ))
#let nb_of_file[$month]++ #: version raccourcie de la ligne précédente
done

for index in "${!nb_of_file[@]}"
do
    printf "for the month of %s we have %d files!\n" ${index} ${nb_of_file[$index]}
done

Ce qui nous donne 
boogie@x61:/tmp$ ll -rt --time-style='+%b %d' y* |./month_tab.sh
for the month of févr. we have 5 files!
for the month of mars we have 10 files!
for the month of janv. we have 5 files!

/!\ Attention les index ne sont pas triés : on a donc une sortie dans le désordre ( ici : février , mars puis janvier.. ).Un tri avec sort peut être nécéssaire.

Pour le fun on peut rajouter un "histogramme" qui illustrera notre compteur avec un "#".On va donc boucler et rajouter un "#" à chaque fichier trouvés par mois :
#!/bin/bash


# memo sur ce que va recevoir notre script en entree :  boogie@x61:/tmp$ ls -l yop_10 
#-rw-r--r-- 1 boogie boogie 0 mars  11 21:16 yop_10


while read -a input
do
# declare -A month : on peut ne pas declarer month comme un tableau : cela fonctionne sans cette declaration d'ou le # 
month=${input[5]}

declare -A nb_of_file # on déclare notre compteur de fichier "nb_of_file" comme un tableau associatif 

(( nb_of_file["$month"]=${nb_of_file["$month"]} +1 ))
#let nb_of_file[$month]++ #: version raccourcie de la ligne précédente
done

for index in "${!nb_of_file[@]}"
do
    printf "for the month of %s we have %d files!:" ${index} ${nb_of_file[$index]} # On ajoute ici un ":" dans notre printf pour passer à la ligne et créer la boucle for qui ajoutera un # à chaque fichier comptés par mois.
        for ((i=0; i<${nb_of_file[$index]} ; i++))
        do
            printf "#"  # on ne passe pas à la ligne pour avoir chaque # ajouter l'un à la suite de l'autre.
        done
            printf "\n" # on rajoute ici notre fin de ligne
done



Ce qui nous donne :
boogie@x61:/tmp$ ls -l y* |./month_tab.sh 
for the month of févr. we have 5 files!:#####
for the month of mars we have 10 files!:##########
for the month of janv. we have 5 files!:#####
 
== chapitre 8 : great scripts 

* Paramètres optionnels de commandes :

On peut définir nous même les options de nos commandes.
La commande built-in getopts va nous permettre de mettre en place ce fonctionnement.
Attention : il existe une commande shell qui s'appelle "getopt".
Pour les scripts la commande built-in "getops"  est préférée.


Avec getopts on va avoir deux chaines de caractères :
-> l'option que l'on va saisir
-> le nom de la variable qui va contenir le resultat de notre option 


boogie@x61:/tmp$ cat i.sh 

#!/bin/bash

# memo du script avec en entrée le resulat de la commande ls -l et le passaga à read 
# boogie@x61:/tmp$ ls -l yap_1
#-rw-r--r-- 1 boogie boogie 7 mars  15 17:18 yap_1

declare -i count=0

while read perm link user group size day month hour filename
do
    if [[ ! "$filename" ]] ; then continue ; fi
    count+=1
    echo " the file proceed is $filename which is $size bytes sized !"
    (( total+=$size ))
done
echo " $count files procedeed for $total bytes in total" 


# -a -c -t

while getopts "act" flag
do
    case $flag in 
        a) aflag=set
           ;;
        c) cflag=set
           ;;
        t) tflag=set
           ;;
        *) echo "usage ${0##*/} [-a] [-c} [-t]  # ici on supprime le path du script pour ne laisser que son nom en aide
           echo "exemple : ls -l |${0##*/} -ac ""
           exit 1
           ;;
    esac
done >&2 # on redirige ici dans toutes les sorties du scripts dans un fichiers d'erreur : c'est une bonne pratique.

Ce qui nous donne :
boogie@x61:/tmp$ ls -l ya* |./i.sh -a
 the file proceed is yap_1 which is 7 bytes sized !
 the file proceed is yap_2 which is 0 bytes sized !
 the file proceed is yap_3 which is 0 bytes sized !
 the file proceed is yap_4 which is 0 bytes sized !
 the file proceed is yap_5 which is 0 bytes sized !
 5 files procedeed for 7 bytes in total
boogie@x61:/tmp$ ls -l ya* |./i.sh -g
 the file proceed is yap_1 which is 7 bytes sized !
 the file proceed is yap_2 which is 0 bytes sized !
 the file proceed is yap_3 which is 0 bytes sized !
 the file proceed is yap_4 which is 0 bytes sized !
 the file proceed is yap_5 which is 0 bytes sized !
 5 files procedeed for 7 bytes in total
./i.sh : option non permise -- g
usage i.sh [-a] [-c} [-t]
exemple : ls -l |i.sh -a

/!\ Nb on peut supprimer le message d'erreur de sortie de getops en ajoutant un ":" au tout début de notre liste d'option. Exemple :
# -a -c -t

while getopts ":act" flag
do
    case $flag in
        a) aflag=set
           ;;
        c) cflag=set
           ;;
        t) tflag=set
           ;;
        *) echo "usage ${0##*/} [-a] [-c} [-t]"
           echo "exemple : ls -l |${0##*/} -ac "
           exit 1
           ;;
    esac

Vas nous donner :

boogie@x61:/tmp$ ls -l ya* |./i.sh -g
 the file proceed is yap_1 which is 7 bytes sized !
 the file proceed is yap_2 which is 0 bytes sized !
 the file proceed is yap_3 which is 0 bytes sized !
 the file proceed is yap_4 which is 0 bytes sized !
 the file proceed is yap_5 which is 0 bytes sized !
 5 files procedeed for 7 bytes in total
usage i.sh [-a] [-c} [-t]
exemple : ls -l |i.sh -ac 

La ligne suivante a disparue  "./i.sh : option non permise -- g" : pour plus d'info : man getopts

On peut grâce au double [[ qui attendent un true pour continue compacter des tests de la sorte :
[[ $aflag ]] && echo " at this moment we have "aflag" is set " . A la place des plus longs : 

if test ${aflag}=="set"  ; then  echo " at this moment we have "AFLAG" is set " ;fi
if [[ ${aflag}=="set" ]] ; then  echo " at this moment we have "aflag" is set " ;fi (attention au comportement avec les différentes version de bash.

OPTIND est une variable interne définie par getopts et qui va indiquer quel est la prochaine option à être traitée.

L'utilisation de shift dans certains script est donc particulièrement indiquée. On le fait dans ce cas comme ceci :
shift (( $OPTIND - 1)) : on décalle l'argument qui vient d'être traité ($OPTIND - 1) vers la gauche avec shift 

Pour associer des options avec des arguments on peut utiliser l'option suivie de ":" 
On definira notre option puis une variable interne OPTARG sera donc définie (grâce au : suivant notre option)
Par exemple dans notre script :
on va rajouter une option -u (pour user) qui prendra en paramètre un nom de user. Exemple : script -u boogie
on rajoute dans notre case l'option u :

        u) uarg="$OPTARG"
            echo " the arg provided is $uarg"
           ;;

et on peut rajouter un check en fin de script 

ogie@x61:/tmp$ cat i.sh 
#!/bin/bash

# memo du script avec en entrée le resulat de la commande ls -l et le passage à read
# boogie@x61:/tmp$ ls -l yap_1
#-rw-r--r-- 1 boogie boogie 7 mars  15 17:18 yap_1

declare -i count=0

  while read perm link user group size day month hour filename
do
    if [[ ! "$filename" ]] ; then continue ; fi
    count+=1
    echo " the file proceed is $filename which is $size bytes sized !"
    (( total+=$size ))
    own=${user}
done

echo "$count files procedeed for $total bytes in total"

echo "ok first check : file processed belong to mister : $own"



# -a -c -t -u 

while getopts "actu:" flag
do
    case $flag in
        a) aflag=set
           ;;
        c) cflag=set
           ;;
        t) tflag=set
           ;;
        u) uarg="$OPTARG"
            echo " the arg provided is $uarg"
           ;;
        *) echo "usage ${0##*/} [-a] [-c} [-t] " # ici on supprime le path du script pour ne laisser que son nom en aide
           echo "exemple : ls -l |${0##*/} -ac "
          exit 1
           ;;
    esac
done >&2 # on redirige ici dans toutes les sorties du scripts dans un fichiers d'erreur : c'est une bonne pratique.

#[[ $uarg && $uarg != ${own} ]] ; 

if [ "${uarg}" != "${own}" ]; then 
   echo "$uarg => not correct  as ${own} was selected"
else test "${uarg}" == "${own}" 
   echo " allright same player : $uarg is $own !!"
fi

Ce qui nous donne :

boogie@x61:/tmp$ ls -l yu* |./i.sh -u boogie
 the file proceed is yup.1 which is 6 bytes sized !
 the file proceed is yup.2 which is 0 bytes sized !
 the file proceed is yup.3 which is 0 bytes sized !
 the file proceed is yup.4 which is 0 bytes sized !
 the file proceed is yup.5 which is 0 bytes sized !
5 files procedeed for 6 bytes in total
ok first check : file processed belong to mister : boogie
 the arg provided is boogie
 allright same player : boogie is boogie !!
boogie@x61:/tmp$ ls -l yu* |./i.sh -u jazz
 the file proceed is yup.1 which is 6 bytes sized !
 the file proceed is yup.2 which is 0 bytes sized !
 the file proceed is yup.3 which is 0 bytes sized !
 the file proceed is yup.4 which is 0 bytes sized !
 the file proceed is yup.5 which is 0 bytes sized !
5 files procedeed for 6 bytes in total
ok first check : file processed belong to mister : boogie
 the arg provided is jazz
jazz => not correct  as boogie was selected

* Problematique d'expansion shell ; sous shell etc ...

on peut vouloir dans notre script écrire  directement la commande ls -l de manière à lancer la script directement  "i.sh" par exemple.
Problème : en faisant cela aucune variable n'est settée ni transmise : résultat on a rien :

boogie@x61:/tmp$ ./i.sh 
 the file proceed is gpg-oVNcvq which is 1024 bytes sized !
 the file proceed is i.sh which is 1381 bytes sized !
 the file proceed is lu11946umznz2.tmp which is 5120 bytes sized !
 the file proceed is orbit-boogie which is 1024 bytes sized !
 the file proceed is OSL_PIPE_1000_SingleOfficeIPC_679ff464ed33aa715ce1775a13f51ba3 which is 0 bytes sized !
 the file proceed is pulse-PKdhtXMmr18n which is 1024 bytes sized !
 the file proceed is ssh-j7kULiCT0R8x which is 1024 bytes sized !
 the file proceed is systemd-private-19aa678fdd0448d58e3ede992ad777fb-rtkit-daemon.service-zjkTdu which is 1024 bytes sized !
 the file proceed is yup.1 which is 6 bytes sized !
 the file proceed is yup.2 which is 0 bytes sized !
 the file proceed is yup.3 which is 0 bytes sized !
 the file proceed is yup.4 which is 0 bytes sized !
 the file proceed is yup.5 which is 0 bytes sized !
0 files procedeed for  bytes in total
ok first check : file processed belong to mister : 
 allright same player :  is  !!

Le problème est lié au passage après le pipe donc l'arrivée dans le while read dans un sous shell : les variables disparaissent donc : dès l'arrivée dans le while : ls -l |  while read perm link user group size day month hour filename

Pour régler ce souci il faut regrouper au sein d'un shell unique les commandes déroulée par la suite : le groupement se fait via l'ajout de {} qui regroupe toutes nos lignes :


ls -l | {  while read perm link user group size day month hour filename
do
    if [[ ! "$filename" ]] ; then continue ; fi
    count+=1
    echo " the file proceed is $filename which is $size bytes sized !"
    (( total+=$size ))
    own=${user}
done

echo "$count files procedeed for $total bytes in total"
echo "ok first check : file processed belong to mister : $own"
}

Dans ce cas on récupère bien le compte de nos fichiers :
boogie@x61:/tmp/folder$ bash i.sh -u boogie
 the file proceed is i.sh which is 1456 bytes sized !
 the file proceed is yup.1 which is 6 bytes sized !
 the file proceed is yup.2 which is 0 bytes sized !
 the file proceed is yup.3 which is 0 bytes sized !
 the file proceed is yup.4 which is 0 bytes sized !
 the file proceed is yup.5 which is 0 bytes sized !
6 files procedeed for 1462 bytes in total
ok first check : file processed belong to mister : boogie
 the arg provided is boogie
...

ATTENTION donc {} va nous aider à tout regrouper dans un même shell 
() passe tout dans un sous shell.
