=== concat des fichiers txt servant de support de cours ud tomcat ===

== chapitre 1 presentation : ==


 -- Overview of the Apache Tomcat Web Server (http://tomcat.apache.org)

 # Tomcat is targeted at:

   -- Java programmers who need a really good web server to publish their web apps

   -- sys admins who need to support the publishing of Java web apps

 # Tomcat is a

       -- free
       -- production-grade
       -- lightweight	 

       -- open-source
       -- cross-platform  
       -- no-fuss

   web server.

   ## It's Java-centric: written in Java, designed to host Java web apps.

   ## It's easy to install on any system.

   ## Out of the box, with no configuration, it's good to go. Customization is usually in small pieces.

   ## Versioning is incremental: sensible improvements, no radical changes

 # We'll cover Tomcat in-depth and hands-on:

   -- installation
   -- starting/stopping
   -- app deployment
   -- management/customization
   -- security
   -- troubleshooting

== chapitre 2 : set up - structure : =




 -- Quick and dirty Tomcat install (no verfication -- that's coming later)

 # Two ways to install: 'verified' and 'unverified'
   ## To begin, we'll do 'unverified'.

 # Strong recommendation: do the 'verfied' install. If you'd like to practice
   with the unverfied install, download Tomcat in ZIP format -- and then delete the ZIP.
   ## Follow up with a verified install, covered in the next two lessons.

 # Dependencies: 

   Define an environment variable named JAVA_HOME that points to the install
   directory of your Java JDK. 

   If you have only the JRE (JVM but no compiler, etc.), then define the environment
   variable JRE_HOME to point to the JRE install directory.

   ## The install directory can be tricky, particularly on a Mac.

   ## Where Java is installed doesn't matter: JAVA_HOME just points to it.

      ### On Linux systems, 

             /usr/local/<Java install> 

          is a typical install directory.

      ### On Windows, 

             C:\Program Files\<Java install> 

          is a typical install directory.

      ### On a Mac (El Capitan), 

             /Library/Java/JavaVirtualMachines/jdk<version>.jdk/Contents/Home 

          is a typical install directory.

--------------------------------------------------------------------------------------------------------

 # Steps to install:

 1. Go to the Tomcat download page: http://tomcat.apache.org/

 2. Check the link to 'Versions' (http://tomcat.apache.org/whichversion.html) to determine
    which version best meets your needs.

    ## Recommendation: latest 'stable' version (as of this writing, 8.x).

    -- Later versions are, in general, backwards compatible: web apps deployed in earlier
       versions should deploy in later versions. 

 3. Download the archive from the recommended mirror server, having picked the format you prefer
    (for instance, ZIP format -- less than 10MB).

 4. Unpack the archive wherever you like on the local system. For a learning (versus production)
    environment, I recommend installing Tomcat in your 'home' directory -- that way there's no
    OS issues regarding permissions.

 5. Let TOMCAT_HOME be your install directory. There's a 'bin' subdirectory:

                         TOMCAT_HOME
                              |
                             bin

 *6. Execute the 'startup' script in TOMCAT_HOME/bin

    -- On Unix-like systems, 'startup.sh'
    -- On Windows, 'startup.bat'

 *7. Open a browser to: http://localhost:8080

 * means 'optional': if you want a verified install, skip steps 6 and 7.

 
 -- Downloading and installing Tomcat (http://tomcat.apache.org/): verification 1

 # The very short story: Tomcat's downloadable as an archive (various options) that
   can be unpacked anywhere you like on the local system.

   ## System rules apply: if you unpack Tomcat somewhere, you need--as a user--the 
      appropriate system-level permissions to do so.

   ## For a learning versus production environment, I like to install Tomcat in my
      home directory:

                    MY_HOME_DIRECTORY
                          |
                        Tomcat

 ------------------------------------------------------------------------------------------

 # Tomcat versions -- alpha/beta/stable (http://tomcat.apache.org/whichversion.html)
   ## There's a link from the download page.

   ## Later versions _should_ accommodate apps written for earlier versions.
 
 # Comes in various archive formats (including ZIP), and an installer for Windows.
   
   ## Tomcat's written in Java -- so the critical requirement is to have Java (JDK or just JRE)
      installed, and either JAVA_HOME (you have the JDK) or JRE_HOME (you have only the JRE) defined.
      
------------------------------------------------------------------------------------------------------

 -- Verifications: Does the downloaded archive match the copy on the download machine?

                                  download             
       Tomcat-on-download-machine --------> Tomcat-copied-to-my-local-machine
                                \           /
                            Are these two the same?

 # Tomcat provides two 'message digests' (aka 'hashes') to enable the sort of checking
   illustrated above.

   ## Here's how a message digest works:

  
     For example, bytes in downloaded Tomcat archive                 For instance, 16 bytes
                    \                           +----------------+               \
          arbitrary number of bytes------------>| message digest |-------->fixed-size digest
                                                +----------------+

   ## Tomcat provides two digests:

      MD5 (Message Digest Version 5):         16-byte digest
      SHA1 (Secure Hash Algorithm Version 1): 20-byte digest

 # Unix-like systems have utilities such as 'md5sum' and 'sha1sum', and Windows
   has 'certUtil' built-in. On a Mac, the commands would be 'md5' and 'sha1'.

   Example: (with % as the command-line prompt on my Unix-like system):

     % md5sum apache-tomcat-8.0.33.zip
       b7ebc21cca3315bab7948513f8e50f79  apache-tomcat-8.0.33.zip         ## output (16 bytes)

     % sha1sum apache-tomcat-8.0.33.zip
       c99b581878e8cfc7337ebdd84dbde615b9a07eb0  apache-tomcat-8.0.33.zip ## output (20 bytes)

     What I downloaded from the Tomcat mirror:

       b7ebc21cca3315bab7948513f8e50f79 *apache-tomcat-8.0.33.zip         ## MD5
       c99b581878e8cfc7337ebdd84dbde615b9a07eb0 *apache-tomcat-8.0.33.zip ## SHA1

   ## Versions of the 'md5sum' and 'sha1sum' utilities are available on Windows, but the
      native 'certUtil' can be used here as well:

     % certUtil -hashfile apache-tomcat-8.0.33-windows-x64.zip MD5
       MD5 hash of file apache-tomcat-8.0.33-windows-x64.zip:
       7f 1c 6a 4d 66 6b 9c 76 ef 3b 72 03 8c 5a 89 1e        ## Matches what's on the download server
       CertUtil: -hashfile command completed successfully.




           




 


 Further verification of the downloaded Tomcat
 
 # For a production environment, this verification would be standard practice; but it's a good idea
   for a learning environment as well.

   ## The standard command-line utility for checking digital signatures is called 'gpg' (GNU Privacy Guard).
      ### 'gpg' is a suite of utilities, including a utility to digitally sign something.

   ## On Windows, 'certutil' can be used for the same purpose, and on a Mac 'codesign' is the built-in 
      equivalent.

      ## However, 'gpg' has become an at least informal standard, and versions are available for
         Windows and Macs:

                  https://www.gnupg.org/download/

         For simplicity, this handout sticks mainly with the 'gpg' utility.

 # Verifying Tomcat's digital signature, as all of its downloadable archives are digitally signed.

   ## Key Pair:

      -- private key, kept secret by the owner
      -- public key, distributed to anyone who wants a copy

   ## The owner of the private key uses it to digitally sign something (e.g., a ZIP file).
   ## The verifier of the signature uses the public key to verify the digital signature.

   ## Here's a depiction of what we're doing in verifying Tomcat's digital signature:
 
                    Unix-like systems have 'gpg' utility to do this, Windows has 'certUtil'
                                                    \
                                                +----------+
         digital signature--------------------->|          |
                                                | verifier |------>yes or no
         public key from signer's key pair----->|          |
                                                +----------+

       ### Here's the signature, from the 'pgp' entry that precedes the 'md5' and 'sha1' 
           entries on the download page. I've placeed this digital signature in the file
           'ds.asc', but any file name would do:

          -----BEGIN PGP SIGNATURE-----
          Version: GnuPG v2

          iQIcBAABCAAGBQJW7GYPAAoJEBDAHFovYFnnwQUP/iltVWLgfqLJkLgosuF9gmyl
          TYHiRuXKncA9upZuO4WKRbWYyUE50A81CfspyaDQmEC5v02v+KjcAOVdXh5aXWQw
          HxVCp9GsfiV/ddfC0fu2NKD+0gmkhBVUpIK6+FWmOcR0spmZxjMnEAE3XPvWtniZ
          KDdsPmiiGcbMKkcUNWKb/8EHh7Dw0W2JfAsUFSS8Axl77/VDmfeyD7lMs6Ydxxuo
          fPEdojEtYtbpfrf6ZjhLvEMoCvwlpTcWxHMZqo5hJsYIBuwQadvbcmy1X8PiqNIi
          v9JMfK53sj11GM6kJn0qjmUpuNt5zIl05P83IaFrm2KkhEhUqI9l55VHldH+z8PA
          pSFHP8W5DoVEyTxK0op5JyQ7tGFFJ6k031I327Sb3nsKocz5nEiZxo/nSIXuxe8R
          0ROFRa8P+0f6LjYqAIg5W8nx0jD7Nrj5hdijY9WCCy/yiAvyySuAxwen4kwkotBx
          +460ctyEb3/7RFqhksGQZsyzCapPA4smgsB9yEEgqQW9lce6z81cVJsXguz8XbV2
          lXsGLcbgcBWbqx8abV+8OGhoSLxur7iLzJaWBL3q1oWrZpnKydW46NJDrKfId6nP
          7SFPDH+gJ0FfQBIGt+5NfoF8TeOdYX5MepdpuM/VpbaR+JKSLspOjF3lauqGCqrR
          NCBTVZApJDCH8LIXoZVh
          =hUOK
          -----END PGP SIGNATURE-----

       ### We now need a series of commands to get Tomcat's public key so that we can verify
           this signature. The commands are given below with comments starting '##'.

           ## Try to verify, even though we lack the public code to do so.
           % gpg --verify ds.asc apache-tomcat-8.0.33.zip
               gpg: Signature made Fri 18 Mar 2016 03:33:19 PM CDT using RSA key ID 2F6059E7
               gpg: Can't check signature: public key not found

           ## Get Tomcat public key from reliable source (e.g., MIT): use 'key ID' above
           % gpg --keyserver pgpkeys.mit.edu --recv-key 2F6059E7
               gpg: requesting key 2F6059E7 from hkp server pgpkeys.mit.edu
               gpg: key 2F6059E7: public key "Mark E D Thomas <markt@apache.org>" imported
               gpg: no ultimately trusted keys found
               gpg: Total number processed: 1 
               gpg:               imported: 1  (RSA: 1)

           ## Now try the verification again.
           % gpg --verify ds.asc apache-tomcat-8.0.33.zip
               gpg: Signature made Fri 18 Mar 2016 03:33:19 PM CDT using RSA key ID 2F6059E7
               gpg: Good signature from "Mark E D Thomas <markt@apache.org>"
               gpg: WARNING: This key is not certified with a trusted signature!
               gpg:          There is no indication that the signature belongs to the owner.
               Primary key fingerprint: A9C5 DF4D 22E9 9998 D987  5A51 10C0 1C5A 2F60 59E7

           ## Get some confirmation on the fingerprint. Tomcat lists all of the developer keys
           ## in the file (available from the download page) in the file KEYS.
           ## The critical question: How much trust do you need to accept the signature?
           % gpg --fingerprint 2F6059E7
               pub   4096R/2F6059E7 2009-09-18
                     Key fingerprint = A9C5 DF4D 22E9 9998 D987  5A51 10C0 1C5A 2F60 59E7
               uid                  Mark E D Thomas <markt@apache.org>
               sub   4096R/5E763BEC 2009-09-18

           ## Get the signer data from the KEYS file (which I've saved locally as KEYS.txt):
           % gpg < KEYS.txt
               pub  1024D/F22C4FED 2001-07-02 Andy Armstrong <andy@tagish.com>
               sub  2048g/02908623 2001-07-02
               pub  1024D/86867BA6 2001-11-22 Jean-Frederic Clere (jfclere) <JFrederic.Clere@fujitsu-siemens.com>
               sub  1024g/4DC1E793 2001-11-22
               ...
               pub  1024D/288584E7 2008-07-02 Rémy Maucherat <remm@apache.org>
               sub  4096g/4B6FAEFB 2008-07-02
               pub  1024D/0D811BBE 2006-11-14 Yoav Shapira <yoavs@computer.org>
               sub  2048g/286BACF1 2006-11-14
               pub  4096R/731FABEE 2011-05-27 Tim Whittington (CODE SIGNING KEY) <timw@apache.org>
               sub  4096R/461B342D 2011-05-27
               pub  3072D/0D498E23 2013-01-14 Mladen Turk (Default signing key) <mturk@apache.org>
               sub  4096g/DC3D1B18 2013-01-14


           

-- Tomcat's directory structure

 # Tomcat can be installed (e.g., by unzipping a downloaded ZIP file) anywhere on the local system.

   ## For reference, TOMCAT_HOME is the top-level install directory.
   
      ### You could define an environment variable with this name, but it's not required.

 # Here's the directory structure for TOMCAT_HOME:

                              TOMCAT_HOME     ## contains LICENSE, NOTICE, RELEASE-NOTES, RUNNING.txt
                                    |
   +----------+----------+----------+----------+----------+---------+
   |          |          |          |          |          |         |
  bin        conf       lib        logs       temp       webapps   work
  
   *## bin:     scripts to start/stop Tomcat, etc.
    ## conf:    configuration files (XML files)
    ## lib:     Tomcat and 3rd-party libraries (JAR files)
    ## logs:    log files (many over time...)
    ## temp:    temporary files created using the Java File API
   *## webapps: deployed web apps (web sites, web services, web sockets,...)
    ## work:    Tomcat-compiled JSP scripts and other assets

   A star * marks the two subdirectories we care about most at the start.

  # More about TOMCAT_HOME/webapps

    ## It's the 'virtual base directory' for a deployed web app, e.g., 'preds.war'.

       ### The 'virtual' underscores that TOMCAT_HOME/webapps is _not_ part of the URI:

              http://localhost:8080/preds    ## no sign of TOMCAT_HOME/webapps

       ### TOMCAT_HOME/webapps can have arbitrarily many subdirectories to any level.

           Example: If 'preds.war' were deployed to TOMCAT_HOME/webapps/examples, then
	            the URL would be:
          
              http://localhost:8080/examples/preds

           -- To keep the URI part as simple as possible, I prefer to put all of my web apps
	      in TOMCAT_HOME/webapps rather than in a subdirectory thereof.
	      



 WAR files and URLs in Tomcat deployment: request mapping ('dispatching')
 
 # How does Tomcat map client requests to the appropriate 'resource' within a web app?
        
                 +--------------------+
    request----->| request dispatcher |----->requested resource
                 +--------------------+

   ## Bascally a two-step operation:

      -- First, find the appropriate WAR file.

      -- Second, find the resource (e.g., HTML page, Jave code) within the WAR file.

      -- If the requested WAR file doesn't exist, or the resource within it, we get the
         familiar "404 Not Found" response from the web server.

--------------------------------------------------------------------------------------------------------

 # The standard way to deploy a web app in Tomcat is to copy a WAR file (JAR file with a .war extension)
   to the TOMCAT_HOME/webapps tree (i.e., this directory or some subdirectory)

   ## The WAR file name is arbitrary.

   ## In this example, the deployed WAR file is named 'preds.war'.

   ## Contents of the deployed 'preds.war' file:

       ajax.xhtml                                 ## the identifier is 'ajax.jsf', a proxy for 'ajax.xhtml'
       WEB-INF/web.xml                            ## standard 'deployment descriptor' (optional)
       WEB-INF/faces-config.xml                   ## JSF deployment descriptor
       WEB-INF/classes/beans/Controller.class     ## backend JavaBean
       WEB-INF/classes/beans/Organization.class   ## ditto
       WEB-INF/classes/beans/Prediction.class     ## ditto
       WEB-INF/lib/javax.faces.jar                ## JSF implementation library

 # The client's URL includes the WAR file's name as the _first_ name in the URI-part of the URL.

   Example with 'preds.war' as the name of the deployed WAR file:


   'scheme'    port number  WAR file name  JSF script in the WAR file
        \               \      /           /
       http://localhost:8080/preds/ajax.jsf   ## URI starts with the / after the port number
              \_______/     \_____________/   ## URI = Uniform Resource Identifier: a name
                  /                \
       server's address       resource URI (Uniform Resource Identifier), aka 'path'

    ## In this example, /preds/ajax.jsf is the URI ('path to resource') -- what's being requested.
   
    ## The URI begins with '/preds' == a slash and then the WAR file's name _without_ the '.war' extension
                 

 -- Tomcat and Java: A quick look behind and look ahead

 # Recall that, in installing Tomcat, we define JAVA_HOME (or JRE_HOME) as an environment variable
   that points to the Java JDK (or JRE) install directory.

   ## Tomcat's implemented in Java, and designed precisely to handle Java web apps.

   ## Output from invoking the 'startup' script (startup.sh or startup.bat) at the command-line:

      % ./startup.sh
        Using CATALINA_BASE:   /home/kalin/tomcat8
        Using CATALINA_HOME:   /home/kalin/tomcat8
        Using CATALINA_TMPDIR: /home/kalin/tomcat8/temp
        Using JRE_HOME:        /usr/local/java8
        Using CLASSPATH:       /home/kalin/tomcat8/bin/bootstrap.jar:/home/kalin/tomcat8/bin/tomcat-juli.jar
        Tomcat started.

       ### To confirm that Tomcat's indeed running, we could open a browser to http://localhost:8080, or
           use the 'curl' utility (https://curl.haxx.se/) from the command-line:

             % curl localhost:8080
     
       ### For now, CATALINA is Tomcat's main component -- its 'web container'.
     
       ### It's common to conflate 'Tomcat' (the web server) and 'Catalina' (the main component).

 # Tomcat runs as a Java 'application', which means as a single process at the system level.

   ## Tomcat implements the 'one-thread-per-request' model of handling client requests:

                           
             TCP or HTTP request        request handed off to a thread from a thread pool
                       \   +--------+              /
      client request ----->| Tomcat |----->client-handling thread
                           +--------+

      ### Tomcat is thus multi-threaded, and multi-threading is the standard Java way to
          manage 'client concurrency'.

          #### Modern Tomcat uses a mix of multi-threading and non-blocking ('asynchronous') I/O
               to manage concurrent client requests.

 # Tomcat can be managed (even remotely) through JMX (Java Management Extensions), in particular 
   by exposing the web container (Catalina) as an MBean.

 Exercise: Install Tomcat on your local system

 # Quick review of the required steps, and some suggestions:

   1. Define JAVA_HOME as an environment variable for the local system so that it 
      points to the install directory of the JDK.

      -- If you've only the JRE, not the full JDK, then define JRE_HOME instead.

         ## The JDK is recommended for some later examples, which require code to be compiled.

         ## There's excellent on-line help for setting environment variables on different
	    systems. Below is a search string, where <Version> represents a particular
            Windows version (e.g., 7, 8, 10) or Mac OS X version (e.g., El Capitan).
            For Linux systems, <Version> would be one of Ubuntu, Fedora, etc.

            "set environment variable in <Version>"  ### Search on this string for quick tips

   2. Download core Tomcat from http://tomcat.apache.org in either archive or installer form.

      -- If you're on Windows and want to run Tomcat as a system service, the Windows
         installer is a good idea.

   3. Verify Tomcat in a way that's appropriate for your needs.

      -- Verify the MD5 and SHA1 digests that Apache provides for all downloads.

      -- Verify the digial signature included in Apache download files.

   4. Do a quick start/stop of the installed Tomcat to make sure it's running.
      Using a browser or 'curl' pointed to http://localhost:8080 to verify that the start worked.

 
 Assessment of the 'install Tomcat' exercise

 # Summary points:

   -- Unless there's an issue of disk space, it's more flexible to install the full JDK rather
      than just the JVM, as the JDK includes the JVM (JAVA_HOME/jre).

      ## In a production environment, it might be policy to have the JVM only, of course.

   -- In general, downloading core Tomcat as an archive, rather than as an installer,
      gives you more flexibility: complete control over where you put it, no hidden effects.

      ## If you want to have Tomcat run as a service, that's still possible, of course -- but
         the Windows installer makes this easier.

   -- The verification of "what's up on the Apache server got to my local machine" is straightforward:

      ## Compute the message digest of the downloaded file locally, and compare against the copy
         on the Apache download server.

      ## Doing both MD5 and SHA1 is about as easy as doing just one:

         -- Windows has the 'certUtil', Mac has the 'md5' and 'sha1' utils, and Linux has
            the 'md5sum' and 'sha1sum' utils.

   -- The verification of digital signatures is tricky, as you need:

      ## The signed resource: in this case, the downloaded archive or installer. This is easy.

      ## The digital signature: available as the 'pgp' tab on the Apache download site. No problem.

      ## A reliable copy of the signer's public key. Now things get tricky:

         -- A list of the signers is available as the 'KEYS' tab on the Apached load site.

         -- Public keys are available from sites such as MIT, used an the earlier lesson.

         -- The public keys themselves need verification...

== chapitre 3 - http - deployment : =



 HTTP (HyperText Transport Protocol) -- the basics for web sites and services

 # For web sockets, we'll be looking at TCP (Transmission Control Protocol) proctocol. First, though, it's HTTP.
 
   ## Other protocols, e.g., SMTP (Simple Mail Transport Protocol) for email, may come into play at the API level,
      but Tomcat is not an email server.

 # HTTP is a messaging protocol, built atop TCP (Transmission Control Protocol)

   ## Two basic types of message: request and response

   Depiction:

      Various request 'methods', including: POST (Create), GET (Read), PUT (Update, Delete (Delete): CRUD ops
                  /
             request message
      client----------------->server

      ## URLs typed into the browser's input box, or clicked hyperlinks, typically generate GET requests.

      ## Forms submitted from a browser typically generate POST requests.

      ## Modern browsers do GET and POST only.

      ## Modern web services, which are typically hit by programs other than browsers, are 'RESTful'
         in that they support all four CRUD operations.
	 
      
             response message
      client<-----------------server
      
-----------------------------------------------      

   Richer depiction with URL 'http://localhost:8080/greet/hello.html' ## URI is '/greet/hello.html', method is GET

                                                              'Create' 'Read' 'Update' 'Delete' ## CRUD operations
                                                                   \      |    /        /
        requires a URI ('noun') and an HTTP method ('verb' such as POST, GET, PUT, or DELETE)
                      \
               request message    +-----------------------+
       client-------------------->| HTTP-compliant server |   ## verb is GET, noun is /greet/hello.html
          /                       +-----------------------+   ## Operation: Read the 'hello' page
   perhaps a browser as the 'user agent'


               response message   +-----------------------+
       client<--------------------| HTTP-compliant server |   ## a server responds to a request
                                  +-----------------------+   ## Response is the embedded 'hello' page 

   ## HTTP is often described as 'stateless', but does contain mechanisms (e.g., cookies and other
      'header elements') to manage state.

   ## In general, it's the web app that maintains 'state' among requests and responses in order to
      support a multi-message conversation.

      ### Tomcat (through the Catalina component) provides mechanisms such as the 'session map' to help
          the programmer maintain state.
  
 # Format of requests/responses

    HTTP request:

       start line   ## HTTP_method URI [HTTP version]        E.g.: POST /skiServ/dataVerifier HTTP/1.1
       headers      ## Key/value pairs, with : as separator  E.g.: Content-Type: application/x-www-form-urlencoded
       newline
       newline
       [body]       ## GET and DELETE have no body; POST and PUT have a body

    HTTP response:      

       start line   ## [HTTP version] Status code (numeric and English)  E.g.: 200 OK
       headers      ## Key/value pairs, with : as separator              E.g.: Server: Apache-Coyote/1.1
       newline
       newline
       body         ## For instance, an HTML page


 More HTTP basics

 # Format of requests/responses

    HTTP request:

       start line   ## HTTP_method URI [HTTP version]        E.g.: POST /skiServ/dataVerifier HTTP/1.1
       headers      ## Key/value pairs, with : as separator  E.g.: Content-Type: application/x-www-form-urlencoded
       newline
       newline
       [body]       ## GET and DELETE have no body; POST and PUT have a body

    HTTP response:      

       start line   ## [HTTP version] Status code (numeric and English) E.g.: 200 OK
       headers      ## Key/value pairs, with : as separator             E.gl: Server: Apache-Coyote/1.1
       newline
       newline
       body         ## For instance, an HTML page
------------------------------------------------------------------------------------------------------------------

 # Simple demo using the handy 'curl' utility (https://curl.haxx.se/ -- works on all systems)

     ## Issue a GET request against the web server on condor.depaul.edu
     % curl --request GET --verbose http://condor.depaul.edu/mkalin/

      * About to connect() to condor.depaul.edu port 80 (#0)
      *   Trying 216.220.180.148... connected

      > GET /mkalin/index.html HTTP/1.1
      > User-Agent: curl libcurl OpenSSL zlib libidn librtmp
      > Host: condor.depaul.edu
      > Accept: */*
      > 

      < HTTP/1.1 200 OK
      < Server: Apache/2.2.3 (Red Hat)
      < ETag: "1c241-bd2-52c9ec63e9b80"
      < Accept-Ranges: bytes
      < Content-Length: 3026
      < Content-Type: text/html
      < Connection: close
      < 
      <html>
      <title>Home page</title>
      <head>
        ...
      </head>
      <body>
        ...
      </body>
      </html>

      * Closing connection #0
----------------------------------------------------------------------------------------------------------

      Context: 
               -- Post a form that contains information about a new equipment item, in this case skis.

               -- The 'dataVerifier' servlet checks the submitted form.

               -- If OK, the 'dataVerifier' redirects to the 'goodResult' servlet (a translated JSP script);
                  otherwise, the 'dataVerifier' redirects to the 'badResult' servlet' (another JSP script).

      % curl --request POST --verbose --data "product=Acme Super Skis&category=Ski equipment&price=1234.56" \
             -L  http://localhost:8080/skiServ/dataVerifier

      > POST /skiServ/dataVerifier HTTP/1.1
      > User-Agent: curl libcurl OpenSSL zlib libidn librtmp
      > Host: localhost:8080
      > Accept: */*
      > Content-Length: 61
      > Content-Type: application/x-www-form-urlencoded

      * upload completely sent off: 61 out of 61 bytes

      < HTTP/1.1 302 Found
      < Server: Apache-Coyote/1.1
      < Set-Cookie: JSESSIONID=E9533CE7667BED64A2E4E0D5AD05CC2A; Path=/skiServ/; HttpOnly
      < Location: http://localhost:8080/skiServ/goodResult.jsp
      < Content-Length: 0
      < 

      * Connection #0 to host localhost left intact
      * Issue another request to this URL: 'http://localhost:8080/skiServ/goodResult.jsp'
      * Violate RFC 2616/10.3.3 and switch from POST to GET
      * Re-using existing connection! (#0) with host localhost
      * Connected to localhost (127.0.0.1) port 8080 (#0)

      > POST /skiServ/goodResult.jsp HTTP/1.1
      > User-Agent: curl libcurl OpenSSL zlib libidn librtmp
      > Host: localhost:8080
      > Accept: */*
      >
 
      < HTTP/1.1 200 OK
      < Server: Apache-Coyote/1.1
      < Set-Cookie: JSESSIONID=DE51C48DD5895E805B0747E2D8AFB2F9; Path=/skiServ/; HttpOnly
      < Content-Type: text/html;charset=ISO-8859-1
      < Content-Length: 303

 -- Interactions among HTTP, the web container, and app-specific code

 # Given an incoming HTTP request to Tomcat/Catalina


             Catalina in the case of Tomcat
                          /                 +-----> static content (e.g., 'productList.html')?
      HTTP request  +---------------+       |
     -------------->| web container |-------+-----> app-specific servlet (e.g., 'myProdListServlet')?
                    +---------------+       |
                                            +-----> framework servlet (e.g., the JSF servlet)? 

    ## For app-specific servlets, recall that JSP scripts are translated into servlet instances (in Tomcat,
       Jasper is the 'JSP engine' that does the translating).

 # Here's how each of these cases is handled:

   -- Requests for static content

        http://...:8080/acmeProducts/productList.html   ## a static HTML page

      are dispatched to the DefaultServer, which comes with the web container Catalina.

              productList.html  +--------------------+
      request------------------>| request dispatcher |----->DefaultServlet ## loaded when Tomcat starts up
                                +--------------------+

             body of the HTTP response
                     /
                 productList.html
      requester<------------------DefaultServlet

 # For dynamic content--the request-handling code in a web app--Catalina 

   -- parses the request

   -- generates a map (key/value pairs) of the request contents

   -- passes the map to the request-handling code

   -- passes a channel reference to the request-handling code so that this
      code can generate a response    

                                                 HttpServletRequest instance
                                                            /
              productList.jsp   +--------------------+  request map
      request------------------>| request dispatcher |-------------->productListServlet ## compiled JSP script
                                +--------------------+


            body of the HTTP response
                     /
                 productList.html
      requester<------------------productListServlet
                     \
               HttpServletResponse instance

 # For various web frameworks (e.g., JSF = JavaServerFaces), the approach is quite similar:

   ## There's an 'interceptor' servlet that represents the framework.

   ## The interceptor then manages the application-specific code.

   Depicition:

                                                 HttpServletRequest instance
                                                            /
              productList.jsf   +--------------------+  request map              
      request------------------>| request dispatcher |-------------->JSF servlet------>app-specific code
                                +--------------------+                  \
                                                                 'interceptor' servlet

-------------------------------------------------------------------------------------------------

 # An HTTP(S) request has the start-line/headers/[body] structure examined earlier:

   -- always a start-line and at least one header element

   -- body is optional (e.g., PUT and POST have a body, GET and DELETE do not)

 # The javax.servlet.http.HttpServlet class encapsulates 'do' methods that are Java
   counterparts of the underlying HTTP methods ('verbs'): doGet, doPost, doPut, doDelete, etc.

   ### In general, the servlet API enables and simplifies program interaction with the
       underlying HTTP request and HTTP response.

   ## The web container (Catalina in Tomcat) parses the request, and creates a Java map
      from the key/value pairs that make up the HTTP headers and (optional) body. Info
      from the HTTP start-line (e.g., the HTTP verb such as GET or POST) also goes into
      this map. 
      
      ### Various 'get' methods are available to extract information from the HTTP
          start-line, the headers, and the body.

      ### The API is flexible: an HTTP request can have arbitrarily many header and body
          elements so the API has, for example, a getParameter(paramName) method.


 -- Deployment basics with Tomcat defaults

 # Tomcat supports two modes of deployment: 

   -- packed: the entire web app is packaged in a WAR file

   -- unpacked: individual pieces in a directory structure that matches
                what you'd get if you were to 'unwar' the corresponding WAR file

      ## If the WAR is 'preds.war', then the 'unpacked' version is available with
         the standard 'jar' utility that ships with the JDK:

         % jar xvf preds.war   ## unpack the contents, leave the WAR file as is

   ## Only 'packed' deployment is required under the Java servlet spec, but Tomcat supports
      either approach to deployment.

 # Packed deployment is cleaner, safer, easier -- no compelling reason not to use it.

   ## Standard packed deployment, in general, should work as is for other web containers such as Jetty.

   ## Packed deployment makes undeployment and redeployment easy:

      -- To undeploy, remove the WAR file from TOMCAT_HOME/webapps: Tomcat then removes the 'unpacked' directory.

      -- To redeploy, overwrite the current copy of the WAR file with a new one: Tomcat again 'unpacks'.

   ## Since a WAR file has its own hierarchical file structure, the rules for 'packed' and 'unpacked' are the same
      with respect to what goes where in the WAR file.

 # How to deploy?

   ## Ant, Maven, and even other scripts are in wide use.

      ### The Apache Tomcat download site provides one such script: more on this later.

      ### IDEs such as Eclipse, NetBeans, and IntelliJ provides scripts under the hood to do
          the work.

      ### A close look at such a script is coming...





 -- Deployment rules -- how the packed (or unpacked) deployment should look

 # What goes where?

   -- configuration files ('deployment descriptors') occur under WEB-INF
     
      ## The standard config file, 'web.xml', occurs in the WEB-INF subdirectory

      ## Other config files (e.g., 'sun-jws.xml') occur in WEB-INF or in a subdirectory rooted in WEB-INF

      ## The config files are in XML format.

   -- TLD (Type Library Description) files, which describe customized JSP tags, likewise occur in the
      WEB-INF tree.

      ## These files, like config files, are in XML format.

   -- Programmer-compiled .class files occur in the WEB-INF/classes tree. 

      Example: Given the source code

         package foo.com;
         public class SampleJavaBean {
           //...
         }

      the compiled class SampleJavaBean.class would be put in the WEB-INF/classes/foo/com directory:

                WEB-INF   ## must be spelled exactly like this
                   |
                classes   ## ditto: all .class files here or below
                   |
                  foo     ## start of my package name
                   |
                  com     ## end of my package name: SampleJavaBean.class is here

   -- JAR files, which are expected to hold libraries and other implementation code (e.g., an
      implementation of a customized tag) occur in the WEB-INF/lib subdirectory.

 # Here's a summation:

            top-level of WAR file    ## Could hold .html, .css, .jsp, .jsf, .js, and other file types
                    |                ## not under deployment restrictions.
                    |                ## However, we might put images in an 'images' subdirectory, JavaScript
                    |                ## code in a 'scripts' subdirectory, HTML and CSS files in an 'assets' 
                    |                ## subdirectory, and so on.
                    |
                 WEB-INF             ## WEB-INF for 'deployment descriptor' files (with .xml extensions)
                    |
          +---------+---------+
          |                   |
         lib               classes   ## WEB-INF/lib for archived code (JARs with .jar extensions)  
                                     ## WEB-INF/classes for byte-code files (.class extensions)   
                                      


 -- WAR file deployment: too tedious to do by hand

 # IDEs (e.g., Eclipse, IntelliJ, NetBeans) use scripts under the hood to automate deployment.

 # Various scripting languages (e.g., Ant, Maven, 'shell', 'bat') are available for automating WAR deployment.

 # Tomcat uses an Ant script to deploy from the Tomcat management console (the web GUI), and makes the full
   script available for downloads under 'Deployer' on the download page (http://aparche.tomcat.org).
   There's documentation at:
   
      https://tomcat.apache.org/tomcat-8.0-doc/deployer-howto.html#Deploying_using_the_Client_Deployer_Package

   ## Tomcat also has a Maven plugin on the download page:

      http://tomcat.apache.org/maven-plugin.html for documentation.

 # For demo purposes, I'm going to use my own Ant script: very simple, saves the .java source files for
   convenience in the constructed WAR; doesn't require a valid 'unpacked' web app to begin

   ## Dependencies: Apache Ant (http://ant.apache.org/) should be installed, version 1.6x or greater.

      ### To check on the installation from the command line: % ant -version

   ## My Ant script is a single file, 'build.xml', and starts out with a page or so of documentation.

 # An Ant script consists of 'tasks', which can be ordered for dependencies. Here's a high-level view,
   with low-level details to follow:

   -- Default task is 'deploy'.                        ## any name would do
 
   -- The 'deploy' task requires the 'compile' task.   ## dependency

   -- The 'compile' task requires the 'build' task.    ## and another

   -- The 'build' task requires the 'clean' task.      ## ditto
   ...
   
              requires          requires        requires        requires
       deploy---------->compile---------->build---------->clean---------->...

   ## The tasks are laid out in an XML file whose default name is 'build.xml'. 

      ### This file may link in other files, typically with a '.properties' extension (e.g., 'deployer.properties')

      ### At the command-line, 

          % ant                  ## execute the default task in the default task file 'build.xml'

          % ant -f myBuild.xml   ## execute the default task in the specified task file 'myBuild.xml'

   ## Tasks can be specified at the command-line:

      Examples:

      % ant compile    ## perform the 'compile' task, and any other task that it requires; and so on.

      % ant build      ## perform the 'build' task,...

      % ant            ## perform the default task

      % ant deploy     ## ditto

      % ant start      ## e.g., start Tomcat 


   

<?xml version = "1.0" encoding = "UTF-8"?>  

<!-- This file (build.xml) is housed in the current working directory, hereafter cwd.
     There should be a src subdirectory:

     cwd  ## Ant script build.xml is here.
      |
     src  ## Everything else is here or below.

     All files except for Java source files should be placed directly in src. Examples include
     XML files (e.g., web.xml), JSP scripts (e.g., hi.jsp), HTML files (e.g., hi.html),
     and JAR files (e.g., jstl.jar). Java source files should be packaged, for example:

     package foo.bar;
     public class Whatever { /*...*/ }

     These source files should be housed in the appropriate subdirectory of src, in this case:

     cwd
      |
     src
      |
     foo
      |
     bar  ## Whatever.java occurs here     

     This build.xml file must be edited but only one line needs to be changed:

        <property name="tomcat.home" value="/home/kalin/tomcat8">

     The value of the tomcat.home property must be set to the install directory for Tomcat, in this 
     example the directory /home/kalin/tomcat8.

     In running the Ant script, you provide the applicaton's name (the name of its WAR file) with a -D flag. 
     Here's a sample:

           ant deploy -Dwar.name=app1

     or

           ant -Dwar.name=app1 deploy

     The Ant task adds the .war extension to your file so that app1.war is the deployed file.

     To begin, you can just type 
     
          ant

     at the command-line prompt. You'll see that you can clean, build, or deploy (ant -Dwar.name=app1 deploy).

     This Ant script packages, for convenience, the Java source in the deployed WAR.
     In a production environment, this would not be best practices, of course.

     This build file makes assumptions based on file extensions. In particular:

        # After a .java file is compiled in its package, the corresponding .class
          file occurs in the same package rooted, in the WAR file, at
          WEB-INF/classes. So if foo.bar.Whatever.java is the fully qualified class name,
          then the resulting .class file winds up in WEB-INF/classes/foo/bar, that is,
          WEB-INF/classes/foo/bar/Whatever.class.

        # Files with a .xml extension (e.g., web.xml) wind up in WEB-INF.

        # Files with a .jar extension wind up in WEB-INF/lib.

        # Files with a .tag extension wind up in WEB-INF/tags

        # Other other files (e.g., JavaScript, HTML, CSS, JSP) wind up in WAR's top level.

     The Ant script creates a separate 'build' directory in which to do its work; your 'src' directory is
     not changed. The command

        ant clean

     removes the 'build' directory and any .war file from the cwd.

    The build.xml file is easily editable if you'd like to make changes.
-->

<project name="TomcatProject" basedir="." default="usage">  

  <!-- #### Change for your system. #### -->
  <property name="tomcat.home" value="/Users/martinkalin/tomcat8"/>

  <!-- Leave the rest as they are. -->
  <property name="tomcat.lib"  value="${tomcat.home}/lib"/>
  <property name="deploy.path" value="${tomcat.home}/webapps"/>
  
  <property name="src.dir"   value="${basedir}/src"/>  
  <property name="build.dir" value="${basedir}/build"/>  
  <property name="dist.dir"  value="${basedir}/dist"/>
  <property name="war.name"  value="(Please supply a name!)"/>
  
  <property name="name" value="TomcatProject"/>  
  <path id="master-classpath">  
    <fileset dir="${tomcat.lib}">  
      <include name="*.jar"/>  
    </fileset>  
    <fileset dir="${src.dir}">
      <include name="*.jar"/>
    </fileset>
    <pathelement path="${build.dir}"/>  
  </path>  
  
  <target name="usage">  
    <echo message=""/>  
    <echo message="${name} build file"/>  
    <echo message=""/>  
    <echo message="ant clean                   --> to remove all but src"/>
    <echo message="ant compile                 --> to compile only"/>
    <echo message="ant deploy -Dwar.name=test1 --> to deploy test1.war"/>  
    <echo message=""/>  
  </target>  
  
  <target name="clean" description="clean up">
    <delete dir="${build.dir}" />
    <delete>
    	<fileset dir="." includes="*.war"/>
    </delete>
  </target>
  
  <target name="prepare" depends="clean">
    <mkdir dir="${build.dir}"/>
    <mkdir dir="${build.dir}/WEB-INF"/>
    <mkdir dir="${build.dir}/WEB-INF/classes"/>
    <mkdir dir="${build.dir}/WEB-INF/lib"/>
    <mkdir dir="${build.dir}/WEB-INF/data"/>
    
    <!-- Copy files from source to build directory  -->
    <copy todir="${build.dir}">
      <fileset dir="${src.dir}">
        <include name="**/*.java"/>
	<include name="*.jsp"/>
	<include name="*.html"/>
	<include name="*.xhtml"/>
	<include name="*.jsf"/>
	<include name="*.js"/>
	<include name="*.css"/>
      </fileset>
    </copy>
    <copy todir="${build.dir}/WEB-INF">
      <fileset dir="${src.dir}">
        <include name="*.xml"/>
      </fileset>
    </copy>
    <copy todir="${build.dir}/WEB-INF/data">
      <fileset dir="${src.dir}">
        <include name="*.db"/>
      </fileset>
    </copy>
    <copy todir="${build.dir}/WEB-INF/lib">
      <fileset dir="${src.dir}">
        <include name="*.jar"/>
      </fileset>
    </copy>
    <copy todir="${build.dir}/WEB-INF/tags">
      <fileset dir="${src.dir}">
        <include name="*.tag"/>
      </fileset>
    </copy>
  </target>
  
  <target name="compile" depends="prepare" 
          description="compile main source tree java files">  
    <javac destdir="${build.dir}/WEB-INF/classes" debug="true"  
           includeantruntime="false" deprecation="false" optimize="false" failonerror="true">  
      <src path="${src.dir}"/>  
      <classpath refid="master-classpath"/>  
    </javac>  
  </target>  
  
  <target name="deploy" depends="compile" 
          description="deploy application as a war file">  
    <delete>
      <fileset dir="${build.dir}" includes="*.java,*.db,*.jar,web.xml"/>
    </delete>
    <war destfile="${war.name}.war"  
         webxml="${build.dir}/WEB-INF/web.xml">  
      <fileset dir="${build.dir}">  
        <include name="**/*.*"/>  
      </fileset>  
    </war>  
    <copy todir="${deploy.path}" preservelastmodified="true">  
      <fileset dir=".">  
        <include name="*.war"/>  
      </fileset>  
    </copy>  
  </target>  
</project> 

 Deployment exercise

 # The ZIP file 'deployExercise.zip' contains the following pieces:

   -- hiA.html              ## links to hiB.html and the HiServlet
   
   -- hiB.html              ## link to hiA.html
   
   -- web.xml               ## sets up link for servlet (more on this later)
   
   -- p1.HiServlet.java     ## fully qualified named of servlet

 # The exercise is to build a deployable WAR file with these contents, and then
   to deploy and test the deployed WAR.

   ## The WAR file's name is arbitrary.

   ## If you use my Ant script, you'd have a directory structure that looks like this:

           build.xml              ## the 'working directory' from which you'd issue the 'ant' command
	      |
	     src                  ## right below the working directory: text files, including HTML and XML
	      |
	      p1                  ## subdirectory representing the package p1
	       -- HiServlet.java  ## Java source

       % ant -Dwar.name=hiThree deploy   ## ant command to deploy      

 # The artifacts are few in number and relatively simple; hence, even a
   manual deployment would not be too bad.

   -- But the preferred approach is to use a script (e.g., my Ant script or the
      one available from the Tomcat download page under 'Deployer', a Maven script -- or
      even an ad hoc script).




                 


 -- Options in the deployment exercise

 # Packed or unpacked?

   ## Packed is standard, and just as easy as unpacked.

      ## Packed is more straightforward: there's one file, the WAR, to move around, backup, etc.

      ## In short, there's no compelling reason to go 'unpacked'.

 # Manual or automated == script or no script?

   ## To opt for an IDE-based deployment is to opt for a script.

   ## In a very simple case, manual works -- but manual doesn't scale.

 # Which script to use?

   ## Lots of choices, including Tomcat's own deployer script.

   ## Pick one you like, or roll your own.

 --------------------------------------------------------------------------------------------

 -- The tricky part of compilation for web apps

 # Data types such as 

      javax.servlet.Servlet                   ## basic interface for lifecycle events
      javax.servlet.ServletContext            ## interface for communicating with the containter
      javax.servlet.http.HttpServlet          ## class for HTTP-based servlets
      javax.servlet.http.HttpServletRequest   ## HTTP request as a Java map
      javax.servlet.http.HttpServletResponse  ## channel for sending HTTP responses to a client

   do not ship with core Java (JSE). 

   ## They ship with Tomcat: TOMCAT_HOME/lib/servlet-api.jar 

      ### For trouble-free compilation, TOMCAT_HOME/lib/*.jar should be on the classpath.

   -- Example with this exercise: manual compilation

      Here's the layout on my local file system, with TOMCAT_HOME pointing to the Tomcat install directory:

            WEB-INF ## current working directory for the 'javac' command shown below
               |
            classes
               |
               p1
                    ## source file HiServlet.java is here in the p1 subdirectory

       % javac -cp .:$TOMCAT_HOME/lib/servlet-api.jar WEB-INF/classes/p1/HiServlet.java   ## Unix-like
  
       % javac -cp .;%TOMCAT_HOME%/lib/servlet-api.jar WEB-INF/classes/p1/HiServlet.java  ## Windows

   ## A script would put the JAR files in TOMCAT_HOME/lib on the classpath.


== chapitre 4 : urls - deploy  troubleshooting  :



 -- Navigation basics for deployed web apps

 # In 'packed' and 'unpacked' deployment, the web app has the familiar hierarchical file-system structure:

                  top-level
                     |
           +...+-----+-----+...+   ## next level
           |   |     |     |   |
          ... ...   ...   ... ...  ## and so on

    ## Navigation in the web app thus follows the patterns familiar from navigating the local file system.

 # HTML documents and deployed JSP/JSF/etc. scripts are treated alike with respect to navigation.

 # The potentially tricky part would be servlets and POJOs, as these are instances of classes whose
   packages can have arbitrarily long names:

          com.org.MyServlet                       ## com.org is the package
          acme.personnel.management.MedicalPlan   ## acme.personnel.management is the package
          ...

   ## Recall that the package names are included in the hierarchy rooted at WEB-INF/classes:

                  WEB-INF
                     |
                  classes
                     |
                    acme
                     |
                 personnel
                     |
                 management

   ## There's a key difference between servlets and POJOs, however:

      ### Servlets are typically HTTP endpoints: http://...:8080/myApp/myServlet  ## myServlet as an HTTP endpoint

      ### POJOs are instances of utility classes, doing the grunt work for servlets--but are not themselves HTTP endpoints.

   ## Tomcat has a nice workaround to take the complexity out of navigation that involves servlets:

      -- Give the servlet an alias in the 'web.xml' deployment descriptor.

         ## Deployed JSP scripts are treated, with respect to navigation, just like HTML documents.

      -- Use the alias to identify the servlet during navigation.



 -- Navigation wrapup: the 404 issue

 # Here's yet another depiction of the example we've been using, with 'hi3.war' as the deployed WAR file:

                     hiTop.html    ## welcome file
                         |
               +---------+---------+
               |                   |
            web-assets          WEB-INF
              -- hiNested.hmtl     | -- web.xml        ## sets 'welcome file' and aliases servelt
                                classes
                                   |
                                   p1
                                    -- HiServlet.class ## aliased as 'helloFromSerlvet'

 # In 'hiTop.html', the link to 'hiNested.html' is:

        <a href = 'web-assets/hiNested.html'>Nested hi</a>         ## relative path

   -- Problem: the link is changed to

        <a href = 'hiNested.html'>Nested hi</a>

      The link now requires that 'hiNested.html' be at the top-level with 'hiTop.html',
      but 'hiNested.html' is in the subdirectory 'web-assets'.

      ## Result: 404 'Not Found' error when the link is followed (e.g., with a click)

 # In 'hiNested.html', the to 'hiTop.html' is:

        <a href = '../hiTop.html'>Top-level hi</a>                      ## relative path

   -- Problem: the link's href is changed to

        <a href = 'hiTop.html'>Top-level hi</a>   

      The link now requires that 'hiTop.html' be in the 'web-assets' subdirectory with 'hiNested.html'.

      ## Result: 404 'Not Found' error when the link is followed (e.g., with a click)

-------------------------------------------------------------------------------------------------------------------------

 -- Friendly recommendations:

  # To avoid subtle navigational problems, my approach is to:

      -- Put _all_ text files (e.g., HTML pages, stylesheets, /JSP/JSF/etc. scripts) in the
         deployed WAR's top-level.

      -- Alias every servlet in 'web.xml' with the URL pattern:

           /<servletName>   ## alias-based path

         For quick review, here's the web.xml entry in hi3.war:

             <servlet-mapping>
               <servlet-name>hiServlet</servlet-name>
               <url-pattern>/helloFromServlet</url-pattern>
             </servlet-mapping>
  



    

 -- What Can Go Wrong in Deployemnt?

 # Tomcat obviously can't help us programmers with errors in the app logic:

   -- Example: Client requests our company's product list, but we reply with the private
               vendor list instead.

 # The errors in question center on the interaction between (a) the web app and (b) the web container, Catalina.

 # The error types, in broad categories to begin:

   -- Problems with XML config files (e.g., the standard deployment descriptor 'web.xml'):

      ## The XML is syntactically ill-formed (i.e., can't pass a 'non-validating parse').
      ## The XML doesn't match a required schema (i.e., can't pass a 'validating parse').

   -- JSP problems: 

      ## JSP scripts, if deployed as such, are translated into servlets. This happens, by default,
         on the 1st client hit (though we can change this easily to deployment time): problem is 
         seen earlier, but obviously doesn't go away.

                   1st request for JSP script 
        1st client---------------------------->Jasper translates script into a servlet ## 'lazy' translation
                                 
                            JSP script
        web app deployed---------------------->Jasper translates script into a servlet ## 'aggressive' translation

         ### If there's a compile-time error, it shows up _after_ we've deployed.

         ### Incentive enough to pre-compile JSP scripts.

         ### 'Unreachable statement' errors can be tricky in JSP -- more on this later.

   -- General Java code run-time problems: infinite loops, NullPointerExceptions, bad type casts, etc.

         ### Compiling as part of deployment catches the standard syntax and other compile-time errors (e.g.,
             missing semicolons).

 # Tomcat, given a 'localhost' URL, provides some nice debugging help, especially in detecting 
   compile-time errors that arise in the JSP-script-to-servlet-instance translation.

 # It's easy for web apps to write to the standard Tomcat log files, which then can be used to aid
   in debugging.



 
 
 -- Deployment errors: what can go wrong and why

 # Web apps can be tricky to debug because, of course, an error might not 
   show up until the app is deployed -- an extra challenge.

   ## Common cases:

      -- bad config file: the XML file doesn't parse

      -- bad JSP script: compiler-error when Jasper tries to translate into a servlet

      -- plain-old-Java problems: null object references, etc.

      -- missing library files
      
      -- right web-app artifact, but packaged in the wrong place      
      ...
------------------------------------------------------------------------------------------------------

 # WAR file is deployed to Tomcat, but Tomcat does not 'unwar' (unpack) the file.

   ## Example 1: The WAR file 'hi.war' contains the deployment file WEB-INF/web.xml:

     <?xml version = "1.0" encoding = "ISO-8859-1"?>
     <web-app>
         <servlet>
             <servlet-name>testServlet</servlet-name>
             <servlet-class>p1.TestServlet</servlet-class>
         </servlet>
         <servlet-mapping>
             <servlet-name>testServlet</servlet-name>
             <url-pattern>/*</url-pattern>
         </servlet-mapping>
 ---->
      ### This XML file is ill-formed because the end tag </web-app> is missing.

      ### Tomcat will not unwar the file. Here's the gist of the error in TOMCAT_HOME/logs/catalina.out
          For Windows, the log file will be catalina.<today's date>.out.
;;;;
SEVERE [localhost-startStop-5] org.apache.tomcat.util.descriptor.web.WebXmlParser.parseWebXml 
       Parse error in application web.xml file at file:/home/kalin/tomcat8/webapps/servlet/WEB-INF/web.xml
       org.xml.sax.SAXParseException; systemId: file:/home/kalin/tomcat8/webapps/servlet/WEB-INF/web.xml; 
       lineNumber: 13; columnNumber: 1; 
       XML document structures must start and end within the same entity.
    at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(ErrorHandlerWrapper.java:203)
    at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.fatalError(ErrorHandlerWrapper.java:177)
    ...
SEVERE [localhost-startStop-5] org.apache.tomcat.util.descriptor.web.WebXmlParser.parseWebXml 
                               Occurred at line 13 column 1
SEVERE [localhost-startStop-5] org.apache.catalina.startup.ContextConfig.configureStart 
                               Marking this application unavailable due to previous error(s)
SEVERE [localhost-startStop-5] org.apache.catalina.core.StandardContext.startInternal 
                               One or more components marked the context as not correctly configured
SEVERE [localhost-startStop-5] org.apache.catalina.core.StandardContext.startInternal 
                               Context [/servlet] startup failed due to previous errors
;;;;

 # In general, if Tomcat doesn't unwar a WAR file, then the 1st place to look is at the configuration files
   in the WAR -- they don't parse.
----------------------------------------------------------------------------------------------

 -- Navigation within a deployed WAR file: a trouble-shooting issue

 # So far we've focused on getting the pieces of a web app in the right places within a WAR file.

   ## How can these code pieces interact within the WAR? Another troubleshooting issue...
 
 # A simple deployment example to illustrate navigation: hi3.war

   ## Output of 'jar tvf hi3.war':
                                 
       hiTop.html
       web-assets/hiNested.html
       WEB-INF/classes/p1/HiServlet.class
       WEB-INF/web.xml

   ## Depiction of the file structure:
 
                      -- hiTop.html                        ## in top-level directory
                            |
            +---------------+--------------+
            |                              |
       web-assets                       WEB-INF
             -- hiNested.html              | -- web.xml    ## in WEB-INF subdirectory
                                           |
                                        classes
                                           |
                                           p1
                                              -- HiServlet.class  ## in WEB-INF/classes/p1 subdirectory
--------------------------------------------------------------------------------------------------------------------

 -- Miscellaneous deployment issues

 # A word about jargon with the deployed WAR file 'hi3.war' as the example:

   ## In the URL 'http://...:8080/hi3', the 'hi3' (WAR file name) is called the 'context' in Tomcat-speak. 

      ### In short, a 'context' is a deployed web app: for packed deployement, the WAR file's name (without the .war)

      ### The 'context' includes all of the WAR file's contents.

      ### The 'context root' is the root of the deployed WAR file, in this case '/hi3/.

   ## Consider the URL 'http://...:8080/'. 

      ## There's only the slash / after the port number. This is the 'root context', in effect the 
         default context -- it yields Tomcat's own homepage because of how Tomcat is set up.

         ### Tomcat is configured so that TOMCAT_HOME/webapps/ROOT contains all of the goodies
	     in the 'root context' -- the full Tomcat web console

      ## In a URL such as 'http://...:8080/hi3/hiTop.html', there's a more specific context: 

         -- hi3, the WAR file's name

         -- hiTop.html, an HTML document at the WAR file's top level

 




 -- The Tomcat Web Console: http://localhost:8080/

 # Two general parts: the public site, and the private site

   ## The public site is information-centric: 

       -- documentation
       -- configuration
       -- examples
       -- wiki 
       -- mailing lists

   ## The private sites:

       -- server status: applications
                         memory usage 
                         AJP (Apache JServ Protocol: e.g., to connect Tomcat to Apache) connector
                         HTTP connector

       -- manager app: monitor and manage web apps

       -- host manager: virtual hosting

       ### Access to the private sites requires user authentication. Here's the setup:

       1. Backup TOMCAT_HOME/conf/tomcat-users.xml.

       2. Edit this file. Here's an example:

####
<?xml version='1.0' encoding='utf-8'?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  ...
  limitations under the License.
-->
<tomcat-users xmlns="http://tomcat.apache.org/xml"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://tomcat.apache.org/xml tomcat-users.xsd"
              version="1.0">
<!--
  NOTE:  By default, no user is included in the "manager-gui" role required
  to operate the "/manager/html" web application.  If you wish to use this app,
  you must define such a user - the username and password are arbitrary. It is
  strongly recommended that you do NOT use one of the users in the commented out
  section below since they are intended for use with the examples web
  application.
-->
<!--
  NOTE:  The sample user and role entries below are intended for use with the
  examples web application. They are wrapped in a comment and thus are ignored
  when reading this file. If you wish to configure these users for use with the
  examples web application, do not forget to remove the <!.. ..> that surrounds
  them. You will also need to set the passwords to something appropriate.
-->
<!--
  <role rolename="tomcat"/>
  <role rolename="role1"/>
  <user username="tomcat" password="<must-be-changed>" roles="tomcat"/>
  <user username="both" password="<must-be-changed>" roles="tomcat,role1"/>
  <user username="role1" password="<must-be-changed>" roles="role1"/>
-->
  <role rolename="manager-gui"/>
  <role rolename="admin-gui"/>
  <role rolename="manager-script"/>
  <user username="tcat"
        password="tcat"
	roles="admin-gui,manager-gui,manager-script"/>
</tomcat-users>
####

       3. Restart Tomcat.


 -- More on deployment errors with JSP scripts

 # The WAR file 'badJSP.war' embeds a JSP scriptmthat has errors. Below is an edited dump that
   Tomcat delivers to help us find and fix the error.

   ## The error message occurs in browser with the server on localhost:

;;;;
runtime error:

org.apache.jasper.JasperException: Unable to compile class for JSP: 

An error occurred at line: 10 in the jsp file: /bad.jsp
Syntax error, insert ";" to complete Statement
7:     <%
8:         out.println("The time is: " + new java.util.Date().toString()); // so far, so good
9:         for (int i = 0; i < 4; i++) out.println("Hello, world!");       // still ok
10:         out.println("Bye, bye...")  //### Error: missing semicolon in statement
11:     %>
12:   </body>
13: </html>

Stacktrace:
	org.apache.jasper.compiler.DefaultErrorHandler.javacError(DefaultErrorHandler.java:102)
	org.apache.jasper.compiler.ErrorDispatcher.javacError(ErrorDispatcher.java:198)
	org.apache.jasper.compiler.JDTCompiler.generateClass(JDTCompiler.java:457)
        ...
	org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
note The full stack trace of the root cause is available in the Apache Tomcat/8.0.33 logs.
;;;;

 ## A 2nd example -- another helpful error dump from Tomcat

org.apache.jasper.JasperException: Unable to compile class for JSP: 

An error occurred at line: 8 in the jsp file: /bad.jsp
java.util.Date.toString cannot be resolved to a type
5:          The code contains errors, which will prevent deployment.
6:        -->
7:     <%
8:         out.println("The time is: " + new java.util.Date.toString()); // ### should be Date(), not Date
9:         for (int i = 0; i < 4; i++) out.println("Hello, world!");     // this one's ok
10:         out.println("Bye, bye...");                                  // this one's fixed
11:     %>

Stacktrace:
	org.apache.jasper.compiler.DefaultErrorHandler.javacError(DefaultErrorHandler.java:102)
        ...
	org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)

 # Comparable help from Tomcat occurs in cases in which servlets or utility classes
   have familiar Java runtime errors (e.g., bad castes, null object references).

 -- Precompiling JSP scripts

 # Tomcat has a nice, short Ant script available for the job:

      https://tomcat.apache.org/tomcat-8.0-doc/jasper-howto.html 

   -- This is the build.xml file.

 # The script assumes the following directory structure, with the 'working directory' as the
   one that contains 'build.xml' and from which the 'ant' commands are entered at the command-line prompt:

                 working directory      ## contains 'build.xml', 'ant' commands issued from here
                       |
                    WEB-INF             ## Jasper creates a 'generated_web.xml' file here
                       |
          +------------+------------+
          |            |            |
         src          lib        classes
          /            \            /
     .jsp files    .jar files   generated .class files

 # Two sample runs with 'bad.jsp' as the example JSP script:

   -- In the first run, the JSP script contains a syntax error.

   -- Before the second run, the error is fixed.

   Here's the JSP script:

     <!doctype>
     <html>
       <body>
         <!-- Below is a 'scriplet': Java code embedded in an HTML template.
              The code contains errors, which will prevent deployment.
         -->
         <%
             out.println("The time is: " + new java.util.Date().toString()); // so far, so good
             for (int i = 0; i < 4; i++) out.println("Hello, world!");     // still ok
             out.println("Bye, bye...")  //### Error: missing semicolon in statement
         %>
       </body>
     </html>

  # 1st run: with error in the JSP script

      % ant -Dtomcat.home=$HOME/tomcat8 -Dwebapp.path=.

	Buildfile: /home/kalin/precompile/build.xml
	Trying to override old definition of datatype resources

	jspc:
	   [jasper] org.apache.jasper.servlet.TldScanner scanJars
	   [jasper] INFO: At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this 
		    logger for a complete list of JARs that were scanned but no TLDs were found in them. 
		    Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.

	compile:
	   [javac] /home/kalin/tcat/mats/precompile/build.xml:23: warning: 'includeantruntime' was not set, 
		   defaulting to build.sysclasspath=last; set to false for repeatable builds
	   [javac] Compiling 1 source file to /home/kalin/precompile/WEB-INF/classes
	   [javac] /home/kalin/precompile/WEB-INF/src/org/apache/jsp/WEB_002dINF/src/bad_jsp.java:113:
	            error: ';' expected
       ### [javac]         out.println("Bye, bye...")  //### Error: missing semicolon in statement
	   [javac]                                   ^
	   [javac] 1 error
	   [javac] Compile failed; see the compiler error output for details.

  # 2nd run: error fixed

      % ant -Dtomcat.home=$HOME/tomcat8 -Dwebapp.path=.

	Buildfile: /home/kalin/precompile/build.xml
	Trying to override old definition of datatype resources

	jspc:
	   [jasper] org.apache.jasper.servlet.TldScanner scanJars
	   [jasper] INFO: At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging
	            for this logger for a complete list of JARs that were scanned but no TLDs were found in them.
		    Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.

	compile:
	   [javac] /home/kalin/precompile/build.xml:23: warning: 'includeantruntime' was not set, 
		   defaulting to build.sysclasspath=last; set to false for repeatable builds
	   [javac] Compiling 1 source file to /home/kalin/precompile/WEB-INF/classes

  # The generated 'web.xml' fragment:

     <!--
       Automatically created by Apache Tomcat JspC.
       Place this fragment in the web.xml before all icon, display-name,
       description, distributable, and context-param elements.
     -->
     <servlet>
        <servlet-name>org.apache.jsp.WEB_002dINF.src.bad_jsp</servlet-name>
        <servlet-class>org.apache.jsp.WEB_002dINF.src.bad_jsp</servlet-class>
     </servlet>

     <servlet-mapping>
        <servlet-name>org.apache.jsp.WEB_002dINF.src.bad_jsp</servlet-name>
        <url-pattern>/WEB-INF/src/bad.jsp</url-pattern>
     </servlet-mapping>
     <!--
       All session-config, mime-mapping, welcome-file-list, error-page, taglib,
       resource-ref, security-constraint, login-config, security-role,
       env-entry, and ejb-ref elements should follow this fragment.
     -->


 -- Wrapup of troubleshooting

 # In 'localhost' context, Tomcat provides lots of troubleshooting help.

 # Web app issues (let's assume WAR deployment, as it's the standard):

   -- Bad XML config files

      ### The sympton is that the deployed WAR file is not 'unpacked' ('unwared').

      ### These errors are usually easy to find, but the XML files could be parsed in the course 
          of generating the WAR file.

   -- JSP translation-time errors: bad Java syntax in the JSP code snippets, missing libraries, etc.

      ### Tomcat has nice debugging help, but pre-compilation may be the way to go if the web app
          relies heavily on JSP: gain in efficiency and convenience.

      ### Even if you don't pack the WAR file with the .class files generated from the precomile, but go
          instead with the JSP, it still may be a time-saver to precomile.

   -- Run-time errors in servlets, POJOs, etc.: Tomcat again provides help, in particular by displaying a
      page about the method that threw the exception.

      ### Customized logging through System.err and System.out statements can be quite helpful.

 # Tomcat and system issues
 
   -- A web app seems to have died in that the app, which once handled requests, no longer seems to do so.

      ## The Tomcat web console lets us redeploy the app easily. If this fails, unloading and reloading are
         worth a shot.

   -- System resources (in particular, heap storage) seem to be running low.

      ## Tomcat has monitoring and diagnostic capabilities.

      ## In the worst case, TOMCAT_HOME/bin/shutdown.sh (or .bat on Windows) is a graceful way to stop 
         Tomcat, give it a chance to rest, and then restart it.


== chapitre 5 - concurence - perfs : =



 -- Web app types that Tomcat can handle

 # At the start, the point was made that Tomcat is "Java centric" -- now it's time for clarification.

                    java
                     |
            +--------+--------+
            |                 |
         language       virtual machine
            /                \
          javac             java

   ## Tomcat's written in Java (language), but can handle any web app with JVM-compatiable byte codes (run-time).

      -- JRuby (on Rails), Clojure, Scala, Java,...

   ## There are Tomcat extensions (e.g., TomEE at http://tomee.apache.org/apache-tomee.html) that come with
      an EJB container and other high-level EE components, all of which can be deployed as WAR files.
---------------------------------------------------------------------------------------------------------------------

 # Three broad categories of web app, but the distinctions among them aren't sharp:

   -- wite sites: HTML-centric, nowadays with lots of web assessts: documents, stylesheets, scripts, images,...

   -- web services: ideally, groupings of 'pure functions' that deliver data and functionality to clients
 
      ## REST-style and SOAP-based: Tomcat can handle both.

   -- web sockets: implemented through TCP-based rather than HTTP-based connections

      ## lower overhead, relief from the request/response pattern that dominates in HTTP

   ## One and the same deployed web app might contain a mix of all three:

      -- A 'chat room' web app might be a mix of HTML documents and web sockets.

      -- A web site might have HTML documents with embedded JavaScript, which issues
         client requests against a web service packaged in the very same WAR as the web site.
-----------------------------------------------------------------------------------------------------------------

 # What follows are three example web apps so that we've concrete examples of deployed WARs as 
   web sites and web services, with web sockets thrown into the mix with a web site.



 -- Where should the JAR files go?

 # Web apps of all stripes need software libraries, packaged as JAR files.

   ## JAR files in this context are not executable Java applications, but rather software libraries
      used in various web apps.

 # The options:

   -- TOMCAT_HOME/lib:  JARs in this directory are loaded at startup and available to all web apps
                        running in the web container.

      ## The current list for Tomcat8, 24 in all:

          annotations-api.jar             ## for persistence, security, etc.
          catalina-ant.jar                ## Ant support
          catalina-ha.jar                 ## cluster management ("ha" = "high availability")
          catalina.jar                    ## web (servlet) container
          catalina-storeconfig.jar        ## XML configuration storage
          catalina-tribes.jar             ## channels and related transport libraries: "group communication"
          ecj-4.5.jar                     ## Eclipse JDT (Java Development Tools) compiler
          el-api.jar                      ## Expression language (JSP 3.x)
          jasper-el.jar                   ## Jasper EL support
          jasper.jar                      ## JSP translator/runtime
          jsp-api.jar                     ## JSP API
          servlet-api.jar                 ## Servlet 3.1 API
          tomcat-api.jar                  ## Interfaces shared with Catalina and Coyote
          tomcat-coyote.jar               ## Connectors (e.g., for HTTP 1.1) and utilities
          tomcat-dbcp.jar                 ## Apache Commons Connection Pooling for RDBMSes
          tomcat-i18n-es.jar              ## i18n for Spanish
          tomcat-i18n-fr.jar              ## i18n for French
          tomcat-i18n-ja.jar              ## i18n for Japanese
          tomcat-jdbc.jar                 ## Tomcat's native connection pooling
          tomcat-jni.jar                  ## Interface to native components such as APR (Apache Portable Runtime)
          tomcat-util.jar                 ## Miscellaneous utilities
          tomcat-util-scan.jar            ## ditto
          tomcat-websocket.jar            ## web socket implementation (1.1)
          websocket-api.jar               ## web socket API (1.1)
 
      ## From the Apache-Tomcat page, four others are available as good candidates for TOMCAT_HOME/lib:

          catalina-jmx-remote.jar         ## Support JMX (Java Management Extension) remote admin from behind firewall
          catalina-ws.jar                 ## With jaxrpc.jar and wsdl4j.jar, support SOAP-based web services
          tomcat-juli-adapters.jar        ## Tomcat's impl. of the java.util.logging API to support per-app logging
          tomcat-juli.jar                 ## More of the same

   -- In the WAR file's WEB-INF/lib subdirectory

      ## Downside: Adds size to the WAR file (but, as the saying goes, 'memory is cheap').

      ## Upside: 'Freezes' deployable WAR by taking versioning and other issues out of play. (Avoids 'DLL hell'.)



 -- Web servers and client concurrency

 # As client requests hit a web server, they're queued up ('serialized'):

    ReqN...Req3  Req2  Req1 +------------+
    ----------------------->| web server |  ## requests queued up until a 'connection refused' error
                            +------------+

 # Although the requests are serialized, they cannot be handled in serial fashion for two main reasons:

   -- An ill-formed request might 'block' the server indefinitely, thereby starving all of the requests behind it.

   -- Even without indefinite blocking, requests later in the queue would have long response times -- and feel starved.

   -- Modern web servers are thus 'concurrent' rather than 'iterative' in their handling of client requests.

 # In short, a web server must handle client requests concurrently rather than one after the other.

   ## The order in which the client responses go out may not match the order in which the requests come in because,
      for example, an earlier-in-the-queue request might take longer to process than a later-in-the-queue request.

      ### Randomness may help to determine the order in which requests are completed: the key point is that all
          queued requests should get attention.

      ### If the server can't handle any more requests concurrently, a 'Connnection Refused' error should be sent
          back to any new requests.

   ## On a multi-processor machine (a production web server would run on such a machine), concurrency becomes
      literal parallelism: mulitiple requests can be handled literally at the same time because request-handling 
      can be done on separate processors.

 # Different web servers support client concurrency in different ways:

   -- Early web servers (e.g., Apache1) used multi-processing: each incoming request is dispatched to a 
      separate process for handling.

   -- Modern web servers (e.g., Apache2, Nginx, IIS, Tomcat) tend to use _some_ mix of
      multi-processing, multi-threading, and non-blocking ('asynchronous') I/O.
 
 # Tomcat uses the preferred Java strategy for concurrency: multithreading.

   ## Tomcat adopts the one-thread-per-request model by handing off each request to a Java java.lang.Thread for handling:

                              +------------+ assign to
         client request------>| dispatcher |----------->thread from a pre-built pool
                              +------------+

      ### The Tomcat core executes as a single process (a Java application) with multiple threads.

      ### In modern Tomcat, reading the request uses non-blocking I/O for efficiency.

      ### At start-up, Tomcat creates thread pools to amortize the cost of thread creation over the server's up time.

          #### There are thread pools per connector: a thread pool for HTTP, another for HTTPS, another for AJP, etc.

 # Tradeoffs of multi-threading:

   -- good news: switching on a processor between two threads in the same process has very low overhead

   -- bad news: threads within the same process share the same 'address space', that is, have access to
                the same memory locations.

      ## The programmer is thus responsible for 'synchronizing' (coordinating) thread access to shared locations
         in order to avoid 'data races' (aka 'race conditions') in which, for instance, two threads try to
         write to the same memory location at exactly the same time.


package rc;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/* A servlet to illustrate a race condition: different threads could access the
   instance field 'balance' at the same time. 

   Fixes:
   
   There are relatively low-level and high-level approaches. At the lowest level,
   explicit 'locking' can be implemented in Java by using a synchronized block that
   ensures mutual exclusion on the synchronized memory location.

   At the high-level, the package java.util.concurrent and its subpackages provide
   data types that have the synchronization code baked into the type itself. For 
   example, the 'predictionsRS' web service seen earlier allows multiple threads to
   access a single list, and the threads can perform any of the CRUD operations.
   At the implementation level, each 'prediction' in the list has an integer ID
   and a 'who says what' entry: both the ID and the entry must be thread-safe.
   Accordingly, the application uses two convenient thread-safe types:

   import java.util.concurrent.atomic.AtomicInteger;
   import java.util.concurrent.CopyOnWriteArrayList;
*/

public class RaceConditionServlet extends HttpServlet {
    int counter = 0;  // one instance of this field, accessible to multiple thread.

    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse res) {
	sendResponse(res);
    }

    @Override
    public void doPost(HttpServletRequest req, HttpServletResponse res) {
	try {
	    int adjustment = Integer.parseInt(req.getParameter("adjustment")); // assume value is available
	    counter += adjustment;
	    sendResponse(res);
	}
	catch(Exception e) { }
    }

    private void sendResponse(HttpServletResponse res) {
	try {
	    String msg = "Current counter value is: " + this.counter;
	    res.getOutputStream().println(msg);
	}
	catch(Exception e) { }
    }
}

 -- Wrapup of concurrency issues for Tomcat

 # The issue:

   -- Tomcat supports 'concurrent request handling' with a mix of multi-threading and non-blocking I/O.

      ## Each request to Tomcat is dispatched to a thread (from a pool) for handling.

      ## Tomcat has thread pools per connector: a thread pool for HTTP, another for HTTPS,...

      ## Pool size is configurable.

   -- Threads within the same process thereby have access to the same memory locations.

      ## Race conditions ('data races') thus can arise when two or more threads try to access the same
         memory location, with at least one of them trying to perform a 'write' operation.

      ## The programmer, not Tomcat, is responsible for ensuring 'thread-safe' memory access within a web app.

         ### This is hard to do well with low-level, synchronized blocks:

                synchronized(lock) {
                   // ensures 'mutual exclusion', hence thread safey: single-threaded execution only
                }

 # Traditional Java ways to address this issue: the Java Application Server with both a
   web and an EJB (Enterprise JavaBean) container:


                  not thread safe           thread safe
                       \                        /
   web request  +---------------+        +---------------+
  ------------->| web container |<------>| EJB container |  ## Session EJBs: popular thread-safe 'request handlers'
                +---------------+        +---------------+
                      /                         \
              'presentation layer'        'app logic layer'

 # Java now has efficient, high-level, thread-safe data types and data structures in 
   java.util.concurrent and its subdirectories.

       Examples:

             Type                      

        ArrayBlockingQueue      ## thread-safe channel, with a backing array as the implementation
        ConcurrentHashMap       ## thread-safe map implemented as a partitioned hash table
        CopyOnWriteArrayList    ## thread-safe list implemented into partitions
        AtomicInteger           ## thread-safe integer
        AtomicIntegerArray      ## thread-safe array of same

           
== chapitre 6 : security : =



 -- Web server and web app security: an overview

    # Security covers two distinct but related levels:

      ## Wire-level (transport-level) security: HTTPS
         ### For Tomcat, this means enabling the HTTPS connector (TOMCAT_HOME/conf/server.xml).

      ## Users/roles security: user authentication and role authorization
         ### Tomcat supports 'container-managed security' in which Catalina, rather than a particular web app,
             does the heavy lifting.
===========================================

 -- Wire-level security issues and services in an Alice-to-Bob message sending scenario

    # Peer authentication (aka mutual challenge):
    
                          Is it really Bod on this end?
                messages   /
         Alice<---------->Bob  
          /
       Is it really Alice on this end?

    # Confidentiality (message encryption/decryption):

               message  +----------------+ encrypted message  +----------------+ message
         Alice--------->| encrypt engine |------------------->| decrypt engine |--------->Bob
                        +----------------+        /           +----------------+
                                      the 'wire' = the communications channel

    # Integrity:

               sent message      received message
         Alice-------------->...------------------>Bob ## Does sent message == received message?
                              \
                           the 'wire'

    # Summary in words:

      ## peer authentication: Alice authenticates her identity to Bob, and Bob does the same to Alice.
         ### In practice, the authentication is often one-way: the receiver authenticates to the sender.
     
      ## confidentiality: Alice encrypts messages sent to Bob, who then decrypts them; same the other way.

      ## integrity: When Bob receives a message, he can confirm that it's the same message that Alice sent.
=================================================================================================================

 -- Users/roles security 
 
   ## Akin to the security in place when we log into a digital device: the OS maintains a 'password file' (with
      password hashes), and groups users in order to implement access rights at the group level.
         
   For instance, a 'login name'                      Is the user a 'senior DB admin'?
            \                                                 \
          identity  +---------------------+ optional  +--------------------+
     user---------->| user authentication |---------->| role authorization |------->user's access rights
                    +---------------------+           +--------------------+
                            \                                  \ 
                         phase 1                             phase 2

  ## A password or other credential vouches for an identity.

  ## Two phase process in which a user provides a credential that verifies the user's identity:
  
     ### The first phase is user authentication: for instance, Alice uses a password, retinal scan,
	 digital certificate, or the like to confirm her identity as Alice.

         #### AWS approach: (a) Client creates a 160-bit hash value using the client's secret key
		            (b) This hash value--and not the secret key--travels over the wire
                            (c) Amazon, with its copy of the secret key, generates another 
                                160-bit value from the same data--and verifies by comparing the two.
				
            -- This is known, in general, as HMAC: keyed-Hash Message Authentication Code

     ### The second (and optional) phase is role authorization: for instance, a database lookup
	 confirms that Alice is authorized to read/write/delete a particular resource, but the
         comparable lookup confirms that Bob is authorized only for read operations on the resource.

 -- Trace of a full security example: SSL + users/roles

  # The setup:

    -- Tomcat has been configured for HTTPS connections.

    -- The web app and Catalina have been configured to let Catalina do user authentication/authorization.

    -- The 'curl' utility is used to issue a request over HTTPS to a deployed web app (a web site).
 
  # What the 'curl' output means:

    -- A line that starts with a star * describes what's happening under the hood.
       In this case, 'curl' (the client) and Tomcat (the HTTPS server) are doing the
       HTTPS 'handshake'.

    -- A line that starts with > comes from 'curl', the client. 
       In this case, 'curl' issues a request against the 'predictions' web site,
       sending a username ('moe') and password ('MoeMoe') in the HTTP header (key is 'Authorization')

    -- A line that starts with < is output from Tomcat to the client.

=================================================

* About to connect() to localhost port 8443 (#0)
*   Trying ::1... connected
* Connected to localhost (::1) port 8443 (#0)
* successfully set certificate verify locations:
*   CAfile: none
  CApath: /etc/ssl/certs
* SSLv3, TLS handshake, Client hello (1):
* SSLv3, TLS handshake, Server hello (2):
* SSLv3, TLS handshake, CERT (11):
* SSLv3, TLS handshake, Server key exchange (12):
* SSLv3, TLS handshake, Server finished (14):
* SSLv3, TLS handshake, Client key exchange (16):
* SSLv3, TLS change cipher, Client hello (1):
* SSLv3, TLS handshake, Finished (20):
* SSLv3, TLS change cipher, Client hello (1):
* SSLv3, TLS handshake, Finished (20):
* SSL connection using EDH-RSA-DES-CBC3-SHA
* Server certificate:
    ...
*   SSL certificate verify result: self signed certificate (18), continuing anyway.  
* Server auth using Basic with user 'moe'

> GET /predictions HTTP/1.1
> Authorization: Basic bW9lOk1vZU1vZU1vZQ==
> User-Agent: curl libcurl OpenSSL zlib libidn
> Host: localhost:8443
> Accept: */*
>
< HTTP/1.1 200 OK
< Server: Apache-Coyote/1.1
< Cache-Control: private
< Transfer-Encoding: chunked
...
<
<html>
...

 -- Setting up Tomcat for HTTPS connections

    # The setup requires two major pieces:

      1. We need a DC. For development, a 'self-signed' DC is good enough,
         although it's inadequate for production.

      2. We need to configure Tomcat so that it can locate our self-signed DC.

    # Step 1: create a self-signed DC

      ## Core Java ships with a 'keytool' utility that can be used to generate a DC.
         At the command line, enter this command (with % as the command-line prompt):

                           'use the RSA algorithm'
                                /
           % keytool -genkey -keyalg RSA -keystore devel.keystore
                       /                             \
             'generate a key pair'             'put DC in this keystore, creating it if necessary'

    # Step 2: configure Tomcat so that it can find the DC from Step 1

      ## Backup and then edit Tomcat's main configuration file: TOMCAT_HOME/conf/server.xml

         ### Here is the relevant section:

           <!-- Define a SSL/TLS HTTP/1.1 Connector on port 8443
               This connector uses the NIO implementation that requires the JSSE
               style configuration. When using the APR/native implementation, the
               OpenSSL style configuration is required as described in the APR/native
               documentation -->
           <!--
           <Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
                      maxThreads="150" SSLEnabled="true" scheme="https" secure="true"
                      clientAuth="false" sslProtocol="TLS" />
           -->

         ### Note that the 'Connector' element is commented out. Uncomment the section and,
             for convenience, add a few elements. I've done so below, with comments after each
             line:

             <Connector port="8443"                                              
                        protocol="org.apache.coyote.http11.Http11NioProtocol"    
                        maxThreads="150"                                        
                        SSLEnabled="true"                                       
                        scheme="https"                                         
                        secure="true"                                         
                        clientAuth="false"                                  
                        sslProtocol="TLS"                                   
                        keystoreFile="${user.home}/devel.keystore"         
                        keystorePass="qubits" />                         

    # With these changes in place, do the following:
 
      ## If Tomcat is running, restart it.

      ## Open a browser to: https://localhost:8443

         ### Depending on configuration, your browser likely will complain about the 'self-signed' DC stored in
             the 'devel.keystore' keystore--you'll get warnings about how 'unsafe' it is to proceed.
       

    # Here's an uncommented entry from server.xml:

       <Connector executor="tomcatThreadPool"
                  port="8080" protocol="HTTP/1.1"
                  connectionTimeout="20000"
                  redirectPort="8443" />

         
                    
  -- Peer authentication and digital certificates

     # To enable HTTPS for Tomcat, we need a digital certificate. Why?
       ## How do DCs and the 'S' in HTTPS link up? 
       
     # Three key terms play a role in wire-level security, 'peer authentication' in particular:

       -- Key Pair (a public and a private key per pair)
       
       -- Digital Certificate (includes a public key and a digital signature as a voucher)
          ## Digital signature: message digest encrypted with the private key from a key pair
       
       -- Certificate Authority (CA): company that vouches for a digital certificate
          ## CA vouches for a DC by adding the CA's digital signature to the DC

       ## HTTPS addresses the man-in-the-middle-challenge by having the two sides (Alice, Bob)
          confirm their identities:

          ### Alice and Bob exchange Digital Certificates (DCs) to confirm their identities.
              Alice sends one or more DCs to Bob, who does the same to Alice.
              Each verifies the DCs of the other.

          ### Alice's own DCs are in her 'keystore'; the ones she trusts are in her 'truststore'.

       ## Core Java comes with a 'keytool' utility for creating a key pair.

       -- Here's a scenario for creating a DC signed by a CA:
    	
    	1. Alice sends a signed certificate request containing her name, her public key,
    	   and perhaps some additional information to a CA.
    	
    	2. The CA creates a message M from Alice's request, signing the message M
    	   with its private key, thereby creating a separate signature message SIG.
    	
    	3. The CA returns to Alice the message M with the its signature SIG.
    	   Together M and SIG form Alice's certificate.
    	
    	4. Alice sends her newly minted certificate to Bob to give him access to her public key.
    	
    	5. Bob verifies the signature SIG using the CA's public key.
    	   If the signature proves valid, he accepts the public key in the certificate as
    	   Alice's public key, that is, as her identity.

     # Keystore and truststore

       ## Core Java ships with a default truststore: 

             JAVA_HOME/jre/lib/security/cacerts

       ## But core Java doesn't come with a default keystore (we'll build one later).
    	
     # Digital Certificate Layout (X.509 v3)

    	Certificate:
    	   Data:
    	       Version: 3 (0x2)
    	       Serial Number: 1 (0x1)
    	       Signature Algorithm: md5WithRSAEncryption
    	       Issuer: C=ZA, ST=Western Cape, L=Cape Town, O=Thawte Consulting cc,
                   OU=Certification Services Division,
                   CN=Thawte Server CA/emailAddress=server-certs@thawte.com
    	       Validity
    	           Not Before: Aug  1 00:00:00 1996 GMT
    	           Not After : Dec 31 23:59:59 2028 GMT
    	       Subject: C=ZA, ST=Western Cape, L=Cape Town, O=Thawte Consulting cc,
    	                OU=Certification Services Division,
    	                CN=Thawte Server CA/emailAddress=server-certs@thawte.com
    	       Subject Public Key Info:
    	           Public Key Algorithm: rsaEncryption
    	           RSA Public Key: (1024 bit)
    	               Modulus (1024 bit):
    	                   00:d3:a4:50:6e:c8:ff:56:6b:e6:cf:5d:b6:ea:0c:
   	                   68:75:47:a2:aa:c2:da:84:25:fc:a8:f4:47:51:da:
   	                   85:b5:20:74:94:86:1e:0f:75:c9:e9:08:61:f5:06:
                           ...
   	                   6d:c0:28:42:99:d7:4c:43:de:c3:f5:21:6d:54:9f:
   	                   5d:c3:58:e1:c0:e4:d9:5b:b0:b8:dc:b4:7b:df:36:
   	                   3a:c2:b5:66:22:12:d6:87:0d
   	               Exponent: 65537 (0x10001)
   	       X509v3 extensions:
   	           X509v3 Basic Constraints: critical
   	               CA:TRUE
   	   Signature Algorithm: md5WithRSAEncryption
   	       07:fa:4c:69:5c:fb:95:cc:46:ee:85:83:4d:21:30:8e:ca:d9:
   	       a8:6f:49:1a:e6:da:51:e3:60:70:6c:84:61:11:a1:1a:c8:48:
               ...
   	       e7:20:1b:8b:ca:a4:ab:8d:e9:51:d9:e2:4c:2c:59:a9:da:b9:
   	       b2:75:1b:f6:42:f2:ef:c7:f2:18:f9:89:bc:a3:ff:8a:23:2e:
   	       70:47


 -- HTTPS exercise: configure Tomcat for HTTPS connections

    # The gist is to repeat the process that we've gone through: doing it from start to finish is worth the effort.

    # The details:

      -- Use the keytool or equivalent to create a DC. If you've time, you might experiment with a different tool.

         ## To start, the 'keytool' is the easiest way to go, but openssl and the Windows Key Manager
	    could be used as well -- with a bit more work. 

      -- Configure Tomcat (TOMCAT_HOME/conf/server.xml) so that it can support HTTPS connections.

         ## In the example we covered, I put the keystore ('devel.keystore') with my self-signed DC in my home directory,
            but a better location would be under TOMCAT_HOME, e.g., TOMCAT_HOME/conf/certs.

         ## The location of the keystore is arbitrary, as the configuration entry in server.xml can specify any location
            on the local file system.

      -- After configuring and then starting or restarting Tomcat, test that Tomcat indeed accepts HTTPS
         connections. 

         ## Open a browser to https://localhost:8443

         ## Use 'curl' instead: curl https://localhost:8443

            ### To avoid the 'bad certificate' warnings from 'curl', use the --insecure flag.

         Either of these should work, assuming that we've left "clientAuth=false" in the Tomcat configuration.





     

 -- Assessing the Tomcat-HTTPS exercise

 # Generating the self-signed certificate

   -- Tomcat accepts DCs in various formats:

      ## JKS:             Java KeyStore (what the 'keytool' utility uses)

      ## PKCS and PKCS12: Public Key Cryptograpy Standards

         ### PKCS12 is an Internet standard.

         ### OpenSSL (https://www.openssl.org/) and Microsoft's Key Manager 
             (https://www.microsoft.com/en-us/download/details.aspx?id=12419) work with PKICS12.

      ## The 'keytool' can import PKCS12 DCs into a JKS keystore.

 # Configuring Tomcat, with the relevant entry from TOMCAT_HOME/conf/server.xml shown below

   ## Big picture -- the 'SSL' for the 'S' in HTTPS is available two ways in Tomcat:

      -- Through JSSE (Java Secure Sockets Extension) introduced in JDK 1.4
 
      -- Through APR (Apache Portable Runtime), a 'native' (that is, implemented-in-C) library for Tomcat,
         which uses OpenSSL by default.

      -- In the the 'Connector' entry for port 8443, the 2nd attribute ('protocol') determines what's used:

            Setting for 'protocol'                              Comment
          
                "HTTP/1.1"                            Let Tomcat pick: not recommended
     "org.apache.coyote.http11.Http11Protocol"        JSSE BIO (Blocking I/O) impelementation
     "org.apache.coyote.http11.Http11NioProtocol"     JSSE NIO (New I/O) implementation
     "org.apache.coyote.http11.Http11Nio2Protocol"    JSSE NIO2 implementation
     "org.apache.coyote.http11.Http11AprProtocol"     APR with OpenSSL implementation ('keep-alive' automatic)
 
     <Connector 
         port="8443"                                             ## if changed, change 'redirectPort' for HTTP connector
         protocol="org.apache.coyote.http11.Http11NioProtocol"   ## covered above 
         maxThreads="150"                                        ## might set higher with APR
	 
         SSLEnabled="true"                                       ## definitely -- turns SSL on
         scheme="https"                                          ## standard scheme for HTTPS
         secure="true"                                           ## definitely -- passes this info to servlets
         clientAuth="false"                                      ## better for web sites: client may not have DC on machine
         sslProtocol="TLS"                                       ## the default: current version is 1.0
         keystoreFile="${user.home}/devel.keystore"              ## can be anywhere on local file system
         keystorePass="qubits" />                                ## set during keytool or equivalent session

 
  -- Users/roles security in web apps

 # In plain terms, it comes down to two questions:
    1. How can you verify your identity? (user authentication)
    2. What access rights go with that identity? (role authorization)
	
   ## Logging into a machine illustrates: you provide a username (identity) and a password (supporting credential).
      The login system then determines what you can with that identity.
	  
   ## Amazon web services example: my accessID (identity) and a hash value generated from my secretKey (credential).
      Amazon authorizes access rights depending on this verified identity (e.g., I can place an order for an item,
      but not set its price).

      ### In short, AWS uses a variation of HMAC (keyed Hash Message Authentication)

 # The two phases in users/roles security:

   1. User authentication (ID + supporting credential)
   2. Role authorization (access rights)

      ### 2 is typically automated with database lookups and the like.

   -- Depiction:

                  +----------------+             +----------------+
      user------->| authentication |------------>| authorization  |-------->secured resource (e.g., an HTML page)
                  +----------------+             +----------------+
                         /                               \
                     required                         optional

 # Implementating users/roles security for web-apps:

   ## Application-managed: not recommended, too ad hoc, does not scale.

   ## Container-managed: let Tomcat handle the authentication/authorization (auth/auth).

      ### Tomcat provides various options, including turning over auth/auth to an LDAP or similar service.

          #### Among the options is JAAS (Java Authentication and Authorization Service), which supports high-level, 
               powerful, and flexible authentication/authorization schemes.
  
 # The challenge on the client side:

   ## Present the identity and credential in exactly the way the container expects.

 # HTTP authentication ("authorization") modes
    
    	BASIC:       browser provides login form, username and password sent as is

    	DIGEST:      message digest of password, not password itself, sent to server 

    	FORM:        app rather than browser provides the login form, and the container handles 
                     the authentication/authorization--preferred method: 
    	
    	CLIENT-CERT: client digital certificate is sent as id and credential:



 -- Tomcat realms in container-managed users/roles security

    # 'Realms' are the Tomcat-side of users/roles security.
    
      ## The 'web.xml' config is the web-app side.

    # A 'realm' is a datastore with user identities (e.g., login  names), credentials (e.g., passwords),
      and security roles.
   
      ## A given realm also includes whatever code infrastructure is required for realm use.

      ## A realm is created and configured in the main Tomcat config file, TOMCAT_HOME/conf/server.xml
      
         ### Once configured, the realm is active when Tomcat is started/restarted.

    # Background technologies:

      ## JNDI: Java Naming and Directory Interface, an API for:

         ## Associating names with resources within a prescribed syntax (the 'Naming' part).

            -- Sample name: url = "jdbc:postgresql://localhost:5432/usersRoles"

         ## Associating names with resources and specifying attributes on such 'bindings' (the
            'Directory' part)

         ## Typically described as the Java EE 'naming and directory service'.

            ### JNDI is the 'interface', and a 'provider' furnishes the implementation.

    # The built-in security realms are:

      -- JDBCRealm: auth/auth info is stored in a relational database, and accessed through a JDBC driver.

      -- DataSourceRealm: auth/auth info is stored in a relational database, accessed through a named
         JNDI JDBC 'DataSource'.

      -- JNDIRealm: auth/auth info is stored in an LDAP based directory server, accessed through a JNDI provider.

      -- UserDatabaseRealm: auth/auth info stored in an UserDatabase JNDI resource, which is typically
         persisted as an XML document on the local file system, with TOMCAT_HOME/conf/tomcat-users.xml
	 as the default. This realm is well suited to development.

         -- UserLockOutRealm: subtype to prevent brute-force attacks that guess passwords ('dictionary attacks')
                            
      -- MemoryRealm: in effect, an earlier version of UserDatabaseRealm (but without JNDI-based lookups)

      -- JAASRealm: auth/auth info access through the JAAS (Java Authentication and Authorization Service)
         framework, with complete flexibility in how the info is persisted. Used in Java Application Servers.

      ## Users can create and configure additional realms.

         -- Examples from TOMCAT_HOME/conf/server.xml and Tomcat documentation:

         <Realm className="org.apache.catalina.realm.LockOutRealm">
           <!-- This Realm uses the UserDatabase configured in the global JNDI
                resources under the key "UserDatabase".  Any edits
                that are performed against this UserDatabase are immediately
                available for use by the Realm.  -->
           <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
                  resourceName="UserDatabase"/>
         </Realm>

         <Realm className="org.apache.catalina.realm.JDBCRealm"
                driverName="org.gjt.mm.mysql.Driver"
                connectionURL="jdbc:mysql://localhost/authority?user=dbuser&amp;password=dbpass"
                userTable="users" userNameCol="user_name" userCredCol="user_pass"
                userRoleTable="user_roles" roleNameCol="role_name"/>

 -- Wrapup of security

    # In a web context, users/roles security should be implemented atop wire-level security
      because sensitive info (e.g., IDs and especially passwords) are traveling over the wire:

              +----------------------+
              | users/roles security |   ## various approaches are possible
              +----------------------+
              |  wire-level security |   ## HTTPS or equivalent (the SSL layer)
              +----------------------+

    # Configuring Tomcat for wire-level security is straightforward:

      -- Get a DC (self-signed is OK for developent) to place in a keystore.

      -- Uncomment the port 8443 connector in TOMCAT_HOME/conf/server.xml
         ## Set the keytoreFile and keystorePass attributes in the connector elements.

      -- Restart Tomcat if it's running.

    # For users/roles security, Tomcat allows us to pick the auth/auth implementation ('realm') 
      to be used for 'container-managed security'.

         -- The default is straightforward: put the auth/auth info in TOMCAT_HOME/conf/tomcat-users.xml.
	    Default realm is UserDatabaseRealm, and requires no configuration in server.xml.

         -- The built-in realms cover the usual approaches, and customization is always possible.

    # On the web-app side, setting up users/roles security should be confined to the configuration file 'web.xml'
      and, where appropriate, to back-end datastores such as databases.

    # For capturing a client's ID (e.g., username) and supporting credential (e.g., password), 
      the preferred approach with the browser as the user-agent is the FORM method:

      ## The web app itself provides a login form, with some naming conventions understood (e.g.,
         the form's action is 'j_security_check', and the username and password are captured in
         input components with the names 'j_username' and 'j_password', respectively).

         ### Storing a message digest of the password, rather than the password itself, requires
             a customized approach, as the 'j_security_check' is the web container's
             code, and not ours. A JAAS approach might make sense here.

      ## The web app also provides, through the standard config file 'web.xml', information about
         the security constraints in play within the app:

         -- Which resources within the deployed WAR file are to be secured? All or only some?

         -- Which wire-level constraints are to apply? 'Confidentiality', 'message integrity', both?
            ## Requiring either one of these is typically sufficient to signal Tomcat that SSL is to be in play.

         -- Which role authorizations, if any, are required to access a particular secured resource?

               
== chapitre 7: logging - monit - virtualhost : ==


 -- Tomcat logging

  # TOMCAT_HOME/logs is the relevant directory, with various log files:
    ## On Unix-like systems, 'catalina.out' is the main log file.

    ## On Windows, it's 'catalina.<date>.out' only (e.g., 'catalina.2016-06-18.log').

  # Out of the box, Tomcat uses Apache Commons Logging (http://commons.apache.org/proper/commons-logging), under
    the Tomcat-specific name JULI.
    ## JULI is Tomcat's implementation of the standard java.util.logging API (so the 'I' is for 'Implementation').

    ## JULI can be configured through property files or programmatically. For Tomcat, this is done in start-up scripts.

    ## Tomcat logging doesn't interfere with customized web-app logging.
       ### Web apps can piggy-back on Tomcat logging by writing to System.out and System.err. These
           writes then are recorded 'catalina.out' (or equivalent).

  # JULI limitations: a java.util.logging implementation is per-JVM, not per web-app. 
    ## If an installation needs per-web-app logging, then a 'plan B' is required -- and that's log4j

    ## What's needed to switch:

       -- log4j at http://logging.apache.org/log4j (.jar and .properties files)

       -- tomcat-juli.jar and tomcat-juli-adapters.jar from the 'extras' section of the Tomcat
          download page at https://tomcat.apache.org/download-80.cgi

       -- installation: for the setup, see https://tomcat.apache.org/tomcat-8.0-doc/logging.html

  # The log4j option is more powerful and flexible. Is it needed on your installation?
--------------------------------------------------------------------------------------------------------------

 # Samples:

   -- from 'catalina.out':
   
...
07-Jun-2016 11:48:24.608 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory
   Deployment of web application directory /Users/martinkalin/tomcat8/webapps/docs has finished in 8 ms
07-Jun-2016 11:48:24.608 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory
   Deploying web application directory /Users/martinkalin/tomcat8/webapps/examples
07-Jun-2016 11:48:24.721 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory
   Deployment of web application directory /Users/martinkalin/tomcat8/webapps/examples has finished in 113 ms
07-Jun-2016 11:48:24.721 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory
   Deploying web application directory /Users/martinkalin/tomcat8/webapps/host-manager
07-Jun-2016 11:48:24.732 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory
   Deployment of web application directory /Users/martinkalin/tomcat8/webapps/host-manager has finished in 11 ms
...
07-Jun-2016 11:48:24.752 INFO [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory
   Deployment of web application directory /Users/martinkalin/tomcat8/webapps/ROOT has finished in 7 ms
07-Jun-2016 11:48:24.754 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler ["http-nio-8080"]
07-Jun-2016 11:48:24.759 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler ["http-nio-8443"]
07-Jun-2016 11:48:24.759 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler ["ajp-nio-8009"]
07-Jun-2016 11:48:24.760 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in 1565 ms
...

   -- from localhost_access_log.2016-06-01.txt

...
0:0:0:0:0:0:0:1 - - [01/Jun/2016:20:01:24 -0500] "GET /chitchat/ HTTP/1.1" 200 858
0:0:0:0:0:0:0:1 - - [01/Jun/2016:20:01:24 -0500] "GET /chitchat/styles.css HTTP/1.1" 200 643
0:0:0:0:0:0:0:1 - - [01/Jun/2016:20:01:24 -0500] "GET /chitchat/chat.js HTTP/1.1" 200 1070
0:0:0:0:0:0:0:1 - - [01/Jun/2016:20:01:24 -0500] "GET /chitchat/chat HTTP/1.1" 101 -
0:0:0:0:0:0:0:1 - - [01/Jun/2016:20:01:24 -0500] "GET /favicon.ico HTTP/1.1" 200 21630
0:0:0:0:0:0:0:1 - - [01/Jun/2016:20:01:46 -0500] "GET /chitchat/ HTTP/1.1" 304 -
0:0:0:0:0:0:0:1 - - [01/Jun/2016:20:01:46 -0500] "GET /chitchat/styles.css HTTP/1.1" 304 -
0:0:0:0:0:0:0:1 - - [01/Jun/2016:20:01:46 -0500] "GET /chitchat/chat.js HTTP/1.1" 304 -
0:0:0:0:0:0:0:1 - - [01/Jun/2016:20:01:46 -0500] "GET /chitchat/chat HTTP/1.1" 101 -
0:0:0:0:0:0:0:1 - - [01/Jun/2016:20:01:46 -0500] "GET /favicon.ico HTTP/1.1" 200 21630
0:0:0:0:0:0:0:1 - - [01/Jun/2016:20:04:46 -0500] "GET /chitchat/ HTTP/1.1" 304 -
0:0:0:0:0:0:0:1 - - [01/Jun/2016:20:04:46 -0500] "GET /chitchat/styles.css HTTP/1.1" 304 -
0:0:0:0:0:0:0:1 - - [01/Jun/2016:20:04:46 -0500] "GET /chitchat/chat.js HTTP/1.1" 304 -
0:0:0:0:0:0:0:1 - - [01/Jun/2016:20:04:46 -0500] "GET /chitchat/chat HTTP/1.1" 101 -
0:0:0:0:0:0:0:1 - - [01/Jun/2016:20:04:46 -0500] "GET /favicon.ico HTTP/1.1" 200 21630
...

 # Analysis

   -- AWStats at http://www.awstats.org

   -- JavaMelody at https://github.com/javamelody/javamelody/wiki

   -- Octopussy at http://www.octopussy.pm/

   -- Psi-Problem at https://github.com/psi-probe/psi-probe

 # Log file backup

    -- logrotate at https://support.rackspace.com/how-to/understanding-logrotate-utility

       ## Can be used on Windows if cygwin (https://www.cygwin.com/) is installed.

       ## LogRotateWin at https://sourceforge.net/projects/logrotatewin is a port that doesn't require cygwin.
 
 

 -- Remote monitoring and management

 # Quick detour on terminology:

   -- I've been using TOMCAT_HOME to designate the install directory for the Tomcat binaries.
      ## The goal was to avoid confusion between CATALINA_HOME and CATALINA_BASE, clarified next.

   -- CATALINA_HOME = my TOMCAT_HOME: install directory for Tomcat binaries on the local machine

   -- CATALINA_BASE = working directory for my personal Tomcat instance, as we could have several
      running on the local system.
      ## Having several Tomcat instances running isn't so popular now as it once was; might be
         used, for example, in a teaching environment -- each student gets a Tomcat instance.

   -- If there's just one instance of Tomcat running (my strong preference), then
      CATALINA_HOME = CATALINA_BASE.
      ## These environment variables need not be set explicitly: Tomcat figures it out.

 # Java-centric monitoring/management tools:

   -- JConsole comes with the JDK (since 1.5). At the command-line:

        % jconsole
 
      ## JConsole complies with JMX (Java Management Extensions), and Tomcat exposes components as MBeans.   

   -- VisualVM (https://visualvm.java.net/) also is worth a look.

 # Making JConsole easier to use for Tomcat monitoring:

   0. Best to shutdown Tomcat first.

   1. In TOMCAT_HOME/bin, create the file 'setenv.sh' ('setenv.bat' in Windows).

   2. Add the following to this file:

        export CATALINA_OPTS="$CATALINA_OPTS -Dcom.sun.management.jmxremote"
        export CATALINA_OPTS="$CATALINA_OPTS -Dcom.sun.management.jmxremote.port=9876"
        export CATALINA_OPTS="$CATALINA_OPTS -Dcom.sun.management.jmxremote.authenticate=false"
        export CATALINA_OPTS="$CATALINA_OPTS -Dcom.sun.management.jmxremote.ssl=false"

      ## For Windows, replace 'export' with 'set', and replace '$CATALINA_OPTS' with '%CATALINA_OPTS%'.

      ## The port number 9876 (2nd line) can be set to any available port on the local system, but
         it's easiest to pick a number > 1023.

   3. Start Tomcat.

 # Other options (and a recommendation)

   ## For remote (or even local) _monitoring_, JConsole and VisualVM are great.

   ## For remote _management_, I recommesh the 'ssh' (Secure SHell) utility.

      ### 'ssh' is available on Windows from PuTTY (http://www.putty.org/).

   ## For system-level monitoring, a tool such as Monit https://mmonit.com/monit/ is worth a look.




  





  -- Tomcat and virtual hosting

  # A scenario to motivate 'virtual hosting':

     -- We've a small company with two product lines: outdoor clothing, and yard equipment.
        There's some connection between the product lines, but we'd like separate 'domain names' for each.

        ## In 'www.google.com' and 'www.yahoo.com', the domain names are 'google.com' and 'yahoo.com', respectively.

        ## We're willing to register two different domain names with a 'domain name registrar', a company
           with the power to reserve a domain name (e.g., GoDaddy is a well know 'domain name registrar').

        ## Our domain names will be: acme.outdoorduds.com and acme.gardening.com.

     -- For now, we've one server (need a backup!) or many one small cluster of servers. For now, assume
        just one server for simplicity.

        ## The key point is that we want requests to two distinct domains to wind up at the same server(s):

           Requests such as

             http://outdoorduds.com:8080/     ## domain name is registered so DNS lookup works
          
           and

             http://yardstuff.com:8080/       ## domain name is registered so DNS lookup works

           should wind up at our single web server (or cluster).

  # Out of the box, Tomcat already has one 'host' configured: localhost.
    ## But 'virtual hosting' becomes interesting only with more than one configured host.

  # How does virtual hosting work in Tomcat?

    ## The notion of an 'Engine' is central in the Tomcat architecture for virtual hosting.

       ### An Engine serves as an entry point into the Catalina web container, which in turn
           can have multiple 'virtual hosts'. Here's a depiction:

                                         web container
           dispatch request to a host       /
                         \             +---------+
    HTTP request------>Engine--------->|  host1  |  ## the Engine is an 'entry point' to the web container
                         /             |  host2  |  
    Tomcat names this 'Catalina'       |   ...   |  ## by default, Tomcat has one Engine -- and names it 'Catalina'
                                       |  hostN  |
                                       +---------+

       ### An Engine's job is to analyze an HTTP request, dispatching the request to the appropriate (virtual) host.

    ## The steps:

       ### We can create a virtual host 'on the fly' with the Tomcat web console, but the permanent fix is to edit
           the main config file TOMCAT_HOME/conf/server.xml.

       1. Backup TOMCAT_HOME/conf/server.xml (just in case).

       2. Edit the Engine section. Here's what I did for illustration:

  #####
  <!-- An Engine represents the entry point (within Catalina) that processes
         every request.  The Engine implementation for Tomcat stand alone
         analyzes the HTTP headers included with the request, and passes them
         on to the appropriate Host (virtual host).
         Documentation at /docs/config/engine.html -->
    <!-- You should set jvmRoute to support load-balancing via AJP ie :
    <Engine name="Catalina" defaultHost="localhost" jvmRoute="jvm1">
    -->
    <Engine name="Catalina" defaultHost="localhost">

      <!--For clustering, please take a look at documentation at:
          /docs/cluster-howto.html  (simple how to)
          /docs/config/cluster.html (reference documentation) -->
      <!--
      <Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/>
      -->

      <!-- Use the LockOutRealm to prevent attempts to guess user passwords
           via a brute-force attack -->
      <Realm className="org.apache.catalina.realm.LockOutRealm">
        <!-- This Realm uses the UserDatabase configured in the global JNDI
             resources under the key "UserDatabase".  Any edits
             that are performed against this UserDatabase are immediately
             available for use by the Realm.  -->
        <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
               resourceName="UserDatabase"/>
      </Realm>

      <Host name="localhost"  appBase="webapps"
            unpackWARs="true" autoDeploy="true">

        <!-- SingleSignOn valve, share authentication between web applications
             Documentation at: /docs/config/valve.html -->
        <!--
        <Valve className="org.apache.catalina.authenticator.SingleSignOn" />
        -->
        <!-- Access log processes all example.
             Documentation at: /docs/config/valve.html
             Note: The pattern used is equivalent to using pattern="common" -->
        <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix="localhost_access_log" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
      </Host>
      <!-- Newly added virtual host -->
      <Host name="outdoorduds.com"               ## domain name
	    appBase="outdoorapps"                ## TOMCAT_HOME/outdoorapps holds the WAR files
	    unpackWARs="true"                    ## unpack, as happens in TOMCAT_HOME/webapps
	    autoDeploy="true">                   ## 'hot' deploy
	<Alias>www.outdoorduds.com</Alias>       ## other features are configurable as well
      </Host>
      
      <!-- Add the other virtual host here -->
      <Host></Host>
    </Engine>
    #####

       3. Restart Tomcat if it's running.
 
       4. Deploy ROOT.war to the new appBsase, TOMCAT_HOME/outdoorapps -- now we have a
          'root context' for the new domain name.

          *** Customized context information, in the form of a separate 'context.xml'
              configuration document, could be added.


 -- Tomcat and CGI (Common Gateway Interface): How Tomcat can host legacy web apps

  # Tomcat's way to host web apps that don't run on the JVM.
    ## Tradtionally, such apps are written in 'dynamic languages' such as Perl, Python, and Ruby -- but
       other languages (e.g., C/C++) are possible as well.

  # CGI is as old as the hills -- popular from early web servers such as Apache1 up through, for
    example, Rails app/web servers such as Mongrel. 

    ### FastCGI and SCGI ('S' for 'Simple') are more recent variants.

  # Here's a depiction:

               Tomcat has a CGIServlet, akin to the DefaultServlet and JspServlet
                                /
             +------------+    CGI    +----------------------------+      
             | web server |<--------->| local program as a web app |
             +------------+           +----------------------------+
                                                  \
                                      written in Perl, Python, Ruby,...


                         acts as the 'interceptor'
                                   \
              HTTP request  +------------+   CGI
             -------------->| CGIServlet |<------->web app in C, Perl, Python, Ruby,...
                            +------------+
                                  /
                              web container

  # How to enable CGI for Tomcat:

    -- TOMCAT_HOME/conf/web.xml is the 'master' deployment descriptor for web apps.
       
       ## Uncommenting the CGI section (and restarting Tomcat) would enable CGI for all
          web apps.

       ## A safer approach is to enable CGI on a per-application basis: copy and uncomment
          the relevant section into the 'web.xml' encapsulated in the deployed WAR file.
          We'll inspect this file shortly.
 
   -- TOMCAT_HOME/conf/context.xml is the 'master' context descriptor. Copy that file into
      your working directory and edit it so that it looks like:

####
<?xml version='1.0' encoding='utf-8'?>
<!-- The priveleged="true" setting is critical. -->
<Context privileged="true" reloadable="true">
    <WatchedResource>WEB-INF/web.xml</WatchedResource>
    <WatchedResource>${catalina.base}/conf/web.xml</WatchedResource>
</Context>
####
   
  -- Here's the contents of a sample deployed web app, called 'greet.war', with comments:

      META-INF/context.xml    ## revised 'context.xml' with priveleged="true" attribute
      WEB-INF/web.xml         ## details of WAR file layout and servlet mapping
      WEB-INF/cgi/hi.cgi      ## sample Perl script: '.cgi' extension is traditional, not required

      ## Here's the Perl script (Python, Ruby, compiled C, etc. would work as well):

           #!/usr/bin/perl

           print "Content-type: text/html\n\n";
           $now = localtime();
           print "<h2>Greetings at: $now.</h2>";

      ## The CGIServlet, in effect, executes this as: perl hi.cgi

      ## After WARing the web app as 'greet.war' and copying the WAR to TOMCAT_HOME/webapps, the request URL is:

          http://localhost:8080/greet/cgi-bin/hi.cgi




    
